(window.webpackJsonp=window.webpackJsonp||[]).push([[1],{442:function(t,n,e){"use strict";e.r(n);n["default"]='\n    \n    <article id="Event-API">\n        <h1>Event API</h1>\n\n        <p>Event是Easycanvas中的事件对象。当Sprite.events下的事件或者addEventListener(EventName, Handle)注册的事件触发时，它是Handle函数的第一个入参。</p>\n\n        <code>\n                someSprite.addEventListener(\'click\', function (e) {\n                    console.log(e.canvasX, e.canvasY);\n                    console.log(e.event.layerX, e.event.layerX);\n                    e.stopPropagation();\n                    e.event.stopPropagation();\n                });\n        </code>\n\n        <p>可使用的属性包含：</p>\n\n        <table>\n            <thead>\n                <tr>\n                    <th align="left">属性</th>\n                    <th align="left">含义</th>\n                </tr>\n            </thead>\n            <tbody>\n                <tr>\n                    <td align="left">canvasX/canvasY <<Number>></td>\n                    <td align="left">点击坐标点的绝对坐标（相对于整个canvas实例）。</td>\n                </tr>\n                <tr>\n                    <td align="left">event <<原生Event>></td>\n                    <td align="left">浏览器原生Event事件。</td>\n                </tr>\n            </tbody>\n        </table>\n\n        <p>可使用的API包含：</p>\n\n        <table>\n        <thead>\n            <tr>\n                <th align="left">API</th>\n                <th align="left">含义</th>\n            </tr>\n        </thead>\n        <tbody>\n            <tr>\n                <td align="left">stopPropagation()</td>\n                <td align="left">停止事件在Easycanvas内的冒泡。事件不会再向当前Sprite的父节点传递。</td>\n            </tr>\n            <tr>\n                <td align="left">event.stopPropagation()</td>\n                <td align="left">停止事件在DOM上的冒泡，即事件不会向上传递到当前canvas节点的parent节点。</td>\n            </tr>\n        </tbody>\n    </table>\n\n    <p>event属性内包含全部的浏览器事件对象属性。</p>\n\n</article>\n\n    \n    <article id="Sprite-API">\n        <h1>Sprite API</h1>\n\n        <p>Sprite是Easycanvas中的基类，拥有大量的属性与API。</p>\n        \n        <p>这些属性可以直接访问修改，也可以用函数的形式返回结果。后者可以实现类似“数据绑定”的概念，如下：</p>\n\n        <code>\n                someSprite.style.left = 100;\n\n                someSprite.style.left = function () {\n                    // window.data.left变化时，left将随之变化\n                    return window.data.left;\n                };\n        </code>\n\n        <p>Sprite类包含如下属性（这些属性可以直接修改）：</p>\n\n        <table>\n            <thead>\n                <tr>\n                    <th align="left">content</th>\n                    <th align="left">以下属性在content对象内</th>\n                </tr>\n            </thead>\n            <tbody>\n                <tr>\n                    <td align="left">img <<Image|Canvas|String|Function>></td>\n                    <td align="left">绘图内容。可以为Image、Canvas对象，也可以是远程图片URL，或者是返回了Image、Canvas、图片URL的一个Function。如果img的类型是String（图像URL），将在下一个tick自动转换为Image对象。</td>\n                </tr>\n                <tr>\n                    <td align="left">text <<String|Function>></td>\n                    <td align="left">绘制文本内容。可以是String，也可以是返回了String的Function。</td>\n                </tr>\n            </tbody>\n            <thead>\n                <tr>\n                    <th align="left">style</th>\n                    <th align="left">以下属性在style对象内</th>\n                </tr>\n            </thead>\n            <tbody>\n                <tr>\n                    <td align="left">visible <<Boolean|Function>></td>\n                    <td align="left">是否可见。默认true。不可见元素也将执行beforeTick等生命周期，但不会进行位置计算和渲染，可以极大节约性能开销。</td>\n                </tr>\n                <tr>\n                    <td align="left">left/top <<Number|String|Function>></td>\n                    <td align="left">相对于父节点的位置（与CSS规则相同）。默认0。可以为百分比字符串，例如\'30%\'，则起点为父节点尺寸的30%。</td>\n                </tr>\n                <tr>\n                    <td align="left">width/height <<Number|String|Function>></td>\n                    <td align="left">节点的宽高（与CSS规则相同）。默认0。可以为百分比字符串，例如\'30%\'，则为父节点宽高的30%。</td>\n                </tr>\n                <tr>\n                    <td align="left">locate <<\'center\'|\'lt\'|\'rt\'|\'ld\'|\'rd\'|Function>></td>\n                    <td align="left">节点的定位方式（类似CSS的transform的translate）。默认\'center\'（以left、top为中心，向四周扩散到width、height的大小）。例如希望在(100,100)的位置展示一个30*30的爆炸效果，只需要让left和top为100、width和height为30即可，而不需要关注图片本身的尺寸，图片将以(100,100)为中心进行渲染。指定为\'lt\'可以使用类似CSS的方式（图片向右下方展开）。</td>\n                </tr>\n                <tr>\n                    <td align="left">zIndex <<Number|Function>></td>\n                    <td align="left">节点的渲染层次（类似CSS的zIndex）。默认0。不建议同一位置存在相同zIndex的多个节点。</td>\n                </tr>\n                <tr>\n                    <td align="left">opacity <<Number|Function>></td>\n                    <td align="left">节点的透明度（与CSS规则相同）。默认1。子节点的透明度会受到父节点影响，相乘计算。为便于使用，允许为子节点设置大于1的透明度，例如父节点设置为0.5、子节点设置为2以上时，子节点将不透明。</td>\n                </tr>\n                <tr>\n                    <td align="left">scale <<Number|Function>></td>\n                    <td align="left">节点的缩放倍数（类似CSS的transform的scale）。默认1。子节点的缩放会受到父节点影响，相乘计算。只是画面效果，不会影响节点的宽高或位置的相关属性、操作。</td>\n                </tr>\n                <tr>\n                    <td align="left">rotate <<Number|Function>></td>\n                    <td align="left">节点的旋转角度（类似CSS的transform的rotate）。默认0。</td>\n                </tr>\n                <tr>\n                    <td align="left">rotateOriginLeft/rotateOriginTop <<Number|Function>></td>\n                    <td align="left">节点的旋转中心（类似CSS的transform-origin）。默认为节点中心。</td>\n                </tr>\n                <tr>\n                    <td align="left">overflow <<\'hidden\'|\'visible\'|Function>></td>\n                    <td align="left">内部子节点的渲染超出当前节点的范围时，展示还是隐藏（类似CSS的overflow）。默认\'visible\'。</td>\n                </tr>\n                <tr>\n                    <td align="left">backgroundColor <<Color|Function>></td>\n                    <td align="left">节点的背景色。支持rgba等常见颜色格式。</td>\n                </tr>\n                <tr>\n                    <td align="left">borderWidth <<Number|Function>></td>\n                    <td align="left">节点的外边框粗细。默认0。外边框不处于节点的容器范围内，因此不参与事件监听的位置判定、不影响使用API获取节点宽高时的结果、不影响子节点位置计算。</td>\n                </tr>\n                <tr>\n                    <td align="left">borderColor <<Color|Function>></td>\n                    <td align="left">节点的边框颜色。支持rgba等常见颜色格式。</td>\n                </tr>\n                <tr>\n                    <td align="left">mirrX/mirrY <<Boolean|Function>> deprecated</td>\n                    <td align="left">是否水平、垂直镜像，仅对content中的img图片生效。</td>\n                </tr>\n                <tr>\n                    <td align="left">fontSize <<Number|Function>></td>\n                    <td align="left">节点的文字大小。默认14。应用包含文字渲染时，请注意根据设备dpr对canvas节点进行缩放（例如在创建Painter类时指定dpr参数），否则锯齿会比较明显。</td>\n                </tr>\n                <tr>\n                    <td align="left">color <<Color|Function>></td>\n                    <td align="left">节点的文字颜色。默认\'black\'。支持rgba等常见颜色格式。</td>\n                </tr>\n                <tr>\n                    <td align="left">fontFamily <<String|Function>></td>\n                    <td align="left">节点的字体。默认\'serif\'。</td>\n                </tr>\n                <tr>\n                    <td align="left">textAlign <<\'left\'|\'center\'|\'right\'|Function>></td>\n                    <td align="left">节点的水平对齐方式。默认\'left\'。</td>\n                </tr>\n                <tr>\n                    <td align="left">textVerticalAlign <<\'top\'|\'middle\'|\'bottom\'|Function>></td>\n                    <td align="left">节点的垂直对齐方式。默认\'top\'。</td>\n                </tr>\n            </tbody>\n            <thead>\n                <tr>\n                    <th align="left">events</th>\n                    <th align="left">以下属性在events对象内，支持自定义扩展事件；除初始化时之外，通常不直接修改，建议利用addEventListener与removeEventListener方法进行添加和删除，详见API部分</th>\n                </tr>\n            </thead>\n            <tbody>\n                <tr>\n                    <td align="left">click/contextmenu/dblclick <<Function>></td>\n                    <td align="left">点击、右键或双指点击、双击时触发。移动端浏览器的点击延迟问题可以通过在创建Painter时指定fastclick解决，相见Painter API部分。</td>\n                </tr>\n                <tr>\n                    <td align="left">touchstart/touchmove/touchend <<Function>></td>\n                    <td align="left">触屏相关事件。</td>\n                </tr>\n                <tr>\n                    <td align="left">mousedown/mousemove/mouseup/mousewheel <<Function>></td>\n                    <td align="left">鼠标相关事件。</td>\n                </tr>\n                <tr>\n                    <td align="left">eIndex <Number></td>\n                    <td align="left">事件层次，默认与zIndex相同，决定节点的事件响应顺序。当一个节点的渲染层级很低，但希望优先尝试命中事件时，可以声明一个较大的eIndex来提高事件响应优先级。事件内部相关方法参考Event API。</td>\n                </tr>\n            </tbody>\n            <thead>\n                <tr>\n                    <th align="left">hooks</th>\n                    <th align="left">以下属性在hooks对象内，支持自定义扩展生命周期；除初始化时之外，通常不直接修改，建议利用on与off方法进行添加和删除，详见API部分</th>\n                </tr>\n            </thead>\n            <tbody>\n                <tr>\n                    <td align="left">beforeTick/ticked <<Function>></td>\n                    <td align="left">每帧之前或之后触发。生命周期钩子的内部相关方法参考Event API。</td>\n                </tr>\n                <tr>\n                    <td align="left">beforeRemove/removed <<Function>></td>\n                    <td align="left">节点被移除之前或之后触发。生命周期钩子的内部相关方法参考Event API。</td>\n                </tr>\n            </tbody>\n        </table>\n\n        <p>Sprite类包含如下API（没有特殊注明返回值的API均会返回当前Sprite自身，以便于链式调用）：</p>\n\n        <table>\n            <thead>\n                <tr>\n                    <th align="left">add(child)</th>\n                    <th align="left">添加子节点。</th>\n                </tr>\n            </thead>\n            <tbody>\n                <tr>\n                    <td align="left">child <<Sprite|Object>></td>\n                    <td align="left">子节点。如果传入的是Object，会调用new Sprite(child)构建一个Sprite类。</td>\n                </tr>\n                <tr>\n                    <td align="left">返回值 <<Sprite>></td>\n                    <td align="left">返回child实例。</td>\n                </tr>\n            </tbody>\n            <thead>\n                <tr>\n                    <th align="left">getRect()</th>\n                    <th align="left">获取Sprite模型所占的区域盒子。</th>\n                </tr>\n            </thead>\n            <tbody>\n                <tr>\n                    <td align="left">返回值 <<{left,top,right,bottom,width,height}>></td>\n                    <td align="left">Sprite所占区域的边界。如果style中没有width和height，但是存在content.img，那么会使用图片的尺寸。这一点与HTML的<<img>>标签的规则是相同的。</td>\n                </tr>\n            </tbody>\n            <thead>\n                <tr>\n                    <th align="left">getStyle(prop, fromLastTick)</th>\n                    <th align="left">获取Sprite的某个样式的渲染结果。</th>\n                </tr>\n            </thead>\n            <tbody>\n                <tr>\n                    <td align="left">prop <<\'left\'|\'opacity\'|...>></td>\n                    <td align="left">要获取的样式。</td>\n                </tr>\n                <tr>\n                    <td align="left">fromLastTick <<Boolean>></td>\n                    <td align="left">从上一帧的渲染缓存中获取，默认true。设置为false将遍历全部父节点进行重新计算。当通过js修改了某个样式后立刻调用这个API，此时新的样式还没有被渲染出来，可以设置为false来判断下一帧的渲染结果。</td>\n                </tr>\n                <tr>\n                    <td align="left">返回值 <<Number|String|Boolean>></td>\n                    <td align="left">对应的渲染结果。位置、透明度等属性会受到父节点的影响，并且位置属性是经过locate运算后的实际渲染结果。</td>\n                </tr>\n            </tbody>\n            <thead>\n                <tr>\n                    <th align="left">getSelfStyle(prop)</th>\n                    <th align="left">获取Sprite当前样式的设置的值。</th>\n                </tr>\n            </thead>\n            <tbody>\n                <tr>\n                    <td align="left">prop <<undefined|\'left\'|\'opacity\'|...>></td>\n                    <td align="left">要获取的样式。留空代表全部获取</td>\n                </tr>\n                <tr>\n                    <td align="left">返回值 <<Number|String|Boolean|Object>></td>\n                    <td align="left">当前设置的值。如果设置的是一个function（例如Transition渐变），会返回当前的结果。如果没有传入prop，会返回一个Object，包含style中的全部属性。</td>\n                </tr>\n            </tbody>\n            <thead>\n                <tr>\n                    <th align="left">remove(child)</th>\n                    <th align="left">移除节点或者子节点。</th>\n                </tr>\n            </thead>\n            <tbody>\n                <tr>\n                    <td align="left">child <<Sprite|undefined>></td>\n                    <td align="left">移除当前节点的child节点，child留空代表移除当前节点。</td>\n                </tr>\n            </tbody>\n            <thead>\n                <tr>\n                    <th align="left">update(config)</th>\n                    <th align="left">立即更新节点属性。</th>\n                </tr>\n            </thead>\n            <tbody>\n                <tr>\n                    <td align="left">config <<Object>></td>\n                    <td align="left">属性集合，例如{style: {left: 1}, content: {text: \'foo\'}}。将立刻触发Sprite的重新计算，相比其它API更加消耗性能。通常情况下可以直接修改属性（如Sprite.style.left=1）来进行更新。</td>\n                </tr>\n            </tbody>\n\n            <thead>\n                <tr>\n                    <th align="left">addEventListener(eventName, callback)</th>\n                    <th align="left">注册事件监听函数。</th>\n                </tr>\n            </thead>\n            <tbody>\n                <tr>\n                    <td align="left">eventName <<String>></td>\n                    <td align="left">事件名，支持几乎全部HTML中的事件，参考事件API。</td>\n                </tr>\n                <tr>\n                    <td align="left">callback <<Function>></td>\n                    <td align="left">事件触发的回调，入参参考事件API。</td>\n                </tr>\n            </tbody>\n            <thead>\n                <tr>\n                    <th align="left">removeEventListener(eventName, callback)</th>\n                    <th align="left">移除一个或全部的事件监听。</th>\n                </tr>\n            </thead>\n            <tbody>\n                <tr>\n                    <td align="left">eventName <<String>></td>\n                    <td align="left">事件名，支持几乎全部HTML中的事件，参考事件API。</td>\n                </tr>\n                <tr>\n                    <td align="left">callback <<undefined|Function>></td>\n                    <td align="left">事件触发的回调，不传入代表移除当前事件的全部监听函数。</td>\n                </tr>\n            </tbody>\n\n            <thead>\n                <tr>\n                    <th align="left">on(hookName, callback)</th>\n                    <th align="left">注册钩子监听函数。可以是生命周期钩子，也可以自定义钩子。</th>\n                </tr>\n            </thead>\n            <tbody>\n                <tr>\n                    <td align="left">hookName <<String>></td>\n                    <td align="left">钩子名。</td>\n                </tr>\n                <tr>\n                    <td align="left">callback <<Function>></td>\n                    <td align="left">钩子触发的回调，入参由触发者决定。</td>\n                </tr>\n            </tbody>\n            <thead>\n                <tr>\n                    <th align="left">off(hookName, callback)</th>\n                    <th align="left">移除一个或全部的钩子监听。</th>\n                </tr>\n            </thead>\n            <tbody>\n                <tr>\n                    <td align="left">hookName <<String>></td>\n                    <td align="left">钩子名。</td>\n                </tr>\n                <tr>\n                    <td align="left">callback <<undefined|Function>></td>\n                    <td align="left">钩子的监听回调，不传入代表移除当前钩子的全部监听函数。</td>\n                </tr>\n            </tbody>\n\n            <thead>\n                <tr>\n                    <th align="left">distribute(hookName, ...params)</th>\n                    <th align="left">触发当前节点的全部子节点的钩子。</th>\n                </tr>\n            </thead>\n            <tbody>\n                <tr>\n                    <td align="left">hookName <<String>></td>\n                    <td align="left">钩子名。</td>\n                </tr>\n                <tr>\n                    <td align="left">params <<any>></td>\n                    <td align="left">传入钩子监听函数的任意个参数。</td>\n                </tr>\n            </tbody>\n\n            <thead>\n                <tr>\n                    <th align="left">broadcast(hookName, ...params)</th>\n                    <th align="left">触发当前节点及其全部子节点的钩子。</th>\n                </tr>\n            </thead>\n            <tbody>\n                <tr>\n                    <td align="left">hookName <<String>></td>\n                    <td align="left">钩子名。</td>\n                </tr>\n                <tr>\n                    <td align="left">params <<any>></td>\n                    <td align="left">传入钩子监听函数的任意个参数。</td>\n                </tr>\n            </tbody>\n\n            <thead>\n                <tr>\n                    <th align="left">trigger(hookName, ...params)</th>\n                    <th align="left">触发当前节点的钩子。</th>\n                </tr>\n            </thead>\n            <tbody>\n                <tr>\n                    <td align="left">hookName <<String>></td>\n                    <td align="left">钩子名。</td>\n                </tr>\n                <tr>\n                    <td align="left">params <<any>></td>\n                    <td align="left">传入钩子监听函数的任意个参数。</td>\n                </tr>\n            </tbody>\n\n            <thead>\n                <tr>\n                    <th align="left">getAllChildren(includeSelf)</th>\n                    <th align="left">获取当前节点的全部子节点（包含子节点的子节点）。</th>\n                </tr>\n            </thead>\n            <tbody>\n                <tr>\n                    <td align="left">includeSelf <<Boolean>></td>\n                    <td align="left">返回值是否需要包含当前节点，默认false。</td>\n                </tr>\n                <tr>\n                    <td align="left">返回值 <<Array>></td>\n                    <td align="left">子节点的集合。</td>\n                </tr>\n            </tbody>\n            <thead>\n                <tr>\n                    <th align="left">getAllVisibleChildren(includeSelf)</th>\n                    <th align="left">获取当前节点的全部style.visible不为false的子节点（包含子节点的子节点）。</th>\n                </tr>\n            </thead>\n            <tbody>\n                <tr>\n                    <td align="left">includeSelf <<Boolean>></td>\n                    <td align="left">返回值是否需要包含当前节点，默认false。</td>\n                </tr>\n                <tr>\n                    <td align="left">返回值 <<Array>></td>\n                    <td align="left">子节点的集合。注意如果一个子节点的style.visible为false，那么它内部的子节点也将被认为是不可见。</td>\n                </tr>\n            </tbody>\n            <thead>\n                <tr>\n                    <th align="left">getAllVisibleChildren(includeSelf)</th>\n                    <th align="left">获取当前节点的全部style.visible不为false的子节点（包含子节点的子节点）。</th>\n                </tr>\n            </thead>\n            <tbody>\n                <tr>\n                    <td align="left">includeSelf <<Boolean>></td>\n                    <td align="left">返回值是否需要包含当前节点，默认false。</td>\n                </tr>\n                <tr>\n                    <td align="left">返回值 <<Array>></td>\n                    <td align="left">子节点的集合。注意如果一个子节点的style.visible为false，那么它内部的子节点也将被认为是不可见。</td>\n                </tr>\n            </tbody>\n            <thead>\n                <tr>\n                    <th align="left">getOuterRect()</th>\n                    <th align="left">获取能容纳Sprite及其全部子节点的区域盒子。</th>\n                </tr>\n            </thead>\n            <tbody>\n                <tr>\n                    <td align="left">返回值 <<{left,top,right,bottom,width,height}>></td>\n                    <td align="left">区域的边界。注意这个方法将忽略style.visible为false的子节点。</td>\n                </tr>\n            </tbody>\n\n            <thead>\n                <tr>\n                    <th align="left">combine() deprecated，建议使用combineAsync</th>\n                    <th align="left">尝试节点合并。如果等待当前节点的全部子节点都在可视区域内渲染完成，将全部渲染结果合并为图片，写入当前节点的content.img。如果有节点未完成渲染或在可视范围之外则无效。合并后通常可以大幅提升性能（例如10个节点合并成为1个，大约可以减少90%的性能开销）。但合并之后子节点无法再修改位置和样式，除非再调用uncombine。合并不影响子节点的事件处理逻辑。建议用于复杂的UI模块。</th>\n                </tr>\n            </thead>\n            <thead>\n                <tr>\n                    <th align="left">combineAsync()</th>\n                    <th align="left">每100毫秒尝试进行一次combine，直至合并成功。</th>\n                </tr>\n            </thead>\n            <thead>\n                <tr>\n                    <th align="left">uncombine()</th>\n                    <th align="left">取消合并，或者终止尝试combineAsync的轮询。</th>\n                </tr>\n            </thead>\n\n            <thead>\n                <tr>\n                    <th align="left">recalculate(removeCache)</th>\n                    <th align="left">重新计算节点的属性。通常不需要直接调用。update()方法内部会调用此API。</th>\n                </tr>\n            </thead>\n            <tbody>\n                <tr>\n                    <td align="left">removeCache <<Boolean>></td>\n                    <td align="left">移除节点内部的缓存，全部重新计算。默认false。通常不需要调用。</td>\n                </tr>\n            </tbody>\n\n            <thead>\n                <tr>\n                    <th align="left">nextTick(callback)</th>\n                    <th align="left">在下一帧运行回调。</th>\n                </tr>\n            </thead>\n            <tbody>\n                <tr>\n                    <td align="left">callback <<Function>></td>\n                    <td align="left">下一帧运行的函数。入参为下一帧的渲染时间，函数内的this指向当前Sprite。</td>\n                </tr>\n            </tbody>\n\n            <thead>\n                <tr>\n                    <th align="left">clear()</th>\n                    <th align="left">移除当前Sprite的全部子节点。</th>\n                </tr>\n            </thead>\n        </table>\n\n    </article>\n\n    \n    <article id="Transition-API">\n        <h1>Transition 数字渐变函数</h1>\n\n        <p>Transition用于为Sprite设置一个可以不断变化的数字属性。例如下面这个例子中，SomeSprite的left将会从0匀速变化到100，然后立刻回到0再重新渐变到100，不断循环：</p>\n\n        <code>\n                const { Transition } = Easycanvas;\n\n                // ... ...\n\n                SomeSprite.style.left = Transition.linear(0, 100, 3000).loop();\n        </code>\n\n        <p>其原理是，Transition.linear会创建一个与时间有关的函数，每次调用时将根据当前帧的渲染时间计算出一个合适的值。</p>\n\n        <p class="tip">Tips：这里根据“当前帧的渲染时间”来计算，而不是用“当前时间”来计算，是为了避免当在大段逻辑中js运行时间超过1毫秒时，前后运行的多个Transition的参考时间不同，导致的一些效果出现微小误差的情况。</p>\n\n        <p>可用的函数及参数含义：</p>\n\n        <table>\n            <thead>\n                <tr>\n                    <th align="left">Transition.linear(a, b, duration)</th>\n                    <th align="left">匀速渐变，从a匀速变化到b</th>\n                </tr>\n            </thead>\n            <tbody>\n                <tr>\n                    <td align="left">a <<Number>></td>\n                    <td align="left">起始数值</td>\n                </tr>\n                <tr>\n                    <td align="left">b <<Number>></td>\n                    <td align="left">终点数值</td>\n                </tr>\n                <tr>\n                    <td align="left">duration <<Number>></td>\n                    <td align="left">过渡用时，单位毫秒</td>\n                </tr>\n            </tbody>\n            <thead>\n                <tr>\n                    <th align="left">Transition.pendulum(a, b, duration, [config])</th>\n                    <th align="left">钟摆渐变，从a向b渐变之后再返回a，数值越靠近a、b变化越慢，在a、b中间时最快</th>\n                </tr>\n            </thead>\n            <tbody>\n                <tr>\n                    <td align="left">config.start <<Number>></td>\n                    <td align="left">起始位置，默认为0，单位为三角函数中的角度，因此一个完整的周期为360。</td>\n                </tr>\n                <tr>\n                    <td align="left">cycle <<Number>></td>\n                    <td align="left">摆动周期，默认为1。</td>\n                </tr>\n            </tbody>\n            <thead>\n                <tr>\n                    <th align="left">Transition.ease(a, b, duration)</th>\n                    <th align="left">加速渐变，其实现为Transition.pendulum(a, b, duration * 2, { cycle: 0.5, })</th>\n                </tr>\n            </thead>\n        </table>\n\n        <p>Transition函数的返回值拥有如下API:</p>\n\n        <table>\n            <thead>\n                <tr>\n                    <th align="left">API</th>\n                    <th align="left">描述</th>\n                </tr>\n            </thead>\n            <tbody>\n                <tr>\n                    <td align="left">loop()</td>\n                    <td align="left">循环进行，数值到达终点后将立刻返回起点，然后重新向终点渐变。</td>\n                </tr>\n                <tr>\n                    <td align="left">then(callback)</td>\n                    <td align="left">结束回调，需要注意循环进行的渐变不会触发回调。回调触发时，当前数值将作为入参传入。</td>\n                </tr>\n                <tr>\n                    <td align="left">restart()</td>\n                    <td align="left">重置渐变。</td>\n                </tr>\n            </tbody>\n        </table>\n\n    </article>\n\n'.replace(/<</g,"&lt;").replace(/>>/g,"&gt;")}}]);