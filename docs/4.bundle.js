(window.webpackJsonp=window.webpackJsonp||[]).push([[4],{441:function(n,a,e){"use strict";e.r(a);var t=`\n    <article id="WebGL-其它格式的模型">\n        <h1>WebGL-其它格式的模型</h1>\n\n        <p>目前支持pmd/pmx/vmd/vpd/fbx/dds格式的文件解析，后续将逐渐补充其它格式。</p>\n\n        <p class="tip">Three.js库提供了一些loader来支持这些格式的加载，但是是和Three.js耦合在一起的，无法单独使用。Easycanvas的loader是以Three.js为基础进行改造而来，只提供顶点、索引等Webgl中必需的属性，因此可以配合Easycanvas本身使用，也可以用于原生Webgl语法。</p>\n\n        <h2>引入方式</h2>\n\n        <code>\n            \x3c!-- js文件方式引入 --\x3e\n            \x3c!-- 注意放在easycanvas.js后；prod为线上压缩版、dev为开发版；开发版带有调试、警告信息 --\x3e\n\n            <script src="http://your-path/easycanvas.standalone.prod.js"><\/script>\n            <script src="http://your-path/plugin.webgl.standalone.prod.js"><\/script>\n            <script src="http://your-path/plugin.webgl.loaders.standalone.prod.js"><\/script>\n\n            \x3c!-- 如果要加载pmd/pmx/vmd，需要额外引入mmdparser --\x3e\n            <script src='https://raw.githubusercontent.com/c-zhuo/easycanvas/develop/0.8.4/demos/resource/mmd/lib/mmdparser.min.js'><\/script>\n\n            \x3c!-- 如果要加载fbx，需要额外引入zlib --\x3e\n            <script src='https://raw.githubusercontent.com/c-zhuo/easycanvas/develop/0.8.4/demos/resource/fbxdds/zlib.min.js'><\/script>\n        </code>\n        <code>\n            \x3c!-- node环境引入 --\x3e\n            \x3c!-- 注意：在node环境引入，也需要引入mmdparser或者zlib --\x3e\n\n            import Easycanvas from 'easycanvas';\n            import EasycanvasWebgl from 'easycanvas/build/plugin.webgl.js';\n            import EasycanvasWebglLoaders from 'easycanvas/build/plugin.webgl.loaders.js';\n\n            Easycanvas.use(EasycanvasWebgl);\n            Easycanvas.use(EasycanvasWebglLoaders);\n        </code>\n\n        <h2>加载FBX模型和DDS图像</h2>\n\n        <p>FBX是一种模型资源文件，DDS是一种压缩图片格式。如下例。</p>\n\n        ${e(83).a}\n    </article>\n`;a["default"]=`\n    \n    <article id="物理引擎">\n        <h1>物理引擎</h1>\n\n        <p>Easycanvas使用的物理引擎是chipmunk，这个引擎拥有c与js版本，被Cocos2d、Hilo使用。</p>\n\n        <p>这里将介绍如何给Sprite一些物理规则，产生重力、碰撞的效果，以及如何对他们施加力、自定义碰撞的处理等。</p>\n        \n        <h2>引入方式</h2>\n\n        <code>\n            \x3c!-- js文件方式引入 --\x3e\n            \x3c!-- 注意放在easycanvas.js后；prod为线上压缩版、dev为开发版；开发版带有调试、警告信息 --\x3e\n\n            <script src="http://your-path/easycanvas.standalone.prod.js"><\/script>\n            <script src="http://your-path/plugin.physics.standalone.prod.js"><\/script>\n        </code>\n        <code>\n            \x3c!-- node环境引入 --\x3e\n\n            import Easycanvas from 'easycanvas';\n            import EasycanvasPhysics from 'easycanvas/build/plugin.physics.js';\n\n            Easycanvas.extend(EasycanvasPhysics);\n        </code>\n\n        <h2>重力、弹力、摩擦</h2>\n\n        <p>物理引擎插件是对Easycanvas的Sprite类进行扩展。<strong>在创建一个Sprite实例时，指定了physics属性，这个实例才可以使用下列由physics插件提供的物理API</strong>。</p>\n\n        <p>Sprite类的physics对象包含shape（形状）、mass（质量）、friction（摩擦系数，通常0～1之间）、elasticity（弹性系数，通常0～1之间）、collisionType（碰撞类型，后面会详细介绍）、static（是否静态）等。这些属性有的会相互覆盖，例如一个Sprite是静态的物理对象（static为true），那么他的mass（质量）其实没有任何作用。</p>\n\n        <p><strong>拥有物理属性的Sprite并不会一开始就遵循物理规则，需要通过launch或者physicsOn方法来开始运算</strong>。当我们在一个Sprite上调用launch方法，那么这个Sprite将成为一个物理容器（更准确的说，是一个物理空间space），其内部的物理规则才会启用，例如物理计算的时间粒度、内部重力系数。如下例：</p>\n\n        <section>\n            <div class="code-2-demo bg-demo"></div>\n            <code>\n                <head>\n                    <script src="./lib/easycanvas/plugin.physics.standalone.prod.js"><\/script>\n                </head>\n                <body>\n                    <canvas id="app"></canvas>\n                </body>\n\n                <script>\n                    var $app = new Easycanvas.Painter();\n                    $app.register(document.getElementById('app'), {\n                        width: 400,\n                        height: 400,\n                    });\n                    $app.start();\n\n                    var BALL = Easycanvas.ImgLoader('https://raw.githubusercontent.com/c-zhuo/easycanvas/master/demos/G.png');\n\n                    var $space = new Easycanvas.Sprite({\n                        physics: {\n                            gravity: 1,\n                            accuracy: 1,\n                        },\n                    });\n                    $app.add($space);\n\n                    // 从这个时刻启，$space的物理规则生效\n                    $space.launch();\n\n                    var $letterG = new Easycanvas.Sprite({\n                        name: 'ball',\n                        content: {\n                            img: BALL,\n                        },\n                        physics: {\n                            // 形状是一个以(10,10)为圆心的，半径8的圆\n                            shape: [\n                                [10, 10, 8]\n                            ],\n                            mass: 0.1, // 质量\n                            friction: 0.2, // 摩擦\n                            elasticity: 1, // 弹性\n                            collisionType: 1,\n                        },\n                        style: {\n                            width: 20, height: 20,\n                            left: 200, top: 50,\n                        },\n                    });\n                    $space.add($letterG);\n\n                    // 从这个时刻启，$letterG的物理运算将开启（会开始下落）\n                    $letterG.physicsOn();\n\n                    var $border = $space.add(new Easycanvas.Sprite({\n                        physics: {\n                            shape: [\n                                // 这里是由四条线段围成的方框，作为边界\n                                [[0, 0], [0, 400]],\n                                [[0, 0], [400, 0]],\n                                [[400, 400], [400, 0]],\n                                [[400, 400], [0, 400]],\n                            ],\n                            friction: 1,\n                            elasticity: 0.9,\n                            collisionType: 1,\n                            static: true\n                        },\n                        style: {\n                            left: 0, top: 0, width: 400, height: 400,\n                            locate: 'lt',\n                        },\n                    }));\n\n                    // 从这个时刻启，$border的物理运算将开启\n                    $border.physicsOn();\n                <\/script>\n            </code>\n        </section>\n\n        <h2>施加力和速度</h2>\n\n        <p>除了上面的API，每一个物理Sprite对象还拥有physicsApplyForce（施加力）、physicsResetForces（清除力）、physicsSetVelocity（设置速度）、physicsGetVelocity（获取速度）等API，例如：</p>\n\n        <section>\n            <div class="code-2-demo bg-demo"></div>\n            <code>\n                <head>\n                    <script src="./lib/easycanvas/plugin.physics.standalone.prod.js"><\/script>\n                </head>\n                <body>\n                    <canvas id="app"></canvas>\n                </body>\n\n                <script>\n                    var $app = new Easycanvas.Painter();\n                    $app.register(document.getElementById('app'), {\n                        width: 400,\n                        height: 400,\n                    });\n                    $app.start();\n\n                    var BALL = Easycanvas.ImgLoader('https://raw.githubusercontent.com/c-zhuo/easycanvas/master/demos/G.png');\n\n                    var $space = new Easycanvas.Sprite({\n                        physics: {\n                            gravity: 1,\n                            accuracy: 2,\n                        },\n                    });\n                    $app.add($space);\n\n                    $space.launch();\n\n                    var $letterG = new Easycanvas.Sprite({\n                        name: 'ball',\n                        content: {\n                            img: BALL,\n                        },\n                        physics: {\n                            // 形状是一个以(10,10)为圆心的，半径8的圆\n                            shape: [\n                                [10, 10, 8]\n                            ],\n                            mass: 1, // 质量\n                            friction: 0.2, // 摩擦\n                            elasticity: 1, // 弹性\n                            collisionType: 1,\n                        },\n                        style: {\n                            width: 20, height: 20,\n                            left: 200, top: 150,\n                        },\n                    });\n                    $space.add($letterG);\n\n                    $letterG.physicsOn();\n\n                    // 持续施加向右的作用力\n                    $letterG.physicsApplyForce({\n                        x: 100, y: 0\n                    });\n\n                    // 设置对象的初始速度（y为负值代表向上）\n                    $letterG.physicsSetVelocity({\n                        x: 0, y: -300\n                    });\n\n                    // 取消刚才施加的力的作用\n                    setTimeout(function () {\n                        $letterG.physicsResetForces();\n                    }, 1000)\n\n                    var $border = $space.add(new Easycanvas.Sprite({\n                        physics: {\n                            shape: [\n                                [[0, 0], [0, 400]],\n                                [[0, 0], [400, 0]],\n                                [[400, 400], [400, 0]],\n                                [[400, 400], [0, 400]],\n                            ],\n                            friction: 1,\n                            elasticity: 0.9,\n                            collisionType: 1,\n                            static: true\n                        },\n                        style: {\n                            left: 0, top: 0, width: 400, height: 400,\n                            locate: 'lt',\n                        },\n                    }));\n                    $border.physicsOn();\n                <\/script>\n            </code>\n        </section>\n\n        <p>Easycanvas并没有失重的API，也不支持动态切换物体的static的属性。但是这些功能可以通过基础API的调用实现。例如“失重”这个功能，可以通过给对象施加一个持续向上的作用力来实现。</p>\n\n        <p class="tip">Tips：为了简化运算，物理学中的万有引力G在这里相当于gravity的500倍，而不是“9.8米每平方秒”的那个G。</p>\n\n        <h2>API</h2>\n\n        <p>物理容器和物理对象都通过new Easycanvas.Sprite方法创建，创建时必须含有physics参数。</p>\n\n        <p>创建物理容器时，physics需要以下两个参数，之后可以通过launch方法启动内部物理规则。</p>\n\n        <table>\n            <thead>\n                <tr>\n                    <th align="left">参数</th>\n                    <th align="left">描述</th>\n                </tr>\n            </thead>\n            <tbody>\n                <tr>\n                    <td align="left">gravity</td>\n                    <td align="left">Number，重力系数，方向向下为正，默认为2（重力=重力系数*500）</td>\n                </tr>\n                <tr>\n                    <td align="left">accuracy</td>\n                    <td align="left">Number，时间流逝速度，默认为2（可以理解为1为慢放、4为二倍速），需要整数</td>\n                </tr>\n            </tbody>\n        </table>\n\n        <p>物理对象拥有如下参数：</p>\n\n        <table>\n            <thead>\n                <tr>\n                    <th align="left">参数</th>\n                    <th align="left">描述</th>\n                </tr>\n            </thead>\n            <tbody>\n                <tr>\n                    <td align="left">static</td>\n                    <td align="left">Boolean，是否为静态物体，默认为false；静态物体不会因为受到力的作用而产生位移，当然也不受重力影响，通常代表地面、场景边界等</td>\n                </tr>\n                <tr>\n                    <td align="left">mass</td>\n                    <td align="left">Number，质量，static不为true的物体必须拥有质量</td>\n                </tr>\n                <tr>\n                    <td align="left">moment</td>\n                    <td align="left">Number，转动惯量，选填；越大代表物体越不容易发生转动，默认会根据物体的形状及质量进行自动估算</td>\n                </tr>\n                <tr>\n                    <td align="left">friction</td>\n                    <td align="left">Number/Array，摩擦系数，通常0～1之间，默认为0；使用数组时可以对对应的shape单独设置</td>\n                </tr>\n                <tr>\n                    <td align="left">elasticity</td>\n                    <td align="left">Number/Array，弹性系数，通常0～1之间，默认为0；使用数组时可以对对应的shape单独设置</td>\n                </tr>\n                <tr>\n                    <td align="left">collisionType</td>\n                    <td align="left">Number/Array，碰撞类型，默认为0；通常用于自定义碰撞事件处理；使用数组时可以对对应的shape单独设置</td>\n                </tr>\n                <tr>\n                    <td align="left">shape</td>\n                    <td align="left">Array，形状集合，包含多个子形状。每个子形状也是一个Array类型。对于每个子形状：[a, b, r]代表圆，[[a1, b1], [a2, b2]]代表一条线（此时static必须为true），[[a1, b1], [a2, b2], [a3, b3], [aN, bN]]代表N边形。注意：“线段”只有当static为true时才可以使用。</td>\n                </tr>\n            </tbody>\n        </table>\n\n        <p>物理对象在调用physicsOn之后，会开始物理规则的运算。之后可以使用以下API：</p>\n\n        <table>\n            <thead>\n                <tr>\n                    <th align="left">API</th>\n                    <th align="left">描述</th>\n                </tr>\n            </thead>\n            <tbody>\n                <tr>\n                    <td align="left">physicsOff()</td>\n                    <td align="left">停止当前的物理规则运算（可以修改Sprite.physics对象的参数后重新调用physicsOn，）</td>\n                </tr>\n                <tr>\n                    <td align="left">physicsSetVelocity({x: Number, y: Number})</td>\n                    <td align="left">设置物体的速度</td>\n                </tr>\n                <tr>\n                    <td align="left">physicsGetVelocity()</td>\n                    <td align="left">查询物体的速度，返回 {x: Number, y: Number}</td>\n                </tr>\n                <tr>\n                    <td align="left">physicsSetAngelVelocity(Number)</td>\n                    <td align="left">设置物体的角速度</td>\n                </tr>\n                <tr>\n                    <td align="left">physicsGetAngelVelocity()</td>\n                    <td align="left">查询物体的角速度，返回 Number</td>\n                </tr>\n                <tr>\n                    <td align="left">physicsApplyImpulse({x, y}, {x, y})</td>\n                    <td align="left">给某个物体一个冲量（可以理解为瞬时的力，会立即改变物体的速度），参数分别为冲量矢量及作用点（作用点默认为{x: 0, y: 0}，代表中心）</td>\n                </tr>\n                <tr>\n                    <td align="left">physicsApplyForce({x, y}, {x, y})</td>\n                    <td align="left">给某个物体施加一个力（持续施加），参数分别为力矢量及作用点（作用点默认为{x: 0, y: 0}，代表中心）</td>\n                </tr>\n                <tr>\n                    <td align="left">physicsResetForces()</td>\n                    <td align="left">移除某个物体受到的全部力（重力除外）</td>\n                </tr>\n            </tbody>\n        </table>\n\n        <p>物理对象拥有以下钩子：</p>\n\n        <table>\n            <thead>\n                <tr>\n                    <th align="left">hook</th>\n                    <th align="left">描述</th>\n                </tr>\n            </thead>\n            <tbody>\n                <tr>\n                    <td align="left">physicsCollisionBegin(b, type, cp, space)</td>\n                    <td align="left">碰撞开始的钩子；发生碰撞的两个物体各触发一次（如果其中一个是静态物体，那么静态物体后触发）；任一返回true，都将取消物理计算（即物体将会重叠，弹性、摩擦等不起作用，不会触发physicsCollisionPreSolve和physicsCollisionPostSolve）；物体分离之前不会再次触发这个钩子</td>\n                </tr>\n                <tr>\n                    <td align="left">physicsCollisionPreSolve(b, type, cp, space)</td>\n                    <td align="left">碰撞处理前的钩子；发生碰撞的两个物体各触发一次（如果其中一个是静态物体，那么静态物体后触发）；任一返回true，都将取消物理计算（不会触发physicsCollisionPostSolve）；在物体分离前会连续调用（每帧调用accuracy次）</td>\n                </tr>\n                <tr>\n                    <td align="left">physicsCollisionPostSolve(b, type, cp, space)</td>\n                    <td align="left">碰撞处理后的钩子；返回值无作用。</td>\n                </tr>\n                <tr>\n                    <td align="left">physicsCollisionSeparate(b, type, cp, space)</td>\n                    <td align="left">物体分离的钩子；返回值无作用。</td>\n                </tr>\n            </tbody>\n            <thead>\n                <tr>\n                    <th align="left">参数</th>\n                    <th align="left">描述</th>\n                </tr>\n            </thead>\n            <tbody>\n                <tr>\n                    <td align="left">this</td>\n                    <td align="left">钩子中的this指向当前Sprite对象</td>\n                </tr>\n                <tr>\n                    <td align="left">b</td>\n                    <td align="left">指向发生碰撞的另一个Sprite对象</td>\n                </tr>\n                <tr>\n                    <td align="left">type</td>\n                    <td align="left">发生碰撞的另一个Sprite对象的碰撞类型，等于b.physics.collisionType</td>\n                </tr>\n                <tr>\n                    <td align="left">cp</td>\n                    <td align="left">碰撞的全部细节，是一个chipmunk对象。包括方向、2个shape等，详情参考<a target="_blank" href="http://wingedrobin.github.io/Chipmunk-js/cp.CollisionHandler.html#begin">这里</a></td>\n                </tr>\n                <tr>\n                    <td align="left">space</td>\n                    <td align="left">物理空间，是一个chipmunk的Space对象。space.$Sprite将指向物理容器的Sprite实例。更多的API见<a target="_blank" href="http://wingedrobin.github.io/Chipmunk-js/cp.Space.html">这里</a></td>\n                </tr>\n            </tbody>\n        </table>\n\n        <p class="tip">Tips：此外，launch方法也会返回chipmunk物理引擎的Space对象，可以用于<a target="_blank" href="http://wingedrobin.github.io/Chipmunk-js/cp.CollisionHandler.html#begin">设置全局的监听函数</a>、遍历所有<a target="_blank" href="http://wingedrobin.github.io/Chipmunk-js/cp.Space.html#eachBody">物体</a>或者<a target="_blank" href="http://wingedrobin.github.io/Chipmunk-js/cp.Space.html#eachShape">形状</a>等。</p>\n    </article>\n\n    \n    <article id="WebGL-加载3DS模型">\n        <h1>WebGL-加载3DS模型</h1>\n\n        <p>WebGL.3DS是Easycanvas提供的对WebGL插件的扩展，需要和WebGL插件共同使用。用于导入3DS文件的模型，并提供了一个loader3DS对象，用于获取3DS文件的数据。</p>\n\n        <p><strong>3DS模型是扩展名为.3ds的文件，此外还有以.max为后缀的文件。max格式的文件虽然无法直接使用，但是可以用其他工具转换为3ds格式。</strong></p>\n\n        <p class="tip">在浏览器端，loader3DS会将3DS文件解析为包含vertices等属性的JSON格式的数据。这个过程会消耗一些性能，因此也可以预先将将3DS转换为JSON，在浏览器里进行引入，以节约性能。</p>\n\n        <h2>引入方式</h2>\n\n        <code>\n            \x3c!-- js文件方式引入 --\x3e\n            \x3c!-- 注意放在easycanvas.js后；prod为线上压缩版、dev为开发版；开发版带有调试、警告信息 --\x3e\n\n            <script src="http://your-path/easycanvas.standalone.prod.js"><\/script>\n            <script src="http://your-path/plugin.webgl.standalone.prod.js"><\/script>\n            <script src="http://your-path/plugin.webgl.3ds.standalone.prod.js"><\/script>\n        </code>\n        <code>\n            \x3c!-- node环境引入 --\x3e\n\n            import Easycanvas from 'easycanvas';\n            import EasycanvasWebgl from 'easycanvas/build/plugin.webgl.js';\n            import EasycanvasWebgl3DS from 'easycanvas/build/plugin.webgl.3ds.js';\n\n            Easycanvas.use(EasycanvasWebgl);\n            Easycanvas.use(EasycanvasWebgl3DS);\n        </code>\n\n        <p>WebGL.3DS插件支持2种使用方式，<strong>导入3DS模型</strong>和<strong>解析3DS文件数据</strong>。前者更加便捷，后者扩展性更强。</p>\n\n        <h2>导入3DS模型</h2>\n\n        <p>可以通过为Sprite类的webgl追加_3ds属性来导入3DS模型。_3ds属性的值为3DS文件的地址，将在Sprite对象创建时发起加载，异步加载成功后进行渲染，如下例：</p>\n\n        <section>\n            <div class="code-2-demo bg-demo"></div>\n            <code>\n                <head>\n                    <script src="./lib/easycanvas/plugin.webgl.standalone.prod.js"><\/script>\n                    <script src="./lib/easycanvas/plugin.webgl.3ds.standalone.prod.js"><\/script>\n                </head>\n                <body>\n                    <canvas id="app"></canvas>\n                </body>\n\n                <script>\n                    var $app = new Easycanvas.Painter({\n                        el: '#app',\n                        width: 400,\n                        height: 400,\n                        webgl: true, // 开启WebGL渲染\n                    });\n\n                    $app.add(new Easycanvas.Sprite({\n                        style: {\n                            left: 200, top: 200,\n                        },\n                        webgl: {\n                            _3dsImg: {\n                                'Flower Center': 'https://raw.githubusercontent.com/c-zhuo/easycanvas/develop/0.8.4/demos/resource/15sunflower/center.jpg',\n                                'Petals': 'https://raw.githubusercontent.com/c-zhuo/easycanvas/develop/0.8.4/demos/resource/15sunflower/petal.jpg',\n                            },\n                            _3ds: 'https://raw.githubusercontent.com/c-zhuo/easycanvas/develop/0.8.4/demos/resource/15sunflower/15sunflower.3DS',\n                            ry: Easycanvas.Transition.linear(0, 360, 5000).loop(),\n                            scale: Easycanvas.Transition.pendulum(0.5, 1, 2000).loop(),\n                        }\n                    }));\n\n                    $app.start();\n                <\/script>\n            </code>\n        </section>\n\n        <p>这个例子中，用_3dsImg指定各个图层所对应的图片文件的地址。由于可能存在多个图层，不支持统一配置colors。如果想指定某一个图层的颜色，可以单独为某一个图层配置colors：</p>\n\n        <section>\n            <div class="code-2-demo bg-demo"></div>\n            <code>\n                <head>\n                    <script src="./lib/easycanvas/plugin.webgl.standalone.prod.js"><\/script>\n                    <script src="./lib/easycanvas/plugin.webgl.3ds.standalone.prod.js"><\/script>\n                </head>\n                <body>\n                    <canvas id="app"></canvas>\n                </body>\n\n                <script>\n                    var $app = new Easycanvas.Painter({\n                        el: '#app',\n                        width: 400,\n                        height: 400,\n                        webgl: true, // 开启WebGL渲染\n                    });\n\n                    $app.add(new Easycanvas.Sprite({\n                        style: {\n                            left: 200, top: 200,\n                        },\n                        webgl: {\n                            _3dsImg: {\n                                'Flower Center': 'https://raw.githubusercontent.com/c-zhuo/easycanvas/develop/0.8.4/demos/resource/15sunflower/center.jpg',\n                                'Petals': [\n                                    255, 0, 0,\n                                    166, 0, 0,\n                                    88, 0, 0,\n                                ],\n                            },\n                            _3ds: 'https://raw.githubusercontent.com/c-zhuo/easycanvas/develop/0.8.4/demos/resource/15sunflower/15sunflower.3DS',\n                            ry: Easycanvas.Transition.linear(0, 360, 5000).loop(),\n                            scale: Easycanvas.Transition.pendulum(0.5, 1, 2000).loop(),\n                        }\n                    }));\n\n                    $app.start();\n                <\/script>\n            </code>\n        </section>\n\n        <p>上面的例子中，我们用3个不同深浅的红色为“Petals”图层进行染色。</p>\n\n        <p><strong>Sprite初始化的时候，webgl中的_3ds等属性将被移除，并添加若干个子Sprite对象，每个都是3DS的一个图层。</strong></p>\n\n        <p class="tip">Tips：解析同一个3DS文件，产生的Sprite将共享顶点、索引等数据，这样有助于提升性能。如果希望对其中的一个进行单独编辑，可以在webgl中增加useCache属性，传入false即可。</p>\n\n        <h2>解析3DS数据</h2>\n\n        <p>下面是一个解析3DS文件的数据的例子。将相同的图层放在一起，可以提升渲染效率。例如下面的例子：</p>\n\n        <section>\n            <div class="code-2-demo bg-demo"></div>\n            <code>\n                <head>\n                    <script src="./lib/easycanvas/plugin.webgl.standalone.prod.js"><\/script>\n                    <script src="./lib/easycanvas/plugin.webgl.3ds.standalone.prod.js"><\/script>\n                </head>\n                <body>\n                    <canvas id="app"></canvas>\n                </body>\n\n                <script>\n                    var $app = new Easycanvas.Painter({\n                        el: '#app',\n                        width: 400,\n                        height: 400,\n                        webgl: true, // 开启WebGL渲染\n                    });\n\n                    var texture = {\n                        // 这几种图片加载方式都是可以的\n                        'Material #45': 'https://raw.githubusercontent.com/c-zhuo/easycanvas/develop/0.8.4/demos/resource/game_char/4.jpg',\n                        'Material #46': 'https://raw.githubusercontent.com/c-zhuo/easycanvas/develop/0.8.4/demos/resource/game_char/3.jpg',\n                        'Material #49': $app.imgLoader('https://raw.githubusercontent.com/c-zhuo/easycanvas/develop/0.8.4/demos/resource/game_char/6.jpg'),\n                        'Material #51': Easycanvas.ImgLoader('https://raw.githubusercontent.com/c-zhuo/easycanvas/develop/0.8.4/demos/resource/game_char/8.jpg'),\n                    };\n\n                    var rz = Easycanvas.Transition.linear(0, 360, 5000).loop();\n\n                    Easycanvas.loader3DS('https://raw.githubusercontent.com/c-zhuo/easycanvas/develop/0.8.4/demos/resource/game_char/sunnvfashi.3DS', function (data) {\n                        data.forEach(function (model) {\n                            var roleShape = {\n                                vertices: model.vertices,\n                                indices: model.indices,\n                                img: texture[model.img],\n                                textures: model.textures,\n                                scale: 20,\n                                rx: 90, ry: 0, rz: rz,\n                            };\n\n                            for (var i = 0; i < 10; i++) {\n                                $app.add({\n                                    name: model.img,\n                                    style: {\n                                        left: 60 + i % 5 * 70,\n                                        top: i >= 5 ? 300 : 100,\n                                    },\n                                    webgl: window.Easycanvas.webglShapes.custom(roleShape),\n                                });\n                            }\n                        });\n                    });\n\n                    $app.start();\n                <\/script>\n            </code>\n        </section>\n\n        <p>看起来场景中有10个人物模型，但是其实，我们是先创建了10个“Material #45”图层、再创建10个“Material #46”图层，以此类推。这样，渲染时可以最大程度的减少图层的切换，提升渲染的效率。</p>\n\n    </article>\n\n    \n    <article id="WebGL-加载MMD模型">\n        <h1>WebGL-加载MMD模型</h1>\n\n        <p>WebGL.MMD是Easycanvas提供的对WebGL插件的扩展，需要和WebGL插件共同使用。用于导入MMD文件的模型，并提供了一个loaderMMD对象，用于获取MMD文件的数据。</p>\n\n        <p><strong>MMD模型包括扩展名为.PMD的模型文件，以及扩展名为.VMD的骨骼动画文件，都可以在Easycanvas中使用。</strong></p>\n\n        <p class="tip">在浏览器端，loaderMMD会将MMD文件解析为包含vertices等属性的JSON格式的数据。这个过程会消耗一些性能，因此也可以预先将将MMD转换为JSON，在浏览器里进行引入，以节约性能。</p>\n\n        <h2>引入方式</h2>\n\n        <p><strong>如果要加载带有物理效果的VMD骨骼动画，需要额外引入Ammo.js</strong>，这是一个3D的物理计算库，不过体积较大（>1MB）。Node环境下建议将Ammo单独放在浏览器加载。</p>\n\n        <code>\n            \x3c!-- js文件方式引入 --\x3e\n            \x3c!-- 注意放在easycanvas.js后；prod为线上压缩版、dev为开发版；开发版带有调试、警告信息 --\x3e\n\n            <script src="http://your-path/ammo.js"><\/script>\n            <script src="http://your-path/easycanvas.standalone.prod.js"><\/script>\n            <script src="http://your-path/plugin.webgl.standalone.prod.js"><\/script>\n            <script src="http://your-path/plugin.webgl.mmd.standalone.prod.js"><\/script>\n        </code>\n        <code>\n            \x3c!-- node环境引入 --\x3e\n\n            import Easycanvas from 'easycanvas';\n            import EasycanvasWebgl from 'easycanvas/build/plugin.webgl.js';\n            import EasycanvasWebglMMD from 'easycanvas/build/plugin.webgl.mmd.js';\n\n            Easycanvas.use(EasycanvasWebgl);\n            Easycanvas.use(EasycanvasWebglMMD);\n        </code>\n\n        <p>WebGL.MMD插件支持2种使用方式，<strong>导入MMD模型</strong>和<strong>解析MMD文件数据</strong>。前者更加便捷，后者扩展性更强。</p>\n\n        <h2>导入MMD模型</h2>\n\n        <p>可以通过为Sprite类的webgl追加mmd属性来导入MMD模型。mmd属性的值为MMD文件的地址，将在Sprite对象创建时发起加载，异步加载成功后进行渲染，如下例：</p>\n\n        <section>\n            <div class="code-2-demo bg-demo"></div>\n            <code>\n                <head>\n                    <script src="./lib/easycanvas/plugin.webgl.standalone.prod.js"><\/script>\n                    <script src="./lib/easycanvas/plugin.webgl.mmd.standalone.prod.js"><\/script>\n                </head>\n                <body>\n                    <canvas id="app"></canvas>\n                </body>\n\n                <script>\n                    var $app = new Easycanvas.Painter({\n                        el: '#app',\n                        width: 400,\n                        height: 400,\n                        webgl: true, // 开启WebGL渲染\n                    });\n\n                    $app.add(new Easycanvas.Sprite({\n                        style: {\n                            left: 180, top: 350,\n                            zIndex: Math.random(),\n                        },\n                        webgl: {\n                            imgPath: 'https://raw.githubusercontent.com/c-zhuo/easycanvas/develop/0.8.4/demos/resource/mmd/model/mokou/',\n                            pmd: 'https://raw.githubusercontent.com/c-zhuo/easycanvas/develop/0.8.4/demos/resource/mmd/model/default/miku_v2.pmd',\n                            rz: 180,\n                            ry: Easycanvas.Transition.linear(0, 360, 5000).loop(),\n                            scale: Easycanvas.Transition.pendulum(10, 15, 3000).loop(),\n                        }\n                    }));\n\n                    $app.start();\n                <\/script>\n            </code>\n        </section>\n\n        <p>其中，imgPath为PMD文件中各图层使用的图片资源的根目录。由于PMD文件包含了图片资源的文件名，因此不需要像加载3DS那样指定。</p>\n\n        <p>这个例子中，大部分图层的纹理是纯色，因此看起来并不立体。不过由于模型中包含大量折线，添加光线后会比较真实：</p>\n\n        <section>\n            <div class="code-2-demo bg-demo"></div>\n            <code>\n                <head>\n                    <script src="./lib/easycanvas/plugin.webgl.standalone.prod.js"><\/script>\n                    <script src="./lib/easycanvas/plugin.webgl.mmd.standalone.prod.js"><\/script>\n                </head>\n                <body>\n                    <canvas id="app"></canvas>\n                </body>\n\n                <script>\n                    var $app = new Easycanvas.Painter({\n                        el: '#app',\n                        width: 400,\n                        height: 400,\n                        webgl: {\n                            light: true,\n                        }\n                    });\n\n                    $app.add(new Easycanvas.Sprite({\n                        style: {\n                            left: 180, top: 350,\n                            zIndex: Math.random(),\n                        },\n                        webgl: {\n                            imgPath: 'https://raw.githubusercontent.com/c-zhuo/easycanvas/develop/0.8.4/demos/resource/mmd/model/mokou/',\n                            pmd: 'https://raw.githubusercontent.com/c-zhuo/easycanvas/develop/0.8.4/demos/resource/mmd/model/default/miku_v2.pmd',\n                            rz: 180,\n                            ry: Easycanvas.Transition.linear(0, 360, 5000).loop(),\n                            scale: Easycanvas.Transition.pendulum(10, 15, 3000).loop(),\n                        }\n                    }));\n\n                    $app.start();\n                <\/script>\n            </code>\n        </section>\n\n        <p>可以通过vmdStart方法来播放一段动作，例如：</p>\n\n        <section>\n            <div class="code-2-demo bg-demo"></div>\n            <code>\n                <head>\n                    <script src="./lib/easycanvas/plugin.webgl.standalone.prod.js"><\/script>\n                    <script src="./lib/easycanvas/plugin.webgl.mmd.standalone.prod.js"><\/script>\n                    <script src='./lib/ammo.js'><\/script>\n                </head>\n                <body>\n                    <canvas id="app"></canvas>\n                </body>\n\n                <script>\n                    var $app = new Easycanvas.Painter({\n                        el: '#app',\n                        width: 400,\n                        height: 400,\n                        webgl: {\n                            light: true,\n                        }\n                    });\n\n                    var miku = $app.add(new Easycanvas.Sprite({\n                        style: {\n                            left: 180, top: 350,\n                        },\n                        webgl: {\n                            imgPath: 'https://raw.githubusercontent.com/c-zhuo/easycanvas/develop/0.8.4/demos/resource/mmd/model/mokou/',\n                            pmd: 'https://raw.githubusercontent.com/c-zhuo/easycanvas/develop/0.8.4/demos/resource/mmd/model/default/miku_v2.pmd',\n                            rz: 180,\n                            scale: 15,\n                        }\n                    }));\n\n                    miku.vmdStart('https://raw.githubusercontent.com/c-zhuo/easycanvas/develop/0.8.4/demos/resource/mmd/vmd/wavefile_v2.vmd');\n\n                    $app.start();\n                <\/script>\n            </code>\n        </section>\n\n        <h2>解析MMD数据</h2>\n\n        <p>下面是一个解析MMD文件的数据的例子。</p>\n\n        <section>\n            <div class="code-2-demo bg-demo"></div>\n            <code>\n                <head>\n                    <script src="./lib/easycanvas/plugin.webgl.standalone.prod.js"><\/script>\n                    <script src="./lib/easycanvas/plugin.webgl.mmd.standalone.prod.js"><\/script>\n                    <script src='./lib/ammo.js'><\/script>\n                </head>\n                <body>\n                    <canvas id="app"></canvas>\n                </body>\n\n                <script>\n                    var $app = new Easycanvas.Painter({\n                        el: '#app',\n                        width: 400,\n                        height: 400,\n                        webgl: {\n                            light: true,\n                        }\n                    });\n\n                    Easycanvas.loaderPMD('https://raw.githubusercontent.com/c-zhuo/easycanvas/develop/0.8.4/demos/resource/mmd/model/default/miku_v2.pmd', function (data, pmd) {\n                        var vertices = data.vertices;\n                        var normals = data.normals;\n                        var textures = data.textures;\n                        var indices = data.indices;\n\n                        var lastCount = 0;\n\n                        pmd.materials.forEach((mt, i) => {\n                            $app.add({\n                                style: {\n                                    left: 180, top: 350,\n                                },\n                                webgl: Easycanvas.webglShapes.custom({\n                                    vertices: vertices,\n                                    normals: normals,\n                                    indices: indices.slice(lastCount, lastCount + mt.vertexCount),\n                                    textures: textures,\n                                    img: mt.fileName ? ('https://raw.githubusercontent.com/c-zhuo/easycanvas/develop/0.8.4/demos/resource/mmd/model/mokou/' + mt.fileName) : undefined,\n                                    rz: 180, scale: 15,\n                                    colors: mt.fileName ? undefined : (\n                                      mt.color.map((num) => {return num * 255}).slice(0, 3)\n                                    ),\n                                })\n                            });\n                            lastCount += mt.vertexCount;\n                        });\n\n                        Easycanvas.loaderVMD('https://raw.githubusercontent.com/c-zhuo/easycanvas/develop/0.8.4/demos/resource/mmd/vmd/wavefile_v2.vmd', function (vmd) {\n                            vmd.start(pmd, $app.children[0].webgl.vertices);\n                        });\n                    });\n\n                    $app.start();\n                <\/script>\n            </code>\n        </section>\n\n        <p>PMD模型中，indices是全部索引，我们需要将他们拆分为各个图层所需要的索引数据；colors是0到1之间的数值，我们也要将他们转换为255以内的rgb色值。由于色值可以循环使用，截取colors时保留长度3的数组即可。</p>\n\n        <p class="tip">将相同的图层放在一起，可以提升渲染效率（可以参考webgl.3DS插件文末的方式）。</p>\n\n    </article>\n\n    ${t}\n    \n    <article id="WebGL">\n        <h1>WebGL</h1>\n\n        <p>Easycanvas支持在canvas中同时渲染2D和3D元素。移动端请避免大量（数百个物体以上）交替使用2D、3D或者颜色纹理、图片纹理进行绘制，否则容易引起卡顿。用WebGL渲染文字时，Easycanvas将使用图片纹理。</p>\n\n        <p>使用时，图片的response需要有跨域的支持，否则图片无法渲染（浏览器会报错）。未来版本会通过base64转换来解决这个问题，但是为了提升性能，建议为域名所在的域名配置跨域的响应头。</p>\n\n        <p>需要注意是的，<strong>WebGL的2D渲染效率可能会比Canvas渲染2D图形要差一些</strong>，因为目前很多浏览器的Canvas API是使用了硬件加速的，浏览器利用GPU进行图形的绘制，效率更高一些。WebGL的优势主要在于可以利用GPU高效进行3D效果所需要的计算。</p>\n\n        <p class="tip">Tips：目前只能在浏览器中使用，暂不支持微信小程序和微信小游戏。</p>\n\n        <h2>引入方式</h2>\n\n        <code>\n            \x3c!-- js文件方式引入 --\x3e\n            \x3c!-- 注意放在easycanvas.js后；prod为线上压缩版、dev为开发版；开发版带有调试、警告信息 --\x3e\n\n            <script src="http://your-path/easycanvas.standalone.prod.js"><\/script>\n            <script src="http://your-path/plugin.webgl.3ds.standalone.prod.js"><\/script>\n        </code>\n        <code>\n            \x3c!-- node环境引入 --\x3e\n\n            import Easycanvas from 'easycanvas';\n            import EasycanvasWebgl from 'easycanvas/build/plugin.webgl.js';\n\n            Easycanvas.use(EasycanvasWebgl);\n\n            \x3c!-- 引入后，常用形状可以在Easycanvas.webglShapes下找到 --\x3e\n            console.log(Easycanvas.webglShapes);\n        </code>\n\n        <h2>WebGL 2D</h2>\n\n        <p>在创建painter实例、或者使用register注册实例到dom上时，指定webgl参数为true就可以使用WebGL进行渲染。开启WebGL之后，整个canvas实例将自动转化为WebGL的绘制，包括content中的img和text都将用WebGL进行渲染。</p>\n\n        <section>\n            <div class="code-2-demo bg-demo"></div>\n            <code>\n                <head>\n                    <script src="./lib/easycanvas/plugin.webgl.standalone.prod.js"><\/script>\n                </head>\n                <body>\n                    <canvas id="app"></canvas>\n                </body>\n\n                <script>\n                    var $app = new Easycanvas.Painter({\n                        el: '#app',\n                        width: 400,\n                        height: 400,\n                        webgl: true, // 开启WebGL渲染\n                    });\n\n                    var $letterG = new Easycanvas.Sprite({\n                        content: {\n                            img: 'https://raw.githubusercontent.com/c-zhuo/easycanvas/master/demos/G.png',\n                        },\n                        style: {\n                            width: 50,\n                            height: 50,\n                            left: Easycanvas.Transition.pendulum(50, 150, 3000).loop(),\n                            top: 100,\n                        },\n                        events: {\n                            click: function (e) {\n                                this.style.width = 100;\n                                return true;\n                            },\n                        },\n                    });\n\n                    $app.add($letterG);\n                    $app.start();\n                <\/script>\n            </code>\n        </section>\n\n        <p class="tip">Tips：如果浏览器不支持WebGL，那么会自动使用Canvas进行渲染，但是只会进行2D的渲染，不会使用下面的3D相关特性。可以将webgl从true改为对象，在webgl的fallback属性设置不支持WebGL模式渲染的回调。</p>\n        \n        <p class="tip">Tips：当渲染带有透明通道的图片，例如png图像时，可以为webgl增加hasAlpha属性，值为true。</p>\n\n        <h2>常见3D形状</h2>\n\n        <p>在支持WebGL的浏览器中，如果要展示3D形状，可以向Sprite类增加webgl参数。引入了WebGL插件之后，会向Easycanvas.webglShapes挂载一些基本的几何体。例如下例是一个旋转的立方体：</p>\n\n        <section>\n            <div class="code-2-demo bg-demo"></div>\n            <code>\n                <head>\n                    <script src="./lib/easycanvas/plugin.webgl.standalone.prod.js"><\/script>\n                </head>\n                <body>\n                    <canvas id="app"></canvas>\n                </body>\n\n                <script>\n                    var $app = new Easycanvas.Painter({\n                        el: '#app',\n                        width: 400,\n                        height: 400,\n                        webgl: true, // 开启WebGL渲染\n                    });\n\n                    var $letterG = new Easycanvas.Sprite({\n                        style: {\n                            left: 100, top: 200,\n                        },\n                        webgl: Easycanvas.webglShapes.block({\n                            a: 20, b: 40, c: 80,\n                            rx: Easycanvas.Transition.linear(0, 360, 1000).loop(),\n                            ry: Easycanvas.Transition.linear(0, 360, 2000).loop(),\n                            rz: 45,\n                            colors: [\n                                255,255,0,\n                                255,0,0,\n                                0,255,0\n                            ],\n                        }),\n                    });\n\n                    $app.add($letterG);\n                    $app.start();\n                <\/script>\n            </code>\n        </section>\n\n        <p>这个例子中，向场景中添加了一个block形状，其中a、b、c是物体的长宽高，rx、ry、rz是x、y、z三个方向的旋转角度。这个例子的位置是用style里的tx和ty指定的。<strong>如果webgl里指定了tx、ty，那么将不再遵守style里的left和top参数，但是不推荐这样使用</strong>，容易引起代码逻辑混乱。</p>\n\n        <p>除了指定颜色，也可以为几何体指定一张贴图，例如下面是两个圆形的石头：</p>\n\n        <section>\n            <div class="code-2-demo bg-demo"></div>\n            <code>\n                <head>\n                    <script src="./lib/easycanvas/plugin.webgl.standalone.prod.js"><\/script>\n                </head>\n                <body>\n                    <canvas id="app"></canvas>\n                </body>\n\n                <script>\n                    var $app = new Easycanvas.Painter({\n                        el: '#app',\n                        width: 400,\n                        height: 400,\n                        webgl: true, // 开启WebGL渲染\n                    });\n\n                    var stone = $app.imgLoader('https://raw.githubusercontent.com/c-zhuo/tanyitan/3d/debug/docs/stone.jpg');\n\n                    var $stone1 = new Easycanvas.Sprite({\n                        style: {\n                            left: 100, top: 200,\n                        },\n                        webgl: Easycanvas.webglShapes.ball({\n                            r: 80, b: 40,\n                            rx: Easycanvas.Transition.linear(0, 360, 1000).loop(),\n                            ry: Easycanvas.Transition.linear(0, 360, 2000).loop(),\n                            rz: 45,\n                            img: stone\n                        }),\n                    });\n                    var $stone2 = new Easycanvas.Sprite({\n                        style: {\n                            left: 300, top: 200,\n                        },\n                        webgl: Easycanvas.webglShapes.ball({\n                            r: 80, b: 10,\n                            rx: Easycanvas.Transition.linear(0, 360, 1000).loop(),\n                            ry: Easycanvas.Transition.linear(0, 360, 2000).loop(),\n                            rz: 45,\n                            img: stone\n                        }),\n                    });\n\n                    $app.add($stone1);\n                    $app.add($stone2);\n                    $app.start();\n                <\/script>\n            </code>\n        </section>\n\n        <p>可以看到，第一个球比第二个“更圆一些”。这是因为<strong>WebGL渲染时，是没有球体或者圆形的，只能用多个三角形来近似渲染</strong>。这里的b参数代表了三角形的密集程度，b越大，越趋近于圆形，但是也越消耗性能。</p>\n\n        <p>除了这几个参数，webgl中也有缩放参数。scale是各个方向的缩放比例，scaleX、scaleY和scaleZ是每个方向的缩放比例，这三个属性的优先级高于scale：</p>\n\n        <section>\n            <div class="code-2-demo bg-demo"></div>\n            <code>\n                <head>\n                    <script src="./lib/easycanvas/plugin.webgl.standalone.prod.js"><\/script>\n                </head>\n                <body>\n                    <canvas id="app"></canvas>\n                </body>\n\n                <script>\n                    var $app = new Easycanvas.Painter({\n                        el: '#app',\n                        width: 400,\n                        height: 400,\n                        webgl: true, // 开启WebGL渲染\n                    });\n\n                    var $stone = new Easycanvas.Sprite({\n                        style: {\n                            left: 200, top: 200,\n                        },\n                        webgl: Easycanvas.webglShapes.block({\n                            a: 40, b: 60, c: 80,\n                            scale: Easycanvas.Transition.pendulum(2, 1, 3000).loop(),\n                            scaleX: Easycanvas.Transition.pendulum(1, 2, 3000).loop(),\n                            ry: Easycanvas.Transition.linear(0, 360, 20000).loop(),\n                            rz: 45,\n                            img: 'https://raw.githubusercontent.com/c-zhuo/tanyitan/3d/debug/docs/stone.jpg'\n                        }),\n                    });\n\n                    $app.add($stone);\n                    $app.start();\n                <\/script>\n            </code>\n        </section>\n\n        <h2>自定义3D形状</h2>\n\n        <p>以下内容需要一定的WebGL知识。</p>\n\n        <p>如果想自定义3D形状，Easycanvas.webglShapes.custom这个API。除了上面的img等参数外，还可以使用以下参数：</p>\n\n        <table>\n            <thead>\n                <tr>\n                    <th align="left">属性</th>\n                    <th align="left">描述</th>\n                    <th align="left">举例</th>\n                </tr>\n            </thead>\n            <tbody>\n                <tr>\n                    <td align="left">vertices(Array, 必传)</td>\n                    <td align="left">顶点，每3个值构成一个空间坐标</td>\n                    <td align="left">[-1, -1, -1, -1, -1, 1, -1, 1, -1]</td>\n                </tr>\n                <tr>\n                    <td align="left">indices(Array, 可选)</td>\n                    <td align="left">索引，indices[n]对应的顶点为[vertices[3*n], vertices[3*n+1], vertices[3*n+2]]</td>\n                    <td align="left">[0, 1, 2, 0, 2, 3, 4, 5, 6, 4, 6, 7]</td>\n                </tr>\n                <tr>\n                    <td align="left">textures(Array, 和colors任选其一)</td>\n                    <td align="left">纹理，每2个值构成一个平面坐标，长度不够时会自动循环</td>\n                    <td align="left">[0, 0, 0, 1, 1, 1, 1, 0]</td>\n                </tr>\n                <tr>\n                    <td align="left">colors(Array, 和textures任选其一)</td>\n                    <td align="left">颜色，每3个值构成一个顶点rgb色值，长度不够时会自动循环，和textures</td>\n                    <td align="left">[255, 255, 0]</td>\n                </tr>\n                <tr>\n                    <td align="left">normals(Array, 可选)</td>\n                    <td align="left">法向量，每3个值构成一个矢量，用于光照，长度需要和顶点数相同</td>\n                    <td align="left">[1, 1, -0.5]</td>\n                </tr>\n            </tbody>\n        </table>\n\n        <p>例如下面这个例子，随机生成了20个坐标点，并且让这些点两两相连，形成一个凸多面体，并且让颜色每帧都进行变化。</p>\n\n        <p class="tip">Tips：由于坐标点两两相连，性能开销几乎与坐标点数量的平方正相关，因此比较耗费性能。如果改为设置1000个以上坐标点，就会产生百万级别的数据，可能导致浏览器卡顿。</p>\n\n        <section>\n            <div class="code-2-demo bg-demo"></div>\n            <code>\n                <head>\n                    <script src="./lib/easycanvas/plugin.webgl.standalone.prod.js"><\/script>\n                </head>\n                <body>\n                    <canvas id="app"></canvas>\n                </body>\n\n                <script>\n                    var $app = new Easycanvas.Painter({\n                        el: '#app',\n                        width: 400,\n                        height: 400,\n                        webgl: true,\n                    });\n\n                    var vertices = [], colors = [], indices = [];\n                    var count = 20;\n\n                     // 初始化count个顶点\n                    for (var i = 0; i < count; i++) {\n                        // 每个顶点随机生成3个坐标；为了避免坐标太相近，每次从上一个顶点的位置进行随机\n                        vertices.push((vertices[i - 3] || 0) + Math.random() * 100 - 50);\n                        vertices.push((vertices[i - 3] || 0) + Math.random() * 100 - 50);\n                        vertices.push((vertices[i - 3] || 0) + Math.random() * 100 - 50);\n\n                        // 随机一些颜色，colors长度不够会自动循环着色，所以数组长度短一些没关系\n                        colors.push(Math.floor(Math.random() * 255));\n                    }\n\n                    for (var i = 0; i < count * 3; i += 3) {\n                        for (var j = i + 3; j < count * 3 - 3; j += 3) {\n                            // 每个顶点都和后面的2个顶点连结，形成多个三角形\n                            indices.push(i / 3);\n                            indices.push(j / 3);\n                            indices.push(j / 3 + 1);\n                        }\n                    }\n\n                    var $random = new Easycanvas.Sprite({\n                        style: {\n                            left: 200, top: 200,\n                        },\n                        webgl: Easycanvas.webglShapes.custom({\n                            vertices: vertices,\n                            indices: indices,\n                            colors: colors,\n                            ry: Easycanvas.Transition.linear(0, 360, 5000).loop(),\n                        }),\n                    });\n\n                    // 设置一个在0和255之间钟摆运动的函数，用于控制颜色\n                    var getColor = Easycanvas.Transition.pendulum(0, 255, 1000).loop();\n                    $random.on('ticked', function (tick) {\n                        for (var i = 0, l = count; i < l; i++) {\n                            // 给每个rgb值的第一个参数赋值，设置red的比重\n                            $random.webgl.colors[i * 3] = getColor();\n                        }\n\n                        this.updateWebglStyle('colors');\n                    });\n\n                    $app.add($random);\n                    $app.start();\n                <\/script>\n            </code>\n        </section>\n\n        <h2>透射</h2>\n\n        <p>透射是3D场景“近大远小”的效果。即例如下面这张图，路的宽度是不变的，但是越远，看起来显得越窄。</p>\n\n        <img class="article-img" width="200" presrc="https://raw.githubusercontent.com/c-zhuo/easycanvas/develop/0.8.4/demos/resource/image/fudgeFactor.jpg"></img>\n\n        <p>这个程度用fudgeFactor参数表示，默认为0，代表远近不影响视觉上的大小。在下例中，随着fudgeFactor的增大，“近大远小”的效果会更加明显。</p>\n\n        <section>\n            <div class="code-2-demo bg-demo"></div>\n            <code>\n                <head>\n                    <script src="./lib/easycanvas/plugin.webgl.standalone.prod.js"><\/script>\n                </head>\n                <body>\n                    <canvas id="app"></canvas>\n                </body>\n\n                <script>\n                    var $app = new Easycanvas.Painter({\n                        el: '#app',\n                        width: 400,\n                        height: 400,\n                        webgl: {\n                            fudgeFactor: Easycanvas.Transition.pendulum(0, 50, 1000).loop(),\n                        }\n                    });\n\n                    [50, 150, 250, 350].forEach(function (x) {\n                        $app.add(new Easycanvas.Sprite({\n                            style: {\n                                left: x, top: 200,\n                            },\n                            webgl: Easycanvas.webglShapes.block({\n                                a: 20, b: 40, c: 80, rz: 45, rx: 30,\n                                colors: [255,255,0,255,0,0,0,255,0],\n                            }),\n                        }));\n                    });\n\n                    $app.start();\n                <\/script>\n            </code>\n        </section>\n\n        <p class="tip">Tips：fudgeFactor为负数时，会出现“远大近小”的效果。</p>\n\n        <h2>视角</h2>\n\n        <p>修改painter实例的webgl参数中的camera，可以调整视角和朝向。Demo如下：</p>\n\n        <section>\n            <div class="code-2-demo bg-demo"></div>\n            <code>\n                <head>\n                    <script src="./lib/easycanvas/plugin.webgl.standalone.prod.js"><\/script>\n                </head>\n                <body>\n                    <canvas id="app"></canvas>\n                </body>\n\n                <script>\n                    var $app = new Easycanvas.Painter({\n                        el: '#app',\n                        width: 400,\n                        height: 400,\n                        webgl: {\n                            camera: {\n                                enable: true,\n                                current: {\n                                    x: 0,\n                                    y: 0,\n                                    z: -100,\n                                },\n                                target: {\n                                    x: 200,\n                                    y: 200,\n                                    z: 0,\n                                },\n                                rotate: {\n                                    x: 0,\n                                    y: -1,\n                                    z: 0,\n                                }\n                            },\n                        }\n                    });\n\n                    [50, 150, 250, 350].forEach(function (x) {\n                        $app.add(new Easycanvas.Sprite({\n                            style: {\n                                left: x, top: 200,\n                            },\n                            webgl: Easycanvas.webglShapes.block({\n                                a: 20, b: 40, c: 80, rz: 45, rx: 30,\n                                colors: [255,255,0,255,0,0,0,255,0],\n                            }),\n                        }));\n                    });\n\n                    // 视角调整间隔\n                    var interval = 2000;\n                    // 调整摄像头位置\n                    var current = $app.webgl.camera.current;\n                    // 调整摄像目标位置\n                    var target = $app.webgl.camera.target;\n                    // 摄像头角度\n                    var rotate = $app.webgl.camera.rotate;\n\n                    function changeCamera () {\n                        Easycanvas.Transition(current, 'x', 'ease', Math.random() * 1000 - 500, interval);\n                        Easycanvas.Transition(current, 'y', 'ease', Math.random() * 600 - 400, interval);\n                        Easycanvas.Transition(target, 'x', 'ease', Math.random() * 100 + 150, interval);\n                        Easycanvas.Transition(target, 'y', 'ease', Math.random() * 100 + 150, interval);\n                        Easycanvas.Transition(rotate, 'x', 'linear', Math.random() * 2 - 1, interval);\n                        Easycanvas.Transition(rotate, 'y', 'linear', Math.random() * 2 - 1, interval);\n                        Easycanvas.Transition(rotate, 'z', 'linear', Math.random() * 2 - 1, interval);\n                    }\n\n                    changeCamera();\n                    setInterval(changeCamera, 1000);\n\n                    $app.start();\n                <\/script>\n            </code>\n        </section>\n\n        <h2>绘制像素点</h2>\n\n        <p>像素点（也可以理解为单色的球体）通过自定义形状进行绘制。Demo如下：</p>\n\n        <section>\n            <div class="code-2-demo bg-demo"></div>\n            <code>\n                <head>\n                    <script src="./lib/easycanvas/plugin.webgl.standalone.prod.js"><\/script>\n                </head>\n                <body>\n                    <canvas id="app"></canvas>\n                </body>\n\n                <script>\n                    var $app = new Easycanvas.Painter({\n                        el: '#app',\n                        width: 400,\n                        height: 400,\n                        webgl: {\n                            singleShader: true,\n                        },\n                        events: {\n                            mousemove: function (e) {\n                                mouseX = e.canvasX;\n                                mouseY = e.canvasY;\n                            },\n                        }\n                    });\n\n                    var mouseX = 200;\n                    var mouseY = 200;\n\n                    function createEffect () {\n                        var $effect = $app.add({\n                            style: {\n                                left: Easycanvas.Transition.pendulum(\n                                    mouseX + 5 - Math.random() * 10,\n                                    mouseX - 100 - Math.random() * 400,\n                                    3000\n                                ).loop(),\n                                top: Easycanvas.Transition.ease(\n                                    mouseY,\n                                    mouseY - 200,\n                                    1000\n                                ),\n                                zIndex: Math.random(),\n                            },\n                            webgl: window.Easycanvas.webglShapes.custom({\n                                vertices: [0, 0, 0],\n                                colors: [\n                                    255, Math.random() * 128, 0, 255,\n                                ],\n                                pointSizes: new Float32Array([10]),\n                                primitive: 0, // points\n                                hasAlpha: true,\n                            }),\n                            hooks: {\n                                ticked: function () {\n                                    this.webgl.pointSizes[0] += 2;\n                                    this.updateWebglStyle('pointSizes');\n\n                                    if (this.webgl.colors[3] > 4) {\n                                        this.webgl.colors[3] -= 4;\n                                        this.updateWebglStyle('colors');\n                                    } else {\n                                        this.remove();\n                                    }\n                                }\n                            }\n                        });\n                    }\n\n                    $app.on('ticked', createEffect, 50);\n\n                    $app.start();\n                <\/script>\n            </code>\n        </section>\n\n        <p class="tip">Tips：这里的singleShader的用途是让Easycanvas使用同一个shader渲染各种不同的图形，以降低切换shader造成的性能损耗。当渲染像素点时，这项必须为true。后续版本可能会解除这个限制。</p>\n    </article>\n\n`.replace(/<</g,"&lt;").replace(/>>/g,"&gt;")}}]);