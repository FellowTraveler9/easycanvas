(window.webpackJsonp=window.webpackJsonp||[]).push([[2],{438:function(n,t,e){"use strict";e.r(t);t["default"]="\n    \n    <article id=\"创建并添加一个对象\">\n        <h1>创建并添加一个对象</h1>\n\n        <h2>创建实例</h2>\n\n        <p>如下例，只需要30行代码，可以在canvas上绘制一个运动的图片。点击蓝色的小按钮可以立即查看效果。</p>\n\n        <section>\n            <div class=\"code-2-demo bg-demo\"></div>\n            <code>\n                <body>\n                    <canvas id=\"app\"></canvas>\n                    <p>点击字母G可以改变尺寸</p>\n                </body>\n\n                <script>\n                    var data = {\n                        imgSize: 50\n                    };\n\n                    var changeSize = function () {\n                        data.imgSize += 20;\n                    };\n\n                    var $app = new Easycanvas.Painter({\n                        el: '#app',\n                        width: 400,\n                        height: 400\n                    });\n\n                    var $letterG = new Easycanvas.Sprite({\n                        content: {\n                            img: 'https://raw.githubusercontent.com/c-zhuo/easycanvas/master/demos/G.png',\n                        },\n                        style: {\n                            left: Easycanvas.Transition.pendulum(50, 150, 3000).loop(),\n                            top: 100,\n                            width: function () {\n                                // 这里是类似“数据绑定”的写法，类似Vue应用中的computed\n                                return data.imgSize;\n                            },\n                            height: function () {\n                                return data.imgSize;\n                            },\n                        },\n                        events: {\n                            click: changeSize\n                        }\n                    });\n\n                    $app.add($letterG);\n                    $app.start();\n                <\/script>\n            </code>\n        </section>\n\n        <p>Easycanvas应用的每一个实例是一个Painter类对象，包含了许多个Sprite类对象，每一个Sprite可能是一幅图片、一段文本，也可以是一个容器。后面将对Painter类和Sprite类的各个参数进行介绍和演示。</p>\n    </article>\n\n\n    \n    <article id=\"自定义事件\">\n        <h1>自定义事件</h1>\n\n        <p>自定义事件一般用于处理多个Sprite之间的互相影响。</p>\n        \n        <p>可以通过on和off来为每个Sprite对象绑定和解除自定义事件，然后通过trigger和broadcast触发。其中<strong>broadcast触发的事件广播不仅会在自身触发，还会传递给它的所有children；trigger只会在自身触发，不会向下传递</strong>。例如下例：</p>\n\n        <section>\n            <div class=\"code-2-demo bg-demo\"></div>\n            <code>\n                <body>\n                    <canvas id=\"app\"></canvas>\n                    <br>\n                    <button id=\"button1\">trigger on parent</button>\n                    <button id=\"button2\">broadcast on parent</button>\n                </body>\n\n                <script>\n                    var G = 'https://raw.githubusercontent.com/c-zhuo/easycanvas/master/demos/G.png';\n\n                    var $app = new Easycanvas.Painter({\n                        el: '#app',\n                        width: 400,\n                        height: 400\n                    });\n\n                    var $parent = new Easycanvas.Sprite({\n                        content: {\n                            img: G,\n                        },\n                        style: {\n                            width: 100, height: 100, left: 100, top: 100, rotate: 0,\n                        },\n                    });\n\n                    var $child1 = $parent.add({\n                        content: {\n                            img: G,\n                        },\n                        style: {\n                            width: 50, height: 50, left: 50, top: 100, rotate: 0,\n                        },\n                    });\n                    var $child2 = $parent.add({\n                        content: {\n                            img: G,\n                        },\n                        style: {\n                            width: 50, height: 50, left: 125, top: 100, rotate: 0,\n                        },\n                    });\n\n                    var add90Deg = function () {\n                        var currentRotate = this.getStyle('rotate');\n                        this.style.rotate = Easycanvas.Transition.linear(currentRotate, currentRotate + 90, 500);\n                    };\n\n                    $parent.on('add90Deg', add90Deg);\n                    $child1.on('add90Deg', add90Deg);\n                    $child2.on('add90Deg', add90Deg, 2000);\n\n                    document.getElementById('button1').addEventListener('click', function () {\n                        $parent.trigger('add90Deg');\n                    });\n                    document.getElementById('button2').addEventListener('click', function () {\n                        $parent.broadcast('add90Deg');\n                    });\n\n                    $app.add($parent);\n                    $app.start();\n                <\/script>\n            </code>\n        </section>\n\n        <p>这上面例子中，如果频繁点击第二个按钮（在parent广播事件），可以看到child1会连续旋转，而child2不会。即使我们给parent也加上3秒的throttle，频繁触发broadcast的时候，child1仍然可以连续旋转。这是因为<strong>各个Sprite对同一个事件的throttle是独立的</strong>。</p>\n\n        <p>自定义事件可以传递一些参数，例如下例：</p>\n\n        <section>\n            <div class=\"code-2-demo bg-demo\"></div>\n            <code>\n                <body>\n                    <canvas id=\"app\"></canvas>\n                    <br>\n                    <button id=\"button1\">trigger 90deg on parent</button>\n                    <button id=\"button2\">broadcast 45deg on parent</button>\n                </body>\n\n                <script>\n                    var G = 'https://raw.githubusercontent.com/c-zhuo/easycanvas/master/demos/G.png';\n\n                    var $app = new Easycanvas.Painter({\n                        el: '#app',\n                        width: 400,\n                        height: 400\n                    });\n\n                    var $parent = new Easycanvas.Sprite({\n                        content: {\n                            img: G,\n                        },\n                        style: {\n                            width: 100, height: 100, left: 100, top: 100, rotate: 0,\n                        },\n                    });\n\n                    var $child1 = $parent.add({\n                        content: {\n                            img: G,\n                        },\n                        style: {\n                            width: 50, height: 50, left: 50, top: 100, rotate: 0,\n                        },\n                    });\n                    var $child2 = $parent.add({\n                        content: {\n                            img: G,\n                        },\n                        style: {\n                            width: 50, height: 50, left: 125, top: 100, rotate: 0,\n                        },\n                    });\n\n                    var addDeg = function (deg) {\n                        var currentRotate = this.self().rotate;\n                        this.style.rotate = Easycanvas.Transition.linear(currentRotate, currentRotate + deg, 500);\n                    };\n\n                    $parent.on('addDeg', addDeg);\n                    $child1.on('addDeg', addDeg);\n                    $child2.on('addDeg', addDeg, 2000);\n\n                    document.getElementById('button1').addEventListener('click', function () {\n                        $parent.trigger('addDeg', 90);\n                    });\n                    document.getElementById('button2').addEventListener('click', function () {\n                        $parent.broadcast('addDeg', 45);\n                    });\n\n                    $app.add($parent);\n                    $app.start();\n                <\/script>\n            </code>\n        </section>\n    </article>\n\n    \n    <article id=\"事件\">\n        <h1>事件</h1>\n\n        <p>这里包括事件的监听处理和顺序控制。</p>\n        \n        <h2>如何监听事件</h2>\n\n        <p>Easycanvas支持几乎全部的浏览器DOM支持的事件。下面的例子简单介绍了如何监听某一个元素的事件：</p>\n\n        <section>\n            <div class=\"code-2-demo bg-demo\"></div>\n            <code>\n                <body>\n                    <canvas id=\"app\"></canvas>\n                    <p id=\"eventName\">鼠标移上去看看</p>\n                </body>\n\n                <script>\n                    var G = 'https://raw.githubusercontent.com/c-zhuo/easycanvas/master/demos/G.png';\n\n                    var $app = new Easycanvas.Painter({\n                        el: '#app',\n                        width: 400,\n                        height: 400\n                    });\n\n                    var handler = function (e) {\n                        document.getElementById('eventName').innerHTML = JSON.stringify({\n                            type: e.type,\n                            x: e.canvasX,\n                            y: e.canvasY,\n                        }) + '<br>' + document.getElementById('eventName').innerHTML;\n                    };\n\n                    var $foo = new Easycanvas.Sprite({\n                        content: {\n                            img: G,\n                        },\n                        style: {\n                            width: 100, height: 100,\n                            left: 100, top: 100,\n                        },\n                        events: {\n                            contextmenu: function (e) {\n                                alert('禁止鼠标右键菜单');\n                                e.stopPropagation();\n                                e.preventDefault();\n                            },\n                            click: handler,\n                            mousedown: handler,\n                            mouseup: handler,\n                            mousemove: handler,\n                        },\n                    });\n\n                    $app.add($foo);\n                    $app.start();\n                <\/script>\n            </code>\n        </section>\n\n        <p><strong>目前支持的事件包括\"click\", \"touchstart\", \"touchmove\", \"touchend\", \"mousedown\", \"mousemove\", \"mouseup\", \"mouseout\", \"mousewheel\", \"contextmenu\"</strong>。</p>\n\n        <p>Easycanvas支持事件的“浏览器端-移动端”转换。例如一个元素绑定了mousedown事件，那么在移动端进行touchstart的时候，这个事件也会触发。反之亦然。但是如果一个元素同时绑定了mousedown和touchstart事件，那么将只触发一个。</p>\n\n        <h2>事件的触发顺序</h2>\n\n        <p><strong>事件的触发顺序和HTML中的顺序相同</strong>，即事件在层次（Sprite.style.zIndex）最高的Sprite上触发，并沿着parent逐一冒泡，直到某一个监听函数调用了stopPropagation()。例如下面这个例子：</p>\n\n        <section>\n            <div class=\"code-2-demo bg-demo\"></div>\n            <code>\n                <body>\n                    <canvas id=\"app\"></canvas>\n                    <p>小的字母G是Sprite3，Sprite3位于Sprite1的Sprite2中；大的是Sprite4</p>\n                </body>\n\n                <script>\n                    var G = 'https://raw.githubusercontent.com/c-zhuo/easycanvas/master/demos/G.png';\n\n                    var $app = new Easycanvas.Painter({\n                        el: '#app',\n                        width: 200,\n                        height: 200\n                    });\n\n                    var Sprite1 = $app.add({\n                        style: {\n                            zIndex: 2,\n                        },\n                        events: {\n                            click: function () {\n                                alert('pass to Sprite1.');\n                            }\n                        },\n                    });\n\n                    var Sprite2 = Sprite1.add({\n                        style: {\n                            width: 10, height: 20\n                        },\n                        events: {\n                            click: function (e) {\n                                alert('pass to Sprite2.');\n                                e.stopPropagation();\n                            }\n                        },\n                    });\n\n                    var Sprite3 = Sprite2.add({\n                        name: 'Sprite3',\n                        content: {\n                            img: G,\n                        },\n                        style: {\n                            left: 100, top: 100,\n                            width: 50, height: 50,\n                        },\n                        events: {\n                            click: function () {\n                                alert('Sprite3 trigger.');\n                            }\n                        },\n                    });\n\n                    var Sprite4 = $app.add({\n                        name: 'Sprite4',\n                        content: {\n                            img: G,\n                        },\n                        style: {\n                            left: 100, top: 100,\n                            width: 150, height: 150,\n                            zIndex: 1,\n                        },\n                        events: {\n                            click: function () {\n                                alert('Sprite4 trigger.');\n                            }\n                        },\n                    });\n\n                    $app.start();\n                <\/script>\n            </code>\n        </section>\n\n        <p><strong>preventDefault</strong>这个API也同样生效，并且可以在<strong>e.event</strong>属性中找到浏览器原生的Event对象，但Event对象的stopPropagation方法不会停止事件在Easycanvas中的冒泡，但它会阻止事件从canvas向上冒泡。</p>\n\n        <p><strong>如果需要自定义事件的触发顺序，可以在events中指定eIndex。</strong>这样事件的先后判定将不使用zIndex，可能会与看到的层次不同，所以不建议大量使用这个API，以免降低调试的效率。例如下面这个例子，zIndex大的、eIndex小，反而后响应到事件：</p>\n\n        <section>\n            <div class=\"code-2-demo bg-demo\"></div>\n            <code>\n                <body>\n                    <canvas id=\"app\"></canvas>\n                    <p>点击中间重叠的部分，会发现下层的Sprite先捕捉到了事件</p>\n                </body>\n\n                <script>\n                    var G = 'https://raw.githubusercontent.com/c-zhuo/easycanvas/master/demos/G.png';\n\n                    var $app = new Easycanvas.Painter({\n                        el: '#app',\n                        width: 200,\n                        height: 200\n                    });\n\n                    $app.add(new Easycanvas.Sprite({\n                        content: {\n                            img: G,\n                        },\n                        style: {\n                            width: 100, height: 100, top: 100,\n                            left: 100, rotate: 0, zIndex: 1,\n                        },\n                        events: {\n                            click: function () {\n                                this.style.rotate += 180;\n                                return true;\n                            },\n                        },\n                    }));\n                    $app.add(new Easycanvas.Sprite({\n                        content: {\n                            img: G,\n                        },\n                        style: {\n                            width: 100, height: 100, top: 100,\n                            left: 150, rotate: 0, zIndex: 2,\n                        },\n                        events: {\n                            eIndex: -1,\n                            click: function () {\n                                this.style.rotate += 180;\n                                return true;\n                            },\n                        },\n                    }));\n\n                    $app.start();\n                <\/script>\n            </code>\n        </section>\n\n        <p class=\"tip\">Tips：如果有eIndex属性，那么无论zIndex是多少都不影响事件的顺序。</p>\n    </article>\n\n    \n    <article id=\"状态钩子\">\n        <h1>状态钩子</h1>\n\n        <p>状态可以用于在每一动画帧的各个阶段进行数据的编辑，Easycanvas目前有ticked、beforeTick、removed、beforeRemove四个钩子。前两者在每次渲染（即每帧）时调用，后两者在Sprite的remove方法触发时调用。beforeTick也可以用于一些比较复杂的动画的每帧坐标计算：</p>\n\n        <section>\n            <div class=\"code-2-demo bg-demo\"></div>\n            <code>\n                <body>\n                    <canvas id=\"app\"></canvas>\n                </body>\n\n                <script>\n                    var G = 'https://raw.githubusercontent.com/c-zhuo/easycanvas/master/demos/G.png';\n\n                    var $app = new Easycanvas.Painter({\n                        el: '#app',\n                        width: 400,\n                        height: 400\n                    });\n\n                    var $foo = new Easycanvas.Sprite({\n                        content: {\n                            img: G,\n                        },\n                        style: {\n                            width: 100, height: 100, left: 200, top: 200, rotate: 0,\n                        },\n                        hooks: {\n                            beforeTick: function (ticks) {\n                                this.style.left += Math.random() * 10 - 5;\n                                this.style.top += Math.random() * 10 - 5;\n\n                                this.style.left = (this.style.left + this.$canvas.width) % this.$canvas.width;\n                                this.style.top = (this.style.top + this.$canvas.height) % this.$canvas.height;\n\n                                this.style.rotate = ticks;\n                            },\n                        },\n                    });\n\n                    $app.add($foo);\n                    $app.start();\n                <\/script>\n            </code>\n        </section>\n\n        <p>tick状态钩子拥有一个参数，代表当前canvas累计的帧数：beforeTick的tick从0开始自增，ticked从1开始自增。</p>\n\n        <p>可以使用Sprite的on与off来进行动态的钩子注册和解绑，并且可以设置throttle，例如下面这个beforeTick的钩子每200毫秒只会触发一次：</p>\n\n        <section>\n            <div class=\"code-2-demo bg-demo\"></div>\n            <code>\n                <body>\n                    <canvas id=\"app\"></canvas>\n                </body>\n\n                <script>\n                    var G = 'https://raw.githubusercontent.com/c-zhuo/easycanvas/master/demos/G.png';\n\n                    var $app = new Easycanvas.Painter({\n                        el: '#app',\n                        width: 400,\n                        height: 400\n                    });\n\n                    var $foo = new Easycanvas.Sprite({\n                        content: {\n                            img: G,\n                        },\n                        style: {\n                            width: 100, height: 100, left: 200, top: 200, rotate: 0,\n                        },\n                    });\n\n                    $foo.on('beforeTick', function () {\n                        this.style.left += Math.random() * 10 - 5;\n                        this.style.top += Math.random() * 10 - 5;\n\n                        this.style.left %= this.$canvas.width;\n                        this.style.top %= this.$canvas.height;\n\n                        this.style.rotate += Math.random() * 10;\n                    }, 200);\n\n                    $app.add($foo);\n                    $app.start();\n                <\/script>\n            </code>\n        </section>\n\n        <p class=\"tip\">Tips：在一些并不需要每帧都触发的场景下，设置throttle可以节约浏览器性能，尤其是在对实时性要求不高的应用中。例如在一个“跑酷”游戏中，人物是否吃到金币就不需要每帧监测，哪怕每100毫秒监测一次也不会损害用户体验，因为晚0.1秒吃到金币并不会引发用户的不良体验；而人物运动引起的地图移动，是每帧都要进行运算的，否则会有掉帧的感觉。</p>\n    </article>\n\n    \n    <article id=\"图片渲染与处理\">\n        <h1>图片渲染与处理</h1>\n\n        <p>这里将介绍图片的裁剪、加载以及图片的像素预处理。</p>\n\n        <h2>图片加载</h2>\n\n        <p>前面的例子中，Sprite创建之后才开始加载图像。这样可能导致图像渲染出来的时候，动画已经进行了一半。一些场合下，我们希望图像加载成功后才开始渲染，那么可以使用Easycanvas提供的imgLoader，例如：</p>\n\n        <section>\n            <div class=\"code-2-demo bg-demo\"></div>\n            <code>\n                <body>\n                    <canvas id=\"app\"></canvas>\n                </body>\n\n                <script>\n                    var $app = new Easycanvas.Painter({\n                        el: '#app',\n                        width: 400,\n                        height: 400\n                    });\n\n                    Easycanvas.ImgLoader(\n                        'https://raw.githubusercontent.com/c-zhuo/easycanvas/master/demos/G.png',\n                        function (img) {\n                            var $letterG = new Easycanvas.Sprite({\n                                content: {\n                                    img: img,\n                                },\n                                style: {\n                                    left: 50, top: 50, width: 50, height: 50,\n                                },\n                            });\n                            $app.add($letterG);\n                        }\n                    );\n\n                    $app.start();\n                <\/script>\n            </code>\n        </section>\n\n        <p>imgLoader将在图片加载完成后触发回调，回调的参数就是图片对象。如果是之前已经加载的图片，回调将立即触发。</p>\n\n        <h2>图片裁剪</h2>\n\n        <p>如果需要将图片源进行裁剪，仅渲染出一部分内容，可以通过修改Sprite的style样式中的cutLeft、cutTop、cutWidth、cutHeight来控制。其中cutLeft和cutTop是裁剪的起点，cutWidth和cutHeight是裁剪的尺寸。例如下图，将字母G的一部分进行了渲染。</p>\n\n        <section>\n            <div class=\"code-2-demo bg-demo\"></div>\n            <code>\n                <body>\n                    <canvas id=\"app\"></canvas>\n                </body>\n\n                <script>\n                    var $app = new Easycanvas.Painter({\n                        el: '#app',\n                        width: 400,\n                        height: 400\n                    });\n\n                    var $letterG = new Easycanvas.Sprite({\n                        content: {\n                            img: 'https://raw.githubusercontent.com/c-zhuo/easycanvas/master/demos/G.png',\n                        },\n                        style: {\n                            left: 50, top: 50, height: 150,\n                            cutLeft: 0, cutTop: 0,\n                            // 我们让裁剪的宽度和绘制的宽度在80和150之间循环变化，并保持相等\n                            cutWidth: Easycanvas.Transition.pendulum(80, 150, 2000).loop(),\n                            width: Easycanvas.Transition.pendulum(80, 150, 2000).loop(),\n                            locate: 'lt',\n                        },\n                    });\n\n                    $app.add($letterG);\n                    $app.start();\n                <\/script>\n            </code>\n        </section>\n\n        <p>left、top、cutWidth、cutHeight的默认值为0，width、height、cutWidth、cutHeight的默认值和图片宽高相同。</p>\n\n        <p>这里的locate是元素的定位方式。如果值为lt，代表以left和top作为左上角顶点，向右下方绘制width和height的长度。<strong>默认值为center，图片将以left和top对应的坐标为中心进行绘制</strong>，类似css的“transform: translateX(-50%) translateY(-50%)”。其它可选属性有rt（作为右上顶点）、ld（作为左下顶点）、rd（作为右下顶点）.</p>\n\n        <p class=\"tip\">在这个例子中，我们在content中增加了一个img属性，表示要渲染一张图片。当然，也可以没有content属性，代表这个Sprite是一个容器，这在复杂的场景中非常实用。</p>\n\n        <h2>像素预处理</h2>\n\n        <p>Easycanvas也提供了一个图片预处理方法imgPretreat，用于进行像素级别的图像预处理。例如：</p>\n\n        <section>\n            <div class=\"code-2-demo bg-demo\"></div>\n            <code>\n                <body>\n                    <canvas id=\"app\"></canvas>\n                </body>\n\n                <script>\n                    var $app = new Easycanvas.Painter({\n                        el: '#app',\n                        width: 400,\n                        height: 400\n                    });\n\n                    var $letterG = new Easycanvas.Sprite({\n                        content: {\n                            img: Easycanvas.imgPretreat(\n                                'https://raw.githubusercontent.com/c-zhuo/easycanvas/master/demos/G.png',\n                                {\n                                    conversion: function (pixel, x, y) {\n                                        return {\n                                            r: x < 80 ? 255 : pixel.r,\n                                            g: pixel.g,\n                                            b: pixel.b,\n                                            a: pixel.a,\n                                        };\n                                    }\n                                }\n                            ),\n                        },\n                        style: {\n                            left: 100, top: 100,\n                        },\n                    });\n\n                    $app.add($letterG);\n                    $app.start();\n                <\/script>\n            </code>\n        </section>\n\n        <p>传入的conversion是一个修改像素点的方法，参数为像素点的rgba值以及像素的坐标。</p>\n\n        <p class=\"tip\">Tips：大面积的像素处理的性能开销较大，移动端设备下不建议对大图片频繁使用imgPretreat，尤其要避免在状态钩子的每帧钩子函数中调用imgPretreat来编辑色值。</p>\n    </article>\n\n\n    \n    <article id=\"嵌套与继承\">\n        <h1>嵌套与继承</h1>\n\n        <p>这里将介绍父子Sprite之间的嵌套关系及属性继承。将一些具有方法、事件绑定的Sprite抽离出来，便于被其它项目或者模块嵌套，可以显著提升开发效率。</p>\n        \n        <h2>嵌套</h2>\n\n        <p>嵌套让树型结构更加清晰，既便于大型动画的设计，又可以更方便地在开发者工具中找到要调试的特定Sprite。嵌套的父、子级Sprite之间有属性的继承规则，类似HTML和CSS一样。</p>\n\n        <p>下面是一个例子，最顶层是一个字母G，它又含有两个children。两个children的位置是继承父级Sprite的。</p>\n\n        <section>\n            <div class=\"code-2-demo bg-demo\"></div>\n            <code>\n                <body>\n                    <canvas id=\"app\"></canvas>\n                </body>\n\n                <script>\n                    var G = 'https://raw.githubusercontent.com/c-zhuo/easycanvas/master/demos/G.png';\n\n                    var $app = new Easycanvas.Painter({\n                        el: '#app',\n                        width: 400,\n                        height: 400\n                    });\n\n                    // 父级Sprite\n                    var $parent = new Easycanvas.Sprite({\n                        content: {\n                            img: G,\n                        },\n                        style: {\n                            width: 50, height: 50,\n                            top: 50, left: Easycanvas.Transition.pendulum(50, 150, 4000).loop(),\n                        },\n                        // 可以通过children属性来指定它的子节点Sprite\n                        children: [{\n                            content: {\n                                img: G,\n                            },\n                            style: {\n                                left: 50, top: 0,\n                                width: 20, height: 20,\n                            }\n                        }],\n                    });\n\n                    $app.add($parent);\n                    $app.start();\n\n                    // 也可以通过add来动态增加子节点Sprite\n                    $parent.add(new Easycanvas.Sprite({\n                        content: {\n                            img: G,\n                        },\n                        style: {\n                            width: 20, height: 20,\n                            left: 50, top: 50,\n                        }\n                    }));\n                <\/script>\n            </code>\n        </section>\n\n        <p>第一个child是放在了children属性里，直接挂载在parent上面的。<strong>当创建一个Sprite类的时候，children中的每一个object都会被转化为Sprite类.</strong>因此，这两个child的添加方式本质上没有任何区别。</p>\n\n        <p>可以通过remove方法来移除某一个Sprite，还是上面这个例子：</p>\n\n        <section>\n            <div class=\"code-2-demo bg-demo\"></div>\n            <code>\n                <body>\n                    <canvas id=\"app\"></canvas>\n                    <p>点击小的字母G时调用remove方法</p>\n                </body>\n\n                <script>\n                    var G = 'https://raw.githubusercontent.com/c-zhuo/easycanvas/master/demos/G.png';\n\n                    var $app = new Easycanvas.Painter({\n                        el: '#app',\n                        width: 400,\n                        height: 400\n                    });\n\n                    var $parent = new Easycanvas.Sprite({\n                        content: {\n                            img: G,\n                        },\n                        style: {\n                            width: 50, height: 50,\n                            top: 50, left: Easycanvas.Transition.pendulum(50, 150, 4000).loop(),\n                        },\n                        // 这里通过children增加第一个子Sprite\n                        children: [{\n                            content: {\n                                img: G,\n                            },\n                            style: {\n                                width: 20, height: 20,\n                                left: 100, top: 0,\n                            },\n                            events: {\n                                click: function () {\n                                    this.remove();\n                                }\n                            }\n                        }],\n                    });\n\n                    // 这里通过add增加第二个子Sprite\n                    $parent.add(new Easycanvas.Sprite({\n                        content: {\n                            img: G,\n                        },\n                        style: {\n                            width: 20, height: 20,\n                            left: 100, top: 80,\n                        },\n                        events: {\n                            click: function () {\n                                this.remove();\n                            }\n                        }\n                    }));\n\n                    $app.add($parent);\n                    $app.start();\n                <\/script>\n            </code>\n        </section>\n\n        <p>关于events的具体用法将在后续介绍。</p>\n\n        <p><strong>每一个子Sprite都有一个$parent属性，指向它的父级Sprite</strong>。根实例没有$parent属性。例如：</p>\n\n        <section>\n            <div class=\"code-2-demo bg-demo\"></div>\n            <code>\n                <script>\n                    var $a = new Easycanvas.Sprite();\n                    var $b = new Easycanvas.Sprite();\n                    $b.add($a);\n\n                    document.write($a.$parent === $b); // true\n\n                    var c = {};\n                    var $c = new Easycanvas.Sprite(c);\n                    $c.add($b);\n\n                    document.write($b.$parent === $c); // true\n                    document.write($b.$parent === c); // false\n\n                    document.write($c.$parent); // undefined\n                <\/script>\n            </code>\n        </section>\n\n        <h2>继承</h2>\n\n        <p>子Sprite的最终位置left、top由它自身属性和父级Sprite相加得来，透明度opacity、缩放scale将相乘处理。在上面的例子中，children之所以左右摇摆，就是因为parent节点的left在左右移动。</p>\n\n        <section>\n            <div class=\"code-2-demo bg-demo\"></div>\n            <code>\n                <body>\n                    <canvas id=\"app\"></canvas>\n                    <p>看起来就像左上角源源不断地出现新的字母G</p>\n                </body>\n\n                <script>\n                    var G = 'https://raw.githubusercontent.com/c-zhuo/easycanvas/master/demos/G.png';\n\n                    var $app = new Easycanvas.Painter({\n                        el: '#app',\n                        width: 400,\n                        height: 400\n                    });\n\n                    var $parent = new Easycanvas.Sprite({\n                        content: {\n                            img: G,\n                        },\n                        style: {\n                            width: 50, height: 50,\n                            // 这里让x和y坐标从30线性变化到50，并循环（到50之后会立即变为30，开始下一次线性过度）\n                            left: Easycanvas.Transition.linear(30, 50, 1000).loop(),\n                            top: Easycanvas.Transition.linear(30, 50, 1000).loop(),\n                        },\n                    });\n\n                    var $lastChild = $parent;\n\n                    for (var i = 0; i < 10; i++) {\n                        // 创建10个Sprite，连续嵌套10层。每一层的透明度都是上一层的0.7倍\n                        var $newChild = new Easycanvas.Sprite({\n                            content: {\n                                img: G,\n                            },\n                            style: {\n                                width: 50, height: 50,\n                                top: 20, left: 20,\n                                opacity: 0.7,\n                                // 让子Sprite被父Sprite遮挡\n                                zIndex: -1\n                            },\n                        });\n\n                        $lastChild.add($newChild);\n\n                        $lastChild = $newChild;\n                    }\n\n                    $app.add($parent);\n                    $app.start();\n                <\/script>\n            </code>\n        </section>\n    </article>\n\n    \n    <article id=\"样式获取与更新\">\n        <h1>样式获取与更新</h1>\n\n        <p>之前已经提到，可以通过Sprite.style来获取某一个Sprite的样式。但是如果某个样式是一个function，那么就需要用到Sprite的一些API来获取当前值。</p>\n        \n        <h2>样式获取</h2>\n\n        <p>Sprite的getRect、getSelfStyle、getStyle这三个API可以获取当前的样式。例如：</p>\n\n        <section>\n            <div class=\"code-2-demo bg-demo\"></div>\n            <code>\n                <body>\n                    <canvas id=\"app\"></canvas>\n                    <p>点击字母G可以改变运动轨迹</p>\n                </body>\n\n                <script>\n                    var mouseX = mouseY = 0;\n                    var $app = new Easycanvas.Painter({\n                        el: '#app',\n                        width: 400,\n                        height: 400,\n                        events: {\n                            mousemove: function (event) {\n                                mouseX = event.canvasX;\n                                mouseY = event.canvasY;\n                            }\n                        }\n                    });\n\n                    var $letterG = new Easycanvas.Sprite({\n                        content: {\n                            img: 'https://raw.githubusercontent.com/c-zhuo/easycanvas/master/demos/G.png',\n                        },\n                        style: {\n                            width: function () {\n                                return mouseX / 2 + 30;\n                            },\n                            height: function () {\n                                return mouseY / 2 + 30;\n                            },\n                            left: Easycanvas.Transition.pendulum(50, 150, 3000).loop(),\n                            top: Easycanvas.Transition.pendulum(50, 150, 4000).loop(),\n                        },\n                        events: {\n                            click: function (e) {\n                                this.style.left = Easycanvas.Transition.pendulum(\n                                    this.getStyle('left'), Math.random() * 350, 3000\n                                ).loop();\n                                this.style.top = Easycanvas.Transition.pendulum(\n                                    this.getStyle('top'), Math.random() * 350, 4000\n                                ).loop();\n                            },\n                        },\n                    });\n\n                    $app.add($letterG);\n                    $app.start();\n                <\/script>\n            </code>\n        </section>\n\n        <p>在这个例子中，我们从当前的坐标位置开始进行新的钟摆。如果像之前的demo一样，用this.style.left来获取，那么取到的只是一个function（Easycanvas.Transition会返回一个function），而不是当前值。</p>\n\n        <p class=\"tip\">Tips：在这个例子中，由于为left赋值了一个transition函数，所以this.style.left()这种写法也可以近似取到当前值，但是不建议这样做。这里之所以说“近似”，是因为this.style.left()将以当前时间进行计算，而getStyle会用渲染的时间点计算，可能会存在几毫秒的误差。</p>\n\n        <p><strong>getRect()获取的是实际渲染的位置，返回的left、top为渲染时左上角的坐标（这一点和HTML5的getBoundingClientRect()获取到的left、top的含义相同），getStyle('opacity')获取的是实际渲染的样式（例如最终的透明度等），而getSelfStyle('left')获取的是当前自身的样式（用来获取一些函数形式的动态属性的当前值，例如一个渐变的当前值）</strong>。其中getSelfStyle()可以不传参数，将返回一个包含当前对象自身所有样式的对象。getSelfStyle().left与getSelfStyle('left')相同（但是更耗性能）。当locate为lt时，getRect().left与getStyle('left')相同。有关locate的介绍，请参阅“图片渲染与处理”。</p>\n\n        <p>上面的例子只有一个层级，因此getStyle和getSelfStyle的效果相同。下面这个例子存在两个层级，所以这两个API的结果不同：</p>\n\n        <section>\n            <div class=\"code-2-demo bg-demo\"></div>\n            <code>\n                <body>\n                    <canvas id=\"app\"></canvas>\n                    <p id=\"getSelfStyle\">点击第二个字母G</p>\n                    <p id=\"getSelfStyleTx\"></p>\n                    <p id=\"getStyle\"></p>\n                    <p id=\"getRect\"></p>\n                </body>\n\n                <script>\n                    var mouseX = mouseY = 0;\n                    var $app = new Easycanvas.Painter({\n                        el: '#app',\n                        width: 400,\n                        height: 400,\n                        events: {\n                            mousemove: function (event) {\n                                mouseX = event.canvasX;\n                                mouseY = event.canvasY;\n                            }\n                        }\n                    });\n\n                    var $parent = new Easycanvas.Sprite({\n                        content: {\n                            img: 'https://raw.githubusercontent.com/c-zhuo/easycanvas/master/demos/G.png',\n                        },\n                        style: {\n                            width: 100,\n                            height: 100,\n                            left: 100,\n                            top: 100,\n                        },\n                    });\n\n                    var $child = new Easycanvas.Sprite({\n                        content: {\n                            img: 'https://raw.githubusercontent.com/c-zhuo/easycanvas/master/demos/G.png',\n                        },\n                        style: {\n                            width: function () {return 100;},\n                            height: 100,\n                            left: 100,\n                            top: 100,\n                        },\n                        events: {\n                            click: function () {\n                                document.getElementById('getSelfStyle').innerHTML = 'getSelfStyle(): ' + JSON.stringify(this.getSelfStyle());\n                                document.getElementById('getSelfStyleTx').innerHTML = 'getSelfStyle().left: ' + JSON.stringify(this.getSelfStyle('left'));\n                                document.getElementById('getStyle').innerHTML = 'getStyle(\"left\"): ' + this.getStyle('left');\n                                document.getElementById('getRect').innerHTML = 'getRect(): ' + JSON.stringify(this.getRect());\n                            }\n                        }\n                    });\n\n                    $app.add($parent);\n                    $parent.add($child);\n                    $app.start();\n                <\/script>\n            </code>\n        </section>\n\n        <p>这个例子中child本身的left和top都是100，所以getSelfStyle返回的都是整数100。用getStyle获取时，会计算它的实际渲染结果（从父节点继承的位置），因此结果为200。而getRect获取的是绘制位置，因为图片的宽高都是100，以(200,200)为中心的话，需要从(150,150)开始绘制宽高都是100的面积。</p>\n\n        <p>为了便于使用，getRect也会返回实际渲染位置距离canvas节点的右侧和底部的坐标值right和bottom。</p>\n\n        <h2>样式更新</h2>\n\n        <p>除了像上面的例子，给this.style直接赋值外，也可以通过update进行赋值。例如：</p>\n\n        <section>\n            <div class=\"code-2-demo bg-demo\"></div>\n            <code>\n                <body>\n                    <canvas id=\"app\"></canvas>\n                    <p id=\"getRect\"></p>\n                    <p id=\"getSelfStyle\"></p>\n                </body>\n\n                <script>\n                    var mouseX = mouseY = 0;\n                    var $app = new Easycanvas.Painter({\n                        el: '#app',\n                        width: 400,\n                        height: 400,\n                        events: {\n                            mousemove: function (event) {\n                                mouseX = event.canvasX;\n                                mouseY = event.canvasY;\n                            }\n                        }\n                    });\n\n                    var $letterG = new Easycanvas.Sprite({\n                        content: {\n                            img: 'https://raw.githubusercontent.com/c-zhuo/easycanvas/master/demos/G.png',\n                        },\n                        style: {\n                            width: function () {\n                                return mouseX / 2 + 30;\n                            },\n                            height: function () {\n                                return mouseY / 2 + 30;\n                            },\n                        },\n                    });\n\n                    $letterG.update({\n                        style: {\n                            left: Easycanvas.Transition.pendulum(50, 150, 3000).loop(),\n                            top: Easycanvas.Transition.pendulum(50, 150, 4000).loop(),\n                        }\n                    });\n\n                    $app.add($letterG);\n                    $app.start();\n                <\/script>\n            </code>\n        </section>\n\n        <p>update除了批量修改style外，也可以用于修改event、conent等属性。未指明的参数将保持不变。</p>\n    </article>\n\n    \n    <article id=\"文本\">\n        <h1>文本渲染</h1>\n\n        <p>这里将介绍单行的展示。</p>\n\n        <p class=\"tip\">Tips：多行文本不被HTML5的canvas原生支持，目前行内的一些解决办法是渲染前预估长度并将文字拆成多行，或者渲染时动态计算是否应该换行。这些方法要么对性能有损伤、要么难以兼容各种字符和字体。因此Easycanvas本身没有计划支持多行文本，但是可以通过Easycanvas的组件来模拟，后续将会介绍。</p>\n        \n        <h2>单行文本</h2>\n\n        <p>为content中的text字段赋值，可以让这个Sprite渲染单行文本。下面这个例子包含了颜色、字体等相关参数：</p>\n\n        <section>\n            <div class=\"code-2-demo bg-demo\"></div>\n            <code>\n                <body>\n                    <canvas id=\"app\"></canvas>\n                </body>\n\n                <script>\n                    var $app = new Easycanvas.Painter({\n                        el: '#app',\n                        width: 400,\n                        height: 400\n                    });\n\n                    var $text = new Easycanvas.Sprite({\n                        content: {\n                            text: '单行text',\n                        },\n                        style: {\n                            left: 150, top: 150,\n                            width: 200, height: 200,\n                            color: 'red',\n                            backgroundColor: 'orange',\n                        },\n                    });\n\n                    var i = 0;\n                    var getFromArray = function (arr) {\n                        return arr[i % arr.length];\n                    };\n\n                    setInterval(function () {\n                        $text.style.textAlign = getFromArray(['left', 'center', 'right']);\n                        $text.style.textVerticalAlign = getFromArray(['top', 'middle', 'bottom']);\n                        $text.style.fontSize = getFromArray(['14px', '28px']);\n                        $text.style.color = getFromArray(['red', '#00FFFF', 'rgba(255, 255, 0, 0.8)']);\n                        i++;\n                    }, 1000);\n\n                    $app.add($text);\n                    $app.start();\n                <\/script>\n            </code>\n        </section>\n\n        <p><strong>上例的文字在PC下的很多浏览器内并不清晰</strong>。这是受到了HTML5的canvas本身的限制：未指定canvas的宽高时，它的大小将和包含的像素点的数量相同，可以理解为“devicePixelRatio”从2或者3变成了1。解决的办法之一，是给canvas的样式进行赋值，让渲染的尺寸两倍于自身包含的像素，例如下例：</p>\n\n        <section>\n            <div class=\"code-2-demo bg-demo\"></div>\n            <code>\n                <body>\n                    <canvas id=\"app\"></canvas>\n                    <style>\n                        canvas {\n                            width: 400px; height: 400px;\n                        }\n                    </style>\n                </body>\n\n                <script>\n                    var $app = new Easycanvas.Painter({\n                        el: '#app',\n                        width: 800,\n                        height: 800\n                    });\n\n                    var $text = new Easycanvas.Sprite({\n                        content: {\n                            text: '单行text',\n                        },\n                        style: {\n                            left: 300, top: 300,\n                            width: 400, height: 400,\n                            color: 'red',\n                        },\n                    });\n\n                    var i = 0;\n                    var getFromArray = function (arr) {\n                        return arr[i % arr.length];\n                    };\n\n                    setInterval(function () {\n                        $text.style.textAlign = getFromArray(['left', 'center', 'right']);\n                        $text.style.textVerticalAlign = getFromArray(['top', 'middle', 'bottom']);\n                        $text.style.fontSize = getFromArray([28, 56]);\n                        $text.style.color = getFromArray(['red', '#00FFFF', 'rgba(255, 255, 0, 0.8)']);\n                        i++;\n                    }, 1000);\n\n                    $app.add($text);\n                    $app.start();\n                <\/script>\n            </code>\n        </section>\n\n        <p>这些属性中，text可以是一个function类型，返回要渲染的字符串，如下例。</p>\n\n        <section>\n            <div class=\"code-2-demo bg-demo\"></div>\n            <code>\n                <body>\n                    <canvas id=\"app\"></canvas>\n                    <style>\n                        canvas {\n                            width: 400px; height: 400px;\n                        }\n                    </style>\n                </body>\n\n                <script>\n                    var MAX_COLOR_IN_36 = parseInt('ffffff', 16);\n                    var leftPads = function (str, length) {\n                        return str.length === length ? str : '0' + leftPads(str, length - 1);\n                    };\n                    var duration = 10000;\n\n                    var $app = new Easycanvas.Painter({\n                        el: '#app',\n                        width: 800,\n                        height: 800\n                    });\n\n                    var $text = new Easycanvas.Sprite({\n                        content: {\n                            text: function () {\n                                return Date.now();\n                            },\n                        },\n                        style: {\n                            left: 300, top: 300,\n                            width: 400, height: 400,\n                            fontSize: 56,\n                            color: function () {\n                                var colorInt10 = Math.floor(Date.now() % duration / duration * MAX_COLOR_IN_36);\n                                return '#' + leftPads(colorInt10.toString(16), 6);\n                            },\n                        },\n                    });\n\n                    $app.add($text);\n                    $app.start();\n                <\/script>\n            </code>\n        </section>\n    </article>\n\n"}}]);