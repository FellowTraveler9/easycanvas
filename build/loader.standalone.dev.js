(function e(t, i) {
    if (typeof exports === "object" && typeof module === "object") module.exports = i(); else if (typeof define === "function" && define.amd) define([], i); else {
        var r = i();
        for (var s in r) (typeof exports === "object" ? exports : t)[s] = r[s];
    }
})(this, function() {
    return function(e) {
        var t = {};
        function i(r) {
            if (t[r]) return t[r].exports;
            var s = t[r] = {
                exports: {},
                id: r,
                loaded: false
            };
            e[r].call(s.exports, s, s.exports, i);
            s.loaded = true;
            return s.exports;
        }
        i.m = e;
        i.c = t;
        i.p = "";
        return i(0);
    }([ function(e, t, i) {
        e.exports = i(106);
    }, , function(e, t) {
        "use strict";
        var i = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(e) {
            return typeof e;
        } : function(e) {
            return e && typeof Symbol === "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
        };
        var r = Array.prototype;
        var s = r.slice;
        var a = r.map;
        var n = r.forEach;
        var o = Object.prototype;
        var l = o.toString;
        var u = l.call(function() {});
        var c = l.call("");
        var h = o.hasOwnProperty;
        e.exports = function() {
            var e = {};
            function t(e, i) {
                var r = this;
                if (!(r instanceof t)) {
                    throw new Error("Type constructor cannot be invoked without 'new'");
                }
                if (l.call(e) !== u) {
                    throw new Error(e + " is not a function");
                }
                var s = l.call(i);
                if (!(s === u || s === c)) {
                    throw new Error(i + " is neither a function nor a string");
                }
                Object.defineProperties(r, {
                    name: {
                        value: i
                    },
                    check: {
                        value: function t(i, s) {
                            var a = e.call(r, i, s);
                            if (!a && s && l.call(s) === u) s(r, i);
                            return a;
                        }
                    }
                });
            }
            var r = t.prototype;
            e.Type = t;
            r.assert = function(e, t) {
                if (!this.check(e, t)) {
                    var i = a(e);
                    throw new Error(i + " does not match type " + this);
                }
                return true;
            };
            function a(e) {
                if (v.check(e)) return "{" + Object.keys(e).map(function(t) {
                    return t + ": " + e[t];
                }).join(", ") + "}";
                if (y.check(e)) return "[" + e.map(a).join(", ") + "]";
                return JSON.stringify(e);
            }
            r.toString = function() {
                var e = this.name;
                if (d.check(e)) return e;
                if (m.check(e)) return e.call(this) + "";
                return e + " type";
            };
            var n = [];
            var o = [];
            var p = {};
            e.builtInTypes = p;
            function f(e, i) {
                var r = l.call(e);
                var s = new t(function(e) {
                    return l.call(e) === r;
                }, i);
                p[i] = s;
                if (e && typeof e.constructor === "function") {
                    n.push(e.constructor);
                    o.push(s);
                }
                return s;
            }
            var d = f("truthy", "string");
            var m = f(function() {}, "function");
            var y = f([], "array");
            var v = f({}, "object");
            var x = f(/./, "RegExp");
            var g = f(new Date(), "Date");
            var b = f(3, "number");
            var E = f(true, "boolean");
            var k = f(null, "null");
            var S = f(void 0, "undefined");
            function w(e, i) {
                if (e instanceof t) return e;
                if (e instanceof P) return e.type;
                if (y.check(e)) return t.fromArray(e);
                if (v.check(e)) return t.fromObject(e);
                if (m.check(e)) {
                    var r = n.indexOf(e);
                    if (r >= 0) {
                        return o[r];
                    }
                    return new t(e, i);
                }
                return new t(function(t) {
                    return t === e;
                }, S.check(i) ? function() {
                    return e + "";
                } : i);
            }
            t.or = function() {
                var e = [];
                var i = arguments.length;
                for (var r = 0; r < i; ++r) {
                    e.push(w(arguments[r]));
                }
                return new t(function(t, r) {
                    for (var s = 0; s < i; ++s) {
                        if (e[s].check(t, r)) return true;
                    }
                    return false;
                }, function() {
                    return e.join(" | ");
                });
            };
            t.fromArray = function(e) {
                if (!y.check(e)) {
                    throw new Error("");
                }
                if (e.length !== 1) {
                    throw new Error("only one element type is permitted for typed arrays");
                }
                return w(e[0]).arrayOf();
            };
            r.arrayOf = function() {
                var e = this;
                return new t(function(t, i) {
                    return y.check(t) && t.every(function(t) {
                        return e.check(t, i);
                    });
                }, function() {
                    return "[" + e + "]";
                });
            };
            t.fromObject = function(e) {
                var i = Object.keys(e).map(function(t) {
                    return new A(t, e[t]);
                });
                return new t(function(e, t) {
                    return v.check(e) && i.every(function(i) {
                        return i.type.check(e[i.name], t);
                    });
                }, function() {
                    return "{ " + i.join(", ") + " }";
                });
            };
            function A(e, t, i, r) {
                var s = this;
                if (!(s instanceof A)) {
                    throw new Error("Field constructor cannot be invoked without 'new'");
                }
                d.assert(e);
                t = w(t);
                var a = {
                    name: {
                        value: e
                    },
                    type: {
                        value: t
                    },
                    hidden: {
                        value: !!r
                    }
                };
                if (m.check(i)) {
                    a.defaultFn = {
                        value: i
                    };
                }
                Object.defineProperties(s, a);
            }
            var C = A.prototype;
            C.toString = function() {
                return JSON.stringify(this.name) + ": " + this.type;
            };
            C.getValue = function(e) {
                var t = e[this.name];
                if (!S.check(t)) return t;
                if (this.defaultFn) t = this.defaultFn.call(e);
                return t;
            };
            t.def = function(e) {
                d.assert(e);
                return h.call(T, e) ? T[e] : T[e] = new P(e);
            };
            var T = Object.create(null);
            function P(e) {
                var i = this;
                if (!(i instanceof P)) {
                    throw new Error("Def constructor cannot be invoked without 'new'");
                }
                Object.defineProperties(i, {
                    typeName: {
                        value: e
                    },
                    baseNames: {
                        value: []
                    },
                    ownFields: {
                        value: Object.create(null)
                    },
                    allSupertypes: {
                        value: Object.create(null)
                    },
                    supertypeList: {
                        value: []
                    },
                    allFields: {
                        value: Object.create(null)
                    },
                    fieldNames: {
                        value: []
                    },
                    type: {
                        value: new t(function(e, t) {
                            return i.check(e, t);
                        }, e)
                    }
                });
            }
            P.fromValue = function(e) {
                if (e && (typeof e === "undefined" ? "undefined" : i(e)) === "object") {
                    var t = e.type;
                    if (typeof t === "string" && h.call(T, t)) {
                        var r = T[t];
                        if (r.finalized) {
                            return r;
                        }
                    }
                }
                return null;
            };
            var D = P.prototype;
            D.isSupertypeOf = function(e) {
                if (e instanceof P) {
                    if (this.finalized !== true || e.finalized !== true) {
                        throw new Error("");
                    }
                    return h.call(e.allSupertypes, this.typeName);
                } else {
                    throw new Error(e + " is not a Def");
                }
            };
            e.getSupertypeNames = function(e) {
                if (!h.call(T, e)) {
                    throw new Error("");
                }
                var t = T[e];
                if (t.finalized !== true) {
                    throw new Error("");
                }
                return t.supertypeList.slice(1);
            };
            e.computeSupertypeLookupTable = function(e) {
                var t = {};
                var i = Object.keys(T);
                var r = i.length;
                for (var s = 0; s < r; ++s) {
                    var a = i[s];
                    var n = T[a];
                    if (n.finalized !== true) {
                        throw new Error("" + a);
                    }
                    for (var o = 0; o < n.supertypeList.length; ++o) {
                        var l = n.supertypeList[o];
                        if (h.call(e, l)) {
                            t[a] = l;
                            break;
                        }
                    }
                }
                return t;
            };
            D.checkAllFields = function(e, t) {
                var i = this.allFields;
                if (this.finalized !== true) {
                    throw new Error("" + this.typeName);
                }
                function r(r) {
                    var s = i[r];
                    var a = s.type;
                    var n = s.getValue(e);
                    return a.check(n, t);
                }
                return v.check(e) && Object.keys(i).every(r);
            };
            D.check = function(e, t) {
                if (this.finalized !== true) {
                    throw new Error("prematurely checking unfinalized type " + this.typeName);
                }
                if (!v.check(e)) return false;
                var i = P.fromValue(e);
                if (!i) {
                    if (this.typeName === "SourceLocation" || this.typeName === "Position") {
                        return this.checkAllFields(e, t);
                    }
                    return false;
                }
                if (t && i === this) return this.checkAllFields(e, t);
                if (!this.isSupertypeOf(i)) return false;
                if (!t) return true;
                return i.checkAllFields(e, t) && this.checkAllFields(e, false);
            };
            D.bases = function() {
                var e = s.call(arguments);
                var t = this.baseNames;
                if (this.finalized) {
                    if (e.length !== t.length) {
                        throw new Error("");
                    }
                    for (var i = 0; i < e.length; i++) {
                        if (e[i] !== t[i]) {
                            throw new Error("");
                        }
                    }
                    return this;
                }
                e.forEach(function(e) {
                    d.assert(e);
                    if (t.indexOf(e) < 0) t.push(e);
                });
                return this;
            };
            Object.defineProperty(D, "buildable", {
                value: false
            });
            var _ = {};
            e.builders = _;
            var N = {};
            e.defineMethod = function(e, t) {
                var i = N[e];
                if (S.check(t)) {
                    delete N[e];
                } else {
                    m.assert(t);
                    Object.defineProperty(N, e, {
                        enumerable: true,
                        configurable: true,
                        value: t
                    });
                }
                return i;
            };
            var F = d.arrayOf();
            D.build = function() {
                var e = this;
                var t = s.call(arguments);
                F.assert(t);
                Object.defineProperty(e, "buildParams", {
                    value: t,
                    writable: false,
                    enumerable: false,
                    configurable: true
                });
                if (e.buildable) {
                    return e;
                }
                e.field("type", String, function() {
                    return e.typeName;
                });
                Object.defineProperty(e, "buildable", {
                    value: true
                });
                function i(t, i, r, s) {
                    if (h.call(t, i)) return;
                    var n = e.allFields;
                    if (!h.call(n, i)) {
                        throw new Error("" + i);
                    }
                    var o = n[i];
                    var l = o.type;
                    var u;
                    if (s) {
                        u = r;
                    } else if (o.defaultFn) {
                        u = o.defaultFn.call(t);
                    } else {
                        var c = "no value or default function given for field " + JSON.stringify(i) + " of " + e.typeName + "(" + e.buildParams.map(function(e) {
                            return n[e];
                        }).join(", ") + ")";
                        throw new Error(c);
                    }
                    if (!l.check(u)) {
                        throw new Error(a(u) + " does not match field " + o + " of type " + e.typeName);
                    }
                    t[i] = u;
                }
                function r() {
                    var t = arguments;
                    var r = t.length;
                    if (!e.finalized) {
                        throw new Error("attempting to instantiate unfinalized type " + e.typeName);
                    }
                    var s = Object.create(N);
                    e.buildParams.forEach(function(e, a) {
                        if (a < r) {
                            i(s, e, t[a], true);
                        } else {
                            i(s, e, null, false);
                        }
                    });
                    Object.keys(e.allFields).forEach(function(e) {
                        i(s, e, null, false);
                    });
                    if (s.type !== e.typeName) {
                        throw new Error("");
                    }
                    return s;
                }
                r.from = function(t) {
                    if (!e.finalized) {
                        throw new Error("attempting to instantiate unfinalized type " + e.typeName);
                    }
                    var r = Object.create(N);
                    Object.keys(e.allFields).forEach(function(e) {
                        if (h.call(t, e)) {
                            i(r, e, t[e], true);
                        } else {
                            i(r, e, null, false);
                        }
                    });
                    if (r.type !== e.typeName) {
                        throw new Error("");
                    }
                    return r;
                };
                Object.defineProperty(_, I(e.typeName), {
                    enumerable: true,
                    value: r
                });
                return e;
            };
            function I(e) {
                return e.replace(/^[A-Z]+/, function(e) {
                    var t = e.length;
                    switch (t) {
                      case 0:
                        return "";

                      case 1:
                        return e.toLowerCase();

                      default:
                        return e.slice(0, t - 1).toLowerCase() + e.charAt(t - 1);
                    }
                });
            }
            e.getBuilderName = I;
            function O(e) {
                e = I(e);
                return e.replace(/(Expression)?$/, "Statement");
            }
            e.getStatementBuilderName = O;
            D.field = function(e, t, i, r) {
                if (this.finalized) {
                    console.error("Ignoring attempt to redefine field " + JSON.stringify(e) + " of finalized type " + JSON.stringify(this.typeName));
                    return this;
                }
                this.ownFields[e] = new A(e, t, i, r);
                return this;
            };
            var L = {};
            e.namedTypes = L;
            function B(e) {
                var t = P.fromValue(e);
                if (t) {
                    return t.fieldNames.slice(0);
                }
                if ("type" in e) {
                    throw new Error("did not recognize object of type " + JSON.stringify(e.type));
                }
                return Object.keys(e);
            }
            e.getFieldNames = B;
            function M(e, t) {
                var i = P.fromValue(e);
                if (i) {
                    var r = i.allFields[t];
                    if (r) {
                        return r.getValue(e);
                    }
                }
                return e && e[t];
            }
            e.getFieldValue = M;
            e.eachField = function(e, t, i) {
                B(e).forEach(function(i) {
                    t.call(this, i, M(e, i));
                }, i);
            };
            e.someField = function(e, t, i) {
                return B(e).some(function(i) {
                    return t.call(this, i, M(e, i));
                }, i);
            };
            Object.defineProperty(D, "finalized", {
                value: false
            });
            D.finalize = function() {
                var e = this;
                if (!e.finalized) {
                    var t = e.allFields;
                    var i = e.allSupertypes;
                    e.baseNames.forEach(function(r) {
                        var s = T[r];
                        if (s instanceof P) {
                            s.finalize();
                            V(t, s.allFields);
                            V(i, s.allSupertypes);
                        } else {
                            var a = "unknown supertype name " + JSON.stringify(r) + " for subtype " + JSON.stringify(e.typeName);
                            throw new Error(a);
                        }
                    });
                    V(t, e.ownFields);
                    i[e.typeName] = e;
                    e.fieldNames.length = 0;
                    for (var r in t) {
                        if (h.call(t, r) && !t[r].hidden) {
                            e.fieldNames.push(r);
                        }
                    }
                    Object.defineProperty(L, e.typeName, {
                        enumerable: true,
                        value: e.type
                    });
                    Object.defineProperty(e, "finalized", {
                        value: true
                    });
                    R(e.typeName, e.supertypeList);
                    if (e.buildable && e.supertypeList.lastIndexOf("Expression") >= 0) {
                        j(e.typeName);
                    }
                }
            };
            function j(e) {
                var t = O(e);
                if (_[t]) return;
                var i = _[I(e)];
                if (!i) return;
                _[t] = function() {
                    return _.expressionStatement(i.apply(_, arguments));
                };
            }
            function R(e, t) {
                t.length = 0;
                t.push(e);
                var i = Object.create(null);
                for (var r = 0; r < t.length; ++r) {
                    e = t[r];
                    var s = T[e];
                    if (s.finalized !== true) {
                        throw new Error("");
                    }
                    if (h.call(i, e)) {
                        delete t[i[e]];
                    }
                    i[e] = r;
                    t.push.apply(t, s.baseNames);
                }
                for (var a = 0, n = a, o = t.length; n < o; ++n) {
                    if (h.call(t, n)) {
                        t[a++] = t[n];
                    }
                }
                t.length = a;
            }
            function V(e, t) {
                Object.keys(t).forEach(function(i) {
                    e[i] = t[i];
                });
                return e;
            }
            e.finalize = function() {
                Object.keys(T).forEach(function(e) {
                    T[e].finalize();
                });
            };
            return e;
        };
    }, , , function(e, t, i) {
        "use strict";
        var r = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(e) {
            return typeof e;
        } : function(e) {
            return e && typeof Symbol === "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
        };
        e.exports = function(e) {
            var t = {};
            var s = e.use(i(2));
            var a = s.Type;
            var n = s.builtInTypes;
            var o = n.number;
            t.geq = function(e) {
                return new a(function(t) {
                    return o.check(t) && t >= e;
                }, o + " >= " + e);
            };
            t.defaults = {
                null: function e() {
                    return null;
                },
                emptyArray: function e() {
                    return [];
                },
                false: function e() {
                    return false;
                },
                true: function e() {
                    return true;
                },
                undefined: function e() {}
            };
            var l = a.or(n.string, n.number, n.boolean, n.null, n.undefined);
            t.isPrimitive = new a(function(e) {
                if (e === null) return true;
                var t = typeof e === "undefined" ? "undefined" : r(e);
                return !(t === "object" || t === "function");
            }, l.toString());
            return t;
        };
    }, function(e, t, i) {
        "use strict";
        e.exports = i(73);
    }, function(e, t, i) {
        (function(t) {
            "use strict";
            var r = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(e) {
                return typeof e;
            } : function(e) {
                return e && typeof Symbol === "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
            };
            function s(e, t) {
                if (e === t) {
                    return 0;
                }
                var i = e.length;
                var r = t.length;
                for (var s = 0, a = Math.min(i, r); s < a; ++s) {
                    if (e[s] !== t[s]) {
                        i = e[s];
                        r = t[s];
                        break;
                    }
                }
                if (i < r) {
                    return -1;
                }
                if (r < i) {
                    return 1;
                }
                return 0;
            }
            function a(e) {
                if (t.Buffer && typeof t.Buffer.isBuffer === "function") {
                    return t.Buffer.isBuffer(e);
                }
                return !!(e != null && e._isBuffer);
            }
            var n = i(61);
            var o = Object.prototype.hasOwnProperty;
            var l = Array.prototype.slice;
            var u = function() {
                return function e() {}.name === "foo";
            }();
            function c(e) {
                return Object.prototype.toString.call(e);
            }
            function h(e) {
                if (a(e)) {
                    return false;
                }
                if (typeof t.ArrayBuffer !== "function") {
                    return false;
                }
                if (typeof ArrayBuffer.isView === "function") {
                    return ArrayBuffer.isView(e);
                }
                if (!e) {
                    return false;
                }
                if (e instanceof DataView) {
                    return true;
                }
                if (e.buffer && e.buffer instanceof ArrayBuffer) {
                    return true;
                }
                return false;
            }
            var p = e.exports = g;
            var f = /\s*function\s+([^\(\s]*)\s*/;
            function d(e) {
                if (!n.isFunction(e)) {
                    return;
                }
                if (u) {
                    return e.name;
                }
                var t = e.toString();
                var i = t.match(f);
                return i && i[1];
            }
            p.AssertionError = function e(t) {
                this.name = "AssertionError";
                this.actual = t.actual;
                this.expected = t.expected;
                this.operator = t.operator;
                if (t.message) {
                    this.message = t.message;
                    this.generatedMessage = false;
                } else {
                    this.message = v(this);
                    this.generatedMessage = true;
                }
                var i = t.stackStartFunction || x;
                if (Error.captureStackTrace) {
                    Error.captureStackTrace(this, i);
                } else {
                    var r = new Error();
                    if (r.stack) {
                        var s = r.stack;
                        var a = d(i);
                        var n = s.indexOf("\n" + a);
                        if (n >= 0) {
                            var o = s.indexOf("\n", n + 1);
                            s = s.substring(o + 1);
                        }
                        this.stack = s;
                    }
                }
            };
            n.inherits(p.AssertionError, Error);
            function m(e, t) {
                if (typeof e === "string") {
                    return e.length < t ? e : e.slice(0, t);
                } else {
                    return e;
                }
            }
            function y(e) {
                if (u || !n.isFunction(e)) {
                    return n.inspect(e);
                }
                var t = d(e);
                var i = t ? ": " + t : "";
                return "[Function" + i + "]";
            }
            function v(e) {
                return m(y(e.actual), 128) + " " + e.operator + " " + m(y(e.expected), 128);
            }
            function x(e, t, i, r, s) {
                throw new p.AssertionError({
                    message: i,
                    actual: e,
                    expected: t,
                    operator: r,
                    stackStartFunction: s
                });
            }
            p.fail = x;
            function g(e, t) {
                if (!e) x(e, true, t, "==", p.ok);
            }
            p.ok = g;
            p.equal = function e(t, i, r) {
                if (t != i) x(t, i, r, "==", p.equal);
            };
            p.notEqual = function e(t, i, r) {
                if (t == i) {
                    x(t, i, r, "!=", p.notEqual);
                }
            };
            p.deepEqual = function e(t, i, r) {
                if (!b(t, i, false)) {
                    x(t, i, r, "deepEqual", p.deepEqual);
                }
            };
            p.deepStrictEqual = function e(t, i, r) {
                if (!b(t, i, true)) {
                    x(t, i, r, "deepStrictEqual", p.deepStrictEqual);
                }
            };
            function b(e, t, i, o) {
                if (e === t) {
                    return true;
                } else if (a(e) && a(t)) {
                    return s(e, t) === 0;
                } else if (n.isDate(e) && n.isDate(t)) {
                    return e.getTime() === t.getTime();
                } else if (n.isRegExp(e) && n.isRegExp(t)) {
                    return e.source === t.source && e.global === t.global && e.multiline === t.multiline && e.lastIndex === t.lastIndex && e.ignoreCase === t.ignoreCase;
                } else if ((e === null || (typeof e === "undefined" ? "undefined" : r(e)) !== "object") && (t === null || (typeof t === "undefined" ? "undefined" : r(t)) !== "object")) {
                    return i ? e === t : e == t;
                } else if (h(e) && h(t) && c(e) === c(t) && !(e instanceof Float32Array || e instanceof Float64Array)) {
                    return s(new Uint8Array(e.buffer), new Uint8Array(t.buffer)) === 0;
                } else if (a(e) !== a(t)) {
                    return false;
                } else {
                    o = o || {
                        actual: [],
                        expected: []
                    };
                    var l = o.actual.indexOf(e);
                    if (l !== -1) {
                        if (l === o.expected.indexOf(t)) {
                            return true;
                        }
                    }
                    o.actual.push(e);
                    o.expected.push(t);
                    return k(e, t, i, o);
                }
            }
            function E(e) {
                return Object.prototype.toString.call(e) == "[object Arguments]";
            }
            function k(e, t, i, r) {
                if (e === null || e === undefined || t === null || t === undefined) return false;
                if (n.isPrimitive(e) || n.isPrimitive(t)) return e === t;
                if (i && Object.getPrototypeOf(e) !== Object.getPrototypeOf(t)) return false;
                var s = E(e);
                var a = E(t);
                if (s && !a || !s && a) return false;
                if (s) {
                    e = l.call(e);
                    t = l.call(t);
                    return b(e, t, i);
                }
                var o = T(e);
                var u = T(t);
                var c, h;
                if (o.length !== u.length) return false;
                o.sort();
                u.sort();
                for (h = o.length - 1; h >= 0; h--) {
                    if (o[h] !== u[h]) return false;
                }
                for (h = o.length - 1; h >= 0; h--) {
                    c = o[h];
                    if (!b(e[c], t[c], i, r)) return false;
                }
                return true;
            }
            p.notDeepEqual = function e(t, i, r) {
                if (b(t, i, false)) {
                    x(t, i, r, "notDeepEqual", p.notDeepEqual);
                }
            };
            p.notDeepStrictEqual = S;
            function S(e, t, i) {
                if (b(e, t, true)) {
                    x(e, t, i, "notDeepStrictEqual", S);
                }
            }
            p.strictEqual = function e(t, i, r) {
                if (t !== i) {
                    x(t, i, r, "===", p.strictEqual);
                }
            };
            p.notStrictEqual = function e(t, i, r) {
                if (t === i) {
                    x(t, i, r, "!==", p.notStrictEqual);
                }
            };
            function w(e, t) {
                if (!e || !t) {
                    return false;
                }
                if (Object.prototype.toString.call(t) == "[object RegExp]") {
                    return t.test(e);
                }
                try {
                    if (e instanceof t) {
                        return true;
                    }
                } catch (e) {}
                if (Error.isPrototypeOf(t)) {
                    return false;
                }
                return t.call({}, e) === true;
            }
            function A(e) {
                var t;
                try {
                    e();
                } catch (e) {
                    t = e;
                }
                return t;
            }
            function C(e, t, i, r) {
                var s;
                if (typeof t !== "function") {
                    throw new TypeError('"block" argument must be a function');
                }
                if (typeof i === "string") {
                    r = i;
                    i = null;
                }
                s = A(t);
                r = (i && i.name ? " (" + i.name + ")." : ".") + (r ? " " + r : ".");
                if (e && !s) {
                    x(s, i, "Missing expected exception" + r);
                }
                var a = typeof r === "string";
                var o = !e && n.isError(s);
                var l = !e && s && !i;
                if (o && a && w(s, i) || l) {
                    x(s, i, "Got unwanted exception" + r);
                }
                if (e && s && i && !w(s, i) || !e && s) {
                    throw s;
                }
            }
            p.throws = function(e, t, i) {
                C(true, e, t, i);
            };
            p.doesNotThrow = function(e, t, i) {
                C(false, e, t, i);
            };
            p.ifError = function(e) {
                if (e) throw e;
            };
            var T = Object.keys || function(e) {
                var t = [];
                for (var i in e) {
                    if (o.call(e, i)) t.push(i);
                }
                return t;
            };
        }).call(t, function() {
            return this;
        }());
    }, function(e, t, i) {
        "use strict";
        var r = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(e) {
            return typeof e;
        } : function(e) {
            return e && typeof Symbol === "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
        };
        var s = i(7);
        var a = i(6);
        var n = a.getFieldValue;
        var o = a.namedTypes;
        var l = i(21);
        var u = l.SourceMapConsumer;
        var c = l.SourceMapGenerator;
        var h = Object.prototype.hasOwnProperty;
        var p = t;
        function f(e, t, i) {
            if (e && h.call(e, t)) {
                return e[t];
            }
            return i;
        }
        p.getOption = f;
        function d() {
            var e = {};
            var t = arguments.length;
            for (var i = 0; i < t; ++i) {
                var r = Object.keys(arguments[i]);
                var s = r.length;
                for (var a = 0; a < s; ++a) {
                    e[r[a]] = true;
                }
            }
            return e;
        }
        p.getUnionOfKeys = d;
        function m(e, t) {
            return e.line - t.line || e.column - t.column;
        }
        p.comparePos = m;
        function y(e) {
            return {
                line: e.line,
                column: e.column
            };
        }
        p.copyPos = y;
        p.composeSourceMaps = function(e, t) {
            if (e) {
                if (!t) {
                    return e;
                }
            } else {
                return t || null;
            }
            var i = new u(e);
            var r = new u(t);
            var s = new c({
                file: t.file,
                sourceRoot: t.sourceRoot
            });
            var a = {};
            r.eachMapping(function(e) {
                var t = i.originalPositionFor({
                    line: e.originalLine,
                    column: e.originalColumn
                });
                var r = t.source;
                if (r === null) {
                    return;
                }
                s.addMapping({
                    source: r,
                    original: y(t),
                    generated: {
                        line: e.generatedLine,
                        column: e.generatedColumn
                    },
                    name: e.name
                });
                var n = i.sourceContentFor(r);
                if (n && !h.call(a, r)) {
                    a[r] = n;
                    s.setSourceContent(r, n);
                }
            });
            return s.toJSON();
        };
        p.getTrueLoc = function(e, t) {
            if (!e.loc) {
                return null;
            }
            var i = {
                start: e.loc.start,
                end: e.loc.end
            };
            function r(e) {
                v(i, e.loc);
            }
            if (e.declaration && e.declaration.decorators && p.isExportDeclaration(e)) {
                e.declaration.decorators.forEach(r);
            }
            if (m(i.start, i.end) < 0) {
                i.start = y(i.start);
                t.skipSpaces(i.start, false, true);
                if (m(i.start, i.end) < 0) {
                    i.end = y(i.end);
                    t.skipSpaces(i.end, true, true);
                }
            }
            if (e.comments) {
                e.comments.forEach(r);
            }
            return i;
        };
        function v(e, t) {
            if (e && t) {
                if (m(t.start, e.start) < 0) {
                    e.start = t.start;
                }
                if (m(e.end, t.end) < 0) {
                    e.end = t.end;
                }
            }
        }
        p.fixFaultyLocations = function(e, t) {
            var i = e.loc;
            if (i) {
                if (i.start.line < 1) {
                    i.start.line = 1;
                }
                if (i.end.line < 1) {
                    i.end.line = 1;
                }
            }
            if (e.type === "File") {
                i.start = t.firstPos();
                i.end = t.lastPos();
            }
            x(e, t);
            g(e, t);
            if (i && e.decorators) {
                e.decorators.forEach(function(e) {
                    v(i, e.loc);
                });
            } else if (e.declaration && p.isExportDeclaration(e)) {
                e.declaration.loc = null;
                var r = e.declaration.decorators;
                if (r) {
                    r.forEach(function(e) {
                        v(i, e.loc);
                    });
                }
            } else if (o.MethodDefinition && o.MethodDefinition.check(e) || o.Property.check(e) && (e.method || e.shorthand)) {
                e.value.loc = null;
                if (o.FunctionExpression.check(e.value)) {
                    e.value.id = null;
                }
            } else if (e.type === "ObjectTypeProperty") {
                var i = e.loc;
                var s = i && i.end;
                if (s) {
                    s = y(s);
                    if (t.prevPos(s) && t.charAt(s) === ",") {
                        if (s = t.skipSpaces(s, true, true)) {
                            i.end = s;
                        }
                    }
                }
            }
        };
        function x(e, t) {
            if (e.type !== "ForStatement") {
                return;
            }
            function i(e) {
                var i = e && e.loc;
                var r = i && i.start;
                var s = i && y(i.end);
                while (r && s && m(r, s) < 0) {
                    t.prevPos(s);
                    if (t.charAt(s) === ";") {
                        i.end.line = s.line;
                        i.end.column = s.column;
                    } else {
                        break;
                    }
                }
            }
            i(e.init);
            i(e.test);
            i(e.update);
        }
        function g(e, t) {
            if (e.type !== "TemplateLiteral") {
                return;
            }
            if (e.quasis.length === 0) {
                return;
            }
            var i = y(e.loc.start);
            s.strictEqual(t.charAt(i), "`");
            s.ok(t.nextPos(i));
            var r = e.quasis[0];
            if (m(r.loc.start, i) < 0) {
                r.loc.start = i;
            }
            var a = y(e.loc.end);
            s.ok(t.prevPos(a));
            s.strictEqual(t.charAt(a), "`");
            var n = e.quasis[e.quasis.length - 1];
            if (m(a, n.loc.end) < 0) {
                n.loc.end = a;
            }
            e.expressions.forEach(function(i, r) {
                var a = t.skipSpaces(i.loc.start, true, false);
                if (t.prevPos(a) && t.charAt(a) === "{" && t.prevPos(a) && t.charAt(a) === "$") {
                    var n = e.quasis[r];
                    if (m(a, n.loc.end) < 0) {
                        n.loc.end = a;
                    }
                }
                var o = t.skipSpaces(i.loc.end, false, false);
                if (t.charAt(o) === "}") {
                    s.ok(t.nextPos(o));
                    var l = e.quasis[r + 1];
                    if (m(l.loc.start, o) < 0) {
                        l.loc.start = o;
                    }
                }
            });
        }
        p.isExportDeclaration = function(e) {
            if (e) switch (e.type) {
              case "ExportDeclaration":
              case "ExportDefaultDeclaration":
              case "ExportDefaultSpecifier":
              case "DeclareExportDeclaration":
              case "ExportNamedDeclaration":
              case "ExportAllDeclaration":
                return true;
            }
            return false;
        };
        p.getParentExportDeclaration = function(e) {
            var t = e.getParentNode();
            if (e.getName() === "declaration" && p.isExportDeclaration(t)) {
                return t;
            }
            return null;
        };
        p.isTrailingCommaEnabled = function(e, t) {
            var i = e.trailingComma;
            if ((typeof i === "undefined" ? "undefined" : r(i)) === "object") {
                return !!i[t];
            }
            return !!i;
        };
    }, , , function(e, t, i) {
        "use strict";
        e.exports = function(e) {
            var t = e.use(i(2));
            var r = t.Type;
            var s = r.def;
            var a = r.or;
            var n = e.use(i(5));
            var o = n.defaults;
            var l = n.geq;
            s("Printable").field("loc", a(s("SourceLocation"), null), o["null"], true);
            s("Node").bases("Printable").field("type", String).field("comments", a([ s("Comment") ], null), o["null"], true);
            s("SourceLocation").build("start", "end", "source").field("start", s("Position")).field("end", s("Position")).field("source", a(String, null), o["null"]);
            s("Position").build("line", "column").field("line", l(1)).field("column", l(0));
            s("File").bases("Node").build("program", "name").field("program", s("Program")).field("name", a(String, null), o["null"]);
            s("Program").bases("Node").build("body").field("body", [ s("Statement") ]);
            s("Function").bases("Node").field("id", a(s("Identifier"), null), o["null"]).field("params", [ s("Pattern") ]).field("body", s("BlockStatement"));
            s("Statement").bases("Node");
            s("EmptyStatement").bases("Statement").build();
            s("BlockStatement").bases("Statement").build("body").field("body", [ s("Statement") ]);
            s("ExpressionStatement").bases("Statement").build("expression").field("expression", s("Expression"));
            s("IfStatement").bases("Statement").build("test", "consequent", "alternate").field("test", s("Expression")).field("consequent", s("Statement")).field("alternate", a(s("Statement"), null), o["null"]);
            s("LabeledStatement").bases("Statement").build("label", "body").field("label", s("Identifier")).field("body", s("Statement"));
            s("BreakStatement").bases("Statement").build("label").field("label", a(s("Identifier"), null), o["null"]);
            s("ContinueStatement").bases("Statement").build("label").field("label", a(s("Identifier"), null), o["null"]);
            s("WithStatement").bases("Statement").build("object", "body").field("object", s("Expression")).field("body", s("Statement"));
            s("SwitchStatement").bases("Statement").build("discriminant", "cases", "lexical").field("discriminant", s("Expression")).field("cases", [ s("SwitchCase") ]).field("lexical", Boolean, o["false"]);
            s("ReturnStatement").bases("Statement").build("argument").field("argument", a(s("Expression"), null));
            s("ThrowStatement").bases("Statement").build("argument").field("argument", s("Expression"));
            s("TryStatement").bases("Statement").build("block", "handler", "finalizer").field("block", s("BlockStatement")).field("handler", a(s("CatchClause"), null), function() {
                return this.handlers && this.handlers[0] || null;
            }).field("handlers", [ s("CatchClause") ], function() {
                return this.handler ? [ this.handler ] : [];
            }, true).field("guardedHandlers", [ s("CatchClause") ], o.emptyArray).field("finalizer", a(s("BlockStatement"), null), o["null"]);
            s("CatchClause").bases("Node").build("param", "guard", "body").field("param", a(s("Pattern"), null), o["null"]).field("guard", a(s("Expression"), null), o["null"]).field("body", s("BlockStatement"));
            s("WhileStatement").bases("Statement").build("test", "body").field("test", s("Expression")).field("body", s("Statement"));
            s("DoWhileStatement").bases("Statement").build("body", "test").field("body", s("Statement")).field("test", s("Expression"));
            s("ForStatement").bases("Statement").build("init", "test", "update", "body").field("init", a(s("VariableDeclaration"), s("Expression"), null)).field("test", a(s("Expression"), null)).field("update", a(s("Expression"), null)).field("body", s("Statement"));
            s("ForInStatement").bases("Statement").build("left", "right", "body").field("left", a(s("VariableDeclaration"), s("Expression"))).field("right", s("Expression")).field("body", s("Statement"));
            s("DebuggerStatement").bases("Statement").build();
            s("Declaration").bases("Statement");
            s("FunctionDeclaration").bases("Function", "Declaration").build("id", "params", "body").field("id", s("Identifier"));
            s("FunctionExpression").bases("Function", "Expression").build("id", "params", "body");
            s("VariableDeclaration").bases("Declaration").build("kind", "declarations").field("kind", a("var", "let", "const")).field("declarations", [ s("VariableDeclarator") ]);
            s("VariableDeclarator").bases("Node").build("id", "init").field("id", s("Pattern")).field("init", a(s("Expression"), null));
            s("Expression").bases("Node", "Pattern");
            s("ThisExpression").bases("Expression").build();
            s("ArrayExpression").bases("Expression").build("elements").field("elements", [ a(s("Expression"), null) ]);
            s("ObjectExpression").bases("Expression").build("properties").field("properties", [ s("Property") ]);
            s("Property").bases("Node").build("kind", "key", "value").field("kind", a("init", "get", "set")).field("key", a(s("Literal"), s("Identifier"))).field("value", s("Expression"));
            s("SequenceExpression").bases("Expression").build("expressions").field("expressions", [ s("Expression") ]);
            var u = a("-", "+", "!", "~", "typeof", "void", "delete");
            s("UnaryExpression").bases("Expression").build("operator", "argument", "prefix").field("operator", u).field("argument", s("Expression")).field("prefix", Boolean, o["true"]);
            var c = a("==", "!=", "===", "!==", "<", "<=", ">", ">=", "<<", ">>", ">>>", "+", "-", "*", "/", "%", "**", "&", "|", "^", "in", "instanceof", "..");
            s("BinaryExpression").bases("Expression").build("operator", "left", "right").field("operator", c).field("left", s("Expression")).field("right", s("Expression"));
            var h = a("=", "+=", "-=", "*=", "/=", "%=", "<<=", ">>=", ">>>=", "|=", "^=", "&=");
            s("AssignmentExpression").bases("Expression").build("operator", "left", "right").field("operator", h).field("left", s("Pattern")).field("right", s("Expression"));
            var p = a("++", "--");
            s("UpdateExpression").bases("Expression").build("operator", "argument", "prefix").field("operator", p).field("argument", s("Expression")).field("prefix", Boolean);
            var f = a("||", "&&");
            s("LogicalExpression").bases("Expression").build("operator", "left", "right").field("operator", f).field("left", s("Expression")).field("right", s("Expression"));
            s("ConditionalExpression").bases("Expression").build("test", "consequent", "alternate").field("test", s("Expression")).field("consequent", s("Expression")).field("alternate", s("Expression"));
            s("NewExpression").bases("Expression").build("callee", "arguments").field("callee", s("Expression")).field("arguments", [ s("Expression") ]);
            s("CallExpression").bases("Expression").build("callee", "arguments").field("callee", s("Expression")).field("arguments", [ s("Expression") ]);
            s("MemberExpression").bases("Expression").build("object", "property", "computed").field("object", s("Expression")).field("property", a(s("Identifier"), s("Expression"))).field("computed", Boolean, function() {
                var e = this.property.type;
                if (e === "Literal" || e === "MemberExpression" || e === "BinaryExpression") {
                    return true;
                }
                return false;
            });
            s("Pattern").bases("Node");
            s("SwitchCase").bases("Node").build("test", "consequent").field("test", a(s("Expression"), null)).field("consequent", [ s("Statement") ]);
            s("Identifier").bases("Node", "Expression", "Pattern").build("name").field("name", String).field("optional", Boolean, o["false"]);
            s("Literal").bases("Node", "Expression").build("value").field("value", a(String, Boolean, null, Number, RegExp)).field("regex", a({
                pattern: String,
                flags: String
            }, null), function() {
                if (this.value instanceof RegExp) {
                    var e = "";
                    if (this.value.ignoreCase) e += "i";
                    if (this.value.multiline) e += "m";
                    if (this.value.global) e += "g";
                    return {
                        pattern: this.value.source,
                        flags: e
                    };
                }
                return null;
            });
            s("Comment").bases("Printable").field("value", String).field("leading", Boolean, o["true"]).field("trailing", Boolean, o["false"]);
        };
    }, function(e, t, i) {
        "use strict";
        e.exports = function(e) {
            e.use(i(35));
            var t = e.use(i(2));
            var r = t.Type.def;
            var s = t.Type.or;
            var a = t.builtInTypes;
            var n = e.use(i(5)).defaults;
            r("Function").field("async", Boolean, n["false"]);
            r("SpreadProperty").bases("Node").build("argument").field("argument", r("Expression"));
            r("ObjectExpression").field("properties", [ s(r("Property"), r("SpreadProperty"), r("SpreadElement")) ]);
            r("SpreadPropertyPattern").bases("Pattern").build("argument").field("argument", r("Pattern"));
            r("ObjectPattern").field("properties", [ s(r("Property"), r("PropertyPattern"), r("SpreadPropertyPattern")) ]);
            r("AwaitExpression").bases("Expression").build("argument", "all").field("argument", s(r("Expression"), null)).field("all", Boolean, n["false"]);
        };
    }, function(e, t, i) {
        "use strict";
        var r = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(e) {
            return typeof e;
        } : function(e) {
            return e && typeof Symbol === "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
        };
        var s = i(7);
        var a = i(21);
        var n = i(20).normalize;
        var o = i(39).makeUniqueKey();
        var l = i(6);
        var u = l.builtInTypes.string;
        var c = i(8).comparePos;
        var h = i(79);
        var p = typeof Symbol === "function";
        var o = "recastLinesSecret";
        if (p) {
            o = Symbol.for(o);
        }
        function f(e) {
            return e[o];
        }
        function d(e, t) {
            s.ok(this instanceof d);
            s.ok(e.length > 0);
            if (t) {
                u.assert(t);
            } else {
                t = null;
            }
            m(this, o, {
                infos: e,
                mappings: [],
                name: t,
                cachedSourceMap: null
            });
            this.length = e.length;
            this.name = t;
            if (t) {
                f(this).mappings.push(new h(this, {
                    start: this.firstPos(),
                    end: this.lastPos()
                }));
            }
        }
        function m(e, t, i) {
            if (p) {
                return e[t] = i;
            }
            Object.defineProperty(e, t, {
                value: i,
                enumerable: false,
                writable: false,
                configurable: true
            });
            return i;
        }
        t.Lines = d;
        var y = d.prototype;
        function v(e) {
            return {
                line: e.line,
                indent: e.indent,
                locked: e.locked,
                sliceStart: e.sliceStart,
                sliceEnd: e.sliceEnd
            };
        }
        var x = {};
        var g = x.hasOwnProperty;
        var b = 10;
        function E(e, t) {
            var i = 0;
            var a = e.length;
            for (var n = 0; n < a; ++n) {
                switch (e.charCodeAt(n)) {
                  case 9:
                    s.strictEqual(typeof t === "undefined" ? "undefined" : r(t), "number");
                    s.ok(t > 0);
                    var o = Math.ceil(i / t) * t;
                    if (o === i) {
                        i += t;
                    } else {
                        i = o;
                    }
                    break;

                  case 11:
                  case 12:
                  case 13:
                  case 65279:
                    break;

                  case 32:
                  default:
                    i += 1;
                    break;
                }
            }
            return i;
        }
        t.countSpaces = E;
        var k = /^\s*/;
        var S = /\u000D\u000A|\u000D(?!\u000A)|\u000A|\u2028|\u2029/;
        function w(e, t) {
            if (e instanceof d) return e;
            e += "";
            var i = t && t.tabWidth;
            var r = e.indexOf("\t") < 0;
            var a = !!(t && t.locked);
            var o = !t && r && e.length <= b;
            s.ok(i || r, "No tab width specified but encountered tabs in string\n" + e);
            if (o && g.call(x, e)) return x[e];
            var l = new d(e.split(S).map(function(e) {
                var t = k.exec(e)[0];
                return {
                    line: e,
                    indent: E(t, i),
                    locked: a,
                    sliceStart: t.length,
                    sliceEnd: e.length
                };
            }), n(t).sourceFileName);
            if (o) x[e] = l;
            return l;
        }
        t.fromString = w;
        function A(e) {
            return !/\S/.test(e);
        }
        y.toString = function(e) {
            return this.sliceString(this.firstPos(), this.lastPos(), e);
        };
        y.getSourceMap = function(e, t) {
            if (!e) {
                return null;
            }
            var i = this;
            function r(i) {
                i = i || {};
                u.assert(e);
                i.file = e;
                if (t) {
                    u.assert(t);
                    i.sourceRoot = t;
                }
                return i;
            }
            var n = f(i);
            if (n.cachedSourceMap) {
                return r(n.cachedSourceMap.toJSON());
            }
            var o = new a.SourceMapGenerator(r());
            var l = {};
            n.mappings.forEach(function(e) {
                var t = e.sourceLines.skipSpaces(e.sourceLoc.start) || e.sourceLines.lastPos();
                var r = i.skipSpaces(e.targetLoc.start) || i.lastPos();
                while (c(t, e.sourceLoc.end) < 0 && c(r, e.targetLoc.end) < 0) {
                    var a = e.sourceLines.charAt(t);
                    var n = i.charAt(r);
                    s.strictEqual(a, n);
                    var u = e.sourceLines.name;
                    o.addMapping({
                        source: u,
                        original: {
                            line: t.line,
                            column: t.column
                        },
                        generated: {
                            line: r.line,
                            column: r.column
                        }
                    });
                    if (!g.call(l, u)) {
                        var h = e.sourceLines.toString();
                        o.setSourceContent(u, h);
                        l[u] = h;
                    }
                    i.nextPos(r, true);
                    e.sourceLines.nextPos(t, true);
                }
            });
            n.cachedSourceMap = o;
            return o.toJSON();
        };
        y.bootstrapCharAt = function(e) {
            s.strictEqual(typeof e === "undefined" ? "undefined" : r(e), "object");
            s.strictEqual(r(e.line), "number");
            s.strictEqual(r(e.column), "number");
            var t = e.line, i = e.column, a = this.toString().split(S), n = a[t - 1];
            if (typeof n === "undefined") return "";
            if (i === n.length && t < a.length) return "\n";
            if (i >= n.length) return "";
            return n.charAt(i);
        };
        y.charAt = function(e) {
            s.strictEqual(typeof e === "undefined" ? "undefined" : r(e), "object");
            s.strictEqual(r(e.line), "number");
            s.strictEqual(r(e.column), "number");
            var t = e.line, i = e.column, a = f(this), n = a.infos, o = n[t - 1], l = i;
            if (typeof o === "undefined" || l < 0) return "";
            var u = this.getIndentAt(t);
            if (l < u) return " ";
            l += o.sliceStart - u;
            if (l === o.sliceEnd && t < this.length) return "\n";
            if (l >= o.sliceEnd) return "";
            return o.line.charAt(l);
        };
        y.stripMargin = function(e, t) {
            if (e === 0) return this;
            s.ok(e > 0, "negative margin: " + e);
            if (t && this.length === 1) return this;
            var i = f(this);
            var r = new d(i.infos.map(function(i, r) {
                if (i.line && (r > 0 || !t)) {
                    i = v(i);
                    i.indent = Math.max(0, i.indent - e);
                }
                return i;
            }));
            if (i.mappings.length > 0) {
                var a = f(r).mappings;
                s.strictEqual(a.length, 0);
                i.mappings.forEach(function(i) {
                    a.push(i.indent(e, t, true));
                });
            }
            return r;
        };
        y.indent = function(e) {
            if (e === 0) return this;
            var t = f(this);
            var i = new d(t.infos.map(function(t) {
                if (t.line && !t.locked) {
                    t = v(t);
                    t.indent += e;
                }
                return t;
            }));
            if (t.mappings.length > 0) {
                var r = f(i).mappings;
                s.strictEqual(r.length, 0);
                t.mappings.forEach(function(t) {
                    r.push(t.indent(e));
                });
            }
            return i;
        };
        y.indentTail = function(e) {
            if (e === 0) return this;
            if (this.length < 2) return this;
            var t = f(this);
            var i = new d(t.infos.map(function(t, i) {
                if (i > 0 && t.line && !t.locked) {
                    t = v(t);
                    t.indent += e;
                }
                return t;
            }));
            if (t.mappings.length > 0) {
                var r = f(i).mappings;
                s.strictEqual(r.length, 0);
                t.mappings.forEach(function(t) {
                    r.push(t.indent(e, true));
                });
            }
            return i;
        };
        y.lockIndentTail = function() {
            if (this.length < 2) {
                return this;
            }
            var e = f(this).infos;
            return new d(e.map(function(e, t) {
                e = v(e);
                e.locked = t > 0;
                return e;
            }));
        };
        y.getIndentAt = function(e) {
            s.ok(e >= 1, "no line " + e + " (line numbers start from 1)");
            var t = f(this), i = t.infos[e - 1];
            return Math.max(i.indent, 0);
        };
        y.guessTabWidth = function() {
            var e = f(this);
            if (g.call(e, "cachedTabWidth")) {
                return e.cachedTabWidth;
            }
            var t = [];
            var i = 0;
            for (var r = 1, s = this.length; r <= s; ++r) {
                var a = e.infos[r - 1];
                var n = a.line.slice(a.sliceStart, a.sliceEnd);
                if (A(n)) {
                    continue;
                }
                var o = Math.abs(a.indent - i);
                t[o] = ~~t[o] + 1;
                i = a.indent;
            }
            var l = -1;
            var u = 2;
            for (var c = 1; c < t.length; c += 1) {
                if (g.call(t, c) && t[c] > l) {
                    l = t[c];
                    u = c;
                }
            }
            return e.cachedTabWidth = u;
        };
        y.startsWithComment = function() {
            var e = f(this);
            if (e.infos.length === 0) {
                return false;
            }
            var t = e.infos[0], i = t.sliceStart, r = t.sliceEnd, s = t.line.slice(i, r).trim();
            return s.length === 0 || s.slice(0, 2) === "//" || s.slice(0, 2) === "/*";
        };
        y.isOnlyWhitespace = function() {
            return A(this.toString());
        };
        y.isPrecededOnlyByWhitespace = function(e) {
            var t = f(this);
            var i = t.infos[e.line - 1];
            var r = Math.max(i.indent, 0);
            var s = e.column - r;
            if (s <= 0) {
                return true;
            }
            var a = i.sliceStart;
            var n = Math.min(a + s, i.sliceEnd);
            var o = i.line.slice(a, n);
            return A(o);
        };
        y.getLineLength = function(e) {
            var t = f(this), i = t.infos[e - 1];
            return this.getIndentAt(e) + i.sliceEnd - i.sliceStart;
        };
        y.nextPos = function(e, t) {
            var i = Math.max(e.line, 0), r = Math.max(e.column, 0);
            if (r < this.getLineLength(i)) {
                e.column += 1;
                return t ? !!this.skipSpaces(e, false, true) : true;
            }
            if (i < this.length) {
                e.line += 1;
                e.column = 0;
                return t ? !!this.skipSpaces(e, false, true) : true;
            }
            return false;
        };
        y.prevPos = function(e, t) {
            var i = e.line, r = e.column;
            if (r < 1) {
                i -= 1;
                if (i < 1) return false;
                r = this.getLineLength(i);
            } else {
                r = Math.min(r - 1, this.getLineLength(i));
            }
            e.line = i;
            e.column = r;
            return t ? !!this.skipSpaces(e, true, true) : true;
        };
        y.firstPos = function() {
            return {
                line: 1,
                column: 0
            };
        };
        y.lastPos = function() {
            return {
                line: this.length,
                column: this.getLineLength(this.length)
            };
        };
        y.skipSpaces = function(e, t, i) {
            if (e) {
                e = i ? e : {
                    line: e.line,
                    column: e.column
                };
            } else if (t) {
                e = this.lastPos();
            } else {
                e = this.firstPos();
            }
            if (t) {
                while (this.prevPos(e)) {
                    if (!A(this.charAt(e)) && this.nextPos(e)) {
                        return e;
                    }
                }
                return null;
            } else {
                while (A(this.charAt(e))) {
                    if (!this.nextPos(e)) {
                        return null;
                    }
                }
                return e;
            }
        };
        y.trimLeft = function() {
            var e = this.skipSpaces(this.firstPos(), false, true);
            return e ? this.slice(e) : T;
        };
        y.trimRight = function() {
            var e = this.skipSpaces(this.lastPos(), true, true);
            return e ? this.slice(this.firstPos(), e) : T;
        };
        y.trim = function() {
            var e = this.skipSpaces(this.firstPos(), false, true);
            if (e === null) return T;
            var t = this.skipSpaces(this.lastPos(), true, true);
            s.notStrictEqual(t, null);
            return this.slice(e, t);
        };
        y.eachPos = function(e, t, i) {
            var r = this.firstPos();
            if (t) {
                r.line = t.line, r.column = t.column;
            }
            if (i && !this.skipSpaces(r, false, true)) {
                return;
            }
            do {
                e.call(this, r);
            } while (this.nextPos(r, i));
        };
        y.bootstrapSlice = function(e, t) {
            var i = this.toString().split(S).slice(e.line - 1, t.line);
            i.push(i.pop().slice(0, t.column));
            i[0] = i[0].slice(e.column);
            return w(i.join("\n"));
        };
        y.slice = function(e, t) {
            if (!t) {
                if (!e) {
                    return this;
                }
                t = this.lastPos();
            }
            var i = f(this);
            var r = i.infos.slice(e.line - 1, t.line);
            if (e.line === t.line) {
                r[0] = C(r[0], e.column, t.column);
            } else {
                s.ok(e.line < t.line);
                r[0] = C(r[0], e.column);
                r.push(C(r.pop(), 0, t.column));
            }
            var a = new d(r);
            if (i.mappings.length > 0) {
                var n = f(a).mappings;
                s.strictEqual(n.length, 0);
                i.mappings.forEach(function(i) {
                    var r = i.slice(this, e, t);
                    if (r) {
                        n.push(r);
                    }
                }, this);
            }
            return a;
        };
        function C(e, t, i) {
            var r = e.sliceStart;
            var a = e.sliceEnd;
            var n = Math.max(e.indent, 0);
            var o = n + a - r;
            if (typeof i === "undefined") {
                i = o;
            }
            t = Math.max(t, 0);
            i = Math.min(i, o);
            i = Math.max(i, t);
            if (i < n) {
                n = i;
                a = r;
            } else {
                a -= o - i;
            }
            o = i;
            o -= t;
            if (t < n) {
                n -= t;
            } else {
                t -= n;
                n = 0;
                r += t;
            }
            s.ok(n >= 0);
            s.ok(r <= a);
            s.strictEqual(o, n + a - r);
            if (e.indent === n && e.sliceStart === r && e.sliceEnd === a) {
                return e;
            }
            return {
                line: e.line,
                indent: n,
                locked: false,
                sliceStart: r,
                sliceEnd: a
            };
        }
        y.bootstrapSliceString = function(e, t, i) {
            return this.slice(e, t).toString(i);
        };
        y.sliceString = function(e, t, i) {
            if (!t) {
                if (!e) {
                    return this;
                }
                t = this.lastPos();
            }
            i = n(i);
            var r = f(this).infos;
            var s = [];
            var a = i.tabWidth;
            for (var o = e.line; o <= t.line; ++o) {
                var l = r[o - 1];
                if (o === e.line) {
                    if (o === t.line) {
                        l = C(l, e.column, t.column);
                    } else {
                        l = C(l, e.column);
                    }
                } else if (o === t.line) {
                    l = C(l, 0, t.column);
                }
                var u = Math.max(l.indent, 0);
                var c = l.line.slice(0, l.sliceStart);
                if (i.reuseWhitespace && A(c) && E(c, i.tabWidth) === u) {
                    s.push(l.line.slice(0, l.sliceEnd));
                    continue;
                }
                var h = 0;
                var p = u;
                if (i.useTabs) {
                    h = Math.floor(u / a);
                    p -= h * a;
                }
                var d = "";
                if (h > 0) {
                    d += new Array(h + 1).join("\t");
                }
                if (p > 0) {
                    d += new Array(p + 1).join(" ");
                }
                d += l.line.slice(l.sliceStart, l.sliceEnd);
                s.push(d);
            }
            return s.join(i.lineTerminator);
        };
        y.isEmpty = function() {
            return this.length < 2 && this.getLineLength(1) < 1;
        };
        y.join = function(e) {
            var t = this;
            var i = f(t);
            var r = [];
            var s = [];
            var a;
            function n(e) {
                if (e === null) return;
                if (a) {
                    var t = e.infos[0];
                    var i = new Array(t.indent + 1).join(" ");
                    var n = r.length;
                    var o = Math.max(a.indent, 0) + a.sliceEnd - a.sliceStart;
                    a.line = a.line.slice(0, a.sliceEnd) + i + t.line.slice(t.sliceStart, t.sliceEnd);
                    a.locked = a.locked || t.locked;
                    a.sliceEnd = a.line.length;
                    if (e.mappings.length > 0) {
                        e.mappings.forEach(function(e) {
                            s.push(e.add(n, o));
                        });
                    }
                } else if (e.mappings.length > 0) {
                    s.push.apply(s, e.mappings);
                }
                e.infos.forEach(function(e, t) {
                    if (!a || t > 0) {
                        a = v(e);
                        r.push(a);
                    }
                });
            }
            function o(e, t) {
                if (t > 0) n(i);
                n(e);
            }
            e.map(function(e) {
                var t = w(e);
                if (t.isEmpty()) return null;
                return f(t);
            }).forEach(t.isEmpty() ? n : o);
            if (r.length < 1) return T;
            var l = new d(r);
            f(l).mappings = s;
            return l;
        };
        t.concat = function(e) {
            return T.join(e);
        };
        y.concat = function(e) {
            var t = arguments, i = [ this ];
            i.push.apply(i, t);
            s.strictEqual(i.length, t.length + 1);
            return T.join(i);
        };
        var T = w("");
    }, function(e, t) {
        "use strict";
        function i(e, t, i) {
            if (t in e) {
                return e[t];
            } else if (arguments.length === 3) {
                return i;
            } else {
                throw new Error('"' + t + '" is a required argument.');
            }
        }
        t.getArg = i;
        var r = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/;
        var s = /^data:.+\,.+$/;
        function a(e) {
            var t = e.match(r);
            if (!t) {
                return null;
            }
            return {
                scheme: t[1],
                auth: t[2],
                host: t[3],
                port: t[4],
                path: t[5]
            };
        }
        t.urlParse = a;
        function n(e) {
            var t = "";
            if (e.scheme) {
                t += e.scheme + ":";
            }
            t += "//";
            if (e.auth) {
                t += e.auth + "@";
            }
            if (e.host) {
                t += e.host;
            }
            if (e.port) {
                t += ":" + e.port;
            }
            if (e.path) {
                t += e.path;
            }
            return t;
        }
        t.urlGenerate = n;
        function o(e) {
            var i = e;
            var r = a(e);
            if (r) {
                if (!r.path) {
                    return e;
                }
                i = r.path;
            }
            var s = t.isAbsolute(i);
            var o = i.split(/\/+/);
            for (var l, u = 0, c = o.length - 1; c >= 0; c--) {
                l = o[c];
                if (l === ".") {
                    o.splice(c, 1);
                } else if (l === "..") {
                    u++;
                } else if (u > 0) {
                    if (l === "") {
                        o.splice(c + 1, u);
                        u = 0;
                    } else {
                        o.splice(c, 2);
                        u--;
                    }
                }
            }
            i = o.join("/");
            if (i === "") {
                i = s ? "/" : ".";
            }
            if (r) {
                r.path = i;
                return n(r);
            }
            return i;
        }
        t.normalize = o;
        function l(e, t) {
            if (e === "") {
                e = ".";
            }
            if (t === "") {
                t = ".";
            }
            var i = a(t);
            var r = a(e);
            if (r) {
                e = r.path || "/";
            }
            if (i && !i.scheme) {
                if (r) {
                    i.scheme = r.scheme;
                }
                return n(i);
            }
            if (i || t.match(s)) {
                return t;
            }
            if (r && !r.host && !r.path) {
                r.host = t;
                return n(r);
            }
            var l = t.charAt(0) === "/" ? t : o(e.replace(/\/+$/, "") + "/" + t);
            if (r) {
                r.path = l;
                return n(r);
            }
            return l;
        }
        t.join = l;
        t.isAbsolute = function(e) {
            return e.charAt(0) === "/" || r.test(e);
        };
        function u(e, t) {
            if (e === "") {
                e = ".";
            }
            e = e.replace(/\/$/, "");
            var i = 0;
            while (t.indexOf(e + "/") !== 0) {
                var r = e.lastIndexOf("/");
                if (r < 0) {
                    return t;
                }
                e = e.slice(0, r);
                if (e.match(/^([^\/]+:\/)?\/*$/)) {
                    return t;
                }
                ++i;
            }
            return Array(i + 1).join("../") + t.substr(e.length + 1);
        }
        t.relative = u;
        var c = function() {
            var e = Object.create(null);
            return !("__proto__" in e);
        }();
        function h(e) {
            return e;
        }
        function p(e) {
            if (d(e)) {
                return "$" + e;
            }
            return e;
        }
        t.toSetString = c ? h : p;
        function f(e) {
            if (d(e)) {
                return e.slice(1);
            }
            return e;
        }
        t.fromSetString = c ? h : f;
        function d(e) {
            if (!e) {
                return false;
            }
            var t = e.length;
            if (t < 9) {
                return false;
            }
            if (e.charCodeAt(t - 1) !== 95 || e.charCodeAt(t - 2) !== 95 || e.charCodeAt(t - 3) !== 111 || e.charCodeAt(t - 4) !== 116 || e.charCodeAt(t - 5) !== 111 || e.charCodeAt(t - 6) !== 114 || e.charCodeAt(t - 7) !== 112 || e.charCodeAt(t - 8) !== 95 || e.charCodeAt(t - 9) !== 95) {
                return false;
            }
            for (var i = t - 10; i >= 0; i--) {
                if (e.charCodeAt(i) !== 36) {
                    return false;
                }
            }
            return true;
        }
        function m(e, t, i) {
            var r = v(e.source, t.source);
            if (r !== 0) {
                return r;
            }
            r = e.originalLine - t.originalLine;
            if (r !== 0) {
                return r;
            }
            r = e.originalColumn - t.originalColumn;
            if (r !== 0 || i) {
                return r;
            }
            r = e.generatedColumn - t.generatedColumn;
            if (r !== 0) {
                return r;
            }
            r = e.generatedLine - t.generatedLine;
            if (r !== 0) {
                return r;
            }
            return v(e.name, t.name);
        }
        t.compareByOriginalPositions = m;
        function y(e, t, i) {
            var r = e.generatedLine - t.generatedLine;
            if (r !== 0) {
                return r;
            }
            r = e.generatedColumn - t.generatedColumn;
            if (r !== 0 || i) {
                return r;
            }
            r = v(e.source, t.source);
            if (r !== 0) {
                return r;
            }
            r = e.originalLine - t.originalLine;
            if (r !== 0) {
                return r;
            }
            r = e.originalColumn - t.originalColumn;
            if (r !== 0) {
                return r;
            }
            return v(e.name, t.name);
        }
        t.compareByGeneratedPositionsDeflated = y;
        function v(e, t) {
            if (e === t) {
                return 0;
            }
            if (e === null) {
                return 1;
            }
            if (t === null) {
                return -1;
            }
            if (e > t) {
                return 1;
            }
            return -1;
        }
        function x(e, t) {
            var i = e.generatedLine - t.generatedLine;
            if (i !== 0) {
                return i;
            }
            i = e.generatedColumn - t.generatedColumn;
            if (i !== 0) {
                return i;
            }
            i = v(e.source, t.source);
            if (i !== 0) {
                return i;
            }
            i = e.originalLine - t.originalLine;
            if (i !== 0) {
                return i;
            }
            i = e.originalColumn - t.originalColumn;
            if (i !== 0) {
                return i;
            }
            return v(e.name, t.name);
        }
        t.compareByGeneratedPositionsInflated = x;
        function g(e) {
            return JSON.parse(e.replace(/^\)]}'[^\n]*\n/, ""));
        }
        t.parseSourceMapInput = g;
        function b(e, t, i) {
            t = t || "";
            if (e) {
                if (e[e.length - 1] !== "/" && t[0] !== "/") {
                    e += "/";
                }
                t = e + t;
            }
            if (i) {
                var r = a(i);
                if (!r) {
                    throw new Error("sourceMapURL could not be parsed");
                }
                if (r.path) {
                    var s = r.path.lastIndexOf("/");
                    if (s >= 0) {
                        r.path = r.path.substring(0, s + 1);
                    }
                }
                t = l(n(r), t);
            }
            return o(t);
        }
        t.computeSourceURL = b;
    }, , , , , function(e, t, i) {
        "use strict";
        e.exports = function(e) {
            var t = e.use(i(2));
            var r = t.namedTypes;
            var s = t.builders;
            var a = t.builtInTypes.number;
            var n = t.builtInTypes.array;
            var o = e.use(i(37));
            var l = e.use(i(72));
            function u(e, t, i) {
                if (!(this instanceof u)) {
                    throw new Error("NodePath constructor cannot be invoked without 'new'");
                }
                o.call(this, e, t, i);
            }
            var c = u.prototype = Object.create(o.prototype, {
                constructor: {
                    value: u,
                    enumerable: false,
                    writable: true,
                    configurable: true
                }
            });
            Object.defineProperties(c, {
                node: {
                    get: function e() {
                        Object.defineProperty(this, "node", {
                            configurable: true,
                            value: this._computeNode()
                        });
                        return this.node;
                    }
                },
                parent: {
                    get: function e() {
                        Object.defineProperty(this, "parent", {
                            configurable: true,
                            value: this._computeParent()
                        });
                        return this.parent;
                    }
                },
                scope: {
                    get: function e() {
                        Object.defineProperty(this, "scope", {
                            configurable: true,
                            value: this._computeScope()
                        });
                        return this.scope;
                    }
                }
            });
            c.replace = function() {
                delete this.node;
                delete this.parent;
                delete this.scope;
                return o.prototype.replace.apply(this, arguments);
            };
            c.prune = function() {
                var e = this.parent;
                this.replace();
                return y(e);
            };
            c._computeNode = function() {
                var e = this.value;
                if (r.Node.check(e)) {
                    return e;
                }
                var t = this.parentPath;
                return t && t.node || null;
            };
            c._computeParent = function() {
                var e = this.value;
                var t = this.parentPath;
                if (!r.Node.check(e)) {
                    while (t && !r.Node.check(t.value)) {
                        t = t.parentPath;
                    }
                    if (t) {
                        t = t.parentPath;
                    }
                }
                while (t && !r.Node.check(t.value)) {
                    t = t.parentPath;
                }
                return t || null;
            };
            c._computeScope = function() {
                var e = this.value;
                var t = this.parentPath;
                var i = t && t.scope;
                if (r.Node.check(e) && l.isEstablishedBy(e)) {
                    i = new l(this, i);
                }
                return i || null;
            };
            c.getValueProperty = function(e) {
                return t.getFieldValue(this.value, e);
            };
            c.needsParens = function(e) {
                var t = this.parentPath;
                if (!t) {
                    return false;
                }
                var i = this.value;
                if (!r.Expression.check(i)) {
                    return false;
                }
                if (i.type === "Identifier") {
                    return false;
                }
                while (!r.Node.check(t.value)) {
                    t = t.parentPath;
                    if (!t) {
                        return false;
                    }
                }
                var s = t.value;
                switch (i.type) {
                  case "UnaryExpression":
                  case "SpreadElement":
                  case "SpreadProperty":
                    return s.type === "MemberExpression" && this.name === "object" && s.object === i;

                  case "BinaryExpression":
                  case "LogicalExpression":
                    switch (s.type) {
                      case "CallExpression":
                        return this.name === "callee" && s.callee === i;

                      case "UnaryExpression":
                      case "SpreadElement":
                      case "SpreadProperty":
                        return true;

                      case "MemberExpression":
                        return this.name === "object" && s.object === i;

                      case "BinaryExpression":
                      case "LogicalExpression":
                        var n = s.operator;
                        var t = f[n];
                        var o = i.operator;
                        var l = f[o];
                        if (t > l) {
                            return true;
                        }
                        if (t === l && this.name === "right") {
                            if (s.right !== i) {
                                throw new Error("Nodes must be equal");
                            }
                            return true;
                        }

                      default:
                        return false;
                    }

                  case "SequenceExpression":
                    switch (s.type) {
                      case "ForStatement":
                        return false;

                      case "ExpressionStatement":
                        return this.name !== "expression";

                      default:
                        return true;
                    }

                  case "YieldExpression":
                    switch (s.type) {
                      case "BinaryExpression":
                      case "LogicalExpression":
                      case "UnaryExpression":
                      case "SpreadElement":
                      case "SpreadProperty":
                      case "CallExpression":
                      case "MemberExpression":
                      case "NewExpression":
                      case "ConditionalExpression":
                      case "YieldExpression":
                        return true;

                      default:
                        return false;
                    }

                  case "Literal":
                    return s.type === "MemberExpression" && a.check(i.value) && this.name === "object" && s.object === i;

                  case "AssignmentExpression":
                  case "ConditionalExpression":
                    switch (s.type) {
                      case "UnaryExpression":
                      case "SpreadElement":
                      case "SpreadProperty":
                      case "BinaryExpression":
                      case "LogicalExpression":
                        return true;

                      case "CallExpression":
                        return this.name === "callee" && s.callee === i;

                      case "ConditionalExpression":
                        return this.name === "test" && s.test === i;

                      case "MemberExpression":
                        return this.name === "object" && s.object === i;

                      default:
                        return false;
                    }

                  default:
                    if (s.type === "NewExpression" && this.name === "callee" && s.callee === i) {
                        return d(i);
                    }
                }
                if (e !== true && !this.canBeFirstInStatement() && this.firstInStatement()) return true;
                return false;
            };
            function h(e) {
                return r.BinaryExpression.check(e) || r.LogicalExpression.check(e);
            }
            function p(e) {
                return r.UnaryExpression.check(e) || r.SpreadElement && r.SpreadElement.check(e) || r.SpreadProperty && r.SpreadProperty.check(e);
            }
            var f = {};
            [ [ "||" ], [ "&&" ], [ "|" ], [ "^" ], [ "&" ], [ "==", "===", "!=", "!==" ], [ "<", ">", "<=", ">=", "in", "instanceof" ], [ ">>", "<<", ">>>" ], [ "+", "-" ], [ "*", "/", "%" ] ].forEach(function(e, t) {
                e.forEach(function(e) {
                    f[e] = t;
                });
            });
            function d(e) {
                if (r.CallExpression.check(e)) {
                    return true;
                }
                if (n.check(e)) {
                    return e.some(d);
                }
                if (r.Node.check(e)) {
                    return t.someField(e, function(e, t) {
                        return d(t);
                    });
                }
                return false;
            }
            c.canBeFirstInStatement = function() {
                var e = this.node;
                return !r.FunctionExpression.check(e) && !r.ObjectExpression.check(e);
            };
            c.firstInStatement = function() {
                return m(this);
            };
            function m(e) {
                for (var t, i; e.parent; e = e.parent) {
                    t = e.node;
                    i = e.parent.node;
                    if (r.BlockStatement.check(i) && e.parent.name === "body" && e.name === 0) {
                        if (i.body[0] !== t) {
                            throw new Error("Nodes must be equal");
                        }
                        return true;
                    }
                    if (r.ExpressionStatement.check(i) && e.name === "expression") {
                        if (i.expression !== t) {
                            throw new Error("Nodes must be equal");
                        }
                        return true;
                    }
                    if (r.SequenceExpression.check(i) && e.parent.name === "expressions" && e.name === 0) {
                        if (i.expressions[0] !== t) {
                            throw new Error("Nodes must be equal");
                        }
                        continue;
                    }
                    if (r.CallExpression.check(i) && e.name === "callee") {
                        if (i.callee !== t) {
                            throw new Error("Nodes must be equal");
                        }
                        continue;
                    }
                    if (r.MemberExpression.check(i) && e.name === "object") {
                        if (i.object !== t) {
                            throw new Error("Nodes must be equal");
                        }
                        continue;
                    }
                    if (r.ConditionalExpression.check(i) && e.name === "test") {
                        if (i.test !== t) {
                            throw new Error("Nodes must be equal");
                        }
                        continue;
                    }
                    if (h(i) && e.name === "left") {
                        if (i.left !== t) {
                            throw new Error("Nodes must be equal");
                        }
                        continue;
                    }
                    if (r.UnaryExpression.check(i) && !i.prefix && e.name === "argument") {
                        if (i.argument !== t) {
                            throw new Error("Nodes must be equal");
                        }
                        continue;
                    }
                    return false;
                }
                return true;
            }
            function y(e) {
                if (r.VariableDeclaration.check(e.node)) {
                    var t = e.get("declarations").value;
                    if (!t || t.length === 0) {
                        return e.prune();
                    }
                } else if (r.ExpressionStatement.check(e.node)) {
                    if (!e.get("expression").value) {
                        return e.prune();
                    }
                } else if (r.IfStatement.check(e.node)) {
                    v(e);
                }
                return e;
            }
            function v(e) {
                var t = e.get("test").value;
                var i = e.get("alternate").value;
                var a = e.get("consequent").value;
                if (!a && !i) {
                    var n = s.expressionStatement(t);
                    e.replace(n);
                } else if (!a && i) {
                    var o = s.unaryExpression("!", t, true);
                    if (r.UnaryExpression.check(t) && t.operator === "!") {
                        o = t.argument;
                    }
                    e.get("test").replace(o);
                    e.get("consequent").replace(i);
                    e.get("alternate").replace();
                }
            }
            return u;
        };
    }, function(e, t, i) {
        "use strict";
        var r = {
            parser: i(89),
            tabWidth: 4,
            useTabs: false,
            reuseWhitespace: true,
            lineTerminator: i(78).EOL || "\n",
            wrapColumn: 74,
            sourceFileName: null,
            sourceMapName: null,
            sourceRoot: null,
            inputSourceMap: null,
            range: false,
            tolerant: true,
            quote: null,
            trailingComma: false,
            arrayBracketSpacing: false,
            objectCurlySpacing: true,
            arrowParensAlways: false,
            flowObjectCommas: true,
            tokens: true
        }, s = r.hasOwnProperty;
        t.normalize = function(e) {
            e = e || r;
            function t(t) {
                return s.call(e, t) ? e[t] : r[t];
            }
            return {
                tabWidth: +t("tabWidth"),
                useTabs: !!t("useTabs"),
                reuseWhitespace: !!t("reuseWhitespace"),
                lineTerminator: t("lineTerminator"),
                wrapColumn: Math.max(t("wrapColumn"), 0),
                sourceFileName: t("sourceFileName"),
                sourceMapName: t("sourceMapName"),
                sourceRoot: t("sourceRoot"),
                inputSourceMap: t("inputSourceMap"),
                parser: t("esprima") || t("parser"),
                range: t("range"),
                tolerant: t("tolerant"),
                quote: t("quote"),
                trailingComma: t("trailingComma"),
                arrayBracketSpacing: t("arrayBracketSpacing"),
                objectCurlySpacing: t("objectCurlySpacing"),
                arrowParensAlways: t("arrowParensAlways"),
                flowObjectCommas: t("flowObjectCommas"),
                tokens: !!t("tokens")
            };
        };
    }, function(e, t, i) {
        "use strict";
        t.SourceMapGenerator = i(45).SourceMapGenerator;
        t.SourceMapConsumer = i(87).SourceMapConsumer;
        t.SourceNode = i(88).SourceNode;
    }, , , , , , , , , , , , , function(e, t, i) {
        "use strict";
        e.exports = function(e) {
            e.use(i(12));
            var t = e.use(i(2));
            var r = e.use(i(5)).defaults;
            var s = t.Type.def;
            var a = t.Type.or;
            s("Noop").bases("Statement").build();
            s("DoExpression").bases("Expression").build("body").field("body", [ s("Statement") ]);
            s("Super").bases("Expression").build();
            s("BindExpression").bases("Expression").build("object", "callee").field("object", a(s("Expression"), null)).field("callee", s("Expression"));
            s("Decorator").bases("Node").build("expression").field("expression", s("Expression"));
            s("Property").field("decorators", a([ s("Decorator") ], null), r["null"]);
            s("MethodDefinition").field("decorators", a([ s("Decorator") ], null), r["null"]);
            s("MetaProperty").bases("Expression").build("meta", "property").field("meta", s("Identifier")).field("property", s("Identifier"));
            s("ParenthesizedExpression").bases("Expression").build("expression").field("expression", s("Expression"));
            s("ImportSpecifier").bases("ModuleSpecifier").build("imported", "local").field("imported", s("Identifier"));
            s("ImportDefaultSpecifier").bases("ModuleSpecifier").build("local");
            s("ImportNamespaceSpecifier").bases("ModuleSpecifier").build("local");
            s("ExportDefaultDeclaration").bases("Declaration").build("declaration").field("declaration", a(s("Declaration"), s("Expression")));
            s("ExportNamedDeclaration").bases("Declaration").build("declaration", "specifiers", "source").field("declaration", a(s("Declaration"), null)).field("specifiers", [ s("ExportSpecifier") ], r.emptyArray).field("source", a(s("Literal"), null), r["null"]);
            s("ExportSpecifier").bases("ModuleSpecifier").build("local", "exported").field("exported", s("Identifier"));
            s("ExportNamespaceSpecifier").bases("Specifier").build("exported").field("exported", s("Identifier"));
            s("ExportDefaultSpecifier").bases("Specifier").build("exported").field("exported", s("Identifier"));
            s("ExportAllDeclaration").bases("Declaration").build("exported", "source").field("exported", a(s("Identifier"), null)).field("source", s("Literal"));
            s("CommentBlock").bases("Comment").build("value", "leading", "trailing");
            s("CommentLine").bases("Comment").build("value", "leading", "trailing");
            s("Directive").bases("Node").build("value").field("value", s("DirectiveLiteral"));
            s("DirectiveLiteral").bases("Node", "Expression").build("value").field("value", String, r["use strict"]);
            s("BlockStatement").bases("Statement").build("body").field("body", [ s("Statement") ]).field("directives", [ s("Directive") ], r.emptyArray);
            s("Program").bases("Node").build("body").field("body", [ s("Statement") ]).field("directives", [ s("Directive") ], r.emptyArray);
            s("StringLiteral").bases("Literal").build("value").field("value", String);
            s("NumericLiteral").bases("Literal").build("value").field("value", Number).field("raw", a(String, null), r["null"]).field("extra", {
                rawValue: Number,
                raw: String
            }, function e() {
                return {
                    rawValue: this.value,
                    raw: this.value + ""
                };
            });
            s("BigIntLiteral").bases("Literal").build("value").field("value", a(String, Number)).field("extra", {
                rawValue: String,
                raw: String
            }, function e() {
                return {
                    rawValue: String(this.value),
                    raw: this.value + "n"
                };
            });
            s("NullLiteral").bases("Literal").build().field("value", null, r["null"]);
            s("BooleanLiteral").bases("Literal").build("value").field("value", Boolean);
            s("RegExpLiteral").bases("Literal").build("pattern", "flags").field("pattern", String).field("flags", String).field("value", RegExp, function() {
                return new RegExp(this.pattern, this.flags);
            });
            var n = a(s("Property"), s("ObjectMethod"), s("ObjectProperty"), s("SpreadProperty"), s("SpreadElement"));
            s("ObjectExpression").bases("Expression").build("properties").field("properties", [ n ]);
            s("ObjectMethod").bases("Node", "Function").build("kind", "key", "params", "body", "computed").field("kind", a("method", "get", "set")).field("key", a(s("Literal"), s("Identifier"), s("Expression"))).field("params", [ s("Pattern") ]).field("body", s("BlockStatement")).field("computed", Boolean, r["false"]).field("generator", Boolean, r["false"]).field("async", Boolean, r["false"]).field("accessibility", a(s("Literal"), null), r["null"]).field("decorators", a([ s("Decorator") ], null), r["null"]);
            s("ObjectProperty").bases("Node").build("key", "value").field("key", a(s("Literal"), s("Identifier"), s("Expression"))).field("value", a(s("Expression"), s("Pattern"))).field("accessibility", a(s("Literal"), null), r["null"]).field("computed", Boolean, r["false"]);
            var o = a(s("MethodDefinition"), s("VariableDeclarator"), s("ClassPropertyDefinition"), s("ClassProperty"), s("ClassMethod"));
            s("ClassBody").bases("Declaration").build("body").field("body", [ o ]);
            s("ClassMethod").bases("Declaration", "Function").build("kind", "key", "params", "body", "computed", "static").field("kind", a("get", "set", "method", "constructor")).field("key", a(s("Literal"), s("Identifier"), s("Expression"))).field("params", [ s("Pattern") ]).field("body", s("BlockStatement")).field("computed", Boolean, r["false"]).field("static", Boolean, r["false"]).field("generator", Boolean, r["false"]).field("async", Boolean, r["false"]).field("decorators", a([ s("Decorator") ], null), r["null"]);
            var l = a(s("Property"), s("PropertyPattern"), s("SpreadPropertyPattern"), s("SpreadProperty"), s("ObjectProperty"), s("RestProperty"));
            s("ObjectPattern").bases("Pattern").build("properties").field("properties", [ l ]).field("decorators", a([ s("Decorator") ], null), r["null"]);
            s("SpreadProperty").bases("Node").build("argument").field("argument", s("Expression"));
            s("RestProperty").bases("Node").build("argument").field("argument", s("Expression"));
            s("ForAwaitStatement").bases("Statement").build("left", "right", "body").field("left", a(s("VariableDeclaration"), s("Expression"))).field("right", s("Expression")).field("body", s("Statement"));
            s("Import").bases("Expression").build();
        };
    }, function(e, t, i) {
        "use strict";
        e.exports = function(e) {
            e.use(i(11));
            var t = e.use(i(2));
            var r = t.Type.def;
            var s = t.Type.or;
            var a = e.use(i(5)).defaults;
            r("Function").field("generator", Boolean, a["false"]).field("expression", Boolean, a["false"]).field("defaults", [ s(r("Expression"), null) ], a.emptyArray).field("rest", s(r("Identifier"), null), a["null"]);
            r("RestElement").bases("Pattern").build("argument").field("argument", r("Pattern")).field("typeAnnotation", s(r("TypeAnnotation"), r("TSTypeAnnotation"), null), a["null"]);
            r("SpreadElementPattern").bases("Pattern").build("argument").field("argument", r("Pattern"));
            r("FunctionDeclaration").build("id", "params", "body", "generator", "expression");
            r("FunctionExpression").build("id", "params", "body", "generator", "expression");
            r("ArrowFunctionExpression").bases("Function", "Expression").build("params", "body", "expression").field("id", null, a["null"]).field("body", s(r("BlockStatement"), r("Expression"))).field("generator", false, a["false"]);
            r("ForOfStatement").bases("Statement").build("left", "right", "body").field("left", s(r("VariableDeclaration"), r("Pattern"))).field("right", r("Expression")).field("body", r("Statement"));
            r("YieldExpression").bases("Expression").build("argument", "delegate").field("argument", s(r("Expression"), null)).field("delegate", Boolean, a["false"]);
            r("GeneratorExpression").bases("Expression").build("body", "blocks", "filter").field("body", r("Expression")).field("blocks", [ r("ComprehensionBlock") ]).field("filter", s(r("Expression"), null));
            r("ComprehensionExpression").bases("Expression").build("body", "blocks", "filter").field("body", r("Expression")).field("blocks", [ r("ComprehensionBlock") ]).field("filter", s(r("Expression"), null));
            r("ComprehensionBlock").bases("Node").build("left", "right", "each").field("left", r("Pattern")).field("right", r("Expression")).field("each", Boolean);
            r("Property").field("key", s(r("Literal"), r("Identifier"), r("Expression"))).field("value", s(r("Expression"), r("Pattern"))).field("method", Boolean, a["false"]).field("shorthand", Boolean, a["false"]).field("computed", Boolean, a["false"]);
            r("PropertyPattern").bases("Pattern").build("key", "pattern").field("key", s(r("Literal"), r("Identifier"), r("Expression"))).field("pattern", r("Pattern")).field("computed", Boolean, a["false"]);
            r("ObjectPattern").bases("Pattern").build("properties").field("properties", [ s(r("PropertyPattern"), r("Property")) ]);
            r("ArrayPattern").bases("Pattern").build("elements").field("elements", [ s(r("Pattern"), null) ]);
            r("MethodDefinition").bases("Declaration").build("kind", "key", "value", "static").field("kind", s("constructor", "method", "get", "set")).field("key", r("Expression")).field("value", r("Function")).field("computed", Boolean, a["false"]).field("static", Boolean, a["false"]);
            r("SpreadElement").bases("Node").build("argument").field("argument", r("Expression"));
            r("ArrayExpression").field("elements", [ s(r("Expression"), r("SpreadElement"), r("RestElement"), null) ]);
            r("NewExpression").field("arguments", [ s(r("Expression"), r("SpreadElement")) ]);
            r("CallExpression").field("arguments", [ s(r("Expression"), r("SpreadElement")) ]);
            r("AssignmentPattern").bases("Pattern").build("left", "right").field("left", r("Pattern")).field("right", r("Expression"));
            var n = s(r("MethodDefinition"), r("VariableDeclarator"), r("ClassPropertyDefinition"), r("ClassProperty"));
            r("ClassProperty").bases("Declaration").build("key").field("key", s(r("Literal"), r("Identifier"), r("Expression"))).field("computed", Boolean, a["false"]);
            r("ClassPropertyDefinition").bases("Declaration").build("definition").field("definition", n);
            r("ClassBody").bases("Declaration").build("body").field("body", [ n ]);
            r("ClassDeclaration").bases("Declaration").build("id", "body", "superClass").field("id", s(r("Identifier"), null)).field("body", r("ClassBody")).field("superClass", s(r("Expression"), null), a["null"]);
            r("ClassExpression").bases("Expression").build("id", "body", "superClass").field("id", s(r("Identifier"), null), a["null"]).field("body", r("ClassBody")).field("superClass", s(r("Expression"), null), a["null"]);
            r("Specifier").bases("Node");
            r("ModuleSpecifier").bases("Specifier").field("local", s(r("Identifier"), null), a["null"]).field("id", s(r("Identifier"), null), a["null"]).field("name", s(r("Identifier"), null), a["null"]);
            r("ImportSpecifier").bases("ModuleSpecifier").build("id", "name");
            r("ImportNamespaceSpecifier").bases("ModuleSpecifier").build("id");
            r("ImportDefaultSpecifier").bases("ModuleSpecifier").build("id");
            r("ImportDeclaration").bases("Declaration").build("specifiers", "source", "importKind").field("specifiers", [ s(r("ImportSpecifier"), r("ImportNamespaceSpecifier"), r("ImportDefaultSpecifier")) ], a.emptyArray).field("source", r("Literal")).field("importKind", s("value", "type"), function() {
                return "value";
            });
            r("TaggedTemplateExpression").bases("Expression").build("tag", "quasi").field("tag", r("Expression")).field("quasi", r("TemplateLiteral"));
            r("TemplateLiteral").bases("Expression").build("quasis", "expressions").field("quasis", [ r("TemplateElement") ]).field("expressions", [ r("Expression") ]);
            r("TemplateElement").bases("Node").build("value", "tail").field("value", {
                cooked: String,
                raw: String
            }).field("tail", Boolean);
        };
    }, function(e, t, i) {
        "use strict";
        e.exports = function(e) {
            e.use(i(12));
            var t = e.use(i(2));
            var r = t.Type.def;
            var s = t.Type.or;
            var a = e.use(i(5)).defaults;
            r("Flow").bases("Node");
            r("FlowType").bases("Flow");
            r("AnyTypeAnnotation").bases("FlowType").build();
            r("EmptyTypeAnnotation").bases("FlowType").build();
            r("MixedTypeAnnotation").bases("FlowType").build();
            r("VoidTypeAnnotation").bases("FlowType").build();
            r("NumberTypeAnnotation").bases("FlowType").build();
            r("NumberLiteralTypeAnnotation").bases("FlowType").build("value", "raw").field("value", Number).field("raw", String);
            r("NumericLiteralTypeAnnotation").bases("FlowType").build("value", "raw").field("value", Number).field("raw", String);
            r("StringTypeAnnotation").bases("FlowType").build();
            r("StringLiteralTypeAnnotation").bases("FlowType").build("value", "raw").field("value", String).field("raw", String);
            r("BooleanTypeAnnotation").bases("FlowType").build();
            r("BooleanLiteralTypeAnnotation").bases("FlowType").build("value", "raw").field("value", Boolean).field("raw", String);
            r("TypeAnnotation").bases("Node").build("typeAnnotation").field("typeAnnotation", r("FlowType"));
            r("NullableTypeAnnotation").bases("FlowType").build("typeAnnotation").field("typeAnnotation", r("FlowType"));
            r("NullLiteralTypeAnnotation").bases("FlowType").build();
            r("NullTypeAnnotation").bases("FlowType").build();
            r("ThisTypeAnnotation").bases("FlowType").build();
            r("ExistsTypeAnnotation").bases("FlowType").build();
            r("ExistentialTypeParam").bases("FlowType").build();
            r("FunctionTypeAnnotation").bases("FlowType").build("params", "returnType", "rest", "typeParameters").field("params", [ r("FunctionTypeParam") ]).field("returnType", r("FlowType")).field("rest", s(r("FunctionTypeParam"), null)).field("typeParameters", s(r("TypeParameterDeclaration"), null));
            r("FunctionTypeParam").bases("Node").build("name", "typeAnnotation", "optional").field("name", r("Identifier")).field("typeAnnotation", r("FlowType")).field("optional", Boolean);
            r("ArrayTypeAnnotation").bases("FlowType").build("elementType").field("elementType", r("FlowType"));
            r("ObjectTypeAnnotation").bases("FlowType").build("properties", "indexers", "callProperties").field("properties", [ s(r("ObjectTypeProperty"), r("ObjectTypeSpreadProperty")) ]).field("indexers", [ r("ObjectTypeIndexer") ], a.emptyArray).field("callProperties", [ r("ObjectTypeCallProperty") ], a.emptyArray).field("exact", Boolean, a["false"]);
            r("Variance").bases("Node").build("kind").field("kind", s("plus", "minus"));
            var n = s(r("Variance"), "plus", "minus", null);
            r("ObjectTypeProperty").bases("Node").build("key", "value", "optional").field("key", s(r("Literal"), r("Identifier"))).field("value", r("FlowType")).field("optional", Boolean).field("variance", n, a["null"]);
            r("ObjectTypeIndexer").bases("Node").build("id", "key", "value").field("id", r("Identifier")).field("key", r("FlowType")).field("value", r("FlowType")).field("variance", n, a["null"]);
            r("ObjectTypeCallProperty").bases("Node").build("value").field("value", r("FunctionTypeAnnotation")).field("static", Boolean, a["false"]);
            r("QualifiedTypeIdentifier").bases("Node").build("qualification", "id").field("qualification", s(r("Identifier"), r("QualifiedTypeIdentifier"))).field("id", r("Identifier"));
            r("GenericTypeAnnotation").bases("FlowType").build("id", "typeParameters").field("id", s(r("Identifier"), r("QualifiedTypeIdentifier"))).field("typeParameters", s(r("TypeParameterInstantiation"), null));
            r("MemberTypeAnnotation").bases("FlowType").build("object", "property").field("object", r("Identifier")).field("property", s(r("MemberTypeAnnotation"), r("GenericTypeAnnotation")));
            r("UnionTypeAnnotation").bases("FlowType").build("types").field("types", [ r("FlowType") ]);
            r("IntersectionTypeAnnotation").bases("FlowType").build("types").field("types", [ r("FlowType") ]);
            r("TypeofTypeAnnotation").bases("FlowType").build("argument").field("argument", r("FlowType"));
            r("ObjectTypeSpreadProperty").bases("Node").build("argument").field("argument", r("FlowType"));
            r("Identifier").field("typeAnnotation", s(r("TypeAnnotation"), null), a["null"]);
            r("ObjectPattern").field("typeAnnotation", s(r("TypeAnnotation"), null), a["null"]);
            r("TypeParameterDeclaration").bases("Node").build("params").field("params", [ r("TypeParameter") ]);
            r("TypeParameterInstantiation").bases("Node").build("params").field("params", [ r("FlowType") ]);
            r("TypeParameter").bases("FlowType").build("name", "variance", "bound").field("name", String).field("variance", n, a["null"]).field("bound", s(r("TypeAnnotation"), null), a["null"]);
            r("Function").field("returnType", s(r("TypeAnnotation"), null), a["null"]).field("typeParameters", s(r("TypeParameterDeclaration"), null), a["null"]);
            r("ClassProperty").build("key", "value", "typeAnnotation", "static").field("value", s(r("Expression"), null)).field("typeAnnotation", s(r("TypeAnnotation"), null)).field("static", Boolean, a["false"]).field("variance", n, a["null"]);
            [ "ClassDeclaration", "ClassExpression" ].forEach(function(e) {
                r(e).field("typeParameters", s(r("TypeParameterDeclaration"), null), a["null"]).field("superTypeParameters", s([ r("GenericTypeAnnotation") ], null), a["null"]);
            });
            r("ClassImplements").bases("Node").build("id").field("id", r("Identifier")).field("superClass", s(r("Expression"), null), a["null"]).field("typeParameters", s(r("TypeParameterInstantiation"), null), a["null"]);
            [ "ClassDeclaration", "ClassExpression" ].forEach(function(e) {
                r(e).field("implements", [ r("ClassImplements") ], a.emptyArray);
            });
            r("InterfaceDeclaration").bases("Declaration").build("id", "body", "extends").field("id", r("Identifier")).field("typeParameters", s(r("TypeParameterDeclaration"), null), a["null"]).field("body", r("ObjectTypeAnnotation")).field("extends", [ r("InterfaceExtends") ]);
            r("DeclareInterface").bases("InterfaceDeclaration").build("id", "body", "extends");
            r("InterfaceExtends").bases("Node").build("id").field("id", r("Identifier")).field("typeParameters", s(r("TypeParameterInstantiation"), null));
            r("TypeAlias").bases("Declaration").build("id", "typeParameters", "right").field("id", r("Identifier")).field("typeParameters", s(r("TypeParameterDeclaration"), null)).field("right", r("FlowType"));
            r("OpaqueType").bases("Declaration").build("id", "typeParameters", "impltype", "supertype").field("id", r("Identifier")).field("typeParameters", s(r("TypeParameterDeclaration"), null)).field("implType", r("FlowType")).field("superType", r("FlowType"));
            r("DeclareTypeAlias").bases("TypeAlias").build("id", "typeParameters", "right");
            r("DeclareOpaqueType").bases("TypeAlias").build("id", "typeParameters", "supertype");
            r("TypeCastExpression").bases("Expression").build("expression", "typeAnnotation").field("expression", r("Expression")).field("typeAnnotation", r("TypeAnnotation"));
            r("TupleTypeAnnotation").bases("FlowType").build("types").field("types", [ r("FlowType") ]);
            r("DeclareVariable").bases("Statement").build("id").field("id", r("Identifier"));
            r("DeclareFunction").bases("Statement").build("id").field("id", r("Identifier"));
            r("DeclareClass").bases("InterfaceDeclaration").build("id");
            r("DeclareModule").bases("Statement").build("id", "body").field("id", s(r("Identifier"), r("Literal"))).field("body", r("BlockStatement"));
            r("DeclareModuleExports").bases("Statement").build("typeAnnotation").field("typeAnnotation", r("TypeAnnotation"));
            r("DeclareExportDeclaration").bases("Declaration").build("default", "declaration", "specifiers", "source").field("default", Boolean).field("declaration", s(r("DeclareVariable"), r("DeclareFunction"), r("DeclareClass"), r("FlowType"), null)).field("specifiers", [ s(r("ExportSpecifier"), r("ExportBatchSpecifier")) ], a.emptyArray).field("source", s(r("Literal"), null), a["null"]);
            r("DeclareExportAllDeclaration").bases("Declaration").build("source").field("source", s(r("Literal"), null), a["null"]);
            r("FlowPredicate").bases("Flow");
            r("InferredPredicate").bases("FlowPredicate").build();
            r("DeclaredPredicate").bases("FlowPredicate").build("value").field("value", r("Expression"));
        };
    }, function(e, t, i) {
        "use strict";
        var r = Array.prototype;
        var s = r.slice;
        var a = r.map;
        var n = Object.prototype;
        var o = n.hasOwnProperty;
        e.exports = function(e) {
            var t = e.use(i(2));
            var r = t.builtInTypes.array;
            var s = t.builtInTypes.number;
            function a(e, t, i) {
                if (!(this instanceof a)) {
                    throw new Error("Path constructor cannot be invoked without 'new'");
                }
                if (t) {
                    if (!(t instanceof a)) {
                        throw new Error("");
                    }
                } else {
                    t = null;
                    i = null;
                }
                this.value = e;
                this.parentPath = t;
                this.name = i;
                this.__childCache = null;
            }
            var n = a.prototype;
            function l(e) {
                return e.__childCache || (e.__childCache = Object.create(null));
            }
            function u(e, t) {
                var i = l(e);
                var r = e.getValueProperty(t);
                var s = i[t];
                if (!o.call(i, t) || s.value !== r) {
                    s = i[t] = new e.constructor(r, e, t);
                }
                return s;
            }
            n.getValueProperty = function e(t) {
                return this.value[t];
            };
            n.get = function e(t) {
                var i = this;
                var r = arguments;
                var s = r.length;
                for (var a = 0; a < s; ++a) {
                    i = u(i, r[a]);
                }
                return i;
            };
            n.each = function e(t, i) {
                var r = [];
                var s = this.value.length;
                var a = 0;
                for (var a = 0; a < s; ++a) {
                    if (o.call(this.value, a)) {
                        r[a] = this.get(a);
                    }
                }
                i = i || this;
                for (a = 0; a < s; ++a) {
                    if (o.call(r, a)) {
                        t.call(i, r[a]);
                    }
                }
            };
            n.map = function e(t, i) {
                var r = [];
                this.each(function(e) {
                    r.push(t.call(this, e));
                }, i);
                return r;
            };
            n.filter = function e(t, i) {
                var r = [];
                this.each(function(e) {
                    if (t.call(this, e)) {
                        r.push(e);
                    }
                }, i);
                return r;
            };
            function c() {}
            function h(e, t, i, a) {
                r.assert(e.value);
                if (t === 0) {
                    return c;
                }
                var n = e.value.length;
                if (n < 1) {
                    return c;
                }
                var u = arguments.length;
                if (u === 2) {
                    i = 0;
                    a = n;
                } else if (u === 3) {
                    i = Math.max(i, 0);
                    a = n;
                } else {
                    i = Math.max(i, 0);
                    a = Math.min(a, n);
                }
                s.assert(i);
                s.assert(a);
                var h = Object.create(null);
                var p = l(e);
                for (var f = i; f < a; ++f) {
                    if (o.call(e.value, f)) {
                        var d = e.get(f);
                        if (d.name !== f) {
                            throw new Error("");
                        }
                        var m = f + t;
                        d.name = m;
                        h[m] = d;
                        delete p[f];
                    }
                }
                delete p.length;
                return function() {
                    for (var t in h) {
                        var i = h[t];
                        if (i.name !== +t) {
                            throw new Error("");
                        }
                        p[t] = i;
                        e.value[t] = i.value;
                    }
                };
            }
            n.shift = function e() {
                var t = h(this, -1);
                var i = this.value.shift();
                t();
                return i;
            };
            n.unshift = function e(t) {
                var i = h(this, arguments.length);
                var r = this.value.unshift.apply(this.value, arguments);
                i();
                return r;
            };
            n.push = function e(t) {
                r.assert(this.value);
                delete l(this).length;
                return this.value.push.apply(this.value, arguments);
            };
            n.pop = function e() {
                r.assert(this.value);
                var t = l(this);
                delete t[this.value.length - 1];
                delete t.length;
                return this.value.pop();
            };
            n.insertAt = function e(t, i) {
                var r = arguments.length;
                var s = h(this, r - 1, t);
                if (s === c) {
                    return this;
                }
                t = Math.max(t, 0);
                for (var a = 1; a < r; ++a) {
                    this.value[t + a - 1] = arguments[a];
                }
                s();
                return this;
            };
            n.insertBefore = function e(t) {
                var i = this.parentPath;
                var r = arguments.length;
                var s = [ this.name ];
                for (var a = 0; a < r; ++a) {
                    s.push(arguments[a]);
                }
                return i.insertAt.apply(i, s);
            };
            n.insertAfter = function e(t) {
                var i = this.parentPath;
                var r = arguments.length;
                var s = [ this.name + 1 ];
                for (var a = 0; a < r; ++a) {
                    s.push(arguments[a]);
                }
                return i.insertAt.apply(i, s);
            };
            function p(e) {
                if (!(e instanceof a)) {
                    throw new Error("");
                }
                var t = e.parentPath;
                if (!t) {
                    return e;
                }
                var i = t.value;
                var s = l(t);
                if (i[e.name] === e.value) {
                    s[e.name] = e;
                } else if (r.check(i)) {
                    var n = i.indexOf(e.value);
                    if (n >= 0) {
                        s[e.name = n] = e;
                    }
                } else {
                    i[e.name] = e.value;
                    s[e.name] = e;
                }
                if (i[e.name] !== e.value) {
                    throw new Error("");
                }
                if (e.parentPath.get(e.name) !== e) {
                    throw new Error("");
                }
                return e;
            }
            n.replace = function e(t) {
                var i = [];
                var s = this.parentPath.value;
                var a = l(this.parentPath);
                var n = arguments.length;
                p(this);
                if (r.check(s)) {
                    var o = s.length;
                    var u = h(this.parentPath, n - 1, this.name + 1);
                    var c = [ this.name, 1 ];
                    for (var f = 0; f < n; ++f) {
                        c.push(arguments[f]);
                    }
                    var d = s.splice.apply(s, c);
                    if (d[0] !== this.value) {
                        throw new Error("");
                    }
                    if (s.length !== o - 1 + n) {
                        throw new Error("");
                    }
                    u();
                    if (n === 0) {
                        delete this.value;
                        delete a[this.name];
                        this.__childCache = null;
                    } else {
                        if (s[this.name] !== t) {
                            throw new Error("");
                        }
                        if (this.value !== t) {
                            this.value = t;
                            this.__childCache = null;
                        }
                        for (f = 0; f < n; ++f) {
                            i.push(this.parentPath.get(this.name + f));
                        }
                        if (i[0] !== this) {
                            throw new Error("");
                        }
                    }
                } else if (n === 1) {
                    if (this.value !== t) {
                        this.__childCache = null;
                    }
                    this.value = s[this.name] = t;
                    i.push(this);
                } else if (n === 0) {
                    delete s[this.name];
                    delete this.value;
                    this.__childCache = null;
                } else {
                    throw new Error("Could not replace path");
                }
                return i;
            };
            return a;
        };
    }, function(e, t, i) {
        var r, s, a;
        (function(e) {
            "use strict";
            var i = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(e) {
                return typeof e;
            } : function(e) {
                return e && typeof Symbol === "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
            };
            (function n(o, l) {
                if ((false ? "undefined" : i(t)) === "object" && (false ? "undefined" : i(e)) === "object") e.exports = l(); else if (true) !(s = [], 
                r = l, a = typeof r === "function" ? r.apply(t, s) : r, a !== undefined && (e.exports = a)); else if ((typeof t === "undefined" ? "undefined" : i(t)) === "object") t["esprima"] = l(); else o["esprima"] = l();
            })(undefined, function() {
                return function(e) {
                    var t = {};
                    function i(r) {
                        if (t[r]) return t[r].exports;
                        var s = t[r] = {
                            exports: {},
                            id: r,
                            loaded: false
                        };
                        e[r].call(s.exports, s, s.exports, i);
                        s.loaded = true;
                        return s.exports;
                    }
                    i.m = e;
                    i.c = t;
                    i.p = "";
                    return i(0);
                }([ function(e, t, i) {
                    "use strict";
                    Object.defineProperty(t, "__esModule", {
                        value: true
                    });
                    var r = i(1);
                    var s = i(3);
                    var a = i(8);
                    var n = i(15);
                    function o(e, t, i) {
                        var n = null;
                        var o = function e(t, r) {
                            if (i) {
                                i(t, r);
                            }
                            if (n) {
                                n.visit(t, r);
                            }
                        };
                        var l = typeof i === "function" ? o : null;
                        var u = false;
                        if (t) {
                            u = typeof t.comment === "boolean" && t.comment;
                            var c = typeof t.attachComment === "boolean" && t.attachComment;
                            if (u || c) {
                                n = new r.CommentHandler();
                                n.attach = c;
                                t.comment = true;
                                l = o;
                            }
                        }
                        var h = false;
                        if (t && typeof t.sourceType === "string") {
                            h = t.sourceType === "module";
                        }
                        var p;
                        if (t && typeof t.jsx === "boolean" && t.jsx) {
                            p = new s.JSXParser(e, t, l);
                        } else {
                            p = new a.Parser(e, t, l);
                        }
                        var f = h ? p.parseModule() : p.parseScript();
                        var d = f;
                        if (u && n) {
                            d.comments = n.comments;
                        }
                        if (p.config.tokens) {
                            d.tokens = p.tokens;
                        }
                        if (p.config.tolerant) {
                            d.errors = p.errorHandler.errors;
                        }
                        return d;
                    }
                    t.parse = o;
                    function l(e, t, i) {
                        var r = t || {};
                        r.sourceType = "module";
                        return o(e, r, i);
                    }
                    t.parseModule = l;
                    function u(e, t, i) {
                        var r = t || {};
                        r.sourceType = "script";
                        return o(e, r, i);
                    }
                    t.parseScript = u;
                    function c(e, t, i) {
                        var r = new n.Tokenizer(e, t);
                        var s;
                        s = [];
                        try {
                            while (true) {
                                var a = r.getNextToken();
                                if (!a) {
                                    break;
                                }
                                if (i) {
                                    a = i(a);
                                }
                                s.push(a);
                            }
                        } catch (e) {
                            r.errorHandler.tolerate(e);
                        }
                        if (r.errorHandler.tolerant) {
                            s.errors = r.errors();
                        }
                        return s;
                    }
                    t.tokenize = c;
                    var h = i(2);
                    t.Syntax = h.Syntax;
                    t.version = "4.0.1";
                }, function(e, t, i) {
                    "use strict";
                    Object.defineProperty(t, "__esModule", {
                        value: true
                    });
                    var r = i(2);
                    var s = function() {
                        function e() {
                            this.attach = false;
                            this.comments = [];
                            this.stack = [];
                            this.leading = [];
                            this.trailing = [];
                        }
                        e.prototype.insertInnerComments = function(e, t) {
                            if (e.type === r.Syntax.BlockStatement && e.body.length === 0) {
                                var i = [];
                                for (var s = this.leading.length - 1; s >= 0; --s) {
                                    var a = this.leading[s];
                                    if (t.end.offset >= a.start) {
                                        i.unshift(a.comment);
                                        this.leading.splice(s, 1);
                                        this.trailing.splice(s, 1);
                                    }
                                }
                                if (i.length) {
                                    e.innerComments = i;
                                }
                            }
                        };
                        e.prototype.findTrailingComments = function(e) {
                            var t = [];
                            if (this.trailing.length > 0) {
                                for (var i = this.trailing.length - 1; i >= 0; --i) {
                                    var r = this.trailing[i];
                                    if (r.start >= e.end.offset) {
                                        t.unshift(r.comment);
                                    }
                                }
                                this.trailing.length = 0;
                                return t;
                            }
                            var s = this.stack[this.stack.length - 1];
                            if (s && s.node.trailingComments) {
                                var a = s.node.trailingComments[0];
                                if (a && a.range[0] >= e.end.offset) {
                                    t = s.node.trailingComments;
                                    delete s.node.trailingComments;
                                }
                            }
                            return t;
                        };
                        e.prototype.findLeadingComments = function(e) {
                            var t = [];
                            var i;
                            while (this.stack.length > 0) {
                                var r = this.stack[this.stack.length - 1];
                                if (r && r.start >= e.start.offset) {
                                    i = r.node;
                                    this.stack.pop();
                                } else {
                                    break;
                                }
                            }
                            if (i) {
                                var s = i.leadingComments ? i.leadingComments.length : 0;
                                for (var a = s - 1; a >= 0; --a) {
                                    var n = i.leadingComments[a];
                                    if (n.range[1] <= e.start.offset) {
                                        t.unshift(n);
                                        i.leadingComments.splice(a, 1);
                                    }
                                }
                                if (i.leadingComments && i.leadingComments.length === 0) {
                                    delete i.leadingComments;
                                }
                                return t;
                            }
                            for (var a = this.leading.length - 1; a >= 0; --a) {
                                var r = this.leading[a];
                                if (r.start <= e.start.offset) {
                                    t.unshift(r.comment);
                                    this.leading.splice(a, 1);
                                }
                            }
                            return t;
                        };
                        e.prototype.visitNode = function(e, t) {
                            if (e.type === r.Syntax.Program && e.body.length > 0) {
                                return;
                            }
                            this.insertInnerComments(e, t);
                            var i = this.findTrailingComments(t);
                            var s = this.findLeadingComments(t);
                            if (s.length > 0) {
                                e.leadingComments = s;
                            }
                            if (i.length > 0) {
                                e.trailingComments = i;
                            }
                            this.stack.push({
                                node: e,
                                start: t.start.offset
                            });
                        };
                        e.prototype.visitComment = function(e, t) {
                            var i = e.type[0] === "L" ? "Line" : "Block";
                            var r = {
                                type: i,
                                value: e.value
                            };
                            if (e.range) {
                                r.range = e.range;
                            }
                            if (e.loc) {
                                r.loc = e.loc;
                            }
                            this.comments.push(r);
                            if (this.attach) {
                                var s = {
                                    comment: {
                                        type: i,
                                        value: e.value,
                                        range: [ t.start.offset, t.end.offset ]
                                    },
                                    start: t.start.offset
                                };
                                if (e.loc) {
                                    s.comment.loc = e.loc;
                                }
                                e.type = i;
                                this.leading.push(s);
                                this.trailing.push(s);
                            }
                        };
                        e.prototype.visit = function(e, t) {
                            if (e.type === "LineComment") {
                                this.visitComment(e, t);
                            } else if (e.type === "BlockComment") {
                                this.visitComment(e, t);
                            } else if (this.attach) {
                                this.visitNode(e, t);
                            }
                        };
                        return e;
                    }();
                    t.CommentHandler = s;
                }, function(e, t) {
                    "use strict";
                    Object.defineProperty(t, "__esModule", {
                        value: true
                    });
                    t.Syntax = {
                        AssignmentExpression: "AssignmentExpression",
                        AssignmentPattern: "AssignmentPattern",
                        ArrayExpression: "ArrayExpression",
                        ArrayPattern: "ArrayPattern",
                        ArrowFunctionExpression: "ArrowFunctionExpression",
                        AwaitExpression: "AwaitExpression",
                        BlockStatement: "BlockStatement",
                        BinaryExpression: "BinaryExpression",
                        BreakStatement: "BreakStatement",
                        CallExpression: "CallExpression",
                        CatchClause: "CatchClause",
                        ClassBody: "ClassBody",
                        ClassDeclaration: "ClassDeclaration",
                        ClassExpression: "ClassExpression",
                        ConditionalExpression: "ConditionalExpression",
                        ContinueStatement: "ContinueStatement",
                        DoWhileStatement: "DoWhileStatement",
                        DebuggerStatement: "DebuggerStatement",
                        EmptyStatement: "EmptyStatement",
                        ExportAllDeclaration: "ExportAllDeclaration",
                        ExportDefaultDeclaration: "ExportDefaultDeclaration",
                        ExportNamedDeclaration: "ExportNamedDeclaration",
                        ExportSpecifier: "ExportSpecifier",
                        ExpressionStatement: "ExpressionStatement",
                        ForStatement: "ForStatement",
                        ForOfStatement: "ForOfStatement",
                        ForInStatement: "ForInStatement",
                        FunctionDeclaration: "FunctionDeclaration",
                        FunctionExpression: "FunctionExpression",
                        Identifier: "Identifier",
                        IfStatement: "IfStatement",
                        ImportDeclaration: "ImportDeclaration",
                        ImportDefaultSpecifier: "ImportDefaultSpecifier",
                        ImportNamespaceSpecifier: "ImportNamespaceSpecifier",
                        ImportSpecifier: "ImportSpecifier",
                        Literal: "Literal",
                        LabeledStatement: "LabeledStatement",
                        LogicalExpression: "LogicalExpression",
                        MemberExpression: "MemberExpression",
                        MetaProperty: "MetaProperty",
                        MethodDefinition: "MethodDefinition",
                        NewExpression: "NewExpression",
                        ObjectExpression: "ObjectExpression",
                        ObjectPattern: "ObjectPattern",
                        Program: "Program",
                        Property: "Property",
                        RestElement: "RestElement",
                        ReturnStatement: "ReturnStatement",
                        SequenceExpression: "SequenceExpression",
                        SpreadElement: "SpreadElement",
                        Super: "Super",
                        SwitchCase: "SwitchCase",
                        SwitchStatement: "SwitchStatement",
                        TaggedTemplateExpression: "TaggedTemplateExpression",
                        TemplateElement: "TemplateElement",
                        TemplateLiteral: "TemplateLiteral",
                        ThisExpression: "ThisExpression",
                        ThrowStatement: "ThrowStatement",
                        TryStatement: "TryStatement",
                        UnaryExpression: "UnaryExpression",
                        UpdateExpression: "UpdateExpression",
                        VariableDeclaration: "VariableDeclaration",
                        VariableDeclarator: "VariableDeclarator",
                        WhileStatement: "WhileStatement",
                        WithStatement: "WithStatement",
                        YieldExpression: "YieldExpression"
                    };
                }, function(e, t, i) {
                    "use strict";
                    var r = this && this.__extends || function() {
                        var e = Object.setPrototypeOf || {
                            __proto__: []
                        } instanceof Array && function(e, t) {
                            e.__proto__ = t;
                        } || function(e, t) {
                            for (var i in t) {
                                if (t.hasOwnProperty(i)) e[i] = t[i];
                            }
                        };
                        return function(t, i) {
                            e(t, i);
                            function r() {
                                this.constructor = t;
                            }
                            t.prototype = i === null ? Object.create(i) : (r.prototype = i.prototype, new r());
                        };
                    }();
                    Object.defineProperty(t, "__esModule", {
                        value: true
                    });
                    var s = i(4);
                    var a = i(5);
                    var n = i(6);
                    var o = i(7);
                    var l = i(8);
                    var u = i(13);
                    var c = i(14);
                    u.TokenName[100] = "JSXIdentifier";
                    u.TokenName[101] = "JSXText";
                    function h(e) {
                        var t;
                        switch (e.type) {
                          case n.JSXSyntax.JSXIdentifier:
                            var i = e;
                            t = i.name;
                            break;

                          case n.JSXSyntax.JSXNamespacedName:
                            var r = e;
                            t = h(r.namespace) + ":" + h(r.name);
                            break;

                          case n.JSXSyntax.JSXMemberExpression:
                            var s = e;
                            t = h(s.object) + "." + h(s.property);
                            break;

                          default:
                            break;
                        }
                        return t;
                    }
                    var p = function(e) {
                        r(t, e);
                        function t(t, i, r) {
                            return e.call(this, t, i, r) || this;
                        }
                        t.prototype.parsePrimaryExpression = function() {
                            return this.match("<") ? this.parseJSXRoot() : e.prototype.parsePrimaryExpression.call(this);
                        };
                        t.prototype.startJSX = function() {
                            this.scanner.index = this.startMarker.index;
                            this.scanner.lineNumber = this.startMarker.line;
                            this.scanner.lineStart = this.startMarker.index - this.startMarker.column;
                        };
                        t.prototype.finishJSX = function() {
                            this.nextToken();
                        };
                        t.prototype.reenterJSX = function() {
                            this.startJSX();
                            this.expectJSX("}");
                            if (this.config.tokens) {
                                this.tokens.pop();
                            }
                        };
                        t.prototype.createJSXNode = function() {
                            this.collectComments();
                            return {
                                index: this.scanner.index,
                                line: this.scanner.lineNumber,
                                column: this.scanner.index - this.scanner.lineStart
                            };
                        };
                        t.prototype.createJSXChildNode = function() {
                            return {
                                index: this.scanner.index,
                                line: this.scanner.lineNumber,
                                column: this.scanner.index - this.scanner.lineStart
                            };
                        };
                        t.prototype.scanXHTMLEntity = function(e) {
                            var t = "&";
                            var i = true;
                            var r = false;
                            var a = false;
                            var n = false;
                            while (!this.scanner.eof() && i && !r) {
                                var o = this.scanner.source[this.scanner.index];
                                if (o === e) {
                                    break;
                                }
                                r = o === ";";
                                t += o;
                                ++this.scanner.index;
                                if (!r) {
                                    switch (t.length) {
                                      case 2:
                                        a = o === "#";
                                        break;

                                      case 3:
                                        if (a) {
                                            n = o === "x";
                                            i = n || s.Character.isDecimalDigit(o.charCodeAt(0));
                                            a = a && !n;
                                        }
                                        break;

                                      default:
                                        i = i && !(a && !s.Character.isDecimalDigit(o.charCodeAt(0)));
                                        i = i && !(n && !s.Character.isHexDigit(o.charCodeAt(0)));
                                        break;
                                    }
                                }
                            }
                            if (i && r && t.length > 2) {
                                var l = t.substr(1, t.length - 2);
                                if (a && l.length > 1) {
                                    t = String.fromCharCode(parseInt(l.substr(1), 10));
                                } else if (n && l.length > 2) {
                                    t = String.fromCharCode(parseInt("0" + l.substr(1), 16));
                                } else if (!a && !n && c.XHTMLEntities[l]) {
                                    t = c.XHTMLEntities[l];
                                }
                            }
                            return t;
                        };
                        t.prototype.lexJSX = function() {
                            var e = this.scanner.source.charCodeAt(this.scanner.index);
                            if (e === 60 || e === 62 || e === 47 || e === 58 || e === 61 || e === 123 || e === 125) {
                                var t = this.scanner.source[this.scanner.index++];
                                return {
                                    type: 7,
                                    value: t,
                                    lineNumber: this.scanner.lineNumber,
                                    lineStart: this.scanner.lineStart,
                                    start: this.scanner.index - 1,
                                    end: this.scanner.index
                                };
                            }
                            if (e === 34 || e === 39) {
                                var i = this.scanner.index;
                                var r = this.scanner.source[this.scanner.index++];
                                var a = "";
                                while (!this.scanner.eof()) {
                                    var n = this.scanner.source[this.scanner.index++];
                                    if (n === r) {
                                        break;
                                    } else if (n === "&") {
                                        a += this.scanXHTMLEntity(r);
                                    } else {
                                        a += n;
                                    }
                                }
                                return {
                                    type: 8,
                                    value: a,
                                    lineNumber: this.scanner.lineNumber,
                                    lineStart: this.scanner.lineStart,
                                    start: i,
                                    end: this.scanner.index
                                };
                            }
                            if (e === 46) {
                                var o = this.scanner.source.charCodeAt(this.scanner.index + 1);
                                var l = this.scanner.source.charCodeAt(this.scanner.index + 2);
                                var t = o === 46 && l === 46 ? "..." : ".";
                                var i = this.scanner.index;
                                this.scanner.index += t.length;
                                return {
                                    type: 7,
                                    value: t,
                                    lineNumber: this.scanner.lineNumber,
                                    lineStart: this.scanner.lineStart,
                                    start: i,
                                    end: this.scanner.index
                                };
                            }
                            if (e === 96) {
                                return {
                                    type: 10,
                                    value: "",
                                    lineNumber: this.scanner.lineNumber,
                                    lineStart: this.scanner.lineStart,
                                    start: this.scanner.index,
                                    end: this.scanner.index
                                };
                            }
                            if (s.Character.isIdentifierStart(e) && e !== 92) {
                                var i = this.scanner.index;
                                ++this.scanner.index;
                                while (!this.scanner.eof()) {
                                    var n = this.scanner.source.charCodeAt(this.scanner.index);
                                    if (s.Character.isIdentifierPart(n) && n !== 92) {
                                        ++this.scanner.index;
                                    } else if (n === 45) {
                                        ++this.scanner.index;
                                    } else {
                                        break;
                                    }
                                }
                                var u = this.scanner.source.slice(i, this.scanner.index);
                                return {
                                    type: 100,
                                    value: u,
                                    lineNumber: this.scanner.lineNumber,
                                    lineStart: this.scanner.lineStart,
                                    start: i,
                                    end: this.scanner.index
                                };
                            }
                            return this.scanner.lex();
                        };
                        t.prototype.nextJSXToken = function() {
                            this.collectComments();
                            this.startMarker.index = this.scanner.index;
                            this.startMarker.line = this.scanner.lineNumber;
                            this.startMarker.column = this.scanner.index - this.scanner.lineStart;
                            var e = this.lexJSX();
                            this.lastMarker.index = this.scanner.index;
                            this.lastMarker.line = this.scanner.lineNumber;
                            this.lastMarker.column = this.scanner.index - this.scanner.lineStart;
                            if (this.config.tokens) {
                                this.tokens.push(this.convertToken(e));
                            }
                            return e;
                        };
                        t.prototype.nextJSXText = function() {
                            this.startMarker.index = this.scanner.index;
                            this.startMarker.line = this.scanner.lineNumber;
                            this.startMarker.column = this.scanner.index - this.scanner.lineStart;
                            var e = this.scanner.index;
                            var t = "";
                            while (!this.scanner.eof()) {
                                var i = this.scanner.source[this.scanner.index];
                                if (i === "{" || i === "<") {
                                    break;
                                }
                                ++this.scanner.index;
                                t += i;
                                if (s.Character.isLineTerminator(i.charCodeAt(0))) {
                                    ++this.scanner.lineNumber;
                                    if (i === "\r" && this.scanner.source[this.scanner.index] === "\n") {
                                        ++this.scanner.index;
                                    }
                                    this.scanner.lineStart = this.scanner.index;
                                }
                            }
                            this.lastMarker.index = this.scanner.index;
                            this.lastMarker.line = this.scanner.lineNumber;
                            this.lastMarker.column = this.scanner.index - this.scanner.lineStart;
                            var r = {
                                type: 101,
                                value: t,
                                lineNumber: this.scanner.lineNumber,
                                lineStart: this.scanner.lineStart,
                                start: e,
                                end: this.scanner.index
                            };
                            if (t.length > 0 && this.config.tokens) {
                                this.tokens.push(this.convertToken(r));
                            }
                            return r;
                        };
                        t.prototype.peekJSXToken = function() {
                            var e = this.scanner.saveState();
                            this.scanner.scanComments();
                            var t = this.lexJSX();
                            this.scanner.restoreState(e);
                            return t;
                        };
                        t.prototype.expectJSX = function(e) {
                            var t = this.nextJSXToken();
                            if (t.type !== 7 || t.value !== e) {
                                this.throwUnexpectedToken(t);
                            }
                        };
                        t.prototype.matchJSX = function(e) {
                            var t = this.peekJSXToken();
                            return t.type === 7 && t.value === e;
                        };
                        t.prototype.parseJSXIdentifier = function() {
                            var e = this.createJSXNode();
                            var t = this.nextJSXToken();
                            if (t.type !== 100) {
                                this.throwUnexpectedToken(t);
                            }
                            return this.finalize(e, new a.JSXIdentifier(t.value));
                        };
                        t.prototype.parseJSXElementName = function() {
                            var e = this.createJSXNode();
                            var t = this.parseJSXIdentifier();
                            if (this.matchJSX(":")) {
                                var i = t;
                                this.expectJSX(":");
                                var r = this.parseJSXIdentifier();
                                t = this.finalize(e, new a.JSXNamespacedName(i, r));
                            } else if (this.matchJSX(".")) {
                                while (this.matchJSX(".")) {
                                    var s = t;
                                    this.expectJSX(".");
                                    var n = this.parseJSXIdentifier();
                                    t = this.finalize(e, new a.JSXMemberExpression(s, n));
                                }
                            }
                            return t;
                        };
                        t.prototype.parseJSXAttributeName = function() {
                            var e = this.createJSXNode();
                            var t;
                            var i = this.parseJSXIdentifier();
                            if (this.matchJSX(":")) {
                                var r = i;
                                this.expectJSX(":");
                                var s = this.parseJSXIdentifier();
                                t = this.finalize(e, new a.JSXNamespacedName(r, s));
                            } else {
                                t = i;
                            }
                            return t;
                        };
                        t.prototype.parseJSXStringLiteralAttribute = function() {
                            var e = this.createJSXNode();
                            var t = this.nextJSXToken();
                            if (t.type !== 8) {
                                this.throwUnexpectedToken(t);
                            }
                            var i = this.getTokenRaw(t);
                            return this.finalize(e, new o.Literal(t.value, i));
                        };
                        t.prototype.parseJSXExpressionAttribute = function() {
                            var e = this.createJSXNode();
                            this.expectJSX("{");
                            this.finishJSX();
                            if (this.match("}")) {
                                this.tolerateError("JSX attributes must only be assigned a non-empty expression");
                            }
                            var t = this.parseAssignmentExpression();
                            this.reenterJSX();
                            return this.finalize(e, new a.JSXExpressionContainer(t));
                        };
                        t.prototype.parseJSXAttributeValue = function() {
                            return this.matchJSX("{") ? this.parseJSXExpressionAttribute() : this.matchJSX("<") ? this.parseJSXElement() : this.parseJSXStringLiteralAttribute();
                        };
                        t.prototype.parseJSXNameValueAttribute = function() {
                            var e = this.createJSXNode();
                            var t = this.parseJSXAttributeName();
                            var i = null;
                            if (this.matchJSX("=")) {
                                this.expectJSX("=");
                                i = this.parseJSXAttributeValue();
                            }
                            return this.finalize(e, new a.JSXAttribute(t, i));
                        };
                        t.prototype.parseJSXSpreadAttribute = function() {
                            var e = this.createJSXNode();
                            this.expectJSX("{");
                            this.expectJSX("...");
                            this.finishJSX();
                            var t = this.parseAssignmentExpression();
                            this.reenterJSX();
                            return this.finalize(e, new a.JSXSpreadAttribute(t));
                        };
                        t.prototype.parseJSXAttributes = function() {
                            var e = [];
                            while (!this.matchJSX("/") && !this.matchJSX(">")) {
                                var t = this.matchJSX("{") ? this.parseJSXSpreadAttribute() : this.parseJSXNameValueAttribute();
                                e.push(t);
                            }
                            return e;
                        };
                        t.prototype.parseJSXOpeningElement = function() {
                            var e = this.createJSXNode();
                            this.expectJSX("<");
                            var t = this.parseJSXElementName();
                            var i = this.parseJSXAttributes();
                            var r = this.matchJSX("/");
                            if (r) {
                                this.expectJSX("/");
                            }
                            this.expectJSX(">");
                            return this.finalize(e, new a.JSXOpeningElement(t, r, i));
                        };
                        t.prototype.parseJSXBoundaryElement = function() {
                            var e = this.createJSXNode();
                            this.expectJSX("<");
                            if (this.matchJSX("/")) {
                                this.expectJSX("/");
                                var t = this.parseJSXElementName();
                                this.expectJSX(">");
                                return this.finalize(e, new a.JSXClosingElement(t));
                            }
                            var i = this.parseJSXElementName();
                            var r = this.parseJSXAttributes();
                            var s = this.matchJSX("/");
                            if (s) {
                                this.expectJSX("/");
                            }
                            this.expectJSX(">");
                            return this.finalize(e, new a.JSXOpeningElement(i, s, r));
                        };
                        t.prototype.parseJSXEmptyExpression = function() {
                            var e = this.createJSXChildNode();
                            this.collectComments();
                            this.lastMarker.index = this.scanner.index;
                            this.lastMarker.line = this.scanner.lineNumber;
                            this.lastMarker.column = this.scanner.index - this.scanner.lineStart;
                            return this.finalize(e, new a.JSXEmptyExpression());
                        };
                        t.prototype.parseJSXExpressionContainer = function() {
                            var e = this.createJSXNode();
                            this.expectJSX("{");
                            var t;
                            if (this.matchJSX("}")) {
                                t = this.parseJSXEmptyExpression();
                                this.expectJSX("}");
                            } else {
                                this.finishJSX();
                                t = this.parseAssignmentExpression();
                                this.reenterJSX();
                            }
                            return this.finalize(e, new a.JSXExpressionContainer(t));
                        };
                        t.prototype.parseJSXChildren = function() {
                            var e = [];
                            while (!this.scanner.eof()) {
                                var t = this.createJSXChildNode();
                                var i = this.nextJSXText();
                                if (i.start < i.end) {
                                    var r = this.getTokenRaw(i);
                                    var s = this.finalize(t, new a.JSXText(i.value, r));
                                    e.push(s);
                                }
                                if (this.scanner.source[this.scanner.index] === "{") {
                                    var n = this.parseJSXExpressionContainer();
                                    e.push(n);
                                } else {
                                    break;
                                }
                            }
                            return e;
                        };
                        t.prototype.parseComplexJSXElement = function(e) {
                            var t = [];
                            while (!this.scanner.eof()) {
                                e.children = e.children.concat(this.parseJSXChildren());
                                var i = this.createJSXChildNode();
                                var r = this.parseJSXBoundaryElement();
                                if (r.type === n.JSXSyntax.JSXOpeningElement) {
                                    var s = r;
                                    if (s.selfClosing) {
                                        var o = this.finalize(i, new a.JSXElement(s, [], null));
                                        e.children.push(o);
                                    } else {
                                        t.push(e);
                                        e = {
                                            node: i,
                                            opening: s,
                                            closing: null,
                                            children: []
                                        };
                                    }
                                }
                                if (r.type === n.JSXSyntax.JSXClosingElement) {
                                    e.closing = r;
                                    var l = h(e.opening.name);
                                    var u = h(e.closing.name);
                                    if (l !== u) {
                                        this.tolerateError("Expected corresponding JSX closing tag for %0", l);
                                    }
                                    if (t.length > 0) {
                                        var o = this.finalize(e.node, new a.JSXElement(e.opening, e.children, e.closing));
                                        e = t[t.length - 1];
                                        e.children.push(o);
                                        t.pop();
                                    } else {
                                        break;
                                    }
                                }
                            }
                            return e;
                        };
                        t.prototype.parseJSXElement = function() {
                            var e = this.createJSXNode();
                            var t = this.parseJSXOpeningElement();
                            var i = [];
                            var r = null;
                            if (!t.selfClosing) {
                                var s = this.parseComplexJSXElement({
                                    node: e,
                                    opening: t,
                                    closing: r,
                                    children: i
                                });
                                i = s.children;
                                r = s.closing;
                            }
                            return this.finalize(e, new a.JSXElement(t, i, r));
                        };
                        t.prototype.parseJSXRoot = function() {
                            if (this.config.tokens) {
                                this.tokens.pop();
                            }
                            this.startJSX();
                            var e = this.parseJSXElement();
                            this.finishJSX();
                            return e;
                        };
                        t.prototype.isStartOfExpression = function() {
                            return e.prototype.isStartOfExpression.call(this) || this.match("<");
                        };
                        return t;
                    }(l.Parser);
                    t.JSXParser = p;
                }, function(e, t) {
                    "use strict";
                    Object.defineProperty(t, "__esModule", {
                        value: true
                    });
                    var i = {
                        NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AD\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]/,
                        NonAsciiIdentifierPart: /[\xAA\xB5\xB7\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1369-\u1371\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFC-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AD\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C4\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/
                    };
                    t.Character = {
                        fromCodePoint: function e(t) {
                            return t < 65536 ? String.fromCharCode(t) : String.fromCharCode(55296 + (t - 65536 >> 10)) + String.fromCharCode(56320 + (t - 65536 & 1023));
                        },
                        isWhiteSpace: function e(t) {
                            return t === 32 || t === 9 || t === 11 || t === 12 || t === 160 || t >= 5760 && [ 5760, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8199, 8200, 8201, 8202, 8239, 8287, 12288, 65279 ].indexOf(t) >= 0;
                        },
                        isLineTerminator: function e(t) {
                            return t === 10 || t === 13 || t === 8232 || t === 8233;
                        },
                        isIdentifierStart: function e(r) {
                            return r === 36 || r === 95 || r >= 65 && r <= 90 || r >= 97 && r <= 122 || r === 92 || r >= 128 && i.NonAsciiIdentifierStart.test(t.Character.fromCodePoint(r));
                        },
                        isIdentifierPart: function e(r) {
                            return r === 36 || r === 95 || r >= 65 && r <= 90 || r >= 97 && r <= 122 || r >= 48 && r <= 57 || r === 92 || r >= 128 && i.NonAsciiIdentifierPart.test(t.Character.fromCodePoint(r));
                        },
                        isDecimalDigit: function e(t) {
                            return t >= 48 && t <= 57;
                        },
                        isHexDigit: function e(t) {
                            return t >= 48 && t <= 57 || t >= 65 && t <= 70 || t >= 97 && t <= 102;
                        },
                        isOctalDigit: function e(t) {
                            return t >= 48 && t <= 55;
                        }
                    };
                }, function(e, t, i) {
                    "use strict";
                    Object.defineProperty(t, "__esModule", {
                        value: true
                    });
                    var r = i(6);
                    var s = function() {
                        function e(e) {
                            this.type = r.JSXSyntax.JSXClosingElement;
                            this.name = e;
                        }
                        return e;
                    }();
                    t.JSXClosingElement = s;
                    var a = function() {
                        function e(e, t, i) {
                            this.type = r.JSXSyntax.JSXElement;
                            this.openingElement = e;
                            this.children = t;
                            this.closingElement = i;
                        }
                        return e;
                    }();
                    t.JSXElement = a;
                    var n = function() {
                        function e() {
                            this.type = r.JSXSyntax.JSXEmptyExpression;
                        }
                        return e;
                    }();
                    t.JSXEmptyExpression = n;
                    var o = function() {
                        function e(e) {
                            this.type = r.JSXSyntax.JSXExpressionContainer;
                            this.expression = e;
                        }
                        return e;
                    }();
                    t.JSXExpressionContainer = o;
                    var l = function() {
                        function e(e) {
                            this.type = r.JSXSyntax.JSXIdentifier;
                            this.name = e;
                        }
                        return e;
                    }();
                    t.JSXIdentifier = l;
                    var u = function() {
                        function e(e, t) {
                            this.type = r.JSXSyntax.JSXMemberExpression;
                            this.object = e;
                            this.property = t;
                        }
                        return e;
                    }();
                    t.JSXMemberExpression = u;
                    var c = function() {
                        function e(e, t) {
                            this.type = r.JSXSyntax.JSXAttribute;
                            this.name = e;
                            this.value = t;
                        }
                        return e;
                    }();
                    t.JSXAttribute = c;
                    var h = function() {
                        function e(e, t) {
                            this.type = r.JSXSyntax.JSXNamespacedName;
                            this.namespace = e;
                            this.name = t;
                        }
                        return e;
                    }();
                    t.JSXNamespacedName = h;
                    var p = function() {
                        function e(e, t, i) {
                            this.type = r.JSXSyntax.JSXOpeningElement;
                            this.name = e;
                            this.selfClosing = t;
                            this.attributes = i;
                        }
                        return e;
                    }();
                    t.JSXOpeningElement = p;
                    var f = function() {
                        function e(e) {
                            this.type = r.JSXSyntax.JSXSpreadAttribute;
                            this.argument = e;
                        }
                        return e;
                    }();
                    t.JSXSpreadAttribute = f;
                    var d = function() {
                        function e(e, t) {
                            this.type = r.JSXSyntax.JSXText;
                            this.value = e;
                            this.raw = t;
                        }
                        return e;
                    }();
                    t.JSXText = d;
                }, function(e, t) {
                    "use strict";
                    Object.defineProperty(t, "__esModule", {
                        value: true
                    });
                    t.JSXSyntax = {
                        JSXAttribute: "JSXAttribute",
                        JSXClosingElement: "JSXClosingElement",
                        JSXElement: "JSXElement",
                        JSXEmptyExpression: "JSXEmptyExpression",
                        JSXExpressionContainer: "JSXExpressionContainer",
                        JSXIdentifier: "JSXIdentifier",
                        JSXMemberExpression: "JSXMemberExpression",
                        JSXNamespacedName: "JSXNamespacedName",
                        JSXOpeningElement: "JSXOpeningElement",
                        JSXSpreadAttribute: "JSXSpreadAttribute",
                        JSXText: "JSXText"
                    };
                }, function(e, t, i) {
                    "use strict";
                    Object.defineProperty(t, "__esModule", {
                        value: true
                    });
                    var r = i(2);
                    var s = function() {
                        function e(e) {
                            this.type = r.Syntax.ArrayExpression;
                            this.elements = e;
                        }
                        return e;
                    }();
                    t.ArrayExpression = s;
                    var a = function() {
                        function e(e) {
                            this.type = r.Syntax.ArrayPattern;
                            this.elements = e;
                        }
                        return e;
                    }();
                    t.ArrayPattern = a;
                    var n = function() {
                        function e(e, t, i) {
                            this.type = r.Syntax.ArrowFunctionExpression;
                            this.id = null;
                            this.params = e;
                            this.body = t;
                            this.generator = false;
                            this.expression = i;
                            this.async = false;
                        }
                        return e;
                    }();
                    t.ArrowFunctionExpression = n;
                    var o = function() {
                        function e(e, t, i) {
                            this.type = r.Syntax.AssignmentExpression;
                            this.operator = e;
                            this.left = t;
                            this.right = i;
                        }
                        return e;
                    }();
                    t.AssignmentExpression = o;
                    var l = function() {
                        function e(e, t) {
                            this.type = r.Syntax.AssignmentPattern;
                            this.left = e;
                            this.right = t;
                        }
                        return e;
                    }();
                    t.AssignmentPattern = l;
                    var u = function() {
                        function e(e, t, i) {
                            this.type = r.Syntax.ArrowFunctionExpression;
                            this.id = null;
                            this.params = e;
                            this.body = t;
                            this.generator = false;
                            this.expression = i;
                            this.async = true;
                        }
                        return e;
                    }();
                    t.AsyncArrowFunctionExpression = u;
                    var c = function() {
                        function e(e, t, i) {
                            this.type = r.Syntax.FunctionDeclaration;
                            this.id = e;
                            this.params = t;
                            this.body = i;
                            this.generator = false;
                            this.expression = false;
                            this.async = true;
                        }
                        return e;
                    }();
                    t.AsyncFunctionDeclaration = c;
                    var h = function() {
                        function e(e, t, i) {
                            this.type = r.Syntax.FunctionExpression;
                            this.id = e;
                            this.params = t;
                            this.body = i;
                            this.generator = false;
                            this.expression = false;
                            this.async = true;
                        }
                        return e;
                    }();
                    t.AsyncFunctionExpression = h;
                    var p = function() {
                        function e(e) {
                            this.type = r.Syntax.AwaitExpression;
                            this.argument = e;
                        }
                        return e;
                    }();
                    t.AwaitExpression = p;
                    var f = function() {
                        function e(e, t, i) {
                            var s = e === "||" || e === "&&";
                            this.type = s ? r.Syntax.LogicalExpression : r.Syntax.BinaryExpression;
                            this.operator = e;
                            this.left = t;
                            this.right = i;
                        }
                        return e;
                    }();
                    t.BinaryExpression = f;
                    var d = function() {
                        function e(e) {
                            this.type = r.Syntax.BlockStatement;
                            this.body = e;
                        }
                        return e;
                    }();
                    t.BlockStatement = d;
                    var m = function() {
                        function e(e) {
                            this.type = r.Syntax.BreakStatement;
                            this.label = e;
                        }
                        return e;
                    }();
                    t.BreakStatement = m;
                    var y = function() {
                        function e(e, t) {
                            this.type = r.Syntax.CallExpression;
                            this.callee = e;
                            this.arguments = t;
                        }
                        return e;
                    }();
                    t.CallExpression = y;
                    var v = function() {
                        function e(e, t) {
                            this.type = r.Syntax.CatchClause;
                            this.param = e;
                            this.body = t;
                        }
                        return e;
                    }();
                    t.CatchClause = v;
                    var x = function() {
                        function e(e) {
                            this.type = r.Syntax.ClassBody;
                            this.body = e;
                        }
                        return e;
                    }();
                    t.ClassBody = x;
                    var g = function() {
                        function e(e, t, i) {
                            this.type = r.Syntax.ClassDeclaration;
                            this.id = e;
                            this.superClass = t;
                            this.body = i;
                        }
                        return e;
                    }();
                    t.ClassDeclaration = g;
                    var b = function() {
                        function e(e, t, i) {
                            this.type = r.Syntax.ClassExpression;
                            this.id = e;
                            this.superClass = t;
                            this.body = i;
                        }
                        return e;
                    }();
                    t.ClassExpression = b;
                    var E = function() {
                        function e(e, t) {
                            this.type = r.Syntax.MemberExpression;
                            this.computed = true;
                            this.object = e;
                            this.property = t;
                        }
                        return e;
                    }();
                    t.ComputedMemberExpression = E;
                    var k = function() {
                        function e(e, t, i) {
                            this.type = r.Syntax.ConditionalExpression;
                            this.test = e;
                            this.consequent = t;
                            this.alternate = i;
                        }
                        return e;
                    }();
                    t.ConditionalExpression = k;
                    var S = function() {
                        function e(e) {
                            this.type = r.Syntax.ContinueStatement;
                            this.label = e;
                        }
                        return e;
                    }();
                    t.ContinueStatement = S;
                    var w = function() {
                        function e() {
                            this.type = r.Syntax.DebuggerStatement;
                        }
                        return e;
                    }();
                    t.DebuggerStatement = w;
                    var A = function() {
                        function e(e, t) {
                            this.type = r.Syntax.ExpressionStatement;
                            this.expression = e;
                            this.directive = t;
                        }
                        return e;
                    }();
                    t.Directive = A;
                    var C = function() {
                        function e(e, t) {
                            this.type = r.Syntax.DoWhileStatement;
                            this.body = e;
                            this.test = t;
                        }
                        return e;
                    }();
                    t.DoWhileStatement = C;
                    var T = function() {
                        function e() {
                            this.type = r.Syntax.EmptyStatement;
                        }
                        return e;
                    }();
                    t.EmptyStatement = T;
                    var P = function() {
                        function e(e) {
                            this.type = r.Syntax.ExportAllDeclaration;
                            this.source = e;
                        }
                        return e;
                    }();
                    t.ExportAllDeclaration = P;
                    var D = function() {
                        function e(e) {
                            this.type = r.Syntax.ExportDefaultDeclaration;
                            this.declaration = e;
                        }
                        return e;
                    }();
                    t.ExportDefaultDeclaration = D;
                    var _ = function() {
                        function e(e, t, i) {
                            this.type = r.Syntax.ExportNamedDeclaration;
                            this.declaration = e;
                            this.specifiers = t;
                            this.source = i;
                        }
                        return e;
                    }();
                    t.ExportNamedDeclaration = _;
                    var N = function() {
                        function e(e, t) {
                            this.type = r.Syntax.ExportSpecifier;
                            this.exported = t;
                            this.local = e;
                        }
                        return e;
                    }();
                    t.ExportSpecifier = N;
                    var F = function() {
                        function e(e) {
                            this.type = r.Syntax.ExpressionStatement;
                            this.expression = e;
                        }
                        return e;
                    }();
                    t.ExpressionStatement = F;
                    var I = function() {
                        function e(e, t, i) {
                            this.type = r.Syntax.ForInStatement;
                            this.left = e;
                            this.right = t;
                            this.body = i;
                            this.each = false;
                        }
                        return e;
                    }();
                    t.ForInStatement = I;
                    var O = function() {
                        function e(e, t, i) {
                            this.type = r.Syntax.ForOfStatement;
                            this.left = e;
                            this.right = t;
                            this.body = i;
                        }
                        return e;
                    }();
                    t.ForOfStatement = O;
                    var L = function() {
                        function e(e, t, i, s) {
                            this.type = r.Syntax.ForStatement;
                            this.init = e;
                            this.test = t;
                            this.update = i;
                            this.body = s;
                        }
                        return e;
                    }();
                    t.ForStatement = L;
                    var B = function() {
                        function e(e, t, i, s) {
                            this.type = r.Syntax.FunctionDeclaration;
                            this.id = e;
                            this.params = t;
                            this.body = i;
                            this.generator = s;
                            this.expression = false;
                            this.async = false;
                        }
                        return e;
                    }();
                    t.FunctionDeclaration = B;
                    var M = function() {
                        function e(e, t, i, s) {
                            this.type = r.Syntax.FunctionExpression;
                            this.id = e;
                            this.params = t;
                            this.body = i;
                            this.generator = s;
                            this.expression = false;
                            this.async = false;
                        }
                        return e;
                    }();
                    t.FunctionExpression = M;
                    var j = function() {
                        function e(e) {
                            this.type = r.Syntax.Identifier;
                            this.name = e;
                        }
                        return e;
                    }();
                    t.Identifier = j;
                    var R = function() {
                        function e(e, t, i) {
                            this.type = r.Syntax.IfStatement;
                            this.test = e;
                            this.consequent = t;
                            this.alternate = i;
                        }
                        return e;
                    }();
                    t.IfStatement = R;
                    var V = function() {
                        function e(e, t) {
                            this.type = r.Syntax.ImportDeclaration;
                            this.specifiers = e;
                            this.source = t;
                        }
                        return e;
                    }();
                    t.ImportDeclaration = V;
                    var U = function() {
                        function e(e) {
                            this.type = r.Syntax.ImportDefaultSpecifier;
                            this.local = e;
                        }
                        return e;
                    }();
                    t.ImportDefaultSpecifier = U;
                    var X = function() {
                        function e(e) {
                            this.type = r.Syntax.ImportNamespaceSpecifier;
                            this.local = e;
                        }
                        return e;
                    }();
                    t.ImportNamespaceSpecifier = X;
                    var q = function() {
                        function e(e, t) {
                            this.type = r.Syntax.ImportSpecifier;
                            this.local = e;
                            this.imported = t;
                        }
                        return e;
                    }();
                    t.ImportSpecifier = q;
                    var J = function() {
                        function e(e, t) {
                            this.type = r.Syntax.LabeledStatement;
                            this.label = e;
                            this.body = t;
                        }
                        return e;
                    }();
                    t.LabeledStatement = J;
                    var z = function() {
                        function e(e, t) {
                            this.type = r.Syntax.Literal;
                            this.value = e;
                            this.raw = t;
                        }
                        return e;
                    }();
                    t.Literal = z;
                    var W = function() {
                        function e(e, t) {
                            this.type = r.Syntax.MetaProperty;
                            this.meta = e;
                            this.property = t;
                        }
                        return e;
                    }();
                    t.MetaProperty = W;
                    var K = function() {
                        function e(e, t, i, s, a) {
                            this.type = r.Syntax.MethodDefinition;
                            this.key = e;
                            this.computed = t;
                            this.value = i;
                            this.kind = s;
                            this.static = a;
                        }
                        return e;
                    }();
                    t.MethodDefinition = K;
                    var G = function() {
                        function e(e) {
                            this.type = r.Syntax.Program;
                            this.body = e;
                            this.sourceType = "module";
                        }
                        return e;
                    }();
                    t.Module = G;
                    var H = function() {
                        function e(e, t) {
                            this.type = r.Syntax.NewExpression;
                            this.callee = e;
                            this.arguments = t;
                        }
                        return e;
                    }();
                    t.NewExpression = H;
                    var Y = function() {
                        function e(e) {
                            this.type = r.Syntax.ObjectExpression;
                            this.properties = e;
                        }
                        return e;
                    }();
                    t.ObjectExpression = Y;
                    var Q = function() {
                        function e(e) {
                            this.type = r.Syntax.ObjectPattern;
                            this.properties = e;
                        }
                        return e;
                    }();
                    t.ObjectPattern = Q;
                    var $ = function() {
                        function e(e, t, i, s, a, n) {
                            this.type = r.Syntax.Property;
                            this.key = t;
                            this.computed = i;
                            this.value = s;
                            this.kind = e;
                            this.method = a;
                            this.shorthand = n;
                        }
                        return e;
                    }();
                    t.Property = $;
                    var Z = function() {
                        function e(e, t, i, s) {
                            this.type = r.Syntax.Literal;
                            this.value = e;
                            this.raw = t;
                            this.regex = {
                                pattern: i,
                                flags: s
                            };
                        }
                        return e;
                    }();
                    t.RegexLiteral = Z;
                    var ee = function() {
                        function e(e) {
                            this.type = r.Syntax.RestElement;
                            this.argument = e;
                        }
                        return e;
                    }();
                    t.RestElement = ee;
                    var te = function() {
                        function e(e) {
                            this.type = r.Syntax.ReturnStatement;
                            this.argument = e;
                        }
                        return e;
                    }();
                    t.ReturnStatement = te;
                    var ie = function() {
                        function e(e) {
                            this.type = r.Syntax.Program;
                            this.body = e;
                            this.sourceType = "script";
                        }
                        return e;
                    }();
                    t.Script = ie;
                    var re = function() {
                        function e(e) {
                            this.type = r.Syntax.SequenceExpression;
                            this.expressions = e;
                        }
                        return e;
                    }();
                    t.SequenceExpression = re;
                    var se = function() {
                        function e(e) {
                            this.type = r.Syntax.SpreadElement;
                            this.argument = e;
                        }
                        return e;
                    }();
                    t.SpreadElement = se;
                    var ae = function() {
                        function e(e, t) {
                            this.type = r.Syntax.MemberExpression;
                            this.computed = false;
                            this.object = e;
                            this.property = t;
                        }
                        return e;
                    }();
                    t.StaticMemberExpression = ae;
                    var ne = function() {
                        function e() {
                            this.type = r.Syntax.Super;
                        }
                        return e;
                    }();
                    t.Super = ne;
                    var oe = function() {
                        function e(e, t) {
                            this.type = r.Syntax.SwitchCase;
                            this.test = e;
                            this.consequent = t;
                        }
                        return e;
                    }();
                    t.SwitchCase = oe;
                    var le = function() {
                        function e(e, t) {
                            this.type = r.Syntax.SwitchStatement;
                            this.discriminant = e;
                            this.cases = t;
                        }
                        return e;
                    }();
                    t.SwitchStatement = le;
                    var ue = function() {
                        function e(e, t) {
                            this.type = r.Syntax.TaggedTemplateExpression;
                            this.tag = e;
                            this.quasi = t;
                        }
                        return e;
                    }();
                    t.TaggedTemplateExpression = ue;
                    var ce = function() {
                        function e(e, t) {
                            this.type = r.Syntax.TemplateElement;
                            this.value = e;
                            this.tail = t;
                        }
                        return e;
                    }();
                    t.TemplateElement = ce;
                    var he = function() {
                        function e(e, t) {
                            this.type = r.Syntax.TemplateLiteral;
                            this.quasis = e;
                            this.expressions = t;
                        }
                        return e;
                    }();
                    t.TemplateLiteral = he;
                    var pe = function() {
                        function e() {
                            this.type = r.Syntax.ThisExpression;
                        }
                        return e;
                    }();
                    t.ThisExpression = pe;
                    var fe = function() {
                        function e(e) {
                            this.type = r.Syntax.ThrowStatement;
                            this.argument = e;
                        }
                        return e;
                    }();
                    t.ThrowStatement = fe;
                    var de = function() {
                        function e(e, t, i) {
                            this.type = r.Syntax.TryStatement;
                            this.block = e;
                            this.handler = t;
                            this.finalizer = i;
                        }
                        return e;
                    }();
                    t.TryStatement = de;
                    var me = function() {
                        function e(e, t) {
                            this.type = r.Syntax.UnaryExpression;
                            this.operator = e;
                            this.argument = t;
                            this.prefix = true;
                        }
                        return e;
                    }();
                    t.UnaryExpression = me;
                    var ye = function() {
                        function e(e, t, i) {
                            this.type = r.Syntax.UpdateExpression;
                            this.operator = e;
                            this.argument = t;
                            this.prefix = i;
                        }
                        return e;
                    }();
                    t.UpdateExpression = ye;
                    var ve = function() {
                        function e(e, t) {
                            this.type = r.Syntax.VariableDeclaration;
                            this.declarations = e;
                            this.kind = t;
                        }
                        return e;
                    }();
                    t.VariableDeclaration = ve;
                    var xe = function() {
                        function e(e, t) {
                            this.type = r.Syntax.VariableDeclarator;
                            this.id = e;
                            this.init = t;
                        }
                        return e;
                    }();
                    t.VariableDeclarator = xe;
                    var ge = function() {
                        function e(e, t) {
                            this.type = r.Syntax.WhileStatement;
                            this.test = e;
                            this.body = t;
                        }
                        return e;
                    }();
                    t.WhileStatement = ge;
                    var be = function() {
                        function e(e, t) {
                            this.type = r.Syntax.WithStatement;
                            this.object = e;
                            this.body = t;
                        }
                        return e;
                    }();
                    t.WithStatement = be;
                    var Ee = function() {
                        function e(e, t) {
                            this.type = r.Syntax.YieldExpression;
                            this.argument = e;
                            this.delegate = t;
                        }
                        return e;
                    }();
                    t.YieldExpression = Ee;
                }, function(e, t, i) {
                    "use strict";
                    Object.defineProperty(t, "__esModule", {
                        value: true
                    });
                    var r = i(9);
                    var s = i(10);
                    var a = i(11);
                    var n = i(7);
                    var o = i(12);
                    var l = i(2);
                    var u = i(13);
                    var c = "ArrowParameterPlaceHolder";
                    var h = function() {
                        function e(e, t, i) {
                            if (t === void 0) {
                                t = {};
                            }
                            this.config = {
                                range: typeof t.range === "boolean" && t.range,
                                loc: typeof t.loc === "boolean" && t.loc,
                                source: null,
                                tokens: typeof t.tokens === "boolean" && t.tokens,
                                comment: typeof t.comment === "boolean" && t.comment,
                                tolerant: typeof t.tolerant === "boolean" && t.tolerant
                            };
                            if (this.config.loc && t.source && t.source !== null) {
                                this.config.source = String(t.source);
                            }
                            this.delegate = i;
                            this.errorHandler = new s.ErrorHandler();
                            this.errorHandler.tolerant = this.config.tolerant;
                            this.scanner = new o.Scanner(e, this.errorHandler);
                            this.scanner.trackComment = this.config.comment;
                            this.operatorPrecedence = {
                                ")": 0,
                                ";": 0,
                                ",": 0,
                                "=": 0,
                                "]": 0,
                                "||": 1,
                                "&&": 2,
                                "|": 3,
                                "^": 4,
                                "&": 5,
                                "==": 6,
                                "!=": 6,
                                "===": 6,
                                "!==": 6,
                                "<": 7,
                                ">": 7,
                                "<=": 7,
                                ">=": 7,
                                "<<": 8,
                                ">>": 8,
                                ">>>": 8,
                                "+": 9,
                                "-": 9,
                                "*": 11,
                                "/": 11,
                                "%": 11
                            };
                            this.lookahead = {
                                type: 2,
                                value: "",
                                lineNumber: this.scanner.lineNumber,
                                lineStart: 0,
                                start: 0,
                                end: 0
                            };
                            this.hasLineTerminator = false;
                            this.context = {
                                isModule: false,
                                await: false,
                                allowIn: true,
                                allowStrictDirective: true,
                                allowYield: true,
                                firstCoverInitializedNameError: null,
                                isAssignmentTarget: false,
                                isBindingElement: false,
                                inFunctionBody: false,
                                inIteration: false,
                                inSwitch: false,
                                labelSet: {},
                                strict: false
                            };
                            this.tokens = [];
                            this.startMarker = {
                                index: 0,
                                line: this.scanner.lineNumber,
                                column: 0
                            };
                            this.lastMarker = {
                                index: 0,
                                line: this.scanner.lineNumber,
                                column: 0
                            };
                            this.nextToken();
                            this.lastMarker = {
                                index: this.scanner.index,
                                line: this.scanner.lineNumber,
                                column: this.scanner.index - this.scanner.lineStart
                            };
                        }
                        e.prototype.throwError = function(e) {
                            var t = [];
                            for (var i = 1; i < arguments.length; i++) {
                                t[i - 1] = arguments[i];
                            }
                            var s = Array.prototype.slice.call(arguments, 1);
                            var a = e.replace(/%(\d)/g, function(e, t) {
                                r.assert(t < s.length, "Message reference must be in range");
                                return s[t];
                            });
                            var n = this.lastMarker.index;
                            var o = this.lastMarker.line;
                            var l = this.lastMarker.column + 1;
                            throw this.errorHandler.createError(n, o, l, a);
                        };
                        e.prototype.tolerateError = function(e) {
                            var t = [];
                            for (var i = 1; i < arguments.length; i++) {
                                t[i - 1] = arguments[i];
                            }
                            var s = Array.prototype.slice.call(arguments, 1);
                            var a = e.replace(/%(\d)/g, function(e, t) {
                                r.assert(t < s.length, "Message reference must be in range");
                                return s[t];
                            });
                            var n = this.lastMarker.index;
                            var o = this.scanner.lineNumber;
                            var l = this.lastMarker.column + 1;
                            this.errorHandler.tolerateError(n, o, l, a);
                        };
                        e.prototype.unexpectedTokenError = function(e, t) {
                            var i = t || a.Messages.UnexpectedToken;
                            var r;
                            if (e) {
                                if (!t) {
                                    i = e.type === 2 ? a.Messages.UnexpectedEOS : e.type === 3 ? a.Messages.UnexpectedIdentifier : e.type === 6 ? a.Messages.UnexpectedNumber : e.type === 8 ? a.Messages.UnexpectedString : e.type === 10 ? a.Messages.UnexpectedTemplate : a.Messages.UnexpectedToken;
                                    if (e.type === 4) {
                                        if (this.scanner.isFutureReservedWord(e.value)) {
                                            i = a.Messages.UnexpectedReserved;
                                        } else if (this.context.strict && this.scanner.isStrictModeReservedWord(e.value)) {
                                            i = a.Messages.StrictReservedWord;
                                        }
                                    }
                                }
                                r = e.value;
                            } else {
                                r = "ILLEGAL";
                            }
                            i = i.replace("%0", r);
                            if (e && typeof e.lineNumber === "number") {
                                var s = e.start;
                                var n = e.lineNumber;
                                var o = this.lastMarker.index - this.lastMarker.column;
                                var l = e.start - o + 1;
                                return this.errorHandler.createError(s, n, l, i);
                            } else {
                                var s = this.lastMarker.index;
                                var n = this.lastMarker.line;
                                var l = this.lastMarker.column + 1;
                                return this.errorHandler.createError(s, n, l, i);
                            }
                        };
                        e.prototype.throwUnexpectedToken = function(e, t) {
                            throw this.unexpectedTokenError(e, t);
                        };
                        e.prototype.tolerateUnexpectedToken = function(e, t) {
                            this.errorHandler.tolerate(this.unexpectedTokenError(e, t));
                        };
                        e.prototype.collectComments = function() {
                            if (!this.config.comment) {
                                this.scanner.scanComments();
                            } else {
                                var e = this.scanner.scanComments();
                                if (e.length > 0 && this.delegate) {
                                    for (var t = 0; t < e.length; ++t) {
                                        var i = e[t];
                                        var r = void 0;
                                        r = {
                                            type: i.multiLine ? "BlockComment" : "LineComment",
                                            value: this.scanner.source.slice(i.slice[0], i.slice[1])
                                        };
                                        if (this.config.range) {
                                            r.range = i.range;
                                        }
                                        if (this.config.loc) {
                                            r.loc = i.loc;
                                        }
                                        var s = {
                                            start: {
                                                line: i.loc.start.line,
                                                column: i.loc.start.column,
                                                offset: i.range[0]
                                            },
                                            end: {
                                                line: i.loc.end.line,
                                                column: i.loc.end.column,
                                                offset: i.range[1]
                                            }
                                        };
                                        this.delegate(r, s);
                                    }
                                }
                            }
                        };
                        e.prototype.getTokenRaw = function(e) {
                            return this.scanner.source.slice(e.start, e.end);
                        };
                        e.prototype.convertToken = function(e) {
                            var t = {
                                type: u.TokenName[e.type],
                                value: this.getTokenRaw(e)
                            };
                            if (this.config.range) {
                                t.range = [ e.start, e.end ];
                            }
                            if (this.config.loc) {
                                t.loc = {
                                    start: {
                                        line: this.startMarker.line,
                                        column: this.startMarker.column
                                    },
                                    end: {
                                        line: this.scanner.lineNumber,
                                        column: this.scanner.index - this.scanner.lineStart
                                    }
                                };
                            }
                            if (e.type === 9) {
                                var i = e.pattern;
                                var r = e.flags;
                                t.regex = {
                                    pattern: i,
                                    flags: r
                                };
                            }
                            return t;
                        };
                        e.prototype.nextToken = function() {
                            var e = this.lookahead;
                            this.lastMarker.index = this.scanner.index;
                            this.lastMarker.line = this.scanner.lineNumber;
                            this.lastMarker.column = this.scanner.index - this.scanner.lineStart;
                            this.collectComments();
                            if (this.scanner.index !== this.startMarker.index) {
                                this.startMarker.index = this.scanner.index;
                                this.startMarker.line = this.scanner.lineNumber;
                                this.startMarker.column = this.scanner.index - this.scanner.lineStart;
                            }
                            var t = this.scanner.lex();
                            this.hasLineTerminator = e.lineNumber !== t.lineNumber;
                            if (t && this.context.strict && t.type === 3) {
                                if (this.scanner.isStrictModeReservedWord(t.value)) {
                                    t.type = 4;
                                }
                            }
                            this.lookahead = t;
                            if (this.config.tokens && t.type !== 2) {
                                this.tokens.push(this.convertToken(t));
                            }
                            return e;
                        };
                        e.prototype.nextRegexToken = function() {
                            this.collectComments();
                            var e = this.scanner.scanRegExp();
                            if (this.config.tokens) {
                                this.tokens.pop();
                                this.tokens.push(this.convertToken(e));
                            }
                            this.lookahead = e;
                            this.nextToken();
                            return e;
                        };
                        e.prototype.createNode = function() {
                            return {
                                index: this.startMarker.index,
                                line: this.startMarker.line,
                                column: this.startMarker.column
                            };
                        };
                        e.prototype.startNode = function(e, t) {
                            if (t === void 0) {
                                t = 0;
                            }
                            var i = e.start - e.lineStart;
                            var r = e.lineNumber;
                            if (i < 0) {
                                i += t;
                                r--;
                            }
                            return {
                                index: e.start,
                                line: r,
                                column: i
                            };
                        };
                        e.prototype.finalize = function(e, t) {
                            if (this.config.range) {
                                t.range = [ e.index, this.lastMarker.index ];
                            }
                            if (this.config.loc) {
                                t.loc = {
                                    start: {
                                        line: e.line,
                                        column: e.column
                                    },
                                    end: {
                                        line: this.lastMarker.line,
                                        column: this.lastMarker.column
                                    }
                                };
                                if (this.config.source) {
                                    t.loc.source = this.config.source;
                                }
                            }
                            if (this.delegate) {
                                var i = {
                                    start: {
                                        line: e.line,
                                        column: e.column,
                                        offset: e.index
                                    },
                                    end: {
                                        line: this.lastMarker.line,
                                        column: this.lastMarker.column,
                                        offset: this.lastMarker.index
                                    }
                                };
                                this.delegate(t, i);
                            }
                            return t;
                        };
                        e.prototype.expect = function(e) {
                            var t = this.nextToken();
                            if (t.type !== 7 || t.value !== e) {
                                this.throwUnexpectedToken(t);
                            }
                        };
                        e.prototype.expectCommaSeparator = function() {
                            if (this.config.tolerant) {
                                var e = this.lookahead;
                                if (e.type === 7 && e.value === ",") {
                                    this.nextToken();
                                } else if (e.type === 7 && e.value === ";") {
                                    this.nextToken();
                                    this.tolerateUnexpectedToken(e);
                                } else {
                                    this.tolerateUnexpectedToken(e, a.Messages.UnexpectedToken);
                                }
                            } else {
                                this.expect(",");
                            }
                        };
                        e.prototype.expectKeyword = function(e) {
                            var t = this.nextToken();
                            if (t.type !== 4 || t.value !== e) {
                                this.throwUnexpectedToken(t);
                            }
                        };
                        e.prototype.match = function(e) {
                            return this.lookahead.type === 7 && this.lookahead.value === e;
                        };
                        e.prototype.matchKeyword = function(e) {
                            return this.lookahead.type === 4 && this.lookahead.value === e;
                        };
                        e.prototype.matchContextualKeyword = function(e) {
                            return this.lookahead.type === 3 && this.lookahead.value === e;
                        };
                        e.prototype.matchAssign = function() {
                            if (this.lookahead.type !== 7) {
                                return false;
                            }
                            var e = this.lookahead.value;
                            return e === "=" || e === "*=" || e === "**=" || e === "/=" || e === "%=" || e === "+=" || e === "-=" || e === "<<=" || e === ">>=" || e === ">>>=" || e === "&=" || e === "^=" || e === "|=";
                        };
                        e.prototype.isolateCoverGrammar = function(e) {
                            var t = this.context.isBindingElement;
                            var i = this.context.isAssignmentTarget;
                            var r = this.context.firstCoverInitializedNameError;
                            this.context.isBindingElement = true;
                            this.context.isAssignmentTarget = true;
                            this.context.firstCoverInitializedNameError = null;
                            var s = e.call(this);
                            if (this.context.firstCoverInitializedNameError !== null) {
                                this.throwUnexpectedToken(this.context.firstCoverInitializedNameError);
                            }
                            this.context.isBindingElement = t;
                            this.context.isAssignmentTarget = i;
                            this.context.firstCoverInitializedNameError = r;
                            return s;
                        };
                        e.prototype.inheritCoverGrammar = function(e) {
                            var t = this.context.isBindingElement;
                            var i = this.context.isAssignmentTarget;
                            var r = this.context.firstCoverInitializedNameError;
                            this.context.isBindingElement = true;
                            this.context.isAssignmentTarget = true;
                            this.context.firstCoverInitializedNameError = null;
                            var s = e.call(this);
                            this.context.isBindingElement = this.context.isBindingElement && t;
                            this.context.isAssignmentTarget = this.context.isAssignmentTarget && i;
                            this.context.firstCoverInitializedNameError = r || this.context.firstCoverInitializedNameError;
                            return s;
                        };
                        e.prototype.consumeSemicolon = function() {
                            if (this.match(";")) {
                                this.nextToken();
                            } else if (!this.hasLineTerminator) {
                                if (this.lookahead.type !== 2 && !this.match("}")) {
                                    this.throwUnexpectedToken(this.lookahead);
                                }
                                this.lastMarker.index = this.startMarker.index;
                                this.lastMarker.line = this.startMarker.line;
                                this.lastMarker.column = this.startMarker.column;
                            }
                        };
                        e.prototype.parsePrimaryExpression = function() {
                            var e = this.createNode();
                            var t;
                            var i, r;
                            switch (this.lookahead.type) {
                              case 3:
                                if ((this.context.isModule || this.context.await) && this.lookahead.value === "await") {
                                    this.tolerateUnexpectedToken(this.lookahead);
                                }
                                t = this.matchAsyncFunction() ? this.parseFunctionExpression() : this.finalize(e, new n.Identifier(this.nextToken().value));
                                break;

                              case 6:
                              case 8:
                                if (this.context.strict && this.lookahead.octal) {
                                    this.tolerateUnexpectedToken(this.lookahead, a.Messages.StrictOctalLiteral);
                                }
                                this.context.isAssignmentTarget = false;
                                this.context.isBindingElement = false;
                                i = this.nextToken();
                                r = this.getTokenRaw(i);
                                t = this.finalize(e, new n.Literal(i.value, r));
                                break;

                              case 1:
                                this.context.isAssignmentTarget = false;
                                this.context.isBindingElement = false;
                                i = this.nextToken();
                                r = this.getTokenRaw(i);
                                t = this.finalize(e, new n.Literal(i.value === "true", r));
                                break;

                              case 5:
                                this.context.isAssignmentTarget = false;
                                this.context.isBindingElement = false;
                                i = this.nextToken();
                                r = this.getTokenRaw(i);
                                t = this.finalize(e, new n.Literal(null, r));
                                break;

                              case 10:
                                t = this.parseTemplateLiteral();
                                break;

                              case 7:
                                switch (this.lookahead.value) {
                                  case "(":
                                    this.context.isBindingElement = false;
                                    t = this.inheritCoverGrammar(this.parseGroupExpression);
                                    break;

                                  case "[":
                                    t = this.inheritCoverGrammar(this.parseArrayInitializer);
                                    break;

                                  case "{":
                                    t = this.inheritCoverGrammar(this.parseObjectInitializer);
                                    break;

                                  case "/":
                                  case "/=":
                                    this.context.isAssignmentTarget = false;
                                    this.context.isBindingElement = false;
                                    this.scanner.index = this.startMarker.index;
                                    i = this.nextRegexToken();
                                    r = this.getTokenRaw(i);
                                    t = this.finalize(e, new n.RegexLiteral(i.regex, r, i.pattern, i.flags));
                                    break;

                                  default:
                                    t = this.throwUnexpectedToken(this.nextToken());
                                }
                                break;

                              case 4:
                                if (!this.context.strict && this.context.allowYield && this.matchKeyword("yield")) {
                                    t = this.parseIdentifierName();
                                } else if (!this.context.strict && this.matchKeyword("let")) {
                                    t = this.finalize(e, new n.Identifier(this.nextToken().value));
                                } else {
                                    this.context.isAssignmentTarget = false;
                                    this.context.isBindingElement = false;
                                    if (this.matchKeyword("function")) {
                                        t = this.parseFunctionExpression();
                                    } else if (this.matchKeyword("this")) {
                                        this.nextToken();
                                        t = this.finalize(e, new n.ThisExpression());
                                    } else if (this.matchKeyword("class")) {
                                        t = this.parseClassExpression();
                                    } else {
                                        t = this.throwUnexpectedToken(this.nextToken());
                                    }
                                }
                                break;

                              default:
                                t = this.throwUnexpectedToken(this.nextToken());
                            }
                            return t;
                        };
                        e.prototype.parseSpreadElement = function() {
                            var e = this.createNode();
                            this.expect("...");
                            var t = this.inheritCoverGrammar(this.parseAssignmentExpression);
                            return this.finalize(e, new n.SpreadElement(t));
                        };
                        e.prototype.parseArrayInitializer = function() {
                            var e = this.createNode();
                            var t = [];
                            this.expect("[");
                            while (!this.match("]")) {
                                if (this.match(",")) {
                                    this.nextToken();
                                    t.push(null);
                                } else if (this.match("...")) {
                                    var i = this.parseSpreadElement();
                                    if (!this.match("]")) {
                                        this.context.isAssignmentTarget = false;
                                        this.context.isBindingElement = false;
                                        this.expect(",");
                                    }
                                    t.push(i);
                                } else {
                                    t.push(this.inheritCoverGrammar(this.parseAssignmentExpression));
                                    if (!this.match("]")) {
                                        this.expect(",");
                                    }
                                }
                            }
                            this.expect("]");
                            return this.finalize(e, new n.ArrayExpression(t));
                        };
                        e.prototype.parsePropertyMethod = function(e) {
                            this.context.isAssignmentTarget = false;
                            this.context.isBindingElement = false;
                            var t = this.context.strict;
                            var i = this.context.allowStrictDirective;
                            this.context.allowStrictDirective = e.simple;
                            var r = this.isolateCoverGrammar(this.parseFunctionSourceElements);
                            if (this.context.strict && e.firstRestricted) {
                                this.tolerateUnexpectedToken(e.firstRestricted, e.message);
                            }
                            if (this.context.strict && e.stricted) {
                                this.tolerateUnexpectedToken(e.stricted, e.message);
                            }
                            this.context.strict = t;
                            this.context.allowStrictDirective = i;
                            return r;
                        };
                        e.prototype.parsePropertyMethodFunction = function() {
                            var e = false;
                            var t = this.createNode();
                            var i = this.context.allowYield;
                            this.context.allowYield = true;
                            var r = this.parseFormalParameters();
                            var s = this.parsePropertyMethod(r);
                            this.context.allowYield = i;
                            return this.finalize(t, new n.FunctionExpression(null, r.params, s, e));
                        };
                        e.prototype.parsePropertyMethodAsyncFunction = function() {
                            var e = this.createNode();
                            var t = this.context.allowYield;
                            var i = this.context.await;
                            this.context.allowYield = false;
                            this.context.await = true;
                            var r = this.parseFormalParameters();
                            var s = this.parsePropertyMethod(r);
                            this.context.allowYield = t;
                            this.context.await = i;
                            return this.finalize(e, new n.AsyncFunctionExpression(null, r.params, s));
                        };
                        e.prototype.parseObjectPropertyKey = function() {
                            var e = this.createNode();
                            var t = this.nextToken();
                            var i;
                            switch (t.type) {
                              case 8:
                              case 6:
                                if (this.context.strict && t.octal) {
                                    this.tolerateUnexpectedToken(t, a.Messages.StrictOctalLiteral);
                                }
                                var r = this.getTokenRaw(t);
                                i = this.finalize(e, new n.Literal(t.value, r));
                                break;

                              case 3:
                              case 1:
                              case 5:
                              case 4:
                                i = this.finalize(e, new n.Identifier(t.value));
                                break;

                              case 7:
                                if (t.value === "[") {
                                    i = this.isolateCoverGrammar(this.parseAssignmentExpression);
                                    this.expect("]");
                                } else {
                                    i = this.throwUnexpectedToken(t);
                                }
                                break;

                              default:
                                i = this.throwUnexpectedToken(t);
                            }
                            return i;
                        };
                        e.prototype.isPropertyKey = function(e, t) {
                            return e.type === l.Syntax.Identifier && e.name === t || e.type === l.Syntax.Literal && e.value === t;
                        };
                        e.prototype.parseObjectProperty = function(e) {
                            var t = this.createNode();
                            var i = this.lookahead;
                            var r;
                            var s = null;
                            var o = null;
                            var l = false;
                            var u = false;
                            var c = false;
                            var h = false;
                            if (i.type === 3) {
                                var p = i.value;
                                this.nextToken();
                                l = this.match("[");
                                h = !this.hasLineTerminator && p === "async" && !this.match(":") && !this.match("(") && !this.match("*") && !this.match(",");
                                s = h ? this.parseObjectPropertyKey() : this.finalize(t, new n.Identifier(p));
                            } else if (this.match("*")) {
                                this.nextToken();
                            } else {
                                l = this.match("[");
                                s = this.parseObjectPropertyKey();
                            }
                            var f = this.qualifiedPropertyName(this.lookahead);
                            if (i.type === 3 && !h && i.value === "get" && f) {
                                r = "get";
                                l = this.match("[");
                                s = this.parseObjectPropertyKey();
                                this.context.allowYield = false;
                                o = this.parseGetterMethod();
                            } else if (i.type === 3 && !h && i.value === "set" && f) {
                                r = "set";
                                l = this.match("[");
                                s = this.parseObjectPropertyKey();
                                o = this.parseSetterMethod();
                            } else if (i.type === 7 && i.value === "*" && f) {
                                r = "init";
                                l = this.match("[");
                                s = this.parseObjectPropertyKey();
                                o = this.parseGeneratorMethod();
                                u = true;
                            } else {
                                if (!s) {
                                    this.throwUnexpectedToken(this.lookahead);
                                }
                                r = "init";
                                if (this.match(":") && !h) {
                                    if (!l && this.isPropertyKey(s, "__proto__")) {
                                        if (e.value) {
                                            this.tolerateError(a.Messages.DuplicateProtoProperty);
                                        }
                                        e.value = true;
                                    }
                                    this.nextToken();
                                    o = this.inheritCoverGrammar(this.parseAssignmentExpression);
                                } else if (this.match("(")) {
                                    o = h ? this.parsePropertyMethodAsyncFunction() : this.parsePropertyMethodFunction();
                                    u = true;
                                } else if (i.type === 3) {
                                    var p = this.finalize(t, new n.Identifier(i.value));
                                    if (this.match("=")) {
                                        this.context.firstCoverInitializedNameError = this.lookahead;
                                        this.nextToken();
                                        c = true;
                                        var d = this.isolateCoverGrammar(this.parseAssignmentExpression);
                                        o = this.finalize(t, new n.AssignmentPattern(p, d));
                                    } else {
                                        c = true;
                                        o = p;
                                    }
                                } else {
                                    this.throwUnexpectedToken(this.nextToken());
                                }
                            }
                            return this.finalize(t, new n.Property(r, s, l, o, u, c));
                        };
                        e.prototype.parseObjectInitializer = function() {
                            var e = this.createNode();
                            this.expect("{");
                            var t = [];
                            var i = {
                                value: false
                            };
                            while (!this.match("}")) {
                                t.push(this.parseObjectProperty(i));
                                if (!this.match("}")) {
                                    this.expectCommaSeparator();
                                }
                            }
                            this.expect("}");
                            return this.finalize(e, new n.ObjectExpression(t));
                        };
                        e.prototype.parseTemplateHead = function() {
                            r.assert(this.lookahead.head, "Template literal must start with a template head");
                            var e = this.createNode();
                            var t = this.nextToken();
                            var i = t.value;
                            var s = t.cooked;
                            return this.finalize(e, new n.TemplateElement({
                                raw: i,
                                cooked: s
                            }, t.tail));
                        };
                        e.prototype.parseTemplateElement = function() {
                            if (this.lookahead.type !== 10) {
                                this.throwUnexpectedToken();
                            }
                            var e = this.createNode();
                            var t = this.nextToken();
                            var i = t.value;
                            var r = t.cooked;
                            return this.finalize(e, new n.TemplateElement({
                                raw: i,
                                cooked: r
                            }, t.tail));
                        };
                        e.prototype.parseTemplateLiteral = function() {
                            var e = this.createNode();
                            var t = [];
                            var i = [];
                            var r = this.parseTemplateHead();
                            i.push(r);
                            while (!r.tail) {
                                t.push(this.parseExpression());
                                r = this.parseTemplateElement();
                                i.push(r);
                            }
                            return this.finalize(e, new n.TemplateLiteral(i, t));
                        };
                        e.prototype.reinterpretExpressionAsPattern = function(e) {
                            switch (e.type) {
                              case l.Syntax.Identifier:
                              case l.Syntax.MemberExpression:
                              case l.Syntax.RestElement:
                              case l.Syntax.AssignmentPattern:
                                break;

                              case l.Syntax.SpreadElement:
                                e.type = l.Syntax.RestElement;
                                this.reinterpretExpressionAsPattern(e.argument);
                                break;

                              case l.Syntax.ArrayExpression:
                                e.type = l.Syntax.ArrayPattern;
                                for (var t = 0; t < e.elements.length; t++) {
                                    if (e.elements[t] !== null) {
                                        this.reinterpretExpressionAsPattern(e.elements[t]);
                                    }
                                }
                                break;

                              case l.Syntax.ObjectExpression:
                                e.type = l.Syntax.ObjectPattern;
                                for (var t = 0; t < e.properties.length; t++) {
                                    this.reinterpretExpressionAsPattern(e.properties[t].value);
                                }
                                break;

                              case l.Syntax.AssignmentExpression:
                                e.type = l.Syntax.AssignmentPattern;
                                delete e.operator;
                                this.reinterpretExpressionAsPattern(e.left);
                                break;

                              default:
                                break;
                            }
                        };
                        e.prototype.parseGroupExpression = function() {
                            var e;
                            this.expect("(");
                            if (this.match(")")) {
                                this.nextToken();
                                if (!this.match("=>")) {
                                    this.expect("=>");
                                }
                                e = {
                                    type: c,
                                    params: [],
                                    async: false
                                };
                            } else {
                                var t = this.lookahead;
                                var i = [];
                                if (this.match("...")) {
                                    e = this.parseRestElement(i);
                                    this.expect(")");
                                    if (!this.match("=>")) {
                                        this.expect("=>");
                                    }
                                    e = {
                                        type: c,
                                        params: [ e ],
                                        async: false
                                    };
                                } else {
                                    var r = false;
                                    this.context.isBindingElement = true;
                                    e = this.inheritCoverGrammar(this.parseAssignmentExpression);
                                    if (this.match(",")) {
                                        var s = [];
                                        this.context.isAssignmentTarget = false;
                                        s.push(e);
                                        while (this.lookahead.type !== 2) {
                                            if (!this.match(",")) {
                                                break;
                                            }
                                            this.nextToken();
                                            if (this.match(")")) {
                                                this.nextToken();
                                                for (var a = 0; a < s.length; a++) {
                                                    this.reinterpretExpressionAsPattern(s[a]);
                                                }
                                                r = true;
                                                e = {
                                                    type: c,
                                                    params: s,
                                                    async: false
                                                };
                                            } else if (this.match("...")) {
                                                if (!this.context.isBindingElement) {
                                                    this.throwUnexpectedToken(this.lookahead);
                                                }
                                                s.push(this.parseRestElement(i));
                                                this.expect(")");
                                                if (!this.match("=>")) {
                                                    this.expect("=>");
                                                }
                                                this.context.isBindingElement = false;
                                                for (var a = 0; a < s.length; a++) {
                                                    this.reinterpretExpressionAsPattern(s[a]);
                                                }
                                                r = true;
                                                e = {
                                                    type: c,
                                                    params: s,
                                                    async: false
                                                };
                                            } else {
                                                s.push(this.inheritCoverGrammar(this.parseAssignmentExpression));
                                            }
                                            if (r) {
                                                break;
                                            }
                                        }
                                        if (!r) {
                                            e = this.finalize(this.startNode(t), new n.SequenceExpression(s));
                                        }
                                    }
                                    if (!r) {
                                        this.expect(")");
                                        if (this.match("=>")) {
                                            if (e.type === l.Syntax.Identifier && e.name === "yield") {
                                                r = true;
                                                e = {
                                                    type: c,
                                                    params: [ e ],
                                                    async: false
                                                };
                                            }
                                            if (!r) {
                                                if (!this.context.isBindingElement) {
                                                    this.throwUnexpectedToken(this.lookahead);
                                                }
                                                if (e.type === l.Syntax.SequenceExpression) {
                                                    for (var a = 0; a < e.expressions.length; a++) {
                                                        this.reinterpretExpressionAsPattern(e.expressions[a]);
                                                    }
                                                } else {
                                                    this.reinterpretExpressionAsPattern(e);
                                                }
                                                var o = e.type === l.Syntax.SequenceExpression ? e.expressions : [ e ];
                                                e = {
                                                    type: c,
                                                    params: o,
                                                    async: false
                                                };
                                            }
                                        }
                                        this.context.isBindingElement = false;
                                    }
                                }
                            }
                            return e;
                        };
                        e.prototype.parseArguments = function() {
                            this.expect("(");
                            var e = [];
                            if (!this.match(")")) {
                                while (true) {
                                    var t = this.match("...") ? this.parseSpreadElement() : this.isolateCoverGrammar(this.parseAssignmentExpression);
                                    e.push(t);
                                    if (this.match(")")) {
                                        break;
                                    }
                                    this.expectCommaSeparator();
                                    if (this.match(")")) {
                                        break;
                                    }
                                }
                            }
                            this.expect(")");
                            return e;
                        };
                        e.prototype.isIdentifierName = function(e) {
                            return e.type === 3 || e.type === 4 || e.type === 1 || e.type === 5;
                        };
                        e.prototype.parseIdentifierName = function() {
                            var e = this.createNode();
                            var t = this.nextToken();
                            if (!this.isIdentifierName(t)) {
                                this.throwUnexpectedToken(t);
                            }
                            return this.finalize(e, new n.Identifier(t.value));
                        };
                        e.prototype.parseNewExpression = function() {
                            var e = this.createNode();
                            var t = this.parseIdentifierName();
                            r.assert(t.name === "new", "New expression must start with `new`");
                            var i;
                            if (this.match(".")) {
                                this.nextToken();
                                if (this.lookahead.type === 3 && this.context.inFunctionBody && this.lookahead.value === "target") {
                                    var s = this.parseIdentifierName();
                                    i = new n.MetaProperty(t, s);
                                } else {
                                    this.throwUnexpectedToken(this.lookahead);
                                }
                            } else {
                                var a = this.isolateCoverGrammar(this.parseLeftHandSideExpression);
                                var o = this.match("(") ? this.parseArguments() : [];
                                i = new n.NewExpression(a, o);
                                this.context.isAssignmentTarget = false;
                                this.context.isBindingElement = false;
                            }
                            return this.finalize(e, i);
                        };
                        e.prototype.parseAsyncArgument = function() {
                            var e = this.parseAssignmentExpression();
                            this.context.firstCoverInitializedNameError = null;
                            return e;
                        };
                        e.prototype.parseAsyncArguments = function() {
                            this.expect("(");
                            var e = [];
                            if (!this.match(")")) {
                                while (true) {
                                    var t = this.match("...") ? this.parseSpreadElement() : this.isolateCoverGrammar(this.parseAsyncArgument);
                                    e.push(t);
                                    if (this.match(")")) {
                                        break;
                                    }
                                    this.expectCommaSeparator();
                                    if (this.match(")")) {
                                        break;
                                    }
                                }
                            }
                            this.expect(")");
                            return e;
                        };
                        e.prototype.parseLeftHandSideExpressionAllowCall = function() {
                            var e = this.lookahead;
                            var t = this.matchContextualKeyword("async");
                            var i = this.context.allowIn;
                            this.context.allowIn = true;
                            var r;
                            if (this.matchKeyword("super") && this.context.inFunctionBody) {
                                r = this.createNode();
                                this.nextToken();
                                r = this.finalize(r, new n.Super());
                                if (!this.match("(") && !this.match(".") && !this.match("[")) {
                                    this.throwUnexpectedToken(this.lookahead);
                                }
                            } else {
                                r = this.inheritCoverGrammar(this.matchKeyword("new") ? this.parseNewExpression : this.parsePrimaryExpression);
                            }
                            while (true) {
                                if (this.match(".")) {
                                    this.context.isBindingElement = false;
                                    this.context.isAssignmentTarget = true;
                                    this.expect(".");
                                    var s = this.parseIdentifierName();
                                    r = this.finalize(this.startNode(e), new n.StaticMemberExpression(r, s));
                                } else if (this.match("(")) {
                                    var a = t && e.lineNumber === this.lookahead.lineNumber;
                                    this.context.isBindingElement = false;
                                    this.context.isAssignmentTarget = false;
                                    var o = a ? this.parseAsyncArguments() : this.parseArguments();
                                    r = this.finalize(this.startNode(e), new n.CallExpression(r, o));
                                    if (a && this.match("=>")) {
                                        for (var l = 0; l < o.length; ++l) {
                                            this.reinterpretExpressionAsPattern(o[l]);
                                        }
                                        r = {
                                            type: c,
                                            params: o,
                                            async: true
                                        };
                                    }
                                } else if (this.match("[")) {
                                    this.context.isBindingElement = false;
                                    this.context.isAssignmentTarget = true;
                                    this.expect("[");
                                    var s = this.isolateCoverGrammar(this.parseExpression);
                                    this.expect("]");
                                    r = this.finalize(this.startNode(e), new n.ComputedMemberExpression(r, s));
                                } else if (this.lookahead.type === 10 && this.lookahead.head) {
                                    var u = this.parseTemplateLiteral();
                                    r = this.finalize(this.startNode(e), new n.TaggedTemplateExpression(r, u));
                                } else {
                                    break;
                                }
                            }
                            this.context.allowIn = i;
                            return r;
                        };
                        e.prototype.parseSuper = function() {
                            var e = this.createNode();
                            this.expectKeyword("super");
                            if (!this.match("[") && !this.match(".")) {
                                this.throwUnexpectedToken(this.lookahead);
                            }
                            return this.finalize(e, new n.Super());
                        };
                        e.prototype.parseLeftHandSideExpression = function() {
                            r.assert(this.context.allowIn, "callee of new expression always allow in keyword.");
                            var e = this.startNode(this.lookahead);
                            var t = this.matchKeyword("super") && this.context.inFunctionBody ? this.parseSuper() : this.inheritCoverGrammar(this.matchKeyword("new") ? this.parseNewExpression : this.parsePrimaryExpression);
                            while (true) {
                                if (this.match("[")) {
                                    this.context.isBindingElement = false;
                                    this.context.isAssignmentTarget = true;
                                    this.expect("[");
                                    var i = this.isolateCoverGrammar(this.parseExpression);
                                    this.expect("]");
                                    t = this.finalize(e, new n.ComputedMemberExpression(t, i));
                                } else if (this.match(".")) {
                                    this.context.isBindingElement = false;
                                    this.context.isAssignmentTarget = true;
                                    this.expect(".");
                                    var i = this.parseIdentifierName();
                                    t = this.finalize(e, new n.StaticMemberExpression(t, i));
                                } else if (this.lookahead.type === 10 && this.lookahead.head) {
                                    var s = this.parseTemplateLiteral();
                                    t = this.finalize(e, new n.TaggedTemplateExpression(t, s));
                                } else {
                                    break;
                                }
                            }
                            return t;
                        };
                        e.prototype.parseUpdateExpression = function() {
                            var e;
                            var t = this.lookahead;
                            if (this.match("++") || this.match("--")) {
                                var i = this.startNode(t);
                                var r = this.nextToken();
                                e = this.inheritCoverGrammar(this.parseUnaryExpression);
                                if (this.context.strict && e.type === l.Syntax.Identifier && this.scanner.isRestrictedWord(e.name)) {
                                    this.tolerateError(a.Messages.StrictLHSPrefix);
                                }
                                if (!this.context.isAssignmentTarget) {
                                    this.tolerateError(a.Messages.InvalidLHSInAssignment);
                                }
                                var s = true;
                                e = this.finalize(i, new n.UpdateExpression(r.value, e, s));
                                this.context.isAssignmentTarget = false;
                                this.context.isBindingElement = false;
                            } else {
                                e = this.inheritCoverGrammar(this.parseLeftHandSideExpressionAllowCall);
                                if (!this.hasLineTerminator && this.lookahead.type === 7) {
                                    if (this.match("++") || this.match("--")) {
                                        if (this.context.strict && e.type === l.Syntax.Identifier && this.scanner.isRestrictedWord(e.name)) {
                                            this.tolerateError(a.Messages.StrictLHSPostfix);
                                        }
                                        if (!this.context.isAssignmentTarget) {
                                            this.tolerateError(a.Messages.InvalidLHSInAssignment);
                                        }
                                        this.context.isAssignmentTarget = false;
                                        this.context.isBindingElement = false;
                                        var o = this.nextToken().value;
                                        var s = false;
                                        e = this.finalize(this.startNode(t), new n.UpdateExpression(o, e, s));
                                    }
                                }
                            }
                            return e;
                        };
                        e.prototype.parseAwaitExpression = function() {
                            var e = this.createNode();
                            this.nextToken();
                            var t = this.parseUnaryExpression();
                            return this.finalize(e, new n.AwaitExpression(t));
                        };
                        e.prototype.parseUnaryExpression = function() {
                            var e;
                            if (this.match("+") || this.match("-") || this.match("~") || this.match("!") || this.matchKeyword("delete") || this.matchKeyword("void") || this.matchKeyword("typeof")) {
                                var t = this.startNode(this.lookahead);
                                var i = this.nextToken();
                                e = this.inheritCoverGrammar(this.parseUnaryExpression);
                                e = this.finalize(t, new n.UnaryExpression(i.value, e));
                                if (this.context.strict && e.operator === "delete" && e.argument.type === l.Syntax.Identifier) {
                                    this.tolerateError(a.Messages.StrictDelete);
                                }
                                this.context.isAssignmentTarget = false;
                                this.context.isBindingElement = false;
                            } else if (this.context.await && this.matchContextualKeyword("await")) {
                                e = this.parseAwaitExpression();
                            } else {
                                e = this.parseUpdateExpression();
                            }
                            return e;
                        };
                        e.prototype.parseExponentiationExpression = function() {
                            var e = this.lookahead;
                            var t = this.inheritCoverGrammar(this.parseUnaryExpression);
                            if (t.type !== l.Syntax.UnaryExpression && this.match("**")) {
                                this.nextToken();
                                this.context.isAssignmentTarget = false;
                                this.context.isBindingElement = false;
                                var i = t;
                                var r = this.isolateCoverGrammar(this.parseExponentiationExpression);
                                t = this.finalize(this.startNode(e), new n.BinaryExpression("**", i, r));
                            }
                            return t;
                        };
                        e.prototype.binaryPrecedence = function(e) {
                            var t = e.value;
                            var i;
                            if (e.type === 7) {
                                i = this.operatorPrecedence[t] || 0;
                            } else if (e.type === 4) {
                                i = t === "instanceof" || this.context.allowIn && t === "in" ? 7 : 0;
                            } else {
                                i = 0;
                            }
                            return i;
                        };
                        e.prototype.parseBinaryExpression = function() {
                            var e = this.lookahead;
                            var t = this.inheritCoverGrammar(this.parseExponentiationExpression);
                            var i = this.lookahead;
                            var r = this.binaryPrecedence(i);
                            if (r > 0) {
                                this.nextToken();
                                this.context.isAssignmentTarget = false;
                                this.context.isBindingElement = false;
                                var s = [ e, this.lookahead ];
                                var a = t;
                                var o = this.isolateCoverGrammar(this.parseExponentiationExpression);
                                var l = [ a, i.value, o ];
                                var u = [ r ];
                                while (true) {
                                    r = this.binaryPrecedence(this.lookahead);
                                    if (r <= 0) {
                                        break;
                                    }
                                    while (l.length > 2 && r <= u[u.length - 1]) {
                                        o = l.pop();
                                        var c = l.pop();
                                        u.pop();
                                        a = l.pop();
                                        s.pop();
                                        var h = this.startNode(s[s.length - 1]);
                                        l.push(this.finalize(h, new n.BinaryExpression(c, a, o)));
                                    }
                                    l.push(this.nextToken().value);
                                    u.push(r);
                                    s.push(this.lookahead);
                                    l.push(this.isolateCoverGrammar(this.parseExponentiationExpression));
                                }
                                var p = l.length - 1;
                                t = l[p];
                                var f = s.pop();
                                while (p > 1) {
                                    var d = s.pop();
                                    var m = f && f.lineStart;
                                    var h = this.startNode(d, m);
                                    var c = l[p - 1];
                                    t = this.finalize(h, new n.BinaryExpression(c, l[p - 2], t));
                                    p -= 2;
                                    f = d;
                                }
                            }
                            return t;
                        };
                        e.prototype.parseConditionalExpression = function() {
                            var e = this.lookahead;
                            var t = this.inheritCoverGrammar(this.parseBinaryExpression);
                            if (this.match("?")) {
                                this.nextToken();
                                var i = this.context.allowIn;
                                this.context.allowIn = true;
                                var r = this.isolateCoverGrammar(this.parseAssignmentExpression);
                                this.context.allowIn = i;
                                this.expect(":");
                                var s = this.isolateCoverGrammar(this.parseAssignmentExpression);
                                t = this.finalize(this.startNode(e), new n.ConditionalExpression(t, r, s));
                                this.context.isAssignmentTarget = false;
                                this.context.isBindingElement = false;
                            }
                            return t;
                        };
                        e.prototype.checkPatternParam = function(e, t) {
                            switch (t.type) {
                              case l.Syntax.Identifier:
                                this.validateParam(e, t, t.name);
                                break;

                              case l.Syntax.RestElement:
                                this.checkPatternParam(e, t.argument);
                                break;

                              case l.Syntax.AssignmentPattern:
                                this.checkPatternParam(e, t.left);
                                break;

                              case l.Syntax.ArrayPattern:
                                for (var i = 0; i < t.elements.length; i++) {
                                    if (t.elements[i] !== null) {
                                        this.checkPatternParam(e, t.elements[i]);
                                    }
                                }
                                break;

                              case l.Syntax.ObjectPattern:
                                for (var i = 0; i < t.properties.length; i++) {
                                    this.checkPatternParam(e, t.properties[i].value);
                                }
                                break;

                              default:
                                break;
                            }
                            e.simple = e.simple && t instanceof n.Identifier;
                        };
                        e.prototype.reinterpretAsCoverFormalsList = function(e) {
                            var t = [ e ];
                            var i;
                            var r = false;
                            switch (e.type) {
                              case l.Syntax.Identifier:
                                break;

                              case c:
                                t = e.params;
                                r = e.async;
                                break;

                              default:
                                return null;
                            }
                            i = {
                                simple: true,
                                paramSet: {}
                            };
                            for (var s = 0; s < t.length; ++s) {
                                var n = t[s];
                                if (n.type === l.Syntax.AssignmentPattern) {
                                    if (n.right.type === l.Syntax.YieldExpression) {
                                        if (n.right.argument) {
                                            this.throwUnexpectedToken(this.lookahead);
                                        }
                                        n.right.type = l.Syntax.Identifier;
                                        n.right.name = "yield";
                                        delete n.right.argument;
                                        delete n.right.delegate;
                                    }
                                } else if (r && n.type === l.Syntax.Identifier && n.name === "await") {
                                    this.throwUnexpectedToken(this.lookahead);
                                }
                                this.checkPatternParam(i, n);
                                t[s] = n;
                            }
                            if (this.context.strict || !this.context.allowYield) {
                                for (var s = 0; s < t.length; ++s) {
                                    var n = t[s];
                                    if (n.type === l.Syntax.YieldExpression) {
                                        this.throwUnexpectedToken(this.lookahead);
                                    }
                                }
                            }
                            if (i.message === a.Messages.StrictParamDupe) {
                                var o = this.context.strict ? i.stricted : i.firstRestricted;
                                this.throwUnexpectedToken(o, i.message);
                            }
                            return {
                                simple: i.simple,
                                params: t,
                                stricted: i.stricted,
                                firstRestricted: i.firstRestricted,
                                message: i.message
                            };
                        };
                        e.prototype.parseAssignmentExpression = function() {
                            var e;
                            if (!this.context.allowYield && this.matchKeyword("yield")) {
                                e = this.parseYieldExpression();
                            } else {
                                var t = this.lookahead;
                                var i = t;
                                e = this.parseConditionalExpression();
                                if (i.type === 3 && i.lineNumber === this.lookahead.lineNumber && i.value === "async") {
                                    if (this.lookahead.type === 3 || this.matchKeyword("yield")) {
                                        var r = this.parsePrimaryExpression();
                                        this.reinterpretExpressionAsPattern(r);
                                        e = {
                                            type: c,
                                            params: [ r ],
                                            async: true
                                        };
                                    }
                                }
                                if (e.type === c || this.match("=>")) {
                                    this.context.isAssignmentTarget = false;
                                    this.context.isBindingElement = false;
                                    var s = e.async;
                                    var o = this.reinterpretAsCoverFormalsList(e);
                                    if (o) {
                                        if (this.hasLineTerminator) {
                                            this.tolerateUnexpectedToken(this.lookahead);
                                        }
                                        this.context.firstCoverInitializedNameError = null;
                                        var u = this.context.strict;
                                        var h = this.context.allowStrictDirective;
                                        this.context.allowStrictDirective = o.simple;
                                        var p = this.context.allowYield;
                                        var f = this.context.await;
                                        this.context.allowYield = true;
                                        this.context.await = s;
                                        var d = this.startNode(t);
                                        this.expect("=>");
                                        var m = void 0;
                                        if (this.match("{")) {
                                            var y = this.context.allowIn;
                                            this.context.allowIn = true;
                                            m = this.parseFunctionSourceElements();
                                            this.context.allowIn = y;
                                        } else {
                                            m = this.isolateCoverGrammar(this.parseAssignmentExpression);
                                        }
                                        var v = m.type !== l.Syntax.BlockStatement;
                                        if (this.context.strict && o.firstRestricted) {
                                            this.throwUnexpectedToken(o.firstRestricted, o.message);
                                        }
                                        if (this.context.strict && o.stricted) {
                                            this.tolerateUnexpectedToken(o.stricted, o.message);
                                        }
                                        e = s ? this.finalize(d, new n.AsyncArrowFunctionExpression(o.params, m, v)) : this.finalize(d, new n.ArrowFunctionExpression(o.params, m, v));
                                        this.context.strict = u;
                                        this.context.allowStrictDirective = h;
                                        this.context.allowYield = p;
                                        this.context.await = f;
                                    }
                                } else {
                                    if (this.matchAssign()) {
                                        if (!this.context.isAssignmentTarget) {
                                            this.tolerateError(a.Messages.InvalidLHSInAssignment);
                                        }
                                        if (this.context.strict && e.type === l.Syntax.Identifier) {
                                            var x = e;
                                            if (this.scanner.isRestrictedWord(x.name)) {
                                                this.tolerateUnexpectedToken(i, a.Messages.StrictLHSAssignment);
                                            }
                                            if (this.scanner.isStrictModeReservedWord(x.name)) {
                                                this.tolerateUnexpectedToken(i, a.Messages.StrictReservedWord);
                                            }
                                        }
                                        if (!this.match("=")) {
                                            this.context.isAssignmentTarget = false;
                                            this.context.isBindingElement = false;
                                        } else {
                                            this.reinterpretExpressionAsPattern(e);
                                        }
                                        i = this.nextToken();
                                        var g = i.value;
                                        var b = this.isolateCoverGrammar(this.parseAssignmentExpression);
                                        e = this.finalize(this.startNode(t), new n.AssignmentExpression(g, e, b));
                                        this.context.firstCoverInitializedNameError = null;
                                    }
                                }
                            }
                            return e;
                        };
                        e.prototype.parseExpression = function() {
                            var e = this.lookahead;
                            var t = this.isolateCoverGrammar(this.parseAssignmentExpression);
                            if (this.match(",")) {
                                var i = [];
                                i.push(t);
                                while (this.lookahead.type !== 2) {
                                    if (!this.match(",")) {
                                        break;
                                    }
                                    this.nextToken();
                                    i.push(this.isolateCoverGrammar(this.parseAssignmentExpression));
                                }
                                t = this.finalize(this.startNode(e), new n.SequenceExpression(i));
                            }
                            return t;
                        };
                        e.prototype.parseStatementListItem = function() {
                            var e;
                            this.context.isAssignmentTarget = true;
                            this.context.isBindingElement = true;
                            if (this.lookahead.type === 4) {
                                switch (this.lookahead.value) {
                                  case "export":
                                    if (!this.context.isModule) {
                                        this.tolerateUnexpectedToken(this.lookahead, a.Messages.IllegalExportDeclaration);
                                    }
                                    e = this.parseExportDeclaration();
                                    break;

                                  case "import":
                                    if (!this.context.isModule) {
                                        this.tolerateUnexpectedToken(this.lookahead, a.Messages.IllegalImportDeclaration);
                                    }
                                    e = this.parseImportDeclaration();
                                    break;

                                  case "const":
                                    e = this.parseLexicalDeclaration({
                                        inFor: false
                                    });
                                    break;

                                  case "function":
                                    e = this.parseFunctionDeclaration();
                                    break;

                                  case "class":
                                    e = this.parseClassDeclaration();
                                    break;

                                  case "let":
                                    e = this.isLexicalDeclaration() ? this.parseLexicalDeclaration({
                                        inFor: false
                                    }) : this.parseStatement();
                                    break;

                                  default:
                                    e = this.parseStatement();
                                    break;
                                }
                            } else {
                                e = this.parseStatement();
                            }
                            return e;
                        };
                        e.prototype.parseBlock = function() {
                            var e = this.createNode();
                            this.expect("{");
                            var t = [];
                            while (true) {
                                if (this.match("}")) {
                                    break;
                                }
                                t.push(this.parseStatementListItem());
                            }
                            this.expect("}");
                            return this.finalize(e, new n.BlockStatement(t));
                        };
                        e.prototype.parseLexicalBinding = function(e, t) {
                            var i = this.createNode();
                            var r = [];
                            var s = this.parsePattern(r, e);
                            if (this.context.strict && s.type === l.Syntax.Identifier) {
                                if (this.scanner.isRestrictedWord(s.name)) {
                                    this.tolerateError(a.Messages.StrictVarName);
                                }
                            }
                            var o = null;
                            if (e === "const") {
                                if (!this.matchKeyword("in") && !this.matchContextualKeyword("of")) {
                                    if (this.match("=")) {
                                        this.nextToken();
                                        o = this.isolateCoverGrammar(this.parseAssignmentExpression);
                                    } else {
                                        this.throwError(a.Messages.DeclarationMissingInitializer, "const");
                                    }
                                }
                            } else if (!t.inFor && s.type !== l.Syntax.Identifier || this.match("=")) {
                                this.expect("=");
                                o = this.isolateCoverGrammar(this.parseAssignmentExpression);
                            }
                            return this.finalize(i, new n.VariableDeclarator(s, o));
                        };
                        e.prototype.parseBindingList = function(e, t) {
                            var i = [ this.parseLexicalBinding(e, t) ];
                            while (this.match(",")) {
                                this.nextToken();
                                i.push(this.parseLexicalBinding(e, t));
                            }
                            return i;
                        };
                        e.prototype.isLexicalDeclaration = function() {
                            var e = this.scanner.saveState();
                            this.scanner.scanComments();
                            var t = this.scanner.lex();
                            this.scanner.restoreState(e);
                            return t.type === 3 || t.type === 7 && t.value === "[" || t.type === 7 && t.value === "{" || t.type === 4 && t.value === "let" || t.type === 4 && t.value === "yield";
                        };
                        e.prototype.parseLexicalDeclaration = function(e) {
                            var t = this.createNode();
                            var i = this.nextToken().value;
                            r.assert(i === "let" || i === "const", "Lexical declaration must be either let or const");
                            var s = this.parseBindingList(i, e);
                            this.consumeSemicolon();
                            return this.finalize(t, new n.VariableDeclaration(s, i));
                        };
                        e.prototype.parseBindingRestElement = function(e, t) {
                            var i = this.createNode();
                            this.expect("...");
                            var r = this.parsePattern(e, t);
                            return this.finalize(i, new n.RestElement(r));
                        };
                        e.prototype.parseArrayPattern = function(e, t) {
                            var i = this.createNode();
                            this.expect("[");
                            var r = [];
                            while (!this.match("]")) {
                                if (this.match(",")) {
                                    this.nextToken();
                                    r.push(null);
                                } else {
                                    if (this.match("...")) {
                                        r.push(this.parseBindingRestElement(e, t));
                                        break;
                                    } else {
                                        r.push(this.parsePatternWithDefault(e, t));
                                    }
                                    if (!this.match("]")) {
                                        this.expect(",");
                                    }
                                }
                            }
                            this.expect("]");
                            return this.finalize(i, new n.ArrayPattern(r));
                        };
                        e.prototype.parsePropertyPattern = function(e, t) {
                            var i = this.createNode();
                            var r = false;
                            var s = false;
                            var a = false;
                            var o;
                            var l;
                            if (this.lookahead.type === 3) {
                                var u = this.lookahead;
                                o = this.parseVariableIdentifier();
                                var c = this.finalize(i, new n.Identifier(u.value));
                                if (this.match("=")) {
                                    e.push(u);
                                    s = true;
                                    this.nextToken();
                                    var h = this.parseAssignmentExpression();
                                    l = this.finalize(this.startNode(u), new n.AssignmentPattern(c, h));
                                } else if (!this.match(":")) {
                                    e.push(u);
                                    s = true;
                                    l = c;
                                } else {
                                    this.expect(":");
                                    l = this.parsePatternWithDefault(e, t);
                                }
                            } else {
                                r = this.match("[");
                                o = this.parseObjectPropertyKey();
                                this.expect(":");
                                l = this.parsePatternWithDefault(e, t);
                            }
                            return this.finalize(i, new n.Property("init", o, r, l, a, s));
                        };
                        e.prototype.parseObjectPattern = function(e, t) {
                            var i = this.createNode();
                            var r = [];
                            this.expect("{");
                            while (!this.match("}")) {
                                r.push(this.parsePropertyPattern(e, t));
                                if (!this.match("}")) {
                                    this.expect(",");
                                }
                            }
                            this.expect("}");
                            return this.finalize(i, new n.ObjectPattern(r));
                        };
                        e.prototype.parsePattern = function(e, t) {
                            var i;
                            if (this.match("[")) {
                                i = this.parseArrayPattern(e, t);
                            } else if (this.match("{")) {
                                i = this.parseObjectPattern(e, t);
                            } else {
                                if (this.matchKeyword("let") && (t === "const" || t === "let")) {
                                    this.tolerateUnexpectedToken(this.lookahead, a.Messages.LetInLexicalBinding);
                                }
                                e.push(this.lookahead);
                                i = this.parseVariableIdentifier(t);
                            }
                            return i;
                        };
                        e.prototype.parsePatternWithDefault = function(e, t) {
                            var i = this.lookahead;
                            var r = this.parsePattern(e, t);
                            if (this.match("=")) {
                                this.nextToken();
                                var s = this.context.allowYield;
                                this.context.allowYield = true;
                                var a = this.isolateCoverGrammar(this.parseAssignmentExpression);
                                this.context.allowYield = s;
                                r = this.finalize(this.startNode(i), new n.AssignmentPattern(r, a));
                            }
                            return r;
                        };
                        e.prototype.parseVariableIdentifier = function(e) {
                            var t = this.createNode();
                            var i = this.nextToken();
                            if (i.type === 4 && i.value === "yield") {
                                if (this.context.strict) {
                                    this.tolerateUnexpectedToken(i, a.Messages.StrictReservedWord);
                                } else if (!this.context.allowYield) {
                                    this.throwUnexpectedToken(i);
                                }
                            } else if (i.type !== 3) {
                                if (this.context.strict && i.type === 4 && this.scanner.isStrictModeReservedWord(i.value)) {
                                    this.tolerateUnexpectedToken(i, a.Messages.StrictReservedWord);
                                } else {
                                    if (this.context.strict || i.value !== "let" || e !== "var") {
                                        this.throwUnexpectedToken(i);
                                    }
                                }
                            } else if ((this.context.isModule || this.context.await) && i.type === 3 && i.value === "await") {
                                this.tolerateUnexpectedToken(i);
                            }
                            return this.finalize(t, new n.Identifier(i.value));
                        };
                        e.prototype.parseVariableDeclaration = function(e) {
                            var t = this.createNode();
                            var i = [];
                            var r = this.parsePattern(i, "var");
                            if (this.context.strict && r.type === l.Syntax.Identifier) {
                                if (this.scanner.isRestrictedWord(r.name)) {
                                    this.tolerateError(a.Messages.StrictVarName);
                                }
                            }
                            var s = null;
                            if (this.match("=")) {
                                this.nextToken();
                                s = this.isolateCoverGrammar(this.parseAssignmentExpression);
                            } else if (r.type !== l.Syntax.Identifier && !e.inFor) {
                                this.expect("=");
                            }
                            return this.finalize(t, new n.VariableDeclarator(r, s));
                        };
                        e.prototype.parseVariableDeclarationList = function(e) {
                            var t = {
                                inFor: e.inFor
                            };
                            var i = [];
                            i.push(this.parseVariableDeclaration(t));
                            while (this.match(",")) {
                                this.nextToken();
                                i.push(this.parseVariableDeclaration(t));
                            }
                            return i;
                        };
                        e.prototype.parseVariableStatement = function() {
                            var e = this.createNode();
                            this.expectKeyword("var");
                            var t = this.parseVariableDeclarationList({
                                inFor: false
                            });
                            this.consumeSemicolon();
                            return this.finalize(e, new n.VariableDeclaration(t, "var"));
                        };
                        e.prototype.parseEmptyStatement = function() {
                            var e = this.createNode();
                            this.expect(";");
                            return this.finalize(e, new n.EmptyStatement());
                        };
                        e.prototype.parseExpressionStatement = function() {
                            var e = this.createNode();
                            var t = this.parseExpression();
                            this.consumeSemicolon();
                            return this.finalize(e, new n.ExpressionStatement(t));
                        };
                        e.prototype.parseIfClause = function() {
                            if (this.context.strict && this.matchKeyword("function")) {
                                this.tolerateError(a.Messages.StrictFunction);
                            }
                            return this.parseStatement();
                        };
                        e.prototype.parseIfStatement = function() {
                            var e = this.createNode();
                            var t;
                            var i = null;
                            this.expectKeyword("if");
                            this.expect("(");
                            var r = this.parseExpression();
                            if (!this.match(")") && this.config.tolerant) {
                                this.tolerateUnexpectedToken(this.nextToken());
                                t = this.finalize(this.createNode(), new n.EmptyStatement());
                            } else {
                                this.expect(")");
                                t = this.parseIfClause();
                                if (this.matchKeyword("else")) {
                                    this.nextToken();
                                    i = this.parseIfClause();
                                }
                            }
                            return this.finalize(e, new n.IfStatement(r, t, i));
                        };
                        e.prototype.parseDoWhileStatement = function() {
                            var e = this.createNode();
                            this.expectKeyword("do");
                            var t = this.context.inIteration;
                            this.context.inIteration = true;
                            var i = this.parseStatement();
                            this.context.inIteration = t;
                            this.expectKeyword("while");
                            this.expect("(");
                            var r = this.parseExpression();
                            if (!this.match(")") && this.config.tolerant) {
                                this.tolerateUnexpectedToken(this.nextToken());
                            } else {
                                this.expect(")");
                                if (this.match(";")) {
                                    this.nextToken();
                                }
                            }
                            return this.finalize(e, new n.DoWhileStatement(i, r));
                        };
                        e.prototype.parseWhileStatement = function() {
                            var e = this.createNode();
                            var t;
                            this.expectKeyword("while");
                            this.expect("(");
                            var i = this.parseExpression();
                            if (!this.match(")") && this.config.tolerant) {
                                this.tolerateUnexpectedToken(this.nextToken());
                                t = this.finalize(this.createNode(), new n.EmptyStatement());
                            } else {
                                this.expect(")");
                                var r = this.context.inIteration;
                                this.context.inIteration = true;
                                t = this.parseStatement();
                                this.context.inIteration = r;
                            }
                            return this.finalize(e, new n.WhileStatement(i, t));
                        };
                        e.prototype.parseForStatement = function() {
                            var e = null;
                            var t = null;
                            var i = null;
                            var r = true;
                            var s, o;
                            var u = this.createNode();
                            this.expectKeyword("for");
                            this.expect("(");
                            if (this.match(";")) {
                                this.nextToken();
                            } else {
                                if (this.matchKeyword("var")) {
                                    e = this.createNode();
                                    this.nextToken();
                                    var c = this.context.allowIn;
                                    this.context.allowIn = false;
                                    var h = this.parseVariableDeclarationList({
                                        inFor: true
                                    });
                                    this.context.allowIn = c;
                                    if (h.length === 1 && this.matchKeyword("in")) {
                                        var p = h[0];
                                        if (p.init && (p.id.type === l.Syntax.ArrayPattern || p.id.type === l.Syntax.ObjectPattern || this.context.strict)) {
                                            this.tolerateError(a.Messages.ForInOfLoopInitializer, "for-in");
                                        }
                                        e = this.finalize(e, new n.VariableDeclaration(h, "var"));
                                        this.nextToken();
                                        s = e;
                                        o = this.parseExpression();
                                        e = null;
                                    } else if (h.length === 1 && h[0].init === null && this.matchContextualKeyword("of")) {
                                        e = this.finalize(e, new n.VariableDeclaration(h, "var"));
                                        this.nextToken();
                                        s = e;
                                        o = this.parseAssignmentExpression();
                                        e = null;
                                        r = false;
                                    } else {
                                        e = this.finalize(e, new n.VariableDeclaration(h, "var"));
                                        this.expect(";");
                                    }
                                } else if (this.matchKeyword("const") || this.matchKeyword("let")) {
                                    e = this.createNode();
                                    var f = this.nextToken().value;
                                    if (!this.context.strict && this.lookahead.value === "in") {
                                        e = this.finalize(e, new n.Identifier(f));
                                        this.nextToken();
                                        s = e;
                                        o = this.parseExpression();
                                        e = null;
                                    } else {
                                        var c = this.context.allowIn;
                                        this.context.allowIn = false;
                                        var h = this.parseBindingList(f, {
                                            inFor: true
                                        });
                                        this.context.allowIn = c;
                                        if (h.length === 1 && h[0].init === null && this.matchKeyword("in")) {
                                            e = this.finalize(e, new n.VariableDeclaration(h, f));
                                            this.nextToken();
                                            s = e;
                                            o = this.parseExpression();
                                            e = null;
                                        } else if (h.length === 1 && h[0].init === null && this.matchContextualKeyword("of")) {
                                            e = this.finalize(e, new n.VariableDeclaration(h, f));
                                            this.nextToken();
                                            s = e;
                                            o = this.parseAssignmentExpression();
                                            e = null;
                                            r = false;
                                        } else {
                                            this.consumeSemicolon();
                                            e = this.finalize(e, new n.VariableDeclaration(h, f));
                                        }
                                    }
                                } else {
                                    var d = this.lookahead;
                                    var c = this.context.allowIn;
                                    this.context.allowIn = false;
                                    e = this.inheritCoverGrammar(this.parseAssignmentExpression);
                                    this.context.allowIn = c;
                                    if (this.matchKeyword("in")) {
                                        if (!this.context.isAssignmentTarget || e.type === l.Syntax.AssignmentExpression) {
                                            this.tolerateError(a.Messages.InvalidLHSInForIn);
                                        }
                                        this.nextToken();
                                        this.reinterpretExpressionAsPattern(e);
                                        s = e;
                                        o = this.parseExpression();
                                        e = null;
                                    } else if (this.matchContextualKeyword("of")) {
                                        if (!this.context.isAssignmentTarget || e.type === l.Syntax.AssignmentExpression) {
                                            this.tolerateError(a.Messages.InvalidLHSInForLoop);
                                        }
                                        this.nextToken();
                                        this.reinterpretExpressionAsPattern(e);
                                        s = e;
                                        o = this.parseAssignmentExpression();
                                        e = null;
                                        r = false;
                                    } else {
                                        if (this.match(",")) {
                                            var m = [ e ];
                                            while (this.match(",")) {
                                                this.nextToken();
                                                m.push(this.isolateCoverGrammar(this.parseAssignmentExpression));
                                            }
                                            e = this.finalize(this.startNode(d), new n.SequenceExpression(m));
                                        }
                                        this.expect(";");
                                    }
                                }
                            }
                            if (typeof s === "undefined") {
                                if (!this.match(";")) {
                                    t = this.parseExpression();
                                }
                                this.expect(";");
                                if (!this.match(")")) {
                                    i = this.parseExpression();
                                }
                            }
                            var y;
                            if (!this.match(")") && this.config.tolerant) {
                                this.tolerateUnexpectedToken(this.nextToken());
                                y = this.finalize(this.createNode(), new n.EmptyStatement());
                            } else {
                                this.expect(")");
                                var v = this.context.inIteration;
                                this.context.inIteration = true;
                                y = this.isolateCoverGrammar(this.parseStatement);
                                this.context.inIteration = v;
                            }
                            return typeof s === "undefined" ? this.finalize(u, new n.ForStatement(e, t, i, y)) : r ? this.finalize(u, new n.ForInStatement(s, o, y)) : this.finalize(u, new n.ForOfStatement(s, o, y));
                        };
                        e.prototype.parseContinueStatement = function() {
                            var e = this.createNode();
                            this.expectKeyword("continue");
                            var t = null;
                            if (this.lookahead.type === 3 && !this.hasLineTerminator) {
                                var i = this.parseVariableIdentifier();
                                t = i;
                                var r = "$" + i.name;
                                if (!Object.prototype.hasOwnProperty.call(this.context.labelSet, r)) {
                                    this.throwError(a.Messages.UnknownLabel, i.name);
                                }
                            }
                            this.consumeSemicolon();
                            if (t === null && !this.context.inIteration) {
                                this.throwError(a.Messages.IllegalContinue);
                            }
                            return this.finalize(e, new n.ContinueStatement(t));
                        };
                        e.prototype.parseBreakStatement = function() {
                            var e = this.createNode();
                            this.expectKeyword("break");
                            var t = null;
                            if (this.lookahead.type === 3 && !this.hasLineTerminator) {
                                var i = this.parseVariableIdentifier();
                                var r = "$" + i.name;
                                if (!Object.prototype.hasOwnProperty.call(this.context.labelSet, r)) {
                                    this.throwError(a.Messages.UnknownLabel, i.name);
                                }
                                t = i;
                            }
                            this.consumeSemicolon();
                            if (t === null && !this.context.inIteration && !this.context.inSwitch) {
                                this.throwError(a.Messages.IllegalBreak);
                            }
                            return this.finalize(e, new n.BreakStatement(t));
                        };
                        e.prototype.parseReturnStatement = function() {
                            if (!this.context.inFunctionBody) {
                                this.tolerateError(a.Messages.IllegalReturn);
                            }
                            var e = this.createNode();
                            this.expectKeyword("return");
                            var t = !this.match(";") && !this.match("}") && !this.hasLineTerminator && this.lookahead.type !== 2 || this.lookahead.type === 8 || this.lookahead.type === 10;
                            var i = t ? this.parseExpression() : null;
                            this.consumeSemicolon();
                            return this.finalize(e, new n.ReturnStatement(i));
                        };
                        e.prototype.parseWithStatement = function() {
                            if (this.context.strict) {
                                this.tolerateError(a.Messages.StrictModeWith);
                            }
                            var e = this.createNode();
                            var t;
                            this.expectKeyword("with");
                            this.expect("(");
                            var i = this.parseExpression();
                            if (!this.match(")") && this.config.tolerant) {
                                this.tolerateUnexpectedToken(this.nextToken());
                                t = this.finalize(this.createNode(), new n.EmptyStatement());
                            } else {
                                this.expect(")");
                                t = this.parseStatement();
                            }
                            return this.finalize(e, new n.WithStatement(i, t));
                        };
                        e.prototype.parseSwitchCase = function() {
                            var e = this.createNode();
                            var t;
                            if (this.matchKeyword("default")) {
                                this.nextToken();
                                t = null;
                            } else {
                                this.expectKeyword("case");
                                t = this.parseExpression();
                            }
                            this.expect(":");
                            var i = [];
                            while (true) {
                                if (this.match("}") || this.matchKeyword("default") || this.matchKeyword("case")) {
                                    break;
                                }
                                i.push(this.parseStatementListItem());
                            }
                            return this.finalize(e, new n.SwitchCase(t, i));
                        };
                        e.prototype.parseSwitchStatement = function() {
                            var e = this.createNode();
                            this.expectKeyword("switch");
                            this.expect("(");
                            var t = this.parseExpression();
                            this.expect(")");
                            var i = this.context.inSwitch;
                            this.context.inSwitch = true;
                            var r = [];
                            var s = false;
                            this.expect("{");
                            while (true) {
                                if (this.match("}")) {
                                    break;
                                }
                                var o = this.parseSwitchCase();
                                if (o.test === null) {
                                    if (s) {
                                        this.throwError(a.Messages.MultipleDefaultsInSwitch);
                                    }
                                    s = true;
                                }
                                r.push(o);
                            }
                            this.expect("}");
                            this.context.inSwitch = i;
                            return this.finalize(e, new n.SwitchStatement(t, r));
                        };
                        e.prototype.parseLabelledStatement = function() {
                            var e = this.createNode();
                            var t = this.parseExpression();
                            var i;
                            if (t.type === l.Syntax.Identifier && this.match(":")) {
                                this.nextToken();
                                var r = t;
                                var s = "$" + r.name;
                                if (Object.prototype.hasOwnProperty.call(this.context.labelSet, s)) {
                                    this.throwError(a.Messages.Redeclaration, "Label", r.name);
                                }
                                this.context.labelSet[s] = true;
                                var o = void 0;
                                if (this.matchKeyword("class")) {
                                    this.tolerateUnexpectedToken(this.lookahead);
                                    o = this.parseClassDeclaration();
                                } else if (this.matchKeyword("function")) {
                                    var u = this.lookahead;
                                    var c = this.parseFunctionDeclaration();
                                    if (this.context.strict) {
                                        this.tolerateUnexpectedToken(u, a.Messages.StrictFunction);
                                    } else if (c.generator) {
                                        this.tolerateUnexpectedToken(u, a.Messages.GeneratorInLegacyContext);
                                    }
                                    o = c;
                                } else {
                                    o = this.parseStatement();
                                }
                                delete this.context.labelSet[s];
                                i = new n.LabeledStatement(r, o);
                            } else {
                                this.consumeSemicolon();
                                i = new n.ExpressionStatement(t);
                            }
                            return this.finalize(e, i);
                        };
                        e.prototype.parseThrowStatement = function() {
                            var e = this.createNode();
                            this.expectKeyword("throw");
                            if (this.hasLineTerminator) {
                                this.throwError(a.Messages.NewlineAfterThrow);
                            }
                            var t = this.parseExpression();
                            this.consumeSemicolon();
                            return this.finalize(e, new n.ThrowStatement(t));
                        };
                        e.prototype.parseCatchClause = function() {
                            var e = this.createNode();
                            this.expectKeyword("catch");
                            this.expect("(");
                            if (this.match(")")) {
                                this.throwUnexpectedToken(this.lookahead);
                            }
                            var t = [];
                            var i = this.parsePattern(t);
                            var r = {};
                            for (var s = 0; s < t.length; s++) {
                                var o = "$" + t[s].value;
                                if (Object.prototype.hasOwnProperty.call(r, o)) {
                                    this.tolerateError(a.Messages.DuplicateBinding, t[s].value);
                                }
                                r[o] = true;
                            }
                            if (this.context.strict && i.type === l.Syntax.Identifier) {
                                if (this.scanner.isRestrictedWord(i.name)) {
                                    this.tolerateError(a.Messages.StrictCatchVariable);
                                }
                            }
                            this.expect(")");
                            var u = this.parseBlock();
                            return this.finalize(e, new n.CatchClause(i, u));
                        };
                        e.prototype.parseFinallyClause = function() {
                            this.expectKeyword("finally");
                            return this.parseBlock();
                        };
                        e.prototype.parseTryStatement = function() {
                            var e = this.createNode();
                            this.expectKeyword("try");
                            var t = this.parseBlock();
                            var i = this.matchKeyword("catch") ? this.parseCatchClause() : null;
                            var r = this.matchKeyword("finally") ? this.parseFinallyClause() : null;
                            if (!i && !r) {
                                this.throwError(a.Messages.NoCatchOrFinally);
                            }
                            return this.finalize(e, new n.TryStatement(t, i, r));
                        };
                        e.prototype.parseDebuggerStatement = function() {
                            var e = this.createNode();
                            this.expectKeyword("debugger");
                            this.consumeSemicolon();
                            return this.finalize(e, new n.DebuggerStatement());
                        };
                        e.prototype.parseStatement = function() {
                            var e;
                            switch (this.lookahead.type) {
                              case 1:
                              case 5:
                              case 6:
                              case 8:
                              case 10:
                              case 9:
                                e = this.parseExpressionStatement();
                                break;

                              case 7:
                                var t = this.lookahead.value;
                                if (t === "{") {
                                    e = this.parseBlock();
                                } else if (t === "(") {
                                    e = this.parseExpressionStatement();
                                } else if (t === ";") {
                                    e = this.parseEmptyStatement();
                                } else {
                                    e = this.parseExpressionStatement();
                                }
                                break;

                              case 3:
                                e = this.matchAsyncFunction() ? this.parseFunctionDeclaration() : this.parseLabelledStatement();
                                break;

                              case 4:
                                switch (this.lookahead.value) {
                                  case "break":
                                    e = this.parseBreakStatement();
                                    break;

                                  case "continue":
                                    e = this.parseContinueStatement();
                                    break;

                                  case "debugger":
                                    e = this.parseDebuggerStatement();
                                    break;

                                  case "do":
                                    e = this.parseDoWhileStatement();
                                    break;

                                  case "for":
                                    e = this.parseForStatement();
                                    break;

                                  case "function":
                                    e = this.parseFunctionDeclaration();
                                    break;

                                  case "if":
                                    e = this.parseIfStatement();
                                    break;

                                  case "return":
                                    e = this.parseReturnStatement();
                                    break;

                                  case "switch":
                                    e = this.parseSwitchStatement();
                                    break;

                                  case "throw":
                                    e = this.parseThrowStatement();
                                    break;

                                  case "try":
                                    e = this.parseTryStatement();
                                    break;

                                  case "var":
                                    e = this.parseVariableStatement();
                                    break;

                                  case "while":
                                    e = this.parseWhileStatement();
                                    break;

                                  case "with":
                                    e = this.parseWithStatement();
                                    break;

                                  default:
                                    e = this.parseExpressionStatement();
                                    break;
                                }
                                break;

                              default:
                                e = this.throwUnexpectedToken(this.lookahead);
                            }
                            return e;
                        };
                        e.prototype.parseFunctionSourceElements = function() {
                            var e = this.createNode();
                            this.expect("{");
                            var t = this.parseDirectivePrologues();
                            var i = this.context.labelSet;
                            var r = this.context.inIteration;
                            var s = this.context.inSwitch;
                            var a = this.context.inFunctionBody;
                            this.context.labelSet = {};
                            this.context.inIteration = false;
                            this.context.inSwitch = false;
                            this.context.inFunctionBody = true;
                            while (this.lookahead.type !== 2) {
                                if (this.match("}")) {
                                    break;
                                }
                                t.push(this.parseStatementListItem());
                            }
                            this.expect("}");
                            this.context.labelSet = i;
                            this.context.inIteration = r;
                            this.context.inSwitch = s;
                            this.context.inFunctionBody = a;
                            return this.finalize(e, new n.BlockStatement(t));
                        };
                        e.prototype.validateParam = function(e, t, i) {
                            var r = "$" + i;
                            if (this.context.strict) {
                                if (this.scanner.isRestrictedWord(i)) {
                                    e.stricted = t;
                                    e.message = a.Messages.StrictParamName;
                                }
                                if (Object.prototype.hasOwnProperty.call(e.paramSet, r)) {
                                    e.stricted = t;
                                    e.message = a.Messages.StrictParamDupe;
                                }
                            } else if (!e.firstRestricted) {
                                if (this.scanner.isRestrictedWord(i)) {
                                    e.firstRestricted = t;
                                    e.message = a.Messages.StrictParamName;
                                } else if (this.scanner.isStrictModeReservedWord(i)) {
                                    e.firstRestricted = t;
                                    e.message = a.Messages.StrictReservedWord;
                                } else if (Object.prototype.hasOwnProperty.call(e.paramSet, r)) {
                                    e.stricted = t;
                                    e.message = a.Messages.StrictParamDupe;
                                }
                            }
                            if (typeof Object.defineProperty === "function") {
                                Object.defineProperty(e.paramSet, r, {
                                    value: true,
                                    enumerable: true,
                                    writable: true,
                                    configurable: true
                                });
                            } else {
                                e.paramSet[r] = true;
                            }
                        };
                        e.prototype.parseRestElement = function(e) {
                            var t = this.createNode();
                            this.expect("...");
                            var i = this.parsePattern(e);
                            if (this.match("=")) {
                                this.throwError(a.Messages.DefaultRestParameter);
                            }
                            if (!this.match(")")) {
                                this.throwError(a.Messages.ParameterAfterRestParameter);
                            }
                            return this.finalize(t, new n.RestElement(i));
                        };
                        e.prototype.parseFormalParameter = function(e) {
                            var t = [];
                            var i = this.match("...") ? this.parseRestElement(t) : this.parsePatternWithDefault(t);
                            for (var r = 0; r < t.length; r++) {
                                this.validateParam(e, t[r], t[r].value);
                            }
                            e.simple = e.simple && i instanceof n.Identifier;
                            e.params.push(i);
                        };
                        e.prototype.parseFormalParameters = function(e) {
                            var t;
                            t = {
                                simple: true,
                                params: [],
                                firstRestricted: e
                            };
                            this.expect("(");
                            if (!this.match(")")) {
                                t.paramSet = {};
                                while (this.lookahead.type !== 2) {
                                    this.parseFormalParameter(t);
                                    if (this.match(")")) {
                                        break;
                                    }
                                    this.expect(",");
                                    if (this.match(")")) {
                                        break;
                                    }
                                }
                            }
                            this.expect(")");
                            return {
                                simple: t.simple,
                                params: t.params,
                                stricted: t.stricted,
                                firstRestricted: t.firstRestricted,
                                message: t.message
                            };
                        };
                        e.prototype.matchAsyncFunction = function() {
                            var e = this.matchContextualKeyword("async");
                            if (e) {
                                var t = this.scanner.saveState();
                                this.scanner.scanComments();
                                var i = this.scanner.lex();
                                this.scanner.restoreState(t);
                                e = t.lineNumber === i.lineNumber && i.type === 4 && i.value === "function";
                            }
                            return e;
                        };
                        e.prototype.parseFunctionDeclaration = function(e) {
                            var t = this.createNode();
                            var i = this.matchContextualKeyword("async");
                            if (i) {
                                this.nextToken();
                            }
                            this.expectKeyword("function");
                            var r = i ? false : this.match("*");
                            if (r) {
                                this.nextToken();
                            }
                            var s;
                            var o = null;
                            var l = null;
                            if (!e || !this.match("(")) {
                                var u = this.lookahead;
                                o = this.parseVariableIdentifier();
                                if (this.context.strict) {
                                    if (this.scanner.isRestrictedWord(u.value)) {
                                        this.tolerateUnexpectedToken(u, a.Messages.StrictFunctionName);
                                    }
                                } else {
                                    if (this.scanner.isRestrictedWord(u.value)) {
                                        l = u;
                                        s = a.Messages.StrictFunctionName;
                                    } else if (this.scanner.isStrictModeReservedWord(u.value)) {
                                        l = u;
                                        s = a.Messages.StrictReservedWord;
                                    }
                                }
                            }
                            var c = this.context.await;
                            var h = this.context.allowYield;
                            this.context.await = i;
                            this.context.allowYield = !r;
                            var p = this.parseFormalParameters(l);
                            var f = p.params;
                            var d = p.stricted;
                            l = p.firstRestricted;
                            if (p.message) {
                                s = p.message;
                            }
                            var m = this.context.strict;
                            var y = this.context.allowStrictDirective;
                            this.context.allowStrictDirective = p.simple;
                            var v = this.parseFunctionSourceElements();
                            if (this.context.strict && l) {
                                this.throwUnexpectedToken(l, s);
                            }
                            if (this.context.strict && d) {
                                this.tolerateUnexpectedToken(d, s);
                            }
                            this.context.strict = m;
                            this.context.allowStrictDirective = y;
                            this.context.await = c;
                            this.context.allowYield = h;
                            return i ? this.finalize(t, new n.AsyncFunctionDeclaration(o, f, v)) : this.finalize(t, new n.FunctionDeclaration(o, f, v, r));
                        };
                        e.prototype.parseFunctionExpression = function() {
                            var e = this.createNode();
                            var t = this.matchContextualKeyword("async");
                            if (t) {
                                this.nextToken();
                            }
                            this.expectKeyword("function");
                            var i = t ? false : this.match("*");
                            if (i) {
                                this.nextToken();
                            }
                            var r;
                            var s = null;
                            var o;
                            var l = this.context.await;
                            var u = this.context.allowYield;
                            this.context.await = t;
                            this.context.allowYield = !i;
                            if (!this.match("(")) {
                                var c = this.lookahead;
                                s = !this.context.strict && !i && this.matchKeyword("yield") ? this.parseIdentifierName() : this.parseVariableIdentifier();
                                if (this.context.strict) {
                                    if (this.scanner.isRestrictedWord(c.value)) {
                                        this.tolerateUnexpectedToken(c, a.Messages.StrictFunctionName);
                                    }
                                } else {
                                    if (this.scanner.isRestrictedWord(c.value)) {
                                        o = c;
                                        r = a.Messages.StrictFunctionName;
                                    } else if (this.scanner.isStrictModeReservedWord(c.value)) {
                                        o = c;
                                        r = a.Messages.StrictReservedWord;
                                    }
                                }
                            }
                            var h = this.parseFormalParameters(o);
                            var p = h.params;
                            var f = h.stricted;
                            o = h.firstRestricted;
                            if (h.message) {
                                r = h.message;
                            }
                            var d = this.context.strict;
                            var m = this.context.allowStrictDirective;
                            this.context.allowStrictDirective = h.simple;
                            var y = this.parseFunctionSourceElements();
                            if (this.context.strict && o) {
                                this.throwUnexpectedToken(o, r);
                            }
                            if (this.context.strict && f) {
                                this.tolerateUnexpectedToken(f, r);
                            }
                            this.context.strict = d;
                            this.context.allowStrictDirective = m;
                            this.context.await = l;
                            this.context.allowYield = u;
                            return t ? this.finalize(e, new n.AsyncFunctionExpression(s, p, y)) : this.finalize(e, new n.FunctionExpression(s, p, y, i));
                        };
                        e.prototype.parseDirective = function() {
                            var e = this.lookahead;
                            var t = this.createNode();
                            var i = this.parseExpression();
                            var r = i.type === l.Syntax.Literal ? this.getTokenRaw(e).slice(1, -1) : null;
                            this.consumeSemicolon();
                            return this.finalize(t, r ? new n.Directive(i, r) : new n.ExpressionStatement(i));
                        };
                        e.prototype.parseDirectivePrologues = function() {
                            var e = null;
                            var t = [];
                            while (true) {
                                var i = this.lookahead;
                                if (i.type !== 8) {
                                    break;
                                }
                                var r = this.parseDirective();
                                t.push(r);
                                var s = r.directive;
                                if (typeof s !== "string") {
                                    break;
                                }
                                if (s === "use strict") {
                                    this.context.strict = true;
                                    if (e) {
                                        this.tolerateUnexpectedToken(e, a.Messages.StrictOctalLiteral);
                                    }
                                    if (!this.context.allowStrictDirective) {
                                        this.tolerateUnexpectedToken(i, a.Messages.IllegalLanguageModeDirective);
                                    }
                                } else {
                                    if (!e && i.octal) {
                                        e = i;
                                    }
                                }
                            }
                            return t;
                        };
                        e.prototype.qualifiedPropertyName = function(e) {
                            switch (e.type) {
                              case 3:
                              case 8:
                              case 1:
                              case 5:
                              case 6:
                              case 4:
                                return true;

                              case 7:
                                return e.value === "[";

                              default:
                                break;
                            }
                            return false;
                        };
                        e.prototype.parseGetterMethod = function() {
                            var e = this.createNode();
                            var t = false;
                            var i = this.context.allowYield;
                            this.context.allowYield = !t;
                            var r = this.parseFormalParameters();
                            if (r.params.length > 0) {
                                this.tolerateError(a.Messages.BadGetterArity);
                            }
                            var s = this.parsePropertyMethod(r);
                            this.context.allowYield = i;
                            return this.finalize(e, new n.FunctionExpression(null, r.params, s, t));
                        };
                        e.prototype.parseSetterMethod = function() {
                            var e = this.createNode();
                            var t = false;
                            var i = this.context.allowYield;
                            this.context.allowYield = !t;
                            var r = this.parseFormalParameters();
                            if (r.params.length !== 1) {
                                this.tolerateError(a.Messages.BadSetterArity);
                            } else if (r.params[0] instanceof n.RestElement) {
                                this.tolerateError(a.Messages.BadSetterRestParameter);
                            }
                            var s = this.parsePropertyMethod(r);
                            this.context.allowYield = i;
                            return this.finalize(e, new n.FunctionExpression(null, r.params, s, t));
                        };
                        e.prototype.parseGeneratorMethod = function() {
                            var e = this.createNode();
                            var t = true;
                            var i = this.context.allowYield;
                            this.context.allowYield = true;
                            var r = this.parseFormalParameters();
                            this.context.allowYield = false;
                            var s = this.parsePropertyMethod(r);
                            this.context.allowYield = i;
                            return this.finalize(e, new n.FunctionExpression(null, r.params, s, t));
                        };
                        e.prototype.isStartOfExpression = function() {
                            var e = true;
                            var t = this.lookahead.value;
                            switch (this.lookahead.type) {
                              case 7:
                                e = t === "[" || t === "(" || t === "{" || t === "+" || t === "-" || t === "!" || t === "~" || t === "++" || t === "--" || t === "/" || t === "/=";
                                break;

                              case 4:
                                e = t === "class" || t === "delete" || t === "function" || t === "let" || t === "new" || t === "super" || t === "this" || t === "typeof" || t === "void" || t === "yield";
                                break;

                              default:
                                break;
                            }
                            return e;
                        };
                        e.prototype.parseYieldExpression = function() {
                            var e = this.createNode();
                            this.expectKeyword("yield");
                            var t = null;
                            var i = false;
                            if (!this.hasLineTerminator) {
                                var r = this.context.allowYield;
                                this.context.allowYield = false;
                                i = this.match("*");
                                if (i) {
                                    this.nextToken();
                                    t = this.parseAssignmentExpression();
                                } else if (this.isStartOfExpression()) {
                                    t = this.parseAssignmentExpression();
                                }
                                this.context.allowYield = r;
                            }
                            return this.finalize(e, new n.YieldExpression(t, i));
                        };
                        e.prototype.parseClassElement = function(e) {
                            var t = this.lookahead;
                            var i = this.createNode();
                            var r = "";
                            var s = null;
                            var o = null;
                            var l = false;
                            var u = false;
                            var c = false;
                            var h = false;
                            if (this.match("*")) {
                                this.nextToken();
                            } else {
                                l = this.match("[");
                                s = this.parseObjectPropertyKey();
                                var p = s;
                                if (p.name === "static" && (this.qualifiedPropertyName(this.lookahead) || this.match("*"))) {
                                    t = this.lookahead;
                                    c = true;
                                    l = this.match("[");
                                    if (this.match("*")) {
                                        this.nextToken();
                                    } else {
                                        s = this.parseObjectPropertyKey();
                                    }
                                }
                                if (t.type === 3 && !this.hasLineTerminator && t.value === "async") {
                                    var f = this.lookahead.value;
                                    if (f !== ":" && f !== "(" && f !== "*") {
                                        h = true;
                                        t = this.lookahead;
                                        s = this.parseObjectPropertyKey();
                                        if (t.type === 3 && t.value === "constructor") {
                                            this.tolerateUnexpectedToken(t, a.Messages.ConstructorIsAsync);
                                        }
                                    }
                                }
                            }
                            var d = this.qualifiedPropertyName(this.lookahead);
                            if (t.type === 3) {
                                if (t.value === "get" && d) {
                                    r = "get";
                                    l = this.match("[");
                                    s = this.parseObjectPropertyKey();
                                    this.context.allowYield = false;
                                    o = this.parseGetterMethod();
                                } else if (t.value === "set" && d) {
                                    r = "set";
                                    l = this.match("[");
                                    s = this.parseObjectPropertyKey();
                                    o = this.parseSetterMethod();
                                }
                            } else if (t.type === 7 && t.value === "*" && d) {
                                r = "init";
                                l = this.match("[");
                                s = this.parseObjectPropertyKey();
                                o = this.parseGeneratorMethod();
                                u = true;
                            }
                            if (!r && s && this.match("(")) {
                                r = "init";
                                o = h ? this.parsePropertyMethodAsyncFunction() : this.parsePropertyMethodFunction();
                                u = true;
                            }
                            if (!r) {
                                this.throwUnexpectedToken(this.lookahead);
                            }
                            if (r === "init") {
                                r = "method";
                            }
                            if (!l) {
                                if (c && this.isPropertyKey(s, "prototype")) {
                                    this.throwUnexpectedToken(t, a.Messages.StaticPrototype);
                                }
                                if (!c && this.isPropertyKey(s, "constructor")) {
                                    if (r !== "method" || !u || o && o.generator) {
                                        this.throwUnexpectedToken(t, a.Messages.ConstructorSpecialMethod);
                                    }
                                    if (e.value) {
                                        this.throwUnexpectedToken(t, a.Messages.DuplicateConstructor);
                                    } else {
                                        e.value = true;
                                    }
                                    r = "constructor";
                                }
                            }
                            return this.finalize(i, new n.MethodDefinition(s, l, o, r, c));
                        };
                        e.prototype.parseClassElementList = function() {
                            var e = [];
                            var t = {
                                value: false
                            };
                            this.expect("{");
                            while (!this.match("}")) {
                                if (this.match(";")) {
                                    this.nextToken();
                                } else {
                                    e.push(this.parseClassElement(t));
                                }
                            }
                            this.expect("}");
                            return e;
                        };
                        e.prototype.parseClassBody = function() {
                            var e = this.createNode();
                            var t = this.parseClassElementList();
                            return this.finalize(e, new n.ClassBody(t));
                        };
                        e.prototype.parseClassDeclaration = function(e) {
                            var t = this.createNode();
                            var i = this.context.strict;
                            this.context.strict = true;
                            this.expectKeyword("class");
                            var r = e && this.lookahead.type !== 3 ? null : this.parseVariableIdentifier();
                            var s = null;
                            if (this.matchKeyword("extends")) {
                                this.nextToken();
                                s = this.isolateCoverGrammar(this.parseLeftHandSideExpressionAllowCall);
                            }
                            var a = this.parseClassBody();
                            this.context.strict = i;
                            return this.finalize(t, new n.ClassDeclaration(r, s, a));
                        };
                        e.prototype.parseClassExpression = function() {
                            var e = this.createNode();
                            var t = this.context.strict;
                            this.context.strict = true;
                            this.expectKeyword("class");
                            var i = this.lookahead.type === 3 ? this.parseVariableIdentifier() : null;
                            var r = null;
                            if (this.matchKeyword("extends")) {
                                this.nextToken();
                                r = this.isolateCoverGrammar(this.parseLeftHandSideExpressionAllowCall);
                            }
                            var s = this.parseClassBody();
                            this.context.strict = t;
                            return this.finalize(e, new n.ClassExpression(i, r, s));
                        };
                        e.prototype.parseModule = function() {
                            this.context.strict = true;
                            this.context.isModule = true;
                            this.scanner.isModule = true;
                            var e = this.createNode();
                            var t = this.parseDirectivePrologues();
                            while (this.lookahead.type !== 2) {
                                t.push(this.parseStatementListItem());
                            }
                            return this.finalize(e, new n.Module(t));
                        };
                        e.prototype.parseScript = function() {
                            var e = this.createNode();
                            var t = this.parseDirectivePrologues();
                            while (this.lookahead.type !== 2) {
                                t.push(this.parseStatementListItem());
                            }
                            return this.finalize(e, new n.Script(t));
                        };
                        e.prototype.parseModuleSpecifier = function() {
                            var e = this.createNode();
                            if (this.lookahead.type !== 8) {
                                this.throwError(a.Messages.InvalidModuleSpecifier);
                            }
                            var t = this.nextToken();
                            var i = this.getTokenRaw(t);
                            return this.finalize(e, new n.Literal(t.value, i));
                        };
                        e.prototype.parseImportSpecifier = function() {
                            var e = this.createNode();
                            var t;
                            var i;
                            if (this.lookahead.type === 3) {
                                t = this.parseVariableIdentifier();
                                i = t;
                                if (this.matchContextualKeyword("as")) {
                                    this.nextToken();
                                    i = this.parseVariableIdentifier();
                                }
                            } else {
                                t = this.parseIdentifierName();
                                i = t;
                                if (this.matchContextualKeyword("as")) {
                                    this.nextToken();
                                    i = this.parseVariableIdentifier();
                                } else {
                                    this.throwUnexpectedToken(this.nextToken());
                                }
                            }
                            return this.finalize(e, new n.ImportSpecifier(i, t));
                        };
                        e.prototype.parseNamedImports = function() {
                            this.expect("{");
                            var e = [];
                            while (!this.match("}")) {
                                e.push(this.parseImportSpecifier());
                                if (!this.match("}")) {
                                    this.expect(",");
                                }
                            }
                            this.expect("}");
                            return e;
                        };
                        e.prototype.parseImportDefaultSpecifier = function() {
                            var e = this.createNode();
                            var t = this.parseIdentifierName();
                            return this.finalize(e, new n.ImportDefaultSpecifier(t));
                        };
                        e.prototype.parseImportNamespaceSpecifier = function() {
                            var e = this.createNode();
                            this.expect("*");
                            if (!this.matchContextualKeyword("as")) {
                                this.throwError(a.Messages.NoAsAfterImportNamespace);
                            }
                            this.nextToken();
                            var t = this.parseIdentifierName();
                            return this.finalize(e, new n.ImportNamespaceSpecifier(t));
                        };
                        e.prototype.parseImportDeclaration = function() {
                            if (this.context.inFunctionBody) {
                                this.throwError(a.Messages.IllegalImportDeclaration);
                            }
                            var e = this.createNode();
                            this.expectKeyword("import");
                            var t;
                            var i = [];
                            if (this.lookahead.type === 8) {
                                t = this.parseModuleSpecifier();
                            } else {
                                if (this.match("{")) {
                                    i = i.concat(this.parseNamedImports());
                                } else if (this.match("*")) {
                                    i.push(this.parseImportNamespaceSpecifier());
                                } else if (this.isIdentifierName(this.lookahead) && !this.matchKeyword("default")) {
                                    i.push(this.parseImportDefaultSpecifier());
                                    if (this.match(",")) {
                                        this.nextToken();
                                        if (this.match("*")) {
                                            i.push(this.parseImportNamespaceSpecifier());
                                        } else if (this.match("{")) {
                                            i = i.concat(this.parseNamedImports());
                                        } else {
                                            this.throwUnexpectedToken(this.lookahead);
                                        }
                                    }
                                } else {
                                    this.throwUnexpectedToken(this.nextToken());
                                }
                                if (!this.matchContextualKeyword("from")) {
                                    var r = this.lookahead.value ? a.Messages.UnexpectedToken : a.Messages.MissingFromClause;
                                    this.throwError(r, this.lookahead.value);
                                }
                                this.nextToken();
                                t = this.parseModuleSpecifier();
                            }
                            this.consumeSemicolon();
                            return this.finalize(e, new n.ImportDeclaration(i, t));
                        };
                        e.prototype.parseExportSpecifier = function() {
                            var e = this.createNode();
                            var t = this.parseIdentifierName();
                            var i = t;
                            if (this.matchContextualKeyword("as")) {
                                this.nextToken();
                                i = this.parseIdentifierName();
                            }
                            return this.finalize(e, new n.ExportSpecifier(t, i));
                        };
                        e.prototype.parseExportDeclaration = function() {
                            if (this.context.inFunctionBody) {
                                this.throwError(a.Messages.IllegalExportDeclaration);
                            }
                            var e = this.createNode();
                            this.expectKeyword("export");
                            var t;
                            if (this.matchKeyword("default")) {
                                this.nextToken();
                                if (this.matchKeyword("function")) {
                                    var i = this.parseFunctionDeclaration(true);
                                    t = this.finalize(e, new n.ExportDefaultDeclaration(i));
                                } else if (this.matchKeyword("class")) {
                                    var i = this.parseClassDeclaration(true);
                                    t = this.finalize(e, new n.ExportDefaultDeclaration(i));
                                } else if (this.matchContextualKeyword("async")) {
                                    var i = this.matchAsyncFunction() ? this.parseFunctionDeclaration(true) : this.parseAssignmentExpression();
                                    t = this.finalize(e, new n.ExportDefaultDeclaration(i));
                                } else {
                                    if (this.matchContextualKeyword("from")) {
                                        this.throwError(a.Messages.UnexpectedToken, this.lookahead.value);
                                    }
                                    var i = this.match("{") ? this.parseObjectInitializer() : this.match("[") ? this.parseArrayInitializer() : this.parseAssignmentExpression();
                                    this.consumeSemicolon();
                                    t = this.finalize(e, new n.ExportDefaultDeclaration(i));
                                }
                            } else if (this.match("*")) {
                                this.nextToken();
                                if (!this.matchContextualKeyword("from")) {
                                    var r = this.lookahead.value ? a.Messages.UnexpectedToken : a.Messages.MissingFromClause;
                                    this.throwError(r, this.lookahead.value);
                                }
                                this.nextToken();
                                var s = this.parseModuleSpecifier();
                                this.consumeSemicolon();
                                t = this.finalize(e, new n.ExportAllDeclaration(s));
                            } else if (this.lookahead.type === 4) {
                                var i = void 0;
                                switch (this.lookahead.value) {
                                  case "let":
                                  case "const":
                                    i = this.parseLexicalDeclaration({
                                        inFor: false
                                    });
                                    break;

                                  case "var":
                                  case "class":
                                  case "function":
                                    i = this.parseStatementListItem();
                                    break;

                                  default:
                                    this.throwUnexpectedToken(this.lookahead);
                                }
                                t = this.finalize(e, new n.ExportNamedDeclaration(i, [], null));
                            } else if (this.matchAsyncFunction()) {
                                var i = this.parseFunctionDeclaration();
                                t = this.finalize(e, new n.ExportNamedDeclaration(i, [], null));
                            } else {
                                var o = [];
                                var l = null;
                                var u = false;
                                this.expect("{");
                                while (!this.match("}")) {
                                    u = u || this.matchKeyword("default");
                                    o.push(this.parseExportSpecifier());
                                    if (!this.match("}")) {
                                        this.expect(",");
                                    }
                                }
                                this.expect("}");
                                if (this.matchContextualKeyword("from")) {
                                    this.nextToken();
                                    l = this.parseModuleSpecifier();
                                    this.consumeSemicolon();
                                } else if (u) {
                                    var r = this.lookahead.value ? a.Messages.UnexpectedToken : a.Messages.MissingFromClause;
                                    this.throwError(r, this.lookahead.value);
                                } else {
                                    this.consumeSemicolon();
                                }
                                t = this.finalize(e, new n.ExportNamedDeclaration(null, o, l));
                            }
                            return t;
                        };
                        return e;
                    }();
                    t.Parser = h;
                }, function(e, t) {
                    "use strict";
                    Object.defineProperty(t, "__esModule", {
                        value: true
                    });
                    function i(e, t) {
                        if (!e) {
                            throw new Error("ASSERT: " + t);
                        }
                    }
                    t.assert = i;
                }, function(e, t) {
                    "use strict";
                    Object.defineProperty(t, "__esModule", {
                        value: true
                    });
                    var i = function() {
                        function e() {
                            this.errors = [];
                            this.tolerant = false;
                        }
                        e.prototype.recordError = function(e) {
                            this.errors.push(e);
                        };
                        e.prototype.tolerate = function(e) {
                            if (this.tolerant) {
                                this.recordError(e);
                            } else {
                                throw e;
                            }
                        };
                        e.prototype.constructError = function(e, t) {
                            var i = new Error(e);
                            try {
                                throw i;
                            } catch (e) {
                                if (Object.create && Object.defineProperty) {
                                    i = Object.create(e);
                                    Object.defineProperty(i, "column", {
                                        value: t
                                    });
                                }
                            }
                            return i;
                        };
                        e.prototype.createError = function(e, t, i, r) {
                            var s = "Line " + t + ": " + r;
                            var a = this.constructError(s, i);
                            a.index = e;
                            a.lineNumber = t;
                            a.description = r;
                            return a;
                        };
                        e.prototype.throwError = function(e, t, i, r) {
                            throw this.createError(e, t, i, r);
                        };
                        e.prototype.tolerateError = function(e, t, i, r) {
                            var s = this.createError(e, t, i, r);
                            if (this.tolerant) {
                                this.recordError(s);
                            } else {
                                throw s;
                            }
                        };
                        return e;
                    }();
                    t.ErrorHandler = i;
                }, function(e, t) {
                    "use strict";
                    Object.defineProperty(t, "__esModule", {
                        value: true
                    });
                    t.Messages = {
                        BadGetterArity: "Getter must not have any formal parameters",
                        BadSetterArity: "Setter must have exactly one formal parameter",
                        BadSetterRestParameter: "Setter function argument must not be a rest parameter",
                        ConstructorIsAsync: "Class constructor may not be an async method",
                        ConstructorSpecialMethod: "Class constructor may not be an accessor",
                        DeclarationMissingInitializer: "Missing initializer in %0 declaration",
                        DefaultRestParameter: "Unexpected token =",
                        DuplicateBinding: "Duplicate binding %0",
                        DuplicateConstructor: "A class may only have one constructor",
                        DuplicateProtoProperty: "Duplicate __proto__ fields are not allowed in object literals",
                        ForInOfLoopInitializer: "%0 loop variable declaration may not have an initializer",
                        GeneratorInLegacyContext: "Generator declarations are not allowed in legacy contexts",
                        IllegalBreak: "Illegal break statement",
                        IllegalContinue: "Illegal continue statement",
                        IllegalExportDeclaration: "Unexpected token",
                        IllegalImportDeclaration: "Unexpected token",
                        IllegalLanguageModeDirective: "Illegal 'use strict' directive in function with non-simple parameter list",
                        IllegalReturn: "Illegal return statement",
                        InvalidEscapedReservedWord: "Keyword must not contain escaped characters",
                        InvalidHexEscapeSequence: "Invalid hexadecimal escape sequence",
                        InvalidLHSInAssignment: "Invalid left-hand side in assignment",
                        InvalidLHSInForIn: "Invalid left-hand side in for-in",
                        InvalidLHSInForLoop: "Invalid left-hand side in for-loop",
                        InvalidModuleSpecifier: "Unexpected token",
                        InvalidRegExp: "Invalid regular expression",
                        LetInLexicalBinding: "let is disallowed as a lexically bound name",
                        MissingFromClause: "Unexpected token",
                        MultipleDefaultsInSwitch: "More than one default clause in switch statement",
                        NewlineAfterThrow: "Illegal newline after throw",
                        NoAsAfterImportNamespace: "Unexpected token",
                        NoCatchOrFinally: "Missing catch or finally after try",
                        ParameterAfterRestParameter: "Rest parameter must be last formal parameter",
                        Redeclaration: "%0 '%1' has already been declared",
                        StaticPrototype: "Classes may not have static property named prototype",
                        StrictCatchVariable: "Catch variable may not be eval or arguments in strict mode",
                        StrictDelete: "Delete of an unqualified identifier in strict mode.",
                        StrictFunction: "In strict mode code, functions can only be declared at top level or inside a block",
                        StrictFunctionName: "Function name may not be eval or arguments in strict mode",
                        StrictLHSAssignment: "Assignment to eval or arguments is not allowed in strict mode",
                        StrictLHSPostfix: "Postfix increment/decrement may not have eval or arguments operand in strict mode",
                        StrictLHSPrefix: "Prefix increment/decrement may not have eval or arguments operand in strict mode",
                        StrictModeWith: "Strict mode code may not include a with statement",
                        StrictOctalLiteral: "Octal literals are not allowed in strict mode.",
                        StrictParamDupe: "Strict mode function may not have duplicate parameter names",
                        StrictParamName: "Parameter name eval or arguments is not allowed in strict mode",
                        StrictReservedWord: "Use of future reserved word in strict mode",
                        StrictVarName: "Variable name may not be eval or arguments in strict mode",
                        TemplateOctalLiteral: "Octal literals are not allowed in template strings.",
                        UnexpectedEOS: "Unexpected end of input",
                        UnexpectedIdentifier: "Unexpected identifier",
                        UnexpectedNumber: "Unexpected number",
                        UnexpectedReserved: "Unexpected reserved word",
                        UnexpectedString: "Unexpected string",
                        UnexpectedTemplate: "Unexpected quasi %0",
                        UnexpectedToken: "Unexpected token %0",
                        UnexpectedTokenIllegal: "Unexpected token ILLEGAL",
                        UnknownLabel: "Undefined label '%0'",
                        UnterminatedRegExp: "Invalid regular expression: missing /"
                    };
                }, function(e, t, i) {
                    "use strict";
                    Object.defineProperty(t, "__esModule", {
                        value: true
                    });
                    var r = i(9);
                    var s = i(4);
                    var a = i(11);
                    function n(e) {
                        return "0123456789abcdef".indexOf(e.toLowerCase());
                    }
                    function o(e) {
                        return "01234567".indexOf(e);
                    }
                    var l = function() {
                        function e(e, t) {
                            this.source = e;
                            this.errorHandler = t;
                            this.trackComment = false;
                            this.isModule = false;
                            this.length = e.length;
                            this.index = 0;
                            this.lineNumber = e.length > 0 ? 1 : 0;
                            this.lineStart = 0;
                            this.curlyStack = [];
                        }
                        e.prototype.saveState = function() {
                            return {
                                index: this.index,
                                lineNumber: this.lineNumber,
                                lineStart: this.lineStart
                            };
                        };
                        e.prototype.restoreState = function(e) {
                            this.index = e.index;
                            this.lineNumber = e.lineNumber;
                            this.lineStart = e.lineStart;
                        };
                        e.prototype.eof = function() {
                            return this.index >= this.length;
                        };
                        e.prototype.throwUnexpectedToken = function(e) {
                            if (e === void 0) {
                                e = a.Messages.UnexpectedTokenIllegal;
                            }
                            return this.errorHandler.throwError(this.index, this.lineNumber, this.index - this.lineStart + 1, e);
                        };
                        e.prototype.tolerateUnexpectedToken = function(e) {
                            if (e === void 0) {
                                e = a.Messages.UnexpectedTokenIllegal;
                            }
                            this.errorHandler.tolerateError(this.index, this.lineNumber, this.index - this.lineStart + 1, e);
                        };
                        e.prototype.skipSingleLineComment = function(e) {
                            var t = [];
                            var i, r;
                            if (this.trackComment) {
                                t = [];
                                i = this.index - e;
                                r = {
                                    start: {
                                        line: this.lineNumber,
                                        column: this.index - this.lineStart - e
                                    },
                                    end: {}
                                };
                            }
                            while (!this.eof()) {
                                var a = this.source.charCodeAt(this.index);
                                ++this.index;
                                if (s.Character.isLineTerminator(a)) {
                                    if (this.trackComment) {
                                        r.end = {
                                            line: this.lineNumber,
                                            column: this.index - this.lineStart - 1
                                        };
                                        var n = {
                                            multiLine: false,
                                            slice: [ i + e, this.index - 1 ],
                                            range: [ i, this.index - 1 ],
                                            loc: r
                                        };
                                        t.push(n);
                                    }
                                    if (a === 13 && this.source.charCodeAt(this.index) === 10) {
                                        ++this.index;
                                    }
                                    ++this.lineNumber;
                                    this.lineStart = this.index;
                                    return t;
                                }
                            }
                            if (this.trackComment) {
                                r.end = {
                                    line: this.lineNumber,
                                    column: this.index - this.lineStart
                                };
                                var n = {
                                    multiLine: false,
                                    slice: [ i + e, this.index ],
                                    range: [ i, this.index ],
                                    loc: r
                                };
                                t.push(n);
                            }
                            return t;
                        };
                        e.prototype.skipMultiLineComment = function() {
                            var e = [];
                            var t, i;
                            if (this.trackComment) {
                                e = [];
                                t = this.index - 2;
                                i = {
                                    start: {
                                        line: this.lineNumber,
                                        column: this.index - this.lineStart - 2
                                    },
                                    end: {}
                                };
                            }
                            while (!this.eof()) {
                                var r = this.source.charCodeAt(this.index);
                                if (s.Character.isLineTerminator(r)) {
                                    if (r === 13 && this.source.charCodeAt(this.index + 1) === 10) {
                                        ++this.index;
                                    }
                                    ++this.lineNumber;
                                    ++this.index;
                                    this.lineStart = this.index;
                                } else if (r === 42) {
                                    if (this.source.charCodeAt(this.index + 1) === 47) {
                                        this.index += 2;
                                        if (this.trackComment) {
                                            i.end = {
                                                line: this.lineNumber,
                                                column: this.index - this.lineStart
                                            };
                                            var a = {
                                                multiLine: true,
                                                slice: [ t + 2, this.index - 2 ],
                                                range: [ t, this.index ],
                                                loc: i
                                            };
                                            e.push(a);
                                        }
                                        return e;
                                    }
                                    ++this.index;
                                } else {
                                    ++this.index;
                                }
                            }
                            if (this.trackComment) {
                                i.end = {
                                    line: this.lineNumber,
                                    column: this.index - this.lineStart
                                };
                                var a = {
                                    multiLine: true,
                                    slice: [ t + 2, this.index ],
                                    range: [ t, this.index ],
                                    loc: i
                                };
                                e.push(a);
                            }
                            this.tolerateUnexpectedToken();
                            return e;
                        };
                        e.prototype.scanComments = function() {
                            var e;
                            if (this.trackComment) {
                                e = [];
                            }
                            var t = this.index === 0;
                            while (!this.eof()) {
                                var i = this.source.charCodeAt(this.index);
                                if (s.Character.isWhiteSpace(i)) {
                                    ++this.index;
                                } else if (s.Character.isLineTerminator(i)) {
                                    ++this.index;
                                    if (i === 13 && this.source.charCodeAt(this.index) === 10) {
                                        ++this.index;
                                    }
                                    ++this.lineNumber;
                                    this.lineStart = this.index;
                                    t = true;
                                } else if (i === 47) {
                                    i = this.source.charCodeAt(this.index + 1);
                                    if (i === 47) {
                                        this.index += 2;
                                        var r = this.skipSingleLineComment(2);
                                        if (this.trackComment) {
                                            e = e.concat(r);
                                        }
                                        t = true;
                                    } else if (i === 42) {
                                        this.index += 2;
                                        var r = this.skipMultiLineComment();
                                        if (this.trackComment) {
                                            e = e.concat(r);
                                        }
                                    } else {
                                        break;
                                    }
                                } else if (t && i === 45) {
                                    if (this.source.charCodeAt(this.index + 1) === 45 && this.source.charCodeAt(this.index + 2) === 62) {
                                        this.index += 3;
                                        var r = this.skipSingleLineComment(3);
                                        if (this.trackComment) {
                                            e = e.concat(r);
                                        }
                                    } else {
                                        break;
                                    }
                                } else if (i === 60 && !this.isModule) {
                                    if (this.source.slice(this.index + 1, this.index + 4) === "!--") {
                                        this.index += 4;
                                        var r = this.skipSingleLineComment(4);
                                        if (this.trackComment) {
                                            e = e.concat(r);
                                        }
                                    } else {
                                        break;
                                    }
                                } else {
                                    break;
                                }
                            }
                            return e;
                        };
                        e.prototype.isFutureReservedWord = function(e) {
                            switch (e) {
                              case "enum":
                              case "export":
                              case "import":
                              case "super":
                                return true;

                              default:
                                return false;
                            }
                        };
                        e.prototype.isStrictModeReservedWord = function(e) {
                            switch (e) {
                              case "implements":
                              case "interface":
                              case "package":
                              case "private":
                              case "protected":
                              case "public":
                              case "static":
                              case "yield":
                              case "let":
                                return true;

                              default:
                                return false;
                            }
                        };
                        e.prototype.isRestrictedWord = function(e) {
                            return e === "eval" || e === "arguments";
                        };
                        e.prototype.isKeyword = function(e) {
                            switch (e.length) {
                              case 2:
                                return e === "if" || e === "in" || e === "do";

                              case 3:
                                return e === "var" || e === "for" || e === "new" || e === "try" || e === "let";

                              case 4:
                                return e === "this" || e === "else" || e === "case" || e === "void" || e === "with" || e === "enum";

                              case 5:
                                return e === "while" || e === "break" || e === "catch" || e === "throw" || e === "const" || e === "yield" || e === "class" || e === "super";

                              case 6:
                                return e === "return" || e === "typeof" || e === "delete" || e === "switch" || e === "export" || e === "import";

                              case 7:
                                return e === "default" || e === "finally" || e === "extends";

                              case 8:
                                return e === "function" || e === "continue" || e === "debugger";

                              case 10:
                                return e === "instanceof";

                              default:
                                return false;
                            }
                        };
                        e.prototype.codePointAt = function(e) {
                            var t = this.source.charCodeAt(e);
                            if (t >= 55296 && t <= 56319) {
                                var i = this.source.charCodeAt(e + 1);
                                if (i >= 56320 && i <= 57343) {
                                    var r = t;
                                    t = (r - 55296) * 1024 + i - 56320 + 65536;
                                }
                            }
                            return t;
                        };
                        e.prototype.scanHexEscape = function(e) {
                            var t = e === "u" ? 4 : 2;
                            var i = 0;
                            for (var r = 0; r < t; ++r) {
                                if (!this.eof() && s.Character.isHexDigit(this.source.charCodeAt(this.index))) {
                                    i = i * 16 + n(this.source[this.index++]);
                                } else {
                                    return null;
                                }
                            }
                            return String.fromCharCode(i);
                        };
                        e.prototype.scanUnicodeCodePointEscape = function() {
                            var e = this.source[this.index];
                            var t = 0;
                            if (e === "}") {
                                this.throwUnexpectedToken();
                            }
                            while (!this.eof()) {
                                e = this.source[this.index++];
                                if (!s.Character.isHexDigit(e.charCodeAt(0))) {
                                    break;
                                }
                                t = t * 16 + n(e);
                            }
                            if (t > 1114111 || e !== "}") {
                                this.throwUnexpectedToken();
                            }
                            return s.Character.fromCodePoint(t);
                        };
                        e.prototype.getIdentifier = function() {
                            var e = this.index++;
                            while (!this.eof()) {
                                var t = this.source.charCodeAt(this.index);
                                if (t === 92) {
                                    this.index = e;
                                    return this.getComplexIdentifier();
                                } else if (t >= 55296 && t < 57343) {
                                    this.index = e;
                                    return this.getComplexIdentifier();
                                }
                                if (s.Character.isIdentifierPart(t)) {
                                    ++this.index;
                                } else {
                                    break;
                                }
                            }
                            return this.source.slice(e, this.index);
                        };
                        e.prototype.getComplexIdentifier = function() {
                            var e = this.codePointAt(this.index);
                            var t = s.Character.fromCodePoint(e);
                            this.index += t.length;
                            var i;
                            if (e === 92) {
                                if (this.source.charCodeAt(this.index) !== 117) {
                                    this.throwUnexpectedToken();
                                }
                                ++this.index;
                                if (this.source[this.index] === "{") {
                                    ++this.index;
                                    i = this.scanUnicodeCodePointEscape();
                                } else {
                                    i = this.scanHexEscape("u");
                                    if (i === null || i === "\\" || !s.Character.isIdentifierStart(i.charCodeAt(0))) {
                                        this.throwUnexpectedToken();
                                    }
                                }
                                t = i;
                            }
                            while (!this.eof()) {
                                e = this.codePointAt(this.index);
                                if (!s.Character.isIdentifierPart(e)) {
                                    break;
                                }
                                i = s.Character.fromCodePoint(e);
                                t += i;
                                this.index += i.length;
                                if (e === 92) {
                                    t = t.substr(0, t.length - 1);
                                    if (this.source.charCodeAt(this.index) !== 117) {
                                        this.throwUnexpectedToken();
                                    }
                                    ++this.index;
                                    if (this.source[this.index] === "{") {
                                        ++this.index;
                                        i = this.scanUnicodeCodePointEscape();
                                    } else {
                                        i = this.scanHexEscape("u");
                                        if (i === null || i === "\\" || !s.Character.isIdentifierPart(i.charCodeAt(0))) {
                                            this.throwUnexpectedToken();
                                        }
                                    }
                                    t += i;
                                }
                            }
                            return t;
                        };
                        e.prototype.octalToDecimal = function(e) {
                            var t = e !== "0";
                            var i = o(e);
                            if (!this.eof() && s.Character.isOctalDigit(this.source.charCodeAt(this.index))) {
                                t = true;
                                i = i * 8 + o(this.source[this.index++]);
                                if ("0123".indexOf(e) >= 0 && !this.eof() && s.Character.isOctalDigit(this.source.charCodeAt(this.index))) {
                                    i = i * 8 + o(this.source[this.index++]);
                                }
                            }
                            return {
                                code: i,
                                octal: t
                            };
                        };
                        e.prototype.scanIdentifier = function() {
                            var e;
                            var t = this.index;
                            var i = this.source.charCodeAt(t) === 92 ? this.getComplexIdentifier() : this.getIdentifier();
                            if (i.length === 1) {
                                e = 3;
                            } else if (this.isKeyword(i)) {
                                e = 4;
                            } else if (i === "null") {
                                e = 5;
                            } else if (i === "true" || i === "false") {
                                e = 1;
                            } else {
                                e = 3;
                            }
                            if (e !== 3 && t + i.length !== this.index) {
                                var r = this.index;
                                this.index = t;
                                this.tolerateUnexpectedToken(a.Messages.InvalidEscapedReservedWord);
                                this.index = r;
                            }
                            return {
                                type: e,
                                value: i,
                                lineNumber: this.lineNumber,
                                lineStart: this.lineStart,
                                start: t,
                                end: this.index
                            };
                        };
                        e.prototype.scanPunctuator = function() {
                            var e = this.index;
                            var t = this.source[this.index];
                            switch (t) {
                              case "(":
                              case "{":
                                if (t === "{") {
                                    this.curlyStack.push("{");
                                }
                                ++this.index;
                                break;

                              case ".":
                                ++this.index;
                                if (this.source[this.index] === "." && this.source[this.index + 1] === ".") {
                                    this.index += 2;
                                    t = "...";
                                }
                                break;

                              case "}":
                                ++this.index;
                                this.curlyStack.pop();
                                break;

                              case ")":
                              case ";":
                              case ",":
                              case "[":
                              case "]":
                              case ":":
                              case "?":
                              case "~":
                                ++this.index;
                                break;

                              default:
                                t = this.source.substr(this.index, 4);
                                if (t === ">>>=") {
                                    this.index += 4;
                                } else {
                                    t = t.substr(0, 3);
                                    if (t === "===" || t === "!==" || t === ">>>" || t === "<<=" || t === ">>=" || t === "**=") {
                                        this.index += 3;
                                    } else {
                                        t = t.substr(0, 2);
                                        if (t === "&&" || t === "||" || t === "==" || t === "!=" || t === "+=" || t === "-=" || t === "*=" || t === "/=" || t === "++" || t === "--" || t === "<<" || t === ">>" || t === "&=" || t === "|=" || t === "^=" || t === "%=" || t === "<=" || t === ">=" || t === "=>" || t === "**") {
                                            this.index += 2;
                                        } else {
                                            t = this.source[this.index];
                                            if ("<>=!+-*%&|^/".indexOf(t) >= 0) {
                                                ++this.index;
                                            }
                                        }
                                    }
                                }
                            }
                            if (this.index === e) {
                                this.throwUnexpectedToken();
                            }
                            return {
                                type: 7,
                                value: t,
                                lineNumber: this.lineNumber,
                                lineStart: this.lineStart,
                                start: e,
                                end: this.index
                            };
                        };
                        e.prototype.scanHexLiteral = function(e) {
                            var t = "";
                            while (!this.eof()) {
                                if (!s.Character.isHexDigit(this.source.charCodeAt(this.index))) {
                                    break;
                                }
                                t += this.source[this.index++];
                            }
                            if (t.length === 0) {
                                this.throwUnexpectedToken();
                            }
                            if (s.Character.isIdentifierStart(this.source.charCodeAt(this.index))) {
                                this.throwUnexpectedToken();
                            }
                            return {
                                type: 6,
                                value: parseInt("0x" + t, 16),
                                lineNumber: this.lineNumber,
                                lineStart: this.lineStart,
                                start: e,
                                end: this.index
                            };
                        };
                        e.prototype.scanBinaryLiteral = function(e) {
                            var t = "";
                            var i;
                            while (!this.eof()) {
                                i = this.source[this.index];
                                if (i !== "0" && i !== "1") {
                                    break;
                                }
                                t += this.source[this.index++];
                            }
                            if (t.length === 0) {
                                this.throwUnexpectedToken();
                            }
                            if (!this.eof()) {
                                i = this.source.charCodeAt(this.index);
                                if (s.Character.isIdentifierStart(i) || s.Character.isDecimalDigit(i)) {
                                    this.throwUnexpectedToken();
                                }
                            }
                            return {
                                type: 6,
                                value: parseInt(t, 2),
                                lineNumber: this.lineNumber,
                                lineStart: this.lineStart,
                                start: e,
                                end: this.index
                            };
                        };
                        e.prototype.scanOctalLiteral = function(e, t) {
                            var i = "";
                            var r = false;
                            if (s.Character.isOctalDigit(e.charCodeAt(0))) {
                                r = true;
                                i = "0" + this.source[this.index++];
                            } else {
                                ++this.index;
                            }
                            while (!this.eof()) {
                                if (!s.Character.isOctalDigit(this.source.charCodeAt(this.index))) {
                                    break;
                                }
                                i += this.source[this.index++];
                            }
                            if (!r && i.length === 0) {
                                this.throwUnexpectedToken();
                            }
                            if (s.Character.isIdentifierStart(this.source.charCodeAt(this.index)) || s.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
                                this.throwUnexpectedToken();
                            }
                            return {
                                type: 6,
                                value: parseInt(i, 8),
                                octal: r,
                                lineNumber: this.lineNumber,
                                lineStart: this.lineStart,
                                start: t,
                                end: this.index
                            };
                        };
                        e.prototype.isImplicitOctalLiteral = function() {
                            for (var e = this.index + 1; e < this.length; ++e) {
                                var t = this.source[e];
                                if (t === "8" || t === "9") {
                                    return false;
                                }
                                if (!s.Character.isOctalDigit(t.charCodeAt(0))) {
                                    return true;
                                }
                            }
                            return true;
                        };
                        e.prototype.scanNumericLiteral = function() {
                            var e = this.index;
                            var t = this.source[e];
                            r.assert(s.Character.isDecimalDigit(t.charCodeAt(0)) || t === ".", "Numeric literal must start with a decimal digit or a decimal point");
                            var i = "";
                            if (t !== ".") {
                                i = this.source[this.index++];
                                t = this.source[this.index];
                                if (i === "0") {
                                    if (t === "x" || t === "X") {
                                        ++this.index;
                                        return this.scanHexLiteral(e);
                                    }
                                    if (t === "b" || t === "B") {
                                        ++this.index;
                                        return this.scanBinaryLiteral(e);
                                    }
                                    if (t === "o" || t === "O") {
                                        return this.scanOctalLiteral(t, e);
                                    }
                                    if (t && s.Character.isOctalDigit(t.charCodeAt(0))) {
                                        if (this.isImplicitOctalLiteral()) {
                                            return this.scanOctalLiteral(t, e);
                                        }
                                    }
                                }
                                while (s.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
                                    i += this.source[this.index++];
                                }
                                t = this.source[this.index];
                            }
                            if (t === ".") {
                                i += this.source[this.index++];
                                while (s.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
                                    i += this.source[this.index++];
                                }
                                t = this.source[this.index];
                            }
                            if (t === "e" || t === "E") {
                                i += this.source[this.index++];
                                t = this.source[this.index];
                                if (t === "+" || t === "-") {
                                    i += this.source[this.index++];
                                }
                                if (s.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
                                    while (s.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
                                        i += this.source[this.index++];
                                    }
                                } else {
                                    this.throwUnexpectedToken();
                                }
                            }
                            if (s.Character.isIdentifierStart(this.source.charCodeAt(this.index))) {
                                this.throwUnexpectedToken();
                            }
                            return {
                                type: 6,
                                value: parseFloat(i),
                                lineNumber: this.lineNumber,
                                lineStart: this.lineStart,
                                start: e,
                                end: this.index
                            };
                        };
                        e.prototype.scanStringLiteral = function() {
                            var e = this.index;
                            var t = this.source[e];
                            r.assert(t === "'" || t === '"', "String literal must starts with a quote");
                            ++this.index;
                            var i = false;
                            var n = "";
                            while (!this.eof()) {
                                var o = this.source[this.index++];
                                if (o === t) {
                                    t = "";
                                    break;
                                } else if (o === "\\") {
                                    o = this.source[this.index++];
                                    if (!o || !s.Character.isLineTerminator(o.charCodeAt(0))) {
                                        switch (o) {
                                          case "u":
                                            if (this.source[this.index] === "{") {
                                                ++this.index;
                                                n += this.scanUnicodeCodePointEscape();
                                            } else {
                                                var l = this.scanHexEscape(o);
                                                if (l === null) {
                                                    this.throwUnexpectedToken();
                                                }
                                                n += l;
                                            }
                                            break;

                                          case "x":
                                            var u = this.scanHexEscape(o);
                                            if (u === null) {
                                                this.throwUnexpectedToken(a.Messages.InvalidHexEscapeSequence);
                                            }
                                            n += u;
                                            break;

                                          case "n":
                                            n += "\n";
                                            break;

                                          case "r":
                                            n += "\r";
                                            break;

                                          case "t":
                                            n += "\t";
                                            break;

                                          case "b":
                                            n += "\b";
                                            break;

                                          case "f":
                                            n += "\f";
                                            break;

                                          case "v":
                                            n += "\v";
                                            break;

                                          case "8":
                                          case "9":
                                            n += o;
                                            this.tolerateUnexpectedToken();
                                            break;

                                          default:
                                            if (o && s.Character.isOctalDigit(o.charCodeAt(0))) {
                                                var c = this.octalToDecimal(o);
                                                i = c.octal || i;
                                                n += String.fromCharCode(c.code);
                                            } else {
                                                n += o;
                                            }
                                            break;
                                        }
                                    } else {
                                        ++this.lineNumber;
                                        if (o === "\r" && this.source[this.index] === "\n") {
                                            ++this.index;
                                        }
                                        this.lineStart = this.index;
                                    }
                                } else if (s.Character.isLineTerminator(o.charCodeAt(0))) {
                                    break;
                                } else {
                                    n += o;
                                }
                            }
                            if (t !== "") {
                                this.index = e;
                                this.throwUnexpectedToken();
                            }
                            return {
                                type: 8,
                                value: n,
                                octal: i,
                                lineNumber: this.lineNumber,
                                lineStart: this.lineStart,
                                start: e,
                                end: this.index
                            };
                        };
                        e.prototype.scanTemplate = function() {
                            var e = "";
                            var t = false;
                            var i = this.index;
                            var r = this.source[i] === "`";
                            var n = false;
                            var o = 2;
                            ++this.index;
                            while (!this.eof()) {
                                var l = this.source[this.index++];
                                if (l === "`") {
                                    o = 1;
                                    n = true;
                                    t = true;
                                    break;
                                } else if (l === "$") {
                                    if (this.source[this.index] === "{") {
                                        this.curlyStack.push("${");
                                        ++this.index;
                                        t = true;
                                        break;
                                    }
                                    e += l;
                                } else if (l === "\\") {
                                    l = this.source[this.index++];
                                    if (!s.Character.isLineTerminator(l.charCodeAt(0))) {
                                        switch (l) {
                                          case "n":
                                            e += "\n";
                                            break;

                                          case "r":
                                            e += "\r";
                                            break;

                                          case "t":
                                            e += "\t";
                                            break;

                                          case "u":
                                            if (this.source[this.index] === "{") {
                                                ++this.index;
                                                e += this.scanUnicodeCodePointEscape();
                                            } else {
                                                var u = this.index;
                                                var c = this.scanHexEscape(l);
                                                if (c !== null) {
                                                    e += c;
                                                } else {
                                                    this.index = u;
                                                    e += l;
                                                }
                                            }
                                            break;

                                          case "x":
                                            var h = this.scanHexEscape(l);
                                            if (h === null) {
                                                this.throwUnexpectedToken(a.Messages.InvalidHexEscapeSequence);
                                            }
                                            e += h;
                                            break;

                                          case "b":
                                            e += "\b";
                                            break;

                                          case "f":
                                            e += "\f";
                                            break;

                                          case "v":
                                            e += "\v";
                                            break;

                                          default:
                                            if (l === "0") {
                                                if (s.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
                                                    this.throwUnexpectedToken(a.Messages.TemplateOctalLiteral);
                                                }
                                                e += "\0";
                                            } else if (s.Character.isOctalDigit(l.charCodeAt(0))) {
                                                this.throwUnexpectedToken(a.Messages.TemplateOctalLiteral);
                                            } else {
                                                e += l;
                                            }
                                            break;
                                        }
                                    } else {
                                        ++this.lineNumber;
                                        if (l === "\r" && this.source[this.index] === "\n") {
                                            ++this.index;
                                        }
                                        this.lineStart = this.index;
                                    }
                                } else if (s.Character.isLineTerminator(l.charCodeAt(0))) {
                                    ++this.lineNumber;
                                    if (l === "\r" && this.source[this.index] === "\n") {
                                        ++this.index;
                                    }
                                    this.lineStart = this.index;
                                    e += "\n";
                                } else {
                                    e += l;
                                }
                            }
                            if (!t) {
                                this.throwUnexpectedToken();
                            }
                            if (!r) {
                                this.curlyStack.pop();
                            }
                            return {
                                type: 10,
                                value: this.source.slice(i + 1, this.index - o),
                                cooked: e,
                                head: r,
                                tail: n,
                                lineNumber: this.lineNumber,
                                lineStart: this.lineStart,
                                start: i,
                                end: this.index
                            };
                        };
                        e.prototype.testRegExp = function(e, t) {
                            var i = "￿";
                            var r = e;
                            var s = this;
                            if (t.indexOf("u") >= 0) {
                                r = r.replace(/\\u\{([0-9a-fA-F]+)\}|\\u([a-fA-F0-9]{4})/g, function(e, t, r) {
                                    var n = parseInt(t || r, 16);
                                    if (n > 1114111) {
                                        s.throwUnexpectedToken(a.Messages.InvalidRegExp);
                                    }
                                    if (n <= 65535) {
                                        return String.fromCharCode(n);
                                    }
                                    return i;
                                }).replace(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g, i);
                            }
                            try {
                                RegExp(r);
                            } catch (e) {
                                this.throwUnexpectedToken(a.Messages.InvalidRegExp);
                            }
                            try {
                                return new RegExp(e, t);
                            } catch (e) {
                                return null;
                            }
                        };
                        e.prototype.scanRegExpBody = function() {
                            var e = this.source[this.index];
                            r.assert(e === "/", "Regular expression literal must start with a slash");
                            var t = this.source[this.index++];
                            var i = false;
                            var n = false;
                            while (!this.eof()) {
                                e = this.source[this.index++];
                                t += e;
                                if (e === "\\") {
                                    e = this.source[this.index++];
                                    if (s.Character.isLineTerminator(e.charCodeAt(0))) {
                                        this.throwUnexpectedToken(a.Messages.UnterminatedRegExp);
                                    }
                                    t += e;
                                } else if (s.Character.isLineTerminator(e.charCodeAt(0))) {
                                    this.throwUnexpectedToken(a.Messages.UnterminatedRegExp);
                                } else if (i) {
                                    if (e === "]") {
                                        i = false;
                                    }
                                } else {
                                    if (e === "/") {
                                        n = true;
                                        break;
                                    } else if (e === "[") {
                                        i = true;
                                    }
                                }
                            }
                            if (!n) {
                                this.throwUnexpectedToken(a.Messages.UnterminatedRegExp);
                            }
                            return t.substr(1, t.length - 2);
                        };
                        e.prototype.scanRegExpFlags = function() {
                            var e = "";
                            var t = "";
                            while (!this.eof()) {
                                var i = this.source[this.index];
                                if (!s.Character.isIdentifierPart(i.charCodeAt(0))) {
                                    break;
                                }
                                ++this.index;
                                if (i === "\\" && !this.eof()) {
                                    i = this.source[this.index];
                                    if (i === "u") {
                                        ++this.index;
                                        var r = this.index;
                                        var a = this.scanHexEscape("u");
                                        if (a !== null) {
                                            t += a;
                                            for (e += "\\u"; r < this.index; ++r) {
                                                e += this.source[r];
                                            }
                                        } else {
                                            this.index = r;
                                            t += "u";
                                            e += "\\u";
                                        }
                                        this.tolerateUnexpectedToken();
                                    } else {
                                        e += "\\";
                                        this.tolerateUnexpectedToken();
                                    }
                                } else {
                                    t += i;
                                    e += i;
                                }
                            }
                            return t;
                        };
                        e.prototype.scanRegExp = function() {
                            var e = this.index;
                            var t = this.scanRegExpBody();
                            var i = this.scanRegExpFlags();
                            var r = this.testRegExp(t, i);
                            return {
                                type: 9,
                                value: "",
                                pattern: t,
                                flags: i,
                                regex: r,
                                lineNumber: this.lineNumber,
                                lineStart: this.lineStart,
                                start: e,
                                end: this.index
                            };
                        };
                        e.prototype.lex = function() {
                            if (this.eof()) {
                                return {
                                    type: 2,
                                    value: "",
                                    lineNumber: this.lineNumber,
                                    lineStart: this.lineStart,
                                    start: this.index,
                                    end: this.index
                                };
                            }
                            var e = this.source.charCodeAt(this.index);
                            if (s.Character.isIdentifierStart(e)) {
                                return this.scanIdentifier();
                            }
                            if (e === 40 || e === 41 || e === 59) {
                                return this.scanPunctuator();
                            }
                            if (e === 39 || e === 34) {
                                return this.scanStringLiteral();
                            }
                            if (e === 46) {
                                if (s.Character.isDecimalDigit(this.source.charCodeAt(this.index + 1))) {
                                    return this.scanNumericLiteral();
                                }
                                return this.scanPunctuator();
                            }
                            if (s.Character.isDecimalDigit(e)) {
                                return this.scanNumericLiteral();
                            }
                            if (e === 96 || e === 125 && this.curlyStack[this.curlyStack.length - 1] === "${") {
                                return this.scanTemplate();
                            }
                            if (e >= 55296 && e < 57343) {
                                if (s.Character.isIdentifierStart(this.codePointAt(this.index))) {
                                    return this.scanIdentifier();
                                }
                            }
                            return this.scanPunctuator();
                        };
                        return e;
                    }();
                    t.Scanner = l;
                }, function(e, t) {
                    "use strict";
                    Object.defineProperty(t, "__esModule", {
                        value: true
                    });
                    t.TokenName = {};
                    t.TokenName[1] = "Boolean";
                    t.TokenName[2] = "<end>";
                    t.TokenName[3] = "Identifier";
                    t.TokenName[4] = "Keyword";
                    t.TokenName[5] = "Null";
                    t.TokenName[6] = "Numeric";
                    t.TokenName[7] = "Punctuator";
                    t.TokenName[8] = "String";
                    t.TokenName[9] = "RegularExpression";
                    t.TokenName[10] = "Template";
                }, function(e, t) {
                    "use strict";
                    Object.defineProperty(t, "__esModule", {
                        value: true
                    });
                    t.XHTMLEntities = {
                        quot: '"',
                        amp: "&",
                        apos: "'",
                        gt: ">",
                        nbsp: " ",
                        iexcl: "¡",
                        cent: "¢",
                        pound: "£",
                        curren: "¤",
                        yen: "¥",
                        brvbar: "¦",
                        sect: "§",
                        uml: "¨",
                        copy: "©",
                        ordf: "ª",
                        laquo: "«",
                        not: "¬",
                        shy: "­",
                        reg: "®",
                        macr: "¯",
                        deg: "°",
                        plusmn: "±",
                        sup2: "²",
                        sup3: "³",
                        acute: "´",
                        micro: "µ",
                        para: "¶",
                        middot: "·",
                        cedil: "¸",
                        sup1: "¹",
                        ordm: "º",
                        raquo: "»",
                        frac14: "¼",
                        frac12: "½",
                        frac34: "¾",
                        iquest: "¿",
                        Agrave: "À",
                        Aacute: "Á",
                        Acirc: "Â",
                        Atilde: "Ã",
                        Auml: "Ä",
                        Aring: "Å",
                        AElig: "Æ",
                        Ccedil: "Ç",
                        Egrave: "È",
                        Eacute: "É",
                        Ecirc: "Ê",
                        Euml: "Ë",
                        Igrave: "Ì",
                        Iacute: "Í",
                        Icirc: "Î",
                        Iuml: "Ï",
                        ETH: "Ð",
                        Ntilde: "Ñ",
                        Ograve: "Ò",
                        Oacute: "Ó",
                        Ocirc: "Ô",
                        Otilde: "Õ",
                        Ouml: "Ö",
                        times: "×",
                        Oslash: "Ø",
                        Ugrave: "Ù",
                        Uacute: "Ú",
                        Ucirc: "Û",
                        Uuml: "Ü",
                        Yacute: "Ý",
                        THORN: "Þ",
                        szlig: "ß",
                        agrave: "à",
                        aacute: "á",
                        acirc: "â",
                        atilde: "ã",
                        auml: "ä",
                        aring: "å",
                        aelig: "æ",
                        ccedil: "ç",
                        egrave: "è",
                        eacute: "é",
                        ecirc: "ê",
                        euml: "ë",
                        igrave: "ì",
                        iacute: "í",
                        icirc: "î",
                        iuml: "ï",
                        eth: "ð",
                        ntilde: "ñ",
                        ograve: "ò",
                        oacute: "ó",
                        ocirc: "ô",
                        otilde: "õ",
                        ouml: "ö",
                        divide: "÷",
                        oslash: "ø",
                        ugrave: "ù",
                        uacute: "ú",
                        ucirc: "û",
                        uuml: "ü",
                        yacute: "ý",
                        thorn: "þ",
                        yuml: "ÿ",
                        OElig: "Œ",
                        oelig: "œ",
                        Scaron: "Š",
                        scaron: "š",
                        Yuml: "Ÿ",
                        fnof: "ƒ",
                        circ: "ˆ",
                        tilde: "˜",
                        Alpha: "Α",
                        Beta: "Β",
                        Gamma: "Γ",
                        Delta: "Δ",
                        Epsilon: "Ε",
                        Zeta: "Ζ",
                        Eta: "Η",
                        Theta: "Θ",
                        Iota: "Ι",
                        Kappa: "Κ",
                        Lambda: "Λ",
                        Mu: "Μ",
                        Nu: "Ν",
                        Xi: "Ξ",
                        Omicron: "Ο",
                        Pi: "Π",
                        Rho: "Ρ",
                        Sigma: "Σ",
                        Tau: "Τ",
                        Upsilon: "Υ",
                        Phi: "Φ",
                        Chi: "Χ",
                        Psi: "Ψ",
                        Omega: "Ω",
                        alpha: "α",
                        beta: "β",
                        gamma: "γ",
                        delta: "δ",
                        epsilon: "ε",
                        zeta: "ζ",
                        eta: "η",
                        theta: "θ",
                        iota: "ι",
                        kappa: "κ",
                        lambda: "λ",
                        mu: "μ",
                        nu: "ν",
                        xi: "ξ",
                        omicron: "ο",
                        pi: "π",
                        rho: "ρ",
                        sigmaf: "ς",
                        sigma: "σ",
                        tau: "τ",
                        upsilon: "υ",
                        phi: "φ",
                        chi: "χ",
                        psi: "ψ",
                        omega: "ω",
                        thetasym: "ϑ",
                        upsih: "ϒ",
                        piv: "ϖ",
                        ensp: " ",
                        emsp: " ",
                        thinsp: " ",
                        zwnj: "‌",
                        zwj: "‍",
                        lrm: "‎",
                        rlm: "‏",
                        ndash: "–",
                        mdash: "—",
                        lsquo: "‘",
                        rsquo: "’",
                        sbquo: "‚",
                        ldquo: "“",
                        rdquo: "”",
                        bdquo: "„",
                        dagger: "†",
                        Dagger: "‡",
                        bull: "•",
                        hellip: "…",
                        permil: "‰",
                        prime: "′",
                        Prime: "″",
                        lsaquo: "‹",
                        rsaquo: "›",
                        oline: "‾",
                        frasl: "⁄",
                        euro: "€",
                        image: "ℑ",
                        weierp: "℘",
                        real: "ℜ",
                        trade: "™",
                        alefsym: "ℵ",
                        larr: "←",
                        uarr: "↑",
                        rarr: "→",
                        darr: "↓",
                        harr: "↔",
                        crarr: "↵",
                        lArr: "⇐",
                        uArr: "⇑",
                        rArr: "⇒",
                        dArr: "⇓",
                        hArr: "⇔",
                        forall: "∀",
                        part: "∂",
                        exist: "∃",
                        empty: "∅",
                        nabla: "∇",
                        isin: "∈",
                        notin: "∉",
                        ni: "∋",
                        prod: "∏",
                        sum: "∑",
                        minus: "−",
                        lowast: "∗",
                        radic: "√",
                        prop: "∝",
                        infin: "∞",
                        ang: "∠",
                        and: "∧",
                        or: "∨",
                        cap: "∩",
                        cup: "∪",
                        int: "∫",
                        there4: "∴",
                        sim: "∼",
                        cong: "≅",
                        asymp: "≈",
                        ne: "≠",
                        equiv: "≡",
                        le: "≤",
                        ge: "≥",
                        sub: "⊂",
                        sup: "⊃",
                        nsub: "⊄",
                        sube: "⊆",
                        supe: "⊇",
                        oplus: "⊕",
                        otimes: "⊗",
                        perp: "⊥",
                        sdot: "⋅",
                        lceil: "⌈",
                        rceil: "⌉",
                        lfloor: "⌊",
                        rfloor: "⌋",
                        loz: "◊",
                        spades: "♠",
                        clubs: "♣",
                        hearts: "♥",
                        diams: "♦",
                        lang: "⟨",
                        rang: "⟩"
                    };
                }, function(e, t, i) {
                    "use strict";
                    Object.defineProperty(t, "__esModule", {
                        value: true
                    });
                    var r = i(10);
                    var s = i(12);
                    var a = i(13);
                    var n = function() {
                        function e() {
                            this.values = [];
                            this.curly = this.paren = -1;
                        }
                        e.prototype.beforeFunctionExpression = function(e) {
                            return [ "(", "{", "[", "in", "typeof", "instanceof", "new", "return", "case", "delete", "throw", "void", "=", "+=", "-=", "*=", "**=", "/=", "%=", "<<=", ">>=", ">>>=", "&=", "|=", "^=", ",", "+", "-", "*", "**", "/", "%", "++", "--", "<<", ">>", ">>>", "&", "|", "^", "!", "~", "&&", "||", "?", ":", "===", "==", ">=", "<=", "<", ">", "!=", "!==" ].indexOf(e) >= 0;
                        };
                        e.prototype.isRegexStart = function() {
                            var e = this.values[this.values.length - 1];
                            var t = e !== null;
                            switch (e) {
                              case "this":
                              case "]":
                                t = false;
                                break;

                              case ")":
                                var i = this.values[this.paren - 1];
                                t = i === "if" || i === "while" || i === "for" || i === "with";
                                break;

                              case "}":
                                t = false;
                                if (this.values[this.curly - 3] === "function") {
                                    var r = this.values[this.curly - 4];
                                    t = r ? !this.beforeFunctionExpression(r) : false;
                                } else if (this.values[this.curly - 4] === "function") {
                                    var r = this.values[this.curly - 5];
                                    t = r ? !this.beforeFunctionExpression(r) : true;
                                }
                                break;

                              default:
                                break;
                            }
                            return t;
                        };
                        e.prototype.push = function(e) {
                            if (e.type === 7 || e.type === 4) {
                                if (e.value === "{") {
                                    this.curly = this.values.length;
                                } else if (e.value === "(") {
                                    this.paren = this.values.length;
                                }
                                this.values.push(e.value);
                            } else {
                                this.values.push(null);
                            }
                        };
                        return e;
                    }();
                    var o = function() {
                        function e(e, t) {
                            this.errorHandler = new r.ErrorHandler();
                            this.errorHandler.tolerant = t ? typeof t.tolerant === "boolean" && t.tolerant : false;
                            this.scanner = new s.Scanner(e, this.errorHandler);
                            this.scanner.trackComment = t ? typeof t.comment === "boolean" && t.comment : false;
                            this.trackRange = t ? typeof t.range === "boolean" && t.range : false;
                            this.trackLoc = t ? typeof t.loc === "boolean" && t.loc : false;
                            this.buffer = [];
                            this.reader = new n();
                        }
                        e.prototype.errors = function() {
                            return this.errorHandler.errors;
                        };
                        e.prototype.getNextToken = function() {
                            if (this.buffer.length === 0) {
                                var e = this.scanner.scanComments();
                                if (this.scanner.trackComment) {
                                    for (var t = 0; t < e.length; ++t) {
                                        var i = e[t];
                                        var r = this.scanner.source.slice(i.slice[0], i.slice[1]);
                                        var s = {
                                            type: i.multiLine ? "BlockComment" : "LineComment",
                                            value: r
                                        };
                                        if (this.trackRange) {
                                            s.range = i.range;
                                        }
                                        if (this.trackLoc) {
                                            s.loc = i.loc;
                                        }
                                        this.buffer.push(s);
                                    }
                                }
                                if (!this.scanner.eof()) {
                                    var n = void 0;
                                    if (this.trackLoc) {
                                        n = {
                                            start: {
                                                line: this.scanner.lineNumber,
                                                column: this.scanner.index - this.scanner.lineStart
                                            },
                                            end: {}
                                        };
                                    }
                                    var o = this.scanner.source[this.scanner.index] === "/" && this.reader.isRegexStart();
                                    var l = o ? this.scanner.scanRegExp() : this.scanner.lex();
                                    this.reader.push(l);
                                    var u = {
                                        type: a.TokenName[l.type],
                                        value: this.scanner.source.slice(l.start, l.end)
                                    };
                                    if (this.trackRange) {
                                        u.range = [ l.start, l.end ];
                                    }
                                    if (this.trackLoc) {
                                        n.end = {
                                            line: this.scanner.lineNumber,
                                            column: this.scanner.index - this.scanner.lineStart
                                        };
                                        u.loc = n;
                                    }
                                    if (l.type === 9) {
                                        var c = l.pattern;
                                        var h = l.flags;
                                        u.regex = {
                                            pattern: c,
                                            flags: h
                                        };
                                    }
                                    this.buffer.push(u);
                                }
                            }
                            return this.buffer.shift();
                        };
                        return e;
                    }();
                    t.Tokenizer = o;
                } ]);
            });
        }).call(t, i(90)(e));
    }, function(e, t) {
        "use strict";
        var i = Object;
        var r = Object.defineProperty;
        var s = Object.create;
        function a(e, t, s) {
            if (r) try {
                r.call(i, e, t, {
                    value: s
                });
            } catch (i) {
                e[t] = s;
            } else {
                e[t] = s;
            }
        }
        function n(e) {
            if (e) {
                a(e, "call", e.call);
                a(e, "apply", e.apply);
            }
            return e;
        }
        n(r);
        n(s);
        var o = n(Object.prototype.hasOwnProperty);
        var l = n(Number.prototype.toString);
        var u = n(String.prototype.slice);
        var c = function e() {};
        function h(e) {
            if (s) {
                return s.call(i, e);
            }
            c.prototype = e || null;
            return new c();
        }
        var p = Math.random;
        var f = h(null);
        function d() {
            do {
                var e = m(u.call(l.call(p(), 36), 2));
            } while (o.call(f, e));
            return f[e] = e;
        }
        function m(e) {
            var t = {};
            t[e] = true;
            return Object.keys(t)[0];
        }
        t.makeUniqueKey = d;
        var y = Object.getOwnPropertyNames;
        Object.getOwnPropertyNames = function e(t) {
            for (var i = y(t), r = 0, s = 0, a = i.length; r < a; ++r) {
                if (!o.call(f, i[r])) {
                    if (r > s) {
                        i[s] = i[r];
                    }
                    ++s;
                }
            }
            i.length = s;
            return i;
        };
        function v(e) {
            return h(null);
        }
        function x(e) {
            var t = d();
            var i = h(null);
            e = e || v;
            function r(r) {
                var s;
                function n(t, a) {
                    if (t === i) {
                        return a ? s = null : s || (s = e(r));
                    }
                }
                a(r, t, n);
            }
            function s(e) {
                if (!o.call(e, t)) r(e);
                return e[t](i);
            }
            s.forget = function(e) {
                if (o.call(e, t)) e[t](i, true);
            };
            return s;
        }
        t.makeAccessor = x;
    }, function(e, t, i) {
        "use strict";
        var r = i(7);
        var s = i(6);
        var a = s.namedTypes;
        var n = s.builtInTypes.array;
        var o = s.builtInTypes.object;
        var l = i(13);
        var u = l.fromString;
        var c = l.Lines;
        var h = l.concat;
        var p = i(8);
        var f = p.comparePos;
        var d = i(39).makeUniqueKey();
        function m(e, t, i) {
            if (!e) {
                return;
            }
            p.fixFaultyLocations(e, t);
            if (i) {
                if (a.Node.check(e) && a.SourceLocation.check(e.loc)) {
                    for (var r = i.length - 1; r >= 0; --r) {
                        if (f(i[r].loc.end, e.loc.start) <= 0) {
                            break;
                        }
                    }
                    i.splice(r + 1, 0, e);
                    return;
                }
            } else if (e[d]) {
                return e[d];
            }
            var l;
            if (n.check(e)) {
                l = Object.keys(e);
            } else if (o.check(e)) {
                l = s.getFieldNames(e);
            } else {
                return;
            }
            if (!i) {
                Object.defineProperty(e, d, {
                    value: i = [],
                    enumerable: false
                });
            }
            for (var r = 0, u = l.length; r < u; ++r) {
                m(e[l[r]], t, i);
            }
            return i;
        }
        function y(e, t, i) {
            var r = m(e, i);
            var s = 0, a = r.length;
            while (s < a) {
                var n = s + a >> 1;
                var o = r[n];
                if (f(o.loc.start, t.loc.start) <= 0 && f(t.loc.end, o.loc.end) <= 0) {
                    y(t.enclosingNode = o, t, i);
                    return;
                }
                if (f(o.loc.end, t.loc.start) <= 0) {
                    var l = o;
                    s = n + 1;
                    continue;
                }
                if (f(t.loc.end, o.loc.start) <= 0) {
                    var u = o;
                    a = n;
                    continue;
                }
                throw new Error("Comment location overlaps with node location");
            }
            if (l) {
                t.precedingNode = l;
            }
            if (u) {
                t.followingNode = u;
            }
        }
        t.attach = function(e, t, i) {
            if (!n.check(e)) {
                return;
            }
            var s = [];
            e.forEach(function(e) {
                e.loc.lines = i;
                y(t, e, i);
                var a = e.precedingNode;
                var n = e.enclosingNode;
                var o = e.followingNode;
                if (a && o) {
                    var l = s.length;
                    if (l > 0) {
                        var u = s[l - 1];
                        r.strictEqual(u.precedingNode === e.precedingNode, u.followingNode === e.followingNode);
                        if (u.followingNode !== e.followingNode) {
                            v(s, i);
                        }
                    }
                    s.push(e);
                } else if (a) {
                    v(s, i);
                    E(a, e);
                } else if (o) {
                    v(s, i);
                    g(o, e);
                } else if (n) {
                    v(s, i);
                    b(n, e);
                } else {
                    throw new Error("AST contains no nodes at all?");
                }
            });
            v(s, i);
            e.forEach(function(e) {
                delete e.precedingNode;
                delete e.enclosingNode;
                delete e.followingNode;
            });
        };
        function v(e, t) {
            var i = e.length;
            if (i === 0) {
                return;
            }
            var s = e[0].precedingNode;
            var a = e[0].followingNode;
            var n = a.loc.start;
            for (var o = i; o > 0; --o) {
                var l = e[o - 1];
                r.strictEqual(l.precedingNode, s);
                r.strictEqual(l.followingNode, a);
                var u = t.sliceString(l.loc.end, n);
                if (/\S/.test(u)) {
                    break;
                }
                n = l.loc.start;
            }
            while (o <= i && (l = e[o]) && (l.type === "Line" || l.type === "CommentLine") && l.loc.start.column > a.loc.start.column) {
                ++o;
            }
            e.forEach(function(e, t) {
                if (t < o) {
                    E(s, e);
                } else {
                    g(a, e);
                }
            });
            e.length = 0;
        }
        function x(e, t) {
            var i = e.comments || (e.comments = []);
            i.push(t);
        }
        function g(e, t) {
            t.leading = true;
            t.trailing = false;
            x(e, t);
        }
        function b(e, t) {
            t.leading = false;
            t.trailing = false;
            x(e, t);
        }
        function E(e, t) {
            t.leading = false;
            t.trailing = true;
            x(e, t);
        }
        function k(e, t) {
            var i = e.getValue();
            a.Comment.assert(i);
            var r = i.loc;
            var s = r && r.lines;
            var n = [ t(e) ];
            if (i.trailing) {
                n.push("\n");
            } else if (s instanceof c) {
                var o = s.slice(r.end, s.skipSpaces(r.end));
                if (o.length === 1) {
                    n.push(o);
                } else {
                    n.push(new Array(o.length).join("\n"));
                }
            } else {
                n.push("\n");
            }
            return h(n);
        }
        function S(e, t) {
            var i = e.getValue(e);
            a.Comment.assert(i);
            var r = i.loc;
            var s = r && r.lines;
            var n = [];
            if (s instanceof c) {
                var o = s.skipSpaces(r.start, true) || s.firstPos();
                var l = s.slice(o, r.start);
                if (l.length === 1) {
                    n.push(l);
                } else {
                    n.push(new Array(l.length).join("\n"));
                }
            }
            n.push(t(e));
            return h(n);
        }
        t.printComments = function(e, t) {
            var i = e.getValue();
            var r = t(e);
            var n = a.Node.check(i) && s.getFieldValue(i, "comments");
            if (!n || n.length === 0) {
                return r;
            }
            var o = [];
            var l = [ r ];
            e.each(function(e) {
                var r = e.getValue();
                var n = s.getFieldValue(r, "leading");
                var u = s.getFieldValue(r, "trailing");
                if (n || u && !(a.Statement.check(i) || r.type === "Block" || r.type === "CommentBlock")) {
                    o.push(k(e, t));
                } else if (u) {
                    l.push(S(e, t));
                }
            }, "comments");
            o.push.apply(o, l);
            return h(o);
        };
    }, function(e, t, i) {
        "use strict";
        var r = i(7);
        var s = i(6);
        var a = s.namedTypes;
        var n = a.Node;
        var o = s.builtInTypes.array;
        var l = s.builtInTypes.number;
        var u = i(8);
        function c(e) {
            r.ok(this instanceof c);
            this.stack = [ e ];
        }
        var h = c.prototype;
        e.exports = c;
        c.from = function(e) {
            if (e instanceof c) {
                return e.copy();
            }
            if (e instanceof s.NodePath) {
                var t = Object.create(c.prototype);
                var i = [ e.value ];
                for (var r; r = e.parentPath; e = r) {
                    i.push(e.name, r.value);
                }
                t.stack = i.reverse();
                return t;
            }
            return new c(e);
        };
        h.copy = function e() {
            var e = Object.create(c.prototype);
            e.stack = this.stack.slice(0);
            return e;
        };
        h.getName = function e() {
            var t = this.stack;
            var i = t.length;
            if (i > 1) {
                return t[i - 2];
            }
            return null;
        };
        h.getValue = function e() {
            var t = this.stack;
            return t[t.length - 1];
        };
        h.valueIsDuplicate = function() {
            var e = this.stack;
            var t = e.length - 1;
            return e.lastIndexOf(e[t], t - 1) >= 0;
        };
        function p(e, t) {
            var i = e.stack;
            for (var r = i.length - 1; r >= 0; r -= 2) {
                var s = i[r];
                if (a.Node.check(s) && --t < 0) {
                    return s;
                }
            }
            return null;
        }
        h.getNode = function e(t) {
            return p(this, ~~t);
        };
        h.getParentNode = function e(t) {
            return p(this, ~~t + 1);
        };
        h.getRootValue = function e() {
            var t = this.stack;
            if (t.length % 2 === 0) {
                return t[1];
            }
            return t[0];
        };
        h.call = function e(t) {
            var i = this.stack;
            var r = i.length;
            var s = i[r - 1];
            var a = arguments.length;
            for (var n = 1; n < a; ++n) {
                var o = arguments[n];
                s = s[o];
                i.push(o, s);
            }
            var l = t(this);
            i.length = r;
            return l;
        };
        h.each = function e(t) {
            var i = this.stack;
            var r = i.length;
            var s = i[r - 1];
            var a = arguments.length;
            for (var n = 1; n < a; ++n) {
                var o = arguments[n];
                s = s[o];
                i.push(o, s);
            }
            for (var n = 0; n < s.length; ++n) {
                if (n in s) {
                    i.push(n, s[n]);
                    t(this);
                    i.length -= 2;
                }
            }
            i.length = r;
        };
        h.map = function e(t) {
            var i = this.stack;
            var r = i.length;
            var s = i[r - 1];
            var a = arguments.length;
            for (var n = 1; n < a; ++n) {
                var o = arguments[n];
                s = s[o];
                i.push(o, s);
            }
            var l = new Array(s.length);
            for (var n = 0; n < s.length; ++n) {
                if (n in s) {
                    i.push(n, s[n]);
                    l[n] = t(this, n);
                    i.length -= 2;
                }
            }
            i.length = r;
            return l;
        };
        h.hasParens = function() {
            var e = this.getNode();
            var t = this.getPrevToken(e);
            if (!t) {
                return false;
            }
            var i = this.getNextToken(e);
            if (!i) {
                return false;
            }
            if (t.value === "(") {
                if (i.value === ")") {
                    return true;
                }
                var r = !this.canBeFirstInStatement() && this.firstInStatement() && !this.needsParens(true);
                if (r) {
                    return true;
                }
            }
            return false;
        };
        h.getPrevToken = function(e) {
            e = e || this.getNode();
            var t = e && e.loc;
            var i = t && t.tokens;
            if (i && t.start.token > 0) {
                var r = i[t.start.token - 1];
                if (r) {
                    var s = this.getRootValue().loc;
                    if (u.comparePos(s.start, r.loc.start) <= 0) {
                        return r;
                    }
                }
            }
            return null;
        };
        h.getNextToken = function(e) {
            e = e || this.getNode();
            var t = e && e.loc;
            var i = t && t.tokens;
            if (i && t.end.token < i.length) {
                var r = i[t.end.token];
                if (r) {
                    var s = this.getRootValue().loc;
                    if (u.comparePos(r.loc.end, s.end) <= 0) {
                        return r;
                    }
                }
            }
            return null;
        };
        h.needsParens = function(e) {
            var t = this.getNode();
            if (t.type === "AssignmentExpression" && t.left.type === "ObjectPattern") {
                return true;
            }
            var i = this.getParentNode();
            if (!i) {
                return false;
            }
            var s = this.getName();
            if (this.getValue() !== t) {
                return false;
            }
            if (a.Statement.check(t)) {
                return false;
            }
            if (t.type === "Identifier") {
                return false;
            }
            if (i.type === "ParenthesizedExpression") {
                return false;
            }
            switch (t.type) {
              case "UnaryExpression":
              case "SpreadElement":
              case "SpreadProperty":
                return i.type === "MemberExpression" && s === "object" && i.object === t;

              case "BinaryExpression":
              case "LogicalExpression":
                switch (i.type) {
                  case "CallExpression":
                    return s === "callee" && i.callee === t;

                  case "UnaryExpression":
                  case "SpreadElement":
                  case "SpreadProperty":
                    return true;

                  case "MemberExpression":
                    return s === "object" && i.object === t;

                  case "BinaryExpression":
                  case "LogicalExpression":
                    var n = i.operator;
                    var o = m[n];
                    var u = t.operator;
                    var c = m[u];
                    if (o > c) {
                        return true;
                    }
                    if (o === c && s === "right") {
                        r.strictEqual(i.right, t);
                        return true;
                    }

                  default:
                    return false;
                }

              case "SequenceExpression":
                switch (i.type) {
                  case "ReturnStatement":
                    return false;

                  case "ForStatement":
                    return false;

                  case "ExpressionStatement":
                    return s !== "expression";

                  default:
                    return true;
                }

              case "YieldExpression":
                switch (i.type) {
                  case "BinaryExpression":
                  case "LogicalExpression":
                  case "UnaryExpression":
                  case "SpreadElement":
                  case "SpreadProperty":
                  case "CallExpression":
                  case "MemberExpression":
                  case "NewExpression":
                  case "ConditionalExpression":
                  case "YieldExpression":
                    return true;

                  default:
                    return false;
                }

              case "IntersectionTypeAnnotation":
              case "UnionTypeAnnotation":
                return i.type === "NullableTypeAnnotation";

              case "Literal":
                return i.type === "MemberExpression" && l.check(t.value) && s === "object" && i.object === t;

              case "NumericLiteral":
                return i.type === "MemberExpression" && s === "object" && i.object === t;

              case "AssignmentExpression":
              case "ConditionalExpression":
                switch (i.type) {
                  case "UnaryExpression":
                  case "SpreadElement":
                  case "SpreadProperty":
                  case "BinaryExpression":
                  case "LogicalExpression":
                    return true;

                  case "CallExpression":
                  case "NewExpression":
                    return s === "callee" && i.callee === t;

                  case "ConditionalExpression":
                    return s === "test" && i.test === t;

                  case "MemberExpression":
                    return s === "object" && i.object === t;

                  default:
                    return false;
                }

              case "ArrowFunctionExpression":
                if (a.CallExpression.check(i) && s === "callee") {
                    return true;
                }
                if (a.MemberExpression.check(i) && s === "object") {
                    return true;
                }
                return f(i);

              case "ObjectExpression":
                if (i.type === "ArrowFunctionExpression" && s === "body") {
                    return true;
                }
                break;

              case "CallExpression":
                if (s === "declaration" && a.ExportDefaultDeclaration.check(i) && a.FunctionExpression.check(t.callee)) {
                    return true;
                }
            }
            if (i.type === "NewExpression" && s === "callee" && i.callee === t) {
                return y(t);
            }
            if (e !== true && !this.canBeFirstInStatement() && this.firstInStatement()) {
                return true;
            }
            return false;
        };
        function f(e) {
            return a.BinaryExpression.check(e) || a.LogicalExpression.check(e);
        }
        function d(e) {
            return a.UnaryExpression.check(e) || a.SpreadElement && a.SpreadElement.check(e) || a.SpreadProperty && a.SpreadProperty.check(e);
        }
        var m = {};
        [ [ "||" ], [ "&&" ], [ "|" ], [ "^" ], [ "&" ], [ "==", "===", "!=", "!==" ], [ "<", ">", "<=", ">=", "in", "instanceof" ], [ ">>", "<<", ">>>" ], [ "+", "-" ], [ "*", "/", "%", "**" ] ].forEach(function(e, t) {
            e.forEach(function(e) {
                m[e] = t;
            });
        });
        function y(e) {
            if (a.CallExpression.check(e)) {
                return true;
            }
            if (o.check(e)) {
                return e.some(y);
            }
            if (a.Node.check(e)) {
                return s.someField(e, function(e, t) {
                    return y(t);
                });
            }
            return false;
        }
        h.canBeFirstInStatement = function() {
            var e = this.getNode();
            if (a.FunctionExpression.check(e)) {
                return false;
            }
            if (a.ObjectExpression.check(e)) {
                return false;
            }
            if (a.ClassExpression.check(e)) {
                return false;
            }
            return true;
        };
        h.firstInStatement = function() {
            var e = this.stack;
            var t, i;
            var s, n;
            for (var o = e.length - 1; o >= 0; o -= 2) {
                if (a.Node.check(e[o])) {
                    s = t;
                    n = i;
                    t = e[o - 1];
                    i = e[o];
                }
                if (!i || !n) {
                    continue;
                }
                if (a.BlockStatement.check(i) && t === "body" && s === 0) {
                    r.strictEqual(i.body[0], n);
                    return true;
                }
                if (a.ExpressionStatement.check(i) && s === "expression") {
                    r.strictEqual(i.expression, n);
                    return true;
                }
                if (a.AssignmentExpression.check(i) && s === "left") {
                    r.strictEqual(i.left, n);
                    return true;
                }
                if (a.ArrowFunctionExpression.check(i) && s === "body") {
                    r.strictEqual(i.body, n);
                    return true;
                }
                if (a.SequenceExpression.check(i) && t === "expressions" && s === 0) {
                    r.strictEqual(i.expressions[0], n);
                    continue;
                }
                if (a.CallExpression.check(i) && s === "callee") {
                    r.strictEqual(i.callee, n);
                    continue;
                }
                if (a.MemberExpression.check(i) && s === "object") {
                    r.strictEqual(i.object, n);
                    continue;
                }
                if (a.ConditionalExpression.check(i) && s === "test") {
                    r.strictEqual(i.test, n);
                    continue;
                }
                if (f(i) && s === "left") {
                    r.strictEqual(i.left, n);
                    continue;
                }
                if (a.UnaryExpression.check(i) && !i.prefix && s === "argument") {
                    r.strictEqual(i.argument, n);
                    continue;
                }
                return false;
            }
            return true;
        };
    }, function(e, t, i) {
        "use strict";
        var r = i(7);
        var s = i(13);
        var a = i(6);
        var n = a.getFieldValue;
        var o = a.namedTypes.Node;
        var l = a.namedTypes.Printable;
        var u = a.namedTypes.Expression;
        var c = a.namedTypes.ReturnStatement;
        var h = a.namedTypes.SourceLocation;
        var p = i(8);
        var f = p.comparePos;
        var d = i(41);
        var m = a.builtInTypes.object;
        var y = a.builtInTypes.array;
        var v = a.builtInTypes.string;
        var x = /[0-9a-z_$]/i;
        function g(e) {
            r.ok(this instanceof g);
            r.ok(e instanceof s.Lines);
            var t = this, i = [];
            t.replace = function(e, t) {
                if (v.check(t)) t = s.fromString(t);
                i.push({
                    lines: t,
                    start: e.start,
                    end: e.end
                });
            };
            t.get = function(t) {
                t = t || {
                    start: {
                        line: 1,
                        column: 0
                    },
                    end: {
                        line: e.length,
                        column: e.getLineLength(e.length)
                    }
                };
                var a = t.start, n = [];
                function o(t, i) {
                    r.ok(f(t, i) <= 0);
                    n.push(e.slice(t, i));
                }
                i.sort(function(e, t) {
                    return f(e.start, t.start);
                }).forEach(function(e) {
                    if (f(a, e.start) > 0) {} else {
                        o(a, e.start);
                        n.push(e.lines);
                        a = e.end;
                    }
                });
                o(a, t.end);
                return s.concat(n);
            };
        }
        t.Patcher = g;
        var b = g.prototype;
        b.tryToReprintComments = function(e, t, i) {
            var s = this;
            if (!e.comments && !t.comments) {
                return true;
            }
            var a = d.from(e);
            var n = d.from(t);
            a.stack.push("comments", E(e));
            n.stack.push("comments", E(t));
            var o = [];
            var l = C(a, n, o);
            if (l && o.length > 0) {
                o.forEach(function(e) {
                    var t = e.oldPath.getValue();
                    r.ok(t.leading || t.trailing);
                    s.replace(t.loc, i(e.newPath).indentTail(t.loc.indent));
                });
            }
            return l;
        };
        function E(e) {
            var t = [];
            if (e.comments && e.comments.length > 0) {
                e.comments.forEach(function(e) {
                    if (e.leading || e.trailing) {
                        t.push(e);
                    }
                });
            }
            return t;
        }
        b.deleteComments = function(e) {
            if (!e.comments) {
                return;
            }
            var t = this;
            e.comments.forEach(function(i) {
                if (i.leading) {
                    t.replace({
                        start: i.loc.start,
                        end: e.loc.lines.skipSpaces(i.loc.end, false, false)
                    }, "");
                } else if (i.trailing) {
                    t.replace({
                        start: e.loc.lines.skipSpaces(i.loc.start, true, false),
                        end: i.loc.end
                    }, "");
                }
            });
        };
        t.getReprinter = function(e) {
            r.ok(e instanceof d);
            var t = e.getValue();
            if (!l.check(t)) return;
            var i = t.original;
            var a = i && i.loc;
            var n = a && a.lines;
            var o = [];
            if (!n || !w(e, o)) return;
            return function(t) {
                var r = new g(n);
                o.forEach(function(e) {
                    var i = e.newPath.getValue();
                    var a = e.oldPath.getValue();
                    h.assert(a.loc, true);
                    var o = !r.tryToReprintComments(i, a, t);
                    if (o) {
                        r.deleteComments(a);
                    }
                    var l = t(e.newPath, {
                        includeComments: o,
                        avoidRootParens: a.type === i.type && e.oldPath.hasParens()
                    }).indentTail(a.loc.indent);
                    var u = k(n, a.loc, l);
                    var c = S(n, a.loc, l);
                    if (u || c) {
                        var p = [];
                        u && p.push(" ");
                        p.push(l);
                        c && p.push(" ");
                        l = s.concat(p);
                    }
                    r.replace(a.loc, l);
                });
                var l = r.get(a).indentTail(-i.loc.indent);
                if (e.needsParens()) {
                    return s.concat([ "(", l, ")" ]);
                }
                return l;
            };
        };
        function k(e, t, i) {
            var r = p.copyPos(t.start);
            var s = e.prevPos(r) && e.charAt(r);
            var a = i.charAt(i.firstPos());
            return s && x.test(s) && a && x.test(a);
        }
        function S(e, t, i) {
            var r = e.charAt(t.end);
            var s = i.lastPos();
            var a = i.prevPos(s) && i.charAt(s);
            return a && x.test(a) && r && x.test(r);
        }
        function w(e, t) {
            var i = e.getValue();
            l.assert(i);
            var s = i.original;
            l.assert(s);
            r.deepEqual(t, []);
            if (i.type !== s.type) {
                return false;
            }
            var a = new d(s);
            var n = P(e, a, t);
            if (!n) {
                t.length = 0;
            }
            return n;
        }
        function A(e, t, i) {
            var r = e.getValue();
            var s = t.getValue();
            if (r === s) return true;
            if (y.check(r)) return C(e, t, i);
            if (m.check(r)) return T(e, t, i);
            return false;
        }
        function C(e, t, i) {
            var r = e.getValue();
            var s = t.getValue();
            if (r === s || e.valueIsDuplicate() || t.valueIsDuplicate()) {
                return true;
            }
            y.assert(r);
            var a = r.length;
            if (!(y.check(s) && s.length === a)) return false;
            for (var n = 0; n < a; ++n) {
                e.stack.push(n, r[n]);
                t.stack.push(n, s[n]);
                var o = A(e, t, i);
                e.stack.length -= 2;
                t.stack.length -= 2;
                if (!o) {
                    return false;
                }
            }
            return true;
        }
        function T(e, t, i) {
            var r = e.getValue();
            m.assert(r);
            if (r.original === null) {
                return false;
            }
            var s = t.getValue();
            if (!m.check(s)) return false;
            if (r === s || e.valueIsDuplicate() || t.valueIsDuplicate()) {
                return true;
            }
            if (l.check(r)) {
                if (!l.check(s)) {
                    return false;
                }
                if (r.type === s.type) {
                    var a = [];
                    if (P(e, t, a)) {
                        i.push.apply(i, a);
                    } else if (s.loc) {
                        i.push({
                            oldPath: t.copy(),
                            newPath: e.copy()
                        });
                    } else {
                        return false;
                    }
                    return true;
                }
                if (u.check(r) && u.check(s) && s.loc) {
                    i.push({
                        oldPath: t.copy(),
                        newPath: e.copy()
                    });
                    return true;
                }
                return false;
            }
            return P(e, t, i);
        }
        function P(e, t, i) {
            var r = e.getValue();
            var s = t.getValue();
            m.assert(r);
            m.assert(s);
            if (r.original === null) {
                return false;
            }
            if (e.needsParens() && !t.hasParens()) {
                return false;
            }
            var n = p.getUnionOfKeys(s, r);
            if (s.type === "File" || r.type === "File") {
                delete n.tokens;
            }
            delete n.loc;
            var o = i.length;
            for (var l in n) {
                if (l.charAt(0) === "_") {
                    continue;
                }
                e.stack.push(l, a.getFieldValue(r, l));
                t.stack.push(l, a.getFieldValue(s, l));
                var u = A(e, t, i);
                e.stack.length -= 2;
                t.stack.length -= 2;
                if (!u) {
                    return false;
                }
            }
            if (c.check(e.getNode()) && i.length > o) {
                return false;
            }
            return true;
        }
    }, function(e, t, i) {
        "use strict";
        var r = i(14);
        var s = Object.prototype.hasOwnProperty;
        var a = typeof Map !== "undefined";
        function n() {
            this._array = [];
            this._set = a ? new Map() : Object.create(null);
        }
        n.fromArray = function e(t, i) {
            var r = new n();
            for (var s = 0, a = t.length; s < a; s++) {
                r.add(t[s], i);
            }
            return r;
        };
        n.prototype.size = function e() {
            return a ? this._set.size : Object.getOwnPropertyNames(this._set).length;
        };
        n.prototype.add = function e(t, i) {
            var n = a ? t : r.toSetString(t);
            var o = a ? this.has(t) : s.call(this._set, n);
            var l = this._array.length;
            if (!o || i) {
                this._array.push(t);
            }
            if (!o) {
                if (a) {
                    this._set.set(t, l);
                } else {
                    this._set[n] = l;
                }
            }
        };
        n.prototype.has = function e(t) {
            if (a) {
                return this._set.has(t);
            } else {
                var i = r.toSetString(t);
                return s.call(this._set, i);
            }
        };
        n.prototype.indexOf = function e(t) {
            if (a) {
                var i = this._set.get(t);
                if (i >= 0) {
                    return i;
                }
            } else {
                var n = r.toSetString(t);
                if (s.call(this._set, n)) {
                    return this._set[n];
                }
            }
            throw new Error('"' + t + '" is not in the set.');
        };
        n.prototype.at = function e(t) {
            if (t >= 0 && t < this._array.length) {
                return this._array[t];
            }
            throw new Error("No element indexed by " + t);
        };
        n.prototype.toArray = function e() {
            return this._array.slice();
        };
        t.ArraySet = n;
    }, function(e, t, i) {
        "use strict";
        var r = i(83);
        var s = 5;
        var a = 1 << s;
        var n = a - 1;
        var o = a;
        function l(e) {
            return e < 0 ? (-e << 1) + 1 : (e << 1) + 0;
        }
        function u(e) {
            var t = (e & 1) === 1;
            var i = e >> 1;
            return t ? -i : i;
        }
        t.encode = function e(t) {
            var i = "";
            var a;
            var u = l(t);
            do {
                a = u & n;
                u >>>= s;
                if (u > 0) {
                    a |= o;
                }
                i += r.encode(a);
            } while (u > 0);
            return i;
        };
        t.decode = function e(t, i, a) {
            var l = t.length;
            var c = 0;
            var h = 0;
            var p, f;
            do {
                if (i >= l) {
                    throw new Error("Expected more digits in base 64 VLQ value.");
                }
                f = r.decode(t.charCodeAt(i++));
                if (f === -1) {
                    throw new Error("Invalid base64 digit: " + t.charAt(i - 1));
                }
                p = !!(f & o);
                f &= n;
                c = c + (f << h);
                h += s;
            } while (p);
            a.value = u(c);
            a.rest = i;
        };
    }, function(e, t, i) {
        "use strict";
        var r = i(44);
        var s = i(14);
        var a = i(43).ArraySet;
        var n = i(85).MappingList;
        function o(e) {
            if (!e) {
                e = {};
            }
            this._file = s.getArg(e, "file", null);
            this._sourceRoot = s.getArg(e, "sourceRoot", null);
            this._skipValidation = s.getArg(e, "skipValidation", false);
            this._sources = new a();
            this._names = new a();
            this._mappings = new n();
            this._sourcesContents = null;
        }
        o.prototype._version = 3;
        o.fromSourceMap = function e(t) {
            var i = t.sourceRoot;
            var r = new o({
                file: t.file,
                sourceRoot: i
            });
            t.eachMapping(function(e) {
                var t = {
                    generated: {
                        line: e.generatedLine,
                        column: e.generatedColumn
                    }
                };
                if (e.source != null) {
                    t.source = e.source;
                    if (i != null) {
                        t.source = s.relative(i, t.source);
                    }
                    t.original = {
                        line: e.originalLine,
                        column: e.originalColumn
                    };
                    if (e.name != null) {
                        t.name = e.name;
                    }
                }
                r.addMapping(t);
            });
            t.sources.forEach(function(e) {
                var a = e;
                if (i !== null) {
                    a = s.relative(i, e);
                }
                if (!r._sources.has(a)) {
                    r._sources.add(a);
                }
                var n = t.sourceContentFor(e);
                if (n != null) {
                    r.setSourceContent(e, n);
                }
            });
            return r;
        };
        o.prototype.addMapping = function e(t) {
            var i = s.getArg(t, "generated");
            var r = s.getArg(t, "original", null);
            var a = s.getArg(t, "source", null);
            var n = s.getArg(t, "name", null);
            if (!this._skipValidation) {
                this._validateMapping(i, r, a, n);
            }
            if (a != null) {
                a = String(a);
                if (!this._sources.has(a)) {
                    this._sources.add(a);
                }
            }
            if (n != null) {
                n = String(n);
                if (!this._names.has(n)) {
                    this._names.add(n);
                }
            }
            this._mappings.add({
                generatedLine: i.line,
                generatedColumn: i.column,
                originalLine: r != null && r.line,
                originalColumn: r != null && r.column,
                source: a,
                name: n
            });
        };
        o.prototype.setSourceContent = function e(t, i) {
            var r = t;
            if (this._sourceRoot != null) {
                r = s.relative(this._sourceRoot, r);
            }
            if (i != null) {
                if (!this._sourcesContents) {
                    this._sourcesContents = Object.create(null);
                }
                this._sourcesContents[s.toSetString(r)] = i;
            } else if (this._sourcesContents) {
                delete this._sourcesContents[s.toSetString(r)];
                if (Object.keys(this._sourcesContents).length === 0) {
                    this._sourcesContents = null;
                }
            }
        };
        o.prototype.applySourceMap = function e(t, i, r) {
            var n = i;
            if (i == null) {
                if (t.file == null) {
                    throw new Error("SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, " + 'or the source map\'s "file" property. Both were omitted.');
                }
                n = t.file;
            }
            var o = this._sourceRoot;
            if (o != null) {
                n = s.relative(o, n);
            }
            var l = new a();
            var u = new a();
            this._mappings.unsortedForEach(function(e) {
                if (e.source === n && e.originalLine != null) {
                    var i = t.originalPositionFor({
                        line: e.originalLine,
                        column: e.originalColumn
                    });
                    if (i.source != null) {
                        e.source = i.source;
                        if (r != null) {
                            e.source = s.join(r, e.source);
                        }
                        if (o != null) {
                            e.source = s.relative(o, e.source);
                        }
                        e.originalLine = i.line;
                        e.originalColumn = i.column;
                        if (i.name != null) {
                            e.name = i.name;
                        }
                    }
                }
                var a = e.source;
                if (a != null && !l.has(a)) {
                    l.add(a);
                }
                var c = e.name;
                if (c != null && !u.has(c)) {
                    u.add(c);
                }
            }, this);
            this._sources = l;
            this._names = u;
            t.sources.forEach(function(e) {
                var i = t.sourceContentFor(e);
                if (i != null) {
                    if (r != null) {
                        e = s.join(r, e);
                    }
                    if (o != null) {
                        e = s.relative(o, e);
                    }
                    this.setSourceContent(e, i);
                }
            }, this);
        };
        o.prototype._validateMapping = function e(t, i, r, s) {
            if (i && typeof i.line !== "number" && typeof i.column !== "number") {
                throw new Error("original.line and original.column are not numbers -- you probably meant to omit " + "the original mapping entirely and only map the generated position. If so, pass " + "null for the original mapping instead of an object with empty or null values.");
            }
            if (t && "line" in t && "column" in t && t.line > 0 && t.column >= 0 && !i && !r && !s) {
                return;
            } else if (t && "line" in t && "column" in t && i && "line" in i && "column" in i && t.line > 0 && t.column >= 0 && i.line > 0 && i.column >= 0 && r) {
                return;
            } else {
                throw new Error("Invalid mapping: " + JSON.stringify({
                    generated: t,
                    source: r,
                    original: i,
                    name: s
                }));
            }
        };
        o.prototype._serializeMappings = function e() {
            var t = 0;
            var i = 1;
            var a = 0;
            var n = 0;
            var o = 0;
            var l = 0;
            var u = "";
            var c;
            var h;
            var p;
            var f;
            var d = this._mappings.toArray();
            for (var m = 0, y = d.length; m < y; m++) {
                h = d[m];
                c = "";
                if (h.generatedLine !== i) {
                    t = 0;
                    while (h.generatedLine !== i) {
                        c += ";";
                        i++;
                    }
                } else {
                    if (m > 0) {
                        if (!s.compareByGeneratedPositionsInflated(h, d[m - 1])) {
                            continue;
                        }
                        c += ",";
                    }
                }
                c += r.encode(h.generatedColumn - t);
                t = h.generatedColumn;
                if (h.source != null) {
                    f = this._sources.indexOf(h.source);
                    c += r.encode(f - l);
                    l = f;
                    c += r.encode(h.originalLine - 1 - n);
                    n = h.originalLine - 1;
                    c += r.encode(h.originalColumn - a);
                    a = h.originalColumn;
                    if (h.name != null) {
                        p = this._names.indexOf(h.name);
                        c += r.encode(p - o);
                        o = p;
                    }
                }
                u += c;
            }
            return u;
        };
        o.prototype._generateSourcesContent = function e(t, i) {
            return t.map(function(e) {
                if (!this._sourcesContents) {
                    return null;
                }
                if (i != null) {
                    e = s.relative(i, e);
                }
                var t = s.toSetString(e);
                return Object.prototype.hasOwnProperty.call(this._sourcesContents, t) ? this._sourcesContents[t] : null;
            }, this);
        };
        o.prototype.toJSON = function e() {
            var t = {
                version: this._version,
                sources: this._sources.toArray(),
                names: this._names.toArray(),
                mappings: this._serializeMappings()
            };
            if (this._file != null) {
                t.file = this._file;
            }
            if (this._sourceRoot != null) {
                t.sourceRoot = this._sourceRoot;
            }
            if (this._sourcesContents) {
                t.sourcesContent = this._generateSourcesContent(t.sources, t.sourceRoot);
            }
            return t;
        };
        o.prototype.toString = function e() {
            return JSON.stringify(this.toJSON());
        };
        t.SourceMapGenerator = o;
    }, , , , , , , , , , , , function(e, t) {
        "use strict";
        var i = Object.assign || function(e) {
            for (var t = 1; t < arguments.length; t++) {
                var i = arguments[t];
                for (var r in i) {
                    if (Object.prototype.hasOwnProperty.call(i, r)) {
                        e[r] = i[r];
                    }
                }
            }
            return e;
        };
        var r = function() {
            function e(e, t) {
                var i = [];
                var r = true;
                var s = false;
                var a = undefined;
                try {
                    for (var n = e[Symbol.iterator](), o; !(r = (o = n.next()).done); r = true) {
                        i.push(o.value);
                        if (t && i.length === t) break;
                    }
                } catch (e) {
                    s = true;
                    a = e;
                } finally {
                    try {
                        if (!r && n["return"]) n["return"]();
                    } finally {
                        if (s) throw a;
                    }
                }
                return i;
            }
            return function(t, i) {
                if (Array.isArray(t)) {
                    return t;
                } else if (Symbol.iterator in Object(t)) {
                    return e(t, i);
                } else {
                    throw new TypeError("Invalid attempt to destructure non-iterable instance");
                }
            };
        }();
        var s = function() {
            function e(e, t) {
                for (var i = 0; i < t.length; i++) {
                    var r = t[i];
                    r.enumerable = r.enumerable || false;
                    r.configurable = true;
                    if ("value" in r) r.writable = true;
                    Object.defineProperty(e, r.key, r);
                }
            }
            return function(t, i, r) {
                if (i) e(t.prototype, i);
                if (r) e(t, r);
                return t;
            };
        }();
        var a = function e(t, i, r) {
            if (t === null) t = Function.prototype;
            var s = Object.getOwnPropertyDescriptor(t, i);
            if (s === undefined) {
                var a = Object.getPrototypeOf(t);
                if (a === null) {
                    return undefined;
                } else {
                    return e(a, i, r);
                }
            } else if ("value" in s) {
                return s.value;
            } else {
                var n = s.get;
                if (n === undefined) {
                    return undefined;
                }
                return n.call(r);
            }
        };
        function n(e) {
            if (Array.isArray(e)) {
                for (var t = 0, i = Array(e.length); t < e.length; t++) {
                    i[t] = e[t];
                }
                return i;
            } else {
                return Array.from(e);
            }
        }
        function o(e, t) {
            if (!e) {
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            }
            return t && (typeof t === "object" || typeof t === "function") ? t : e;
        }
        function l(e, t) {
            if (typeof t !== "function" && t !== null) {
                throw new TypeError("Super expression must either be null or a function, not " + typeof t);
            }
            e.prototype = Object.create(t && t.prototype, {
                constructor: {
                    value: e,
                    enumerable: false,
                    writable: true,
                    configurable: true
                }
            });
            if (t) Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t;
        }
        function u(e, t) {
            if (!(e instanceof t)) {
                throw new TypeError("Cannot call a class as a function");
            }
        }
        Object.defineProperty(t, "__esModule", {
            value: true
        });
        var c = true;
        var h = true;
        var p = true;
        var f = true;
        var d = true;
        var m = true;
        var y = function e(t) {
            var i = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
            u(this, e);
            this.label = t;
            this.keyword = i.keyword;
            this.beforeExpr = !!i.beforeExpr;
            this.startsExpr = !!i.startsExpr;
            this.rightAssociative = !!i.rightAssociative;
            this.isLoop = !!i.isLoop;
            this.isAssign = !!i.isAssign;
            this.prefix = !!i.prefix;
            this.postfix = !!i.postfix;
            this.binop = i.binop != null ? i.binop : null;
            this.updateContext = null;
        };
        var v = new Map();
        function x(e) {
            var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
            t.keyword = e;
            var i = new y(e, t);
            v.set(e, i);
            return i;
        }
        function g(e, t) {
            return new y(e, {
                beforeExpr: c,
                binop: t
            });
        }
        var b = {
            num: new y("num", {
                startsExpr: h
            }),
            bigint: new y("bigint", {
                startsExpr: h
            }),
            regexp: new y("regexp", {
                startsExpr: h
            }),
            string: new y("string", {
                startsExpr: h
            }),
            name: new y("name", {
                startsExpr: h
            }),
            eof: new y("eof"),
            bracketL: new y("[", {
                beforeExpr: c,
                startsExpr: h
            }),
            bracketR: new y("]"),
            braceL: new y("{", {
                beforeExpr: c,
                startsExpr: h
            }),
            braceBarL: new y("{|", {
                beforeExpr: c,
                startsExpr: h
            }),
            braceR: new y("}"),
            braceBarR: new y("|}"),
            parenL: new y("(", {
                beforeExpr: c,
                startsExpr: h
            }),
            parenR: new y(")"),
            comma: new y(",", {
                beforeExpr: c
            }),
            semi: new y(";", {
                beforeExpr: c
            }),
            colon: new y(":", {
                beforeExpr: c
            }),
            doubleColon: new y("::", {
                beforeExpr: c
            }),
            dot: new y("."),
            question: new y("?", {
                beforeExpr: c
            }),
            questionDot: new y("?."),
            arrow: new y("=>", {
                beforeExpr: c
            }),
            template: new y("template"),
            ellipsis: new y("...", {
                beforeExpr: c
            }),
            backQuote: new y("`", {
                startsExpr: h
            }),
            dollarBraceL: new y("${", {
                beforeExpr: c,
                startsExpr: h
            }),
            at: new y("@"),
            hash: new y("#", {
                startsExpr: h
            }),
            interpreterDirective: new y("#!..."),
            eq: new y("=", {
                beforeExpr: c,
                isAssign: f
            }),
            assign: new y("_=", {
                beforeExpr: c,
                isAssign: f
            }),
            incDec: new y("++/--", {
                prefix: d,
                postfix: m,
                startsExpr: h
            }),
            bang: new y("!", {
                beforeExpr: c,
                prefix: d,
                startsExpr: h
            }),
            tilde: new y("~", {
                beforeExpr: c,
                prefix: d,
                startsExpr: h
            }),
            pipeline: g("|>", 0),
            nullishCoalescing: g("??", 1),
            logicalOR: g("||", 1),
            logicalAND: g("&&", 2),
            bitwiseOR: g("|", 3),
            bitwiseXOR: g("^", 4),
            bitwiseAND: g("&", 5),
            equality: g("==/!=/===/!==", 6),
            relational: g("</>/<=/>=", 7),
            bitShift: g("<</>>/>>>", 8),
            plusMin: new y("+/-", {
                beforeExpr: c,
                binop: 9,
                prefix: d,
                startsExpr: h
            }),
            modulo: g("%", 10),
            star: g("*", 10),
            slash: g("/", 10),
            exponent: new y("**", {
                beforeExpr: c,
                binop: 11,
                rightAssociative: true
            }),
            _break: x("break"),
            _case: x("case", {
                beforeExpr: c
            }),
            _catch: x("catch"),
            _continue: x("continue"),
            _debugger: x("debugger"),
            _default: x("default", {
                beforeExpr: c
            }),
            _do: x("do", {
                isLoop: p,
                beforeExpr: c
            }),
            _else: x("else", {
                beforeExpr: c
            }),
            _finally: x("finally"),
            _for: x("for", {
                isLoop: p
            }),
            _function: x("function", {
                startsExpr: h
            }),
            _if: x("if"),
            _return: x("return", {
                beforeExpr: c
            }),
            _switch: x("switch"),
            _throw: x("throw", {
                beforeExpr: c,
                prefix: d,
                startsExpr: h
            }),
            _try: x("try"),
            _var: x("var"),
            _const: x("const"),
            _while: x("while", {
                isLoop: p
            }),
            _with: x("with"),
            _new: x("new", {
                beforeExpr: c,
                startsExpr: h
            }),
            _this: x("this", {
                startsExpr: h
            }),
            _super: x("super", {
                startsExpr: h
            }),
            _class: x("class", {
                startsExpr: h
            }),
            _extends: x("extends", {
                beforeExpr: c
            }),
            _export: x("export"),
            _import: x("import", {
                startsExpr: h
            }),
            _null: x("null", {
                startsExpr: h
            }),
            _true: x("true", {
                startsExpr: h
            }),
            _false: x("false", {
                startsExpr: h
            }),
            _in: x("in", {
                beforeExpr: c,
                binop: 7
            }),
            _instanceof: x("instanceof", {
                beforeExpr: c,
                binop: 7
            }),
            _typeof: x("typeof", {
                beforeExpr: c,
                prefix: d,
                startsExpr: h
            }),
            _void: x("void", {
                beforeExpr: c,
                prefix: d,
                startsExpr: h
            }),
            _delete: x("delete", {
                beforeExpr: c,
                prefix: d,
                startsExpr: h
            })
        };
        var E = 0, k = 1, S = 2, w = 4, A = 8, C = 16, T = 32, P = 64, D = 128, _ = 256, N = k | S;
        function F(e, t) {
            return S | (e ? w : 0) | (t ? A : 0);
        }
        var I = 1, O = 2, L = 4, B = 8, M = 16, j = 64, R = 128, V = 256, U = 512, X = 1024;
        var q = I | O | B | R, J = I | 0 | B | 0, z = I | 0 | L | 0, W = I | 0 | M | 0, K = 0 | O | 0 | R, G = 0 | O | 0 | 0, H = I | O | B | V, Y = 0 | 0 | 0 | X, Q = 0 | 0 | 0 | j, $ = I | 0 | 0 | j, Z = H | U, ee = Y;
        function te(e) {
            return e != null && e.type === "Property" && e.kind === "init" && e.method === false;
        }
        var ie = function e(t) {
            return function(e) {
                l(t, e);
                function t() {
                    u(this, t);
                    return o(this, (t.__proto__ || Object.getPrototypeOf(t)).apply(this, arguments));
                }
                s(t, [ {
                    key: "estreeParseRegExpLiteral",
                    value: function e(t) {
                        var i = t.pattern, r = t.flags;
                        var s = null;
                        try {
                            s = new RegExp(i, r);
                        } catch (e) {}
                        var a = this.estreeParseLiteral(s);
                        a.regex = {
                            pattern: i,
                            flags: r
                        };
                        return a;
                    }
                }, {
                    key: "estreeParseLiteral",
                    value: function e(t) {
                        return this.parseLiteral(t, "Literal");
                    }
                }, {
                    key: "directiveToStmt",
                    value: function e(t) {
                        var i = t.value;
                        var r = this.startNodeAt(t.start, t.loc.start);
                        var s = this.startNodeAt(i.start, i.loc.start);
                        s.value = i.value;
                        s.raw = i.extra.raw;
                        r.expression = this.finishNodeAt(s, "Literal", i.end, i.loc.end);
                        r.directive = i.extra.raw.slice(1, -1);
                        return this.finishNodeAt(r, "ExpressionStatement", t.end, t.loc.end);
                    }
                }, {
                    key: "initFunction",
                    value: function e(i, r) {
                        a(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), "initFunction", this).call(this, i, r);
                        i.expression = false;
                    }
                }, {
                    key: "checkDeclaration",
                    value: function e(i) {
                        if (te(i)) {
                            this.checkDeclaration(i.value);
                        } else {
                            a(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), "checkDeclaration", this).call(this, i);
                        }
                    }
                }, {
                    key: "checkGetterSetterParams",
                    value: function e(t) {
                        var i = t;
                        var r = i.kind === "get" ? 0 : 1;
                        var s = i.start;
                        if (i.value.params.length !== r) {
                            if (i.kind === "get") {
                                this.raise(s, "getter must not have any formal parameters");
                            } else {
                                this.raise(s, "setter must have exactly one formal parameter");
                            }
                        }
                        if (i.kind === "set" && i.value.params[0].type === "RestElement") {
                            this.raise(s, "setter function argument must not be a rest parameter");
                        }
                    }
                }, {
                    key: "checkLVal",
                    value: function e(i) {
                        var r = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Q;
                        var s = this;
                        var n = arguments[2];
                        var o = arguments[3];
                        switch (i.type) {
                          case "ObjectPattern":
                            i.properties.forEach(function(e) {
                                s.checkLVal(e.type === "Property" ? e.value : e, r, n, "object destructuring pattern");
                            });
                            break;

                          default:
                            a(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), "checkLVal", this).call(this, i, r, n, o);
                        }
                    }
                }, {
                    key: "checkPropClash",
                    value: function e(t, i) {
                        if (t.type === "SpreadElement" || t.computed || t.method || t.shorthand) {
                            return;
                        }
                        var r = t.key;
                        var s = r.type === "Identifier" ? r.name : String(r.value);
                        if (s === "__proto__" && t.kind === "init") {
                            if (i.proto) {
                                this.raise(r.start, "Redefinition of __proto__ property");
                            }
                            i.proto = true;
                        }
                    }
                }, {
                    key: "isStrictBody",
                    value: function e(t) {
                        var i = t.body.type === "BlockStatement";
                        if (i && t.body.body.length > 0) {
                            for (var r = 0, s = t.body.body; r < s.length; r++) {
                                var a = s[r];
                                if (a.type === "ExpressionStatement" && a.expression.type === "Literal") {
                                    if (a.expression.value === "use strict") return true;
                                } else {
                                    break;
                                }
                            }
                        }
                        return false;
                    }
                }, {
                    key: "isValidDirective",
                    value: function e(t) {
                        return t.type === "ExpressionStatement" && t.expression.type === "Literal" && typeof t.expression.value === "string" && (!t.expression.extra || !t.expression.extra.parenthesized);
                    }
                }, {
                    key: "stmtToDirective",
                    value: function e(i) {
                        var r = a(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), "stmtToDirective", this).call(this, i);
                        var s = i.expression.value;
                        r.value.value = s;
                        return r;
                    }
                }, {
                    key: "parseBlockBody",
                    value: function e(i, r, s, n) {
                        var o = this;
                        a(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), "parseBlockBody", this).call(this, i, r, s, n);
                        var l = i.directives.map(function(e) {
                            return o.directiveToStmt(e);
                        });
                        i.body = l.concat(i.body);
                        delete i.directives;
                    }
                }, {
                    key: "pushClassMethod",
                    value: function e(t, i, r, s, a, n) {
                        this.parseMethod(i, r, s, a, n, "ClassMethod", true);
                        if (i.typeParameters) {
                            i.value.typeParameters = i.typeParameters;
                            delete i.typeParameters;
                        }
                        t.body.push(i);
                    }
                }, {
                    key: "parseExprAtom",
                    value: function e(i) {
                        switch (this.state.type) {
                          case b.regexp:
                            return this.estreeParseRegExpLiteral(this.state.value);

                          case b.num:
                          case b.string:
                            return this.estreeParseLiteral(this.state.value);

                          case b._null:
                            return this.estreeParseLiteral(null);

                          case b._true:
                            return this.estreeParseLiteral(true);

                          case b._false:
                            return this.estreeParseLiteral(false);

                          default:
                            return a(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), "parseExprAtom", this).call(this, i);
                        }
                    }
                }, {
                    key: "parseLiteral",
                    value: function e(i, r, s, n) {
                        var o = a(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), "parseLiteral", this).call(this, i, r, s, n);
                        o.raw = o.extra.raw;
                        delete o.extra;
                        return o;
                    }
                }, {
                    key: "parseFunctionBody",
                    value: function e(i, r) {
                        var s = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
                        a(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), "parseFunctionBody", this).call(this, i, r, s);
                        i.expression = i.body.type !== "BlockStatement";
                    }
                }, {
                    key: "parseMethod",
                    value: function e(i, r, s, n, o, l) {
                        var u = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : false;
                        var c = this.startNode();
                        c.kind = i.kind;
                        c = a(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), "parseMethod", this).call(this, c, r, s, n, o, l, u);
                        c.type = "FunctionExpression";
                        delete c.kind;
                        i.value = c;
                        l = l === "ClassMethod" ? "MethodDefinition" : l;
                        return this.finishNode(i, l);
                    }
                }, {
                    key: "parseObjectMethod",
                    value: function e(i, r, s, n, o) {
                        var l = a(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), "parseObjectMethod", this).call(this, i, r, s, n, o);
                        if (l) {
                            l.type = "Property";
                            if (l.kind === "method") l.kind = "init";
                            l.shorthand = false;
                        }
                        return l;
                    }
                }, {
                    key: "parseObjectProperty",
                    value: function e(i, r, s, n, o) {
                        var l = a(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), "parseObjectProperty", this).call(this, i, r, s, n, o);
                        if (l) {
                            l.kind = "init";
                            l.type = "Property";
                        }
                        return l;
                    }
                }, {
                    key: "toAssignable",
                    value: function e(i, r, s) {
                        if (te(i)) {
                            this.toAssignable(i.value, r, s);
                            return i;
                        }
                        return a(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), "toAssignable", this).call(this, i, r, s);
                    }
                }, {
                    key: "toAssignableObjectExpressionProp",
                    value: function e(i, r, s) {
                        if (i.kind === "get" || i.kind === "set") {
                            this.raise(i.key.start, "Object pattern can't contain getter or setter");
                        } else if (i.method) {
                            this.raise(i.key.start, "Object pattern can't contain methods");
                        } else {
                            a(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), "toAssignableObjectExpressionProp", this).call(this, i, r, s);
                        }
                    }
                } ]);
                return t;
            }(t);
        };
        var re = /\r\n?|[\n\u2028\u2029]/;
        var se = new RegExp(re.source, "g");
        function ae(e) {
            switch (e) {
              case 10:
              case 13:
              case 8232:
              case 8233:
                return true;

              default:
                return false;
            }
        }
        var ne = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;
        function oe(e) {
            switch (e) {
              case 9:
              case 11:
              case 12:
              case 32:
              case 160:
              case 5760:
              case 8192:
              case 8193:
              case 8194:
              case 8195:
              case 8196:
              case 8197:
              case 8198:
              case 8199:
              case 8200:
              case 8201:
              case 8202:
              case 8239:
              case 8287:
              case 12288:
              case 65279:
                return true;

              default:
                return false;
            }
        }
        var le = function e(t, i, r, s) {
            u(this, e);
            this.token = t;
            this.isExpr = !!i;
            this.preserveSpace = !!r;
            this.override = s;
        };
        var ue = {
            braceStatement: new le("{", false),
            braceExpression: new le("{", true),
            templateQuasi: new le("${", false),
            parenStatement: new le("(", false),
            parenExpression: new le("(", true),
            template: new le("`", true, true, function(e) {
                return e.readTmplToken();
            }),
            functionExpression: new le("function", true),
            functionStatement: new le("function", false)
        };
        b.parenR.updateContext = b.braceR.updateContext = function() {
            if (this.state.context.length === 1) {
                this.state.exprAllowed = true;
                return;
            }
            var e = this.state.context.pop();
            if (e === ue.braceStatement && this.curContext().token === "function") {
                e = this.state.context.pop();
            }
            this.state.exprAllowed = !e.isExpr;
        };
        b.name.updateContext = function(e) {
            var t = false;
            if (e !== b.dot) {
                if (this.state.value === "of" && !this.state.exprAllowed || this.state.value === "yield" && this.scope.inGenerator) {
                    t = true;
                }
            }
            this.state.exprAllowed = t;
            if (this.state.isIterator) {
                this.state.isIterator = false;
            }
        };
        b.braceL.updateContext = function(e) {
            this.state.context.push(this.braceIsBlock(e) ? ue.braceStatement : ue.braceExpression);
            this.state.exprAllowed = true;
        };
        b.dollarBraceL.updateContext = function() {
            this.state.context.push(ue.templateQuasi);
            this.state.exprAllowed = true;
        };
        b.parenL.updateContext = function(e) {
            var t = e === b._if || e === b._for || e === b._with || e === b._while;
            this.state.context.push(t ? ue.parenStatement : ue.parenExpression);
            this.state.exprAllowed = true;
        };
        b.incDec.updateContext = function() {};
        b._function.updateContext = b._class.updateContext = function(e) {
            if (e.beforeExpr && e !== b.semi && e !== b._else && !(e === b._return && re.test(this.input.slice(this.state.lastTokEnd, this.state.start))) && !((e === b.colon || e === b.braceL) && this.curContext() === ue.b_stat)) {
                this.state.context.push(ue.functionExpression);
            } else {
                this.state.context.push(ue.functionStatement);
            }
            this.state.exprAllowed = false;
        };
        b.backQuote.updateContext = function() {
            if (this.curContext() === ue.template) {
                this.state.context.pop();
            } else {
                this.state.context.push(ue.template);
            }
            this.state.exprAllowed = false;
        };
        var ce = {
            strict: [ "implements", "interface", "let", "package", "private", "protected", "public", "static", "yield" ],
            strictBind: [ "eval", "arguments" ]
        };
        var he = new Set(ce.strict);
        var pe = new Set(ce.strict.concat(ce.strictBind));
        var fe = function e(t, i) {
            return i && t === "await" || t === "enum";
        };
        function de(e, t) {
            return fe(e, t) || he.has(e);
        }
        function me(e, t) {
            return fe(e, t) || pe.has(e);
        }
        function ye(e) {
            return v.has(e);
        }
        var ve = /^in(stanceof)?$/;
        var xe = "ªµºÀ-ÖØ-öø-ˁˆ-ˑˠ-ˤˬˮͰ-ʹͶͷͺ-ͽͿΆΈ-ΊΌΎ-ΡΣ-ϵϷ-ҁҊ-ԯԱ-Ֆՙՠ-ֈא-תׯ-ײؠ-يٮٯٱ-ۓەۥۦۮۯۺ-ۼۿܐܒ-ܯݍ-ޥޱߊ-ߪߴߵߺࠀ-ࠕࠚࠤࠨࡀ-ࡘࡠ-ࡪࢠ-ࢴࢶ-ࢽऄ-हऽॐक़-ॡॱ-ঀঅ-ঌএঐও-নপ-রলশ-হঽৎড়ঢ়য়-ৡৰৱৼਅ-ਊਏਐਓ-ਨਪ-ਰਲਲ਼ਵਸ਼ਸਹਖ਼-ੜਫ਼ੲ-ੴઅ-ઍએ-ઑઓ-નપ-રલળવ-હઽૐૠૡૹଅ-ଌଏଐଓ-ନପ-ରଲଳଵ-ହଽଡ଼ଢ଼ୟ-ୡୱஃஅ-ஊஎ-ஐஒ-கஙசஜஞடணதந-பம-ஹௐఅ-ఌఎ-ఐఒ-నప-హఽౘ-ౚౠౡಀಅ-ಌಎ-ಐಒ-ನಪ-ಳವ-ಹಽೞೠೡೱೲഅ-ഌഎ-ഐഒ-ഺഽൎൔ-ൖൟ-ൡൺ-ൿඅ-ඖක-නඳ-රලව-ෆก-ะาำเ-ๆກຂຄຆ-ຊຌ-ຣລວ-ະາຳຽເ-ໄໆໜ-ໟༀཀ-ཇཉ-ཬྈ-ྌက-ဪဿၐ-ၕၚ-ၝၡၥၦၮ-ၰၵ-ႁႎႠ-ჅჇჍა-ჺჼ-ቈቊ-ቍቐ-ቖቘቚ-ቝበ-ኈኊ-ኍነ-ኰኲ-ኵኸ-ኾዀዂ-ዅወ-ዖዘ-ጐጒ-ጕጘ-ፚᎀ-ᎏᎠ-Ᏽᏸ-ᏽᐁ-ᙬᙯ-ᙿᚁ-ᚚᚠ-ᛪᛮ-ᛸᜀ-ᜌᜎ-ᜑᜠ-ᜱᝀ-ᝑᝠ-ᝬᝮ-ᝰក-ឳៗៜᠠ-ᡸᢀ-ᢨᢪᢰ-ᣵᤀ-ᤞᥐ-ᥭᥰ-ᥴᦀ-ᦫᦰ-ᧉᨀ-ᨖᨠ-ᩔᪧᬅ-ᬳᭅ-ᭋᮃ-ᮠᮮᮯᮺ-ᯥᰀ-ᰣᱍ-ᱏᱚ-ᱽᲀ-ᲈᲐ-ᲺᲽ-Ჿᳩ-ᳬᳮ-ᳳᳵᳶᳺᴀ-ᶿḀ-ἕἘ-Ἕἠ-ὅὈ-Ὅὐ-ὗὙὛὝὟ-ώᾀ-ᾴᾶ-ᾼιῂ-ῄῆ-ῌῐ-ΐῖ-Ίῠ-Ῥῲ-ῴῶ-ῼⁱⁿₐ-ₜℂℇℊ-ℓℕ℘-ℝℤΩℨK-ℹℼ-ℿⅅ-ⅉⅎⅠ-ↈⰀ-Ⱞⰰ-ⱞⱠ-ⳤⳫ-ⳮⳲⳳⴀ-ⴥⴧⴭⴰ-ⵧⵯⶀ-ⶖⶠ-ⶦⶨ-ⶮⶰ-ⶶⶸ-ⶾⷀ-ⷆⷈ-ⷎⷐ-ⷖⷘ-ⷞ々-〇〡-〩〱-〵〸-〼ぁ-ゖ゛-ゟァ-ヺー-ヿㄅ-ㄯㄱ-ㆎㆠ-ㆺㇰ-ㇿ㐀-䶵一-鿯ꀀ-ꒌꓐ-ꓽꔀ-ꘌꘐ-ꘟꘪꘫꙀ-ꙮꙿ-ꚝꚠ-ꛯꜗ-ꜟꜢ-ꞈꞋ-ꞿꟂ-Ᶎꟷ-ꠁꠃ-ꠅꠇ-ꠊꠌ-ꠢꡀ-ꡳꢂ-ꢳꣲ-ꣷꣻꣽꣾꤊ-ꤥꤰ-ꥆꥠ-ꥼꦄ-ꦲꧏꧠ-ꧤꧦ-ꧯꧺ-ꧾꨀ-ꨨꩀ-ꩂꩄ-ꩋꩠ-ꩶꩺꩾ-ꪯꪱꪵꪶꪹ-ꪽꫀꫂꫛ-ꫝꫠ-ꫪꫲ-ꫴꬁ-ꬆꬉ-ꬎꬑ-ꬖꬠ-ꬦꬨ-ꬮꬰ-ꭚꭜ-ꭧꭰ-ꯢ가-힣ힰ-ퟆퟋ-ퟻ豈-舘並-龎ﬀ-ﬆﬓ-ﬗיִײַ-ﬨשׁ-זּטּ-לּמּנּסּףּפּצּ-ﮱﯓ-ﴽﵐ-ﶏﶒ-ﷇﷰ-ﷻﹰ-ﹴﹶ-ﻼＡ-Ｚａ-ｚｦ-ﾾￂ-ￇￊ-ￏￒ-ￗￚ-ￜ";
        var ge = "‌‍·̀-ͯ·҃-֑҇-ׇֽֿׁׂׅׄؐ-ًؚ-٩ٰۖ-ۜ۟-۪ۤۧۨ-ۭ۰-۹ܑܰ-݊ަ-ް߀-߉߫-߽߳ࠖ-࠙ࠛ-ࠣࠥ-ࠧࠩ-࡙࠭-࡛࣓-ࣣ࣡-ःऺ-़ा-ॏ॑-ॗॢॣ०-९ঁ-ঃ়া-ৄেৈো-্ৗৢৣ০-৯৾ਁ-ਃ਼ਾ-ੂੇੈੋ-੍ੑ੦-ੱੵઁ-ઃ઼ા-ૅે-ૉો-્ૢૣ૦-૯ૺ-૿ଁ-ଃ଼ା-ୄେୈୋ-୍ୖୗୢୣ୦-୯ஂா-ூெ-ைொ-்ௗ௦-௯ఀ-ఄా-ౄె-ైొ-్ౕౖౢౣ౦-౯ಁ-ಃ಼ಾ-ೄೆ-ೈೊ-್ೕೖೢೣ೦-೯ഀ-ഃ഻഼ാ-ൄെ-ൈൊ-്ൗൢൣ൦-൯ංඃ්ා-ුූෘ-ෟ෦-෯ෲෳัิ-ฺ็-๎๐-๙ັິ-ຼ່-ໍ໐-໙༘༙༠-༩༹༵༷༾༿ཱ-྄྆྇ྍ-ྗྙ-ྼ࿆ါ-ှ၀-၉ၖ-ၙၞ-ၠၢ-ၤၧ-ၭၱ-ၴႂ-ႍႏ-ႝ፝-፟፩-፱ᜒ-᜔ᜲ-᜴ᝒᝓᝲᝳ឴-៓៝០-៩᠋-᠍᠐-᠙ᢩᤠ-ᤫᤰ-᤻᥆-᥏᧐-᧚ᨗ-ᨛᩕ-ᩞ᩠-᩿᩼-᪉᪐-᪙᪰-᪽ᬀ-ᬄ᬴-᭄᭐-᭙᭫-᭳ᮀ-ᮂᮡ-ᮭ᮰-᮹᯦-᯳ᰤ-᰷᱀-᱉᱐-᱙᳐-᳔᳒-᳨᳭᳴᳷-᳹᷀-᷹᷻-᷿‿⁀⁔⃐-⃥⃜⃡-⃰⳯-⵿⳱ⷠ-〪ⷿ-゙゚〯꘠-꘩꙯ꙴ-꙽ꚞꚟ꛰꛱ꠂ꠆ꠋꠣ-ꠧꢀꢁꢴ-ꣅ꣐-꣙꣠-꣱ꣿ-꤉ꤦ-꤭ꥇ-꥓ꦀ-ꦃ꦳-꧀꧐-꧙ꧥ꧰-꧹ꨩ-ꨶꩃꩌꩍ꩐-꩙ꩻ-ꩽꪰꪲ-ꪴꪷꪸꪾ꪿꫁ꫫ-ꫯꫵ꫶ꯣ-ꯪ꯬꯭꯰-꯹ﬞ︀-️︠-︯︳︴﹍-﹏０-９＿";
        var be = new RegExp("[" + xe + "]");
        var Ee = new RegExp("[" + xe + ge + "]");
        xe = ge = null;
        var ke = [ 0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 157, 310, 10, 21, 11, 7, 153, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 477, 28, 11, 0, 9, 21, 155, 22, 13, 52, 76, 44, 33, 24, 27, 35, 30, 0, 12, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 85, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 0, 33, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 230, 43, 117, 63, 32, 0, 161, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 35, 56, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 270, 921, 103, 110, 18, 195, 2749, 1070, 4050, 582, 8634, 568, 8, 30, 114, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 754, 9486, 286, 50, 2, 18, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 2357, 44, 11, 6, 17, 0, 370, 43, 1301, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42710, 42, 4148, 12, 221, 3, 5761, 15, 7472, 3104, 541 ];
        var Se = [ 509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 525, 10, 176, 2, 54, 14, 32, 9, 16, 3, 46, 10, 54, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 4, 9, 83, 11, 7, 0, 161, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 232, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 19306, 9, 135, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 19723, 1, 5319, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 262, 6, 10, 9, 419, 13, 1495, 6, 110, 6, 6, 9, 792487, 239 ];
        function we(e, t) {
            var i = 65536;
            for (var r = 0, s = t.length; r < s; r += 2) {
                i += t[r];
                if (i > e) return false;
                i += t[r + 1];
                if (i >= e) return true;
            }
            return false;
        }
        function Ae(e) {
            if (e < 65) return e === 36;
            if (e <= 90) return true;
            if (e < 97) return e === 95;
            if (e <= 122) return true;
            if (e <= 65535) {
                return e >= 170 && be.test(String.fromCharCode(e));
            }
            return we(e, ke);
        }
        function Ce(e, t) {
            return e === 64 && t === 64;
        }
        function Te(e) {
            if (e < 48) return e === 36;
            if (e < 58) return true;
            if (e < 65) return false;
            if (e <= 90) return true;
            if (e < 97) return e === 95;
            if (e <= 122) return true;
            if (e <= 65535) {
                return e >= 170 && Ee.test(String.fromCharCode(e));
            }
            return we(e, ke) || we(e, Se);
        }
        var Pe = [ "any", "bool", "boolean", "empty", "false", "mixed", "null", "number", "static", "string", "true", "typeof", "void", "interface", "extends", "_" ];
        function De(e) {
            return e.type === "DeclareExportAllDeclaration" || e.type === "DeclareExportDeclaration" && (!e.declaration || e.declaration.type !== "TypeAlias" && e.declaration.type !== "InterfaceDeclaration");
        }
        function _e(e) {
            return e.importKind === "type" || e.importKind === "typeof";
        }
        function Ne(e) {
            return (e.type === b.name || !!e.type.keyword) && e.value !== "from";
        }
        var Fe = {
            const: "declare export var",
            let: "declare export var",
            type: "export type",
            interface: "export interface"
        };
        function Ie(e, t) {
            var i = [];
            var r = [];
            for (var s = 0; s < e.length; s++) {
                (t(e[s], s, e) ? i : r).push(e[s]);
            }
            return [ i, r ];
        }
        var Oe = /\*?\s*@((?:no)?flow)\b/;
        var Le = function e(t) {
            return function(e) {
                l(t, e);
                function t(e, i) {
                    u(this, t);
                    var r = o(this, (t.__proto__ || Object.getPrototypeOf(t)).call(this, e, i));
                    r.flowPragma = undefined;
                    return r;
                }
                s(t, [ {
                    key: "shouldParseTypes",
                    value: function e() {
                        return this.getPluginOption("flow", "all") || this.flowPragma === "flow";
                    }
                }, {
                    key: "finishToken",
                    value: function e(i, r) {
                        if (i !== b.string && i !== b.semi && i !== b.interpreterDirective) {
                            if (this.flowPragma === undefined) {
                                this.flowPragma = null;
                            }
                        }
                        return a(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), "finishToken", this).call(this, i, r);
                    }
                }, {
                    key: "addComment",
                    value: function e(i) {
                        if (this.flowPragma === undefined) {
                            var r = Oe.exec(i.value);
                            if (!r) ; else if (r[1] === "flow") {
                                this.flowPragma = "flow";
                            } else if (r[1] === "noflow") {
                                this.flowPragma = "noflow";
                            } else {
                                throw new Error("Unexpected flow pragma");
                            }
                        }
                        return a(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), "addComment", this).call(this, i);
                    }
                }, {
                    key: "flowParseTypeInitialiser",
                    value: function e(t) {
                        var i = this.state.inType;
                        this.state.inType = true;
                        this.expect(t || b.colon);
                        var r = this.flowParseType();
                        this.state.inType = i;
                        return r;
                    }
                }, {
                    key: "flowParsePredicate",
                    value: function e() {
                        var t = this.startNode();
                        var i = this.state.startLoc;
                        var r = this.state.start;
                        this.expect(b.modulo);
                        var s = this.state.startLoc;
                        this.expectContextual("checks");
                        if (i.line !== s.line || i.column !== s.column - 1) {
                            this.raise(r, "Spaces between ´%´ and ´checks´ are not allowed here.");
                        }
                        if (this.eat(b.parenL)) {
                            t.value = this.parseExpression();
                            this.expect(b.parenR);
                            return this.finishNode(t, "DeclaredPredicate");
                        } else {
                            return this.finishNode(t, "InferredPredicate");
                        }
                    }
                }, {
                    key: "flowParseTypeAndPredicateInitialiser",
                    value: function e() {
                        var t = this.state.inType;
                        this.state.inType = true;
                        this.expect(b.colon);
                        var i = null;
                        var r = null;
                        if (this.match(b.modulo)) {
                            this.state.inType = t;
                            r = this.flowParsePredicate();
                        } else {
                            i = this.flowParseType();
                            this.state.inType = t;
                            if (this.match(b.modulo)) {
                                r = this.flowParsePredicate();
                            }
                        }
                        return [ i, r ];
                    }
                }, {
                    key: "flowParseDeclareClass",
                    value: function e(t) {
                        this.next();
                        this.flowParseInterfaceish(t, true);
                        return this.finishNode(t, "DeclareClass");
                    }
                }, {
                    key: "flowParseDeclareFunction",
                    value: function e(t) {
                        this.next();
                        var i = t.id = this.parseIdentifier();
                        var s = this.startNode();
                        var a = this.startNode();
                        if (this.isRelational("<")) {
                            s.typeParameters = this.flowParseTypeParameterDeclaration();
                        } else {
                            s.typeParameters = null;
                        }
                        this.expect(b.parenL);
                        var n = this.flowParseFunctionTypeParams();
                        s.params = n.params;
                        s.rest = n.rest;
                        this.expect(b.parenR);
                        var o = this.flowParseTypeAndPredicateInitialiser();
                        var l = r(o, 2);
                        s.returnType = l[0];
                        t.predicate = l[1];
                        a.typeAnnotation = this.finishNode(s, "FunctionTypeAnnotation");
                        i.typeAnnotation = this.finishNode(a, "TypeAnnotation");
                        this.resetEndLocation(i);
                        this.semicolon();
                        return this.finishNode(t, "DeclareFunction");
                    }
                }, {
                    key: "flowParseDeclare",
                    value: function e(t, i) {
                        if (this.match(b._class)) {
                            return this.flowParseDeclareClass(t);
                        } else if (this.match(b._function)) {
                            return this.flowParseDeclareFunction(t);
                        } else if (this.match(b._var)) {
                            return this.flowParseDeclareVariable(t);
                        } else if (this.eatContextual("module")) {
                            if (this.match(b.dot)) {
                                return this.flowParseDeclareModuleExports(t);
                            } else {
                                if (i) {
                                    this.unexpected(this.state.lastTokStart, "`declare module` cannot be used inside another `declare module`");
                                }
                                return this.flowParseDeclareModule(t);
                            }
                        } else if (this.isContextual("type")) {
                            return this.flowParseDeclareTypeAlias(t);
                        } else if (this.isContextual("opaque")) {
                            return this.flowParseDeclareOpaqueType(t);
                        } else if (this.isContextual("interface")) {
                            return this.flowParseDeclareInterface(t);
                        } else if (this.match(b._export)) {
                            return this.flowParseDeclareExportDeclaration(t, i);
                        } else {
                            throw this.unexpected();
                        }
                    }
                }, {
                    key: "flowParseDeclareVariable",
                    value: function e(t) {
                        this.next();
                        t.id = this.flowParseTypeAnnotatableIdentifier(true);
                        this.semicolon();
                        return this.finishNode(t, "DeclareVariable");
                    }
                }, {
                    key: "flowParseDeclareModule",
                    value: function e(t) {
                        var i = this;
                        this.scope.enter(E);
                        if (this.match(b.string)) {
                            t.id = this.parseExprAtom();
                        } else {
                            t.id = this.parseIdentifier();
                        }
                        var r = t.body = this.startNode();
                        var s = r.body = [];
                        this.expect(b.braceL);
                        while (!this.match(b.braceR)) {
                            var a = this.startNode();
                            if (this.match(b._import)) {
                                this.next();
                                if (!this.isContextual("type") && !this.isContextual("typeof")) {
                                    this.unexpected(this.state.lastTokStart, "Imports within a `declare module` body must always be `import type` or `import typeof`");
                                }
                                this.parseImport(a);
                            } else {
                                this.expectContextual("declare", "Only declares and type imports are allowed inside declare module");
                                a = this.flowParseDeclare(a, true);
                            }
                            s.push(a);
                        }
                        this.scope.exit();
                        this.expect(b.braceR);
                        this.finishNode(r, "BlockStatement");
                        var n = null;
                        var o = false;
                        var l = "Found both `declare module.exports` and `declare export` in the same module. " + "Modules can only have 1 since they are either an ES module or they are a CommonJS module";
                        s.forEach(function(e) {
                            if (De(e)) {
                                if (n === "CommonJS") {
                                    i.unexpected(e.start, l);
                                }
                                n = "ES";
                            } else if (e.type === "DeclareModuleExports") {
                                if (o) {
                                    i.unexpected(e.start, "Duplicate `declare module.exports` statement");
                                }
                                if (n === "ES") i.unexpected(e.start, l);
                                n = "CommonJS";
                                o = true;
                            }
                        });
                        t.kind = n || "CommonJS";
                        return this.finishNode(t, "DeclareModule");
                    }
                }, {
                    key: "flowParseDeclareExportDeclaration",
                    value: function e(t, i) {
                        this.expect(b._export);
                        if (this.eat(b._default)) {
                            if (this.match(b._function) || this.match(b._class)) {
                                t.declaration = this.flowParseDeclare(this.startNode());
                            } else {
                                t.declaration = this.flowParseType();
                                this.semicolon();
                            }
                            t.default = true;
                            return this.finishNode(t, "DeclareExportDeclaration");
                        } else {
                            if (this.match(b._const) || this.isLet() || (this.isContextual("type") || this.isContextual("interface")) && !i) {
                                var r = this.state.value;
                                var s = Fe[r];
                                this.unexpected(this.state.start, "`declare export " + r + "` is not supported. Use `" + s + "` instead");
                            }
                            if (this.match(b._var) || this.match(b._function) || this.match(b._class) || this.isContextual("opaque")) {
                                t.declaration = this.flowParseDeclare(this.startNode());
                                t.default = false;
                                return this.finishNode(t, "DeclareExportDeclaration");
                            } else if (this.match(b.star) || this.match(b.braceL) || this.isContextual("interface") || this.isContextual("type") || this.isContextual("opaque")) {
                                t = this.parseExport(t);
                                if (t.type === "ExportNamedDeclaration") {
                                    t.type = "ExportDeclaration";
                                    t.default = false;
                                    delete t.exportKind;
                                }
                                t.type = "Declare" + t.type;
                                return t;
                            }
                        }
                        throw this.unexpected();
                    }
                }, {
                    key: "flowParseDeclareModuleExports",
                    value: function e(t) {
                        this.next();
                        this.expectContextual("exports");
                        t.typeAnnotation = this.flowParseTypeAnnotation();
                        this.semicolon();
                        return this.finishNode(t, "DeclareModuleExports");
                    }
                }, {
                    key: "flowParseDeclareTypeAlias",
                    value: function e(t) {
                        this.next();
                        this.flowParseTypeAlias(t);
                        t.type = "DeclareTypeAlias";
                        return t;
                    }
                }, {
                    key: "flowParseDeclareOpaqueType",
                    value: function e(t) {
                        this.next();
                        this.flowParseOpaqueType(t, true);
                        t.type = "DeclareOpaqueType";
                        return t;
                    }
                }, {
                    key: "flowParseDeclareInterface",
                    value: function e(t) {
                        this.next();
                        this.flowParseInterfaceish(t);
                        return this.finishNode(t, "DeclareInterface");
                    }
                }, {
                    key: "flowParseInterfaceish",
                    value: function e(t) {
                        var i = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
                        t.id = this.flowParseRestrictedIdentifier(!i);
                        if (this.isRelational("<")) {
                            t.typeParameters = this.flowParseTypeParameterDeclaration();
                        } else {
                            t.typeParameters = null;
                        }
                        t.extends = [];
                        t.implements = [];
                        t.mixins = [];
                        if (this.eat(b._extends)) {
                            do {
                                t.extends.push(this.flowParseInterfaceExtends());
                            } while (!i && this.eat(b.comma));
                        }
                        if (this.isContextual("mixins")) {
                            this.next();
                            do {
                                t.mixins.push(this.flowParseInterfaceExtends());
                            } while (this.eat(b.comma));
                        }
                        if (this.isContextual("implements")) {
                            this.next();
                            do {
                                t.implements.push(this.flowParseInterfaceExtends());
                            } while (this.eat(b.comma));
                        }
                        t.body = this.flowParseObjectType({
                            allowStatic: i,
                            allowExact: false,
                            allowSpread: false,
                            allowProto: i,
                            allowInexact: false
                        });
                    }
                }, {
                    key: "flowParseInterfaceExtends",
                    value: function e() {
                        var t = this.startNode();
                        t.id = this.flowParseQualifiedTypeIdentifier();
                        if (this.isRelational("<")) {
                            t.typeParameters = this.flowParseTypeParameterInstantiation();
                        } else {
                            t.typeParameters = null;
                        }
                        return this.finishNode(t, "InterfaceExtends");
                    }
                }, {
                    key: "flowParseInterface",
                    value: function e(t) {
                        this.flowParseInterfaceish(t);
                        return this.finishNode(t, "InterfaceDeclaration");
                    }
                }, {
                    key: "checkNotUnderscore",
                    value: function e(t) {
                        if (t === "_") {
                            throw this.unexpected(null, "`_` is only allowed as a type argument to call or new");
                        }
                    }
                }, {
                    key: "checkReservedType",
                    value: function e(t, i) {
                        if (Pe.indexOf(t) > -1) {
                            this.raise(i, "Cannot overwrite reserved type " + t);
                        }
                    }
                }, {
                    key: "flowParseRestrictedIdentifier",
                    value: function e(t) {
                        this.checkReservedType(this.state.value, this.state.start);
                        return this.parseIdentifier(t);
                    }
                }, {
                    key: "flowParseTypeAlias",
                    value: function e(t) {
                        t.id = this.flowParseRestrictedIdentifier();
                        this.scope.declareName(t.id.name, J, t.id.start);
                        if (this.isRelational("<")) {
                            t.typeParameters = this.flowParseTypeParameterDeclaration();
                        } else {
                            t.typeParameters = null;
                        }
                        t.right = this.flowParseTypeInitialiser(b.eq);
                        this.semicolon();
                        return this.finishNode(t, "TypeAlias");
                    }
                }, {
                    key: "flowParseOpaqueType",
                    value: function e(t, i) {
                        this.expectContextual("type");
                        t.id = this.flowParseRestrictedIdentifier(true);
                        this.scope.declareName(t.id.name, J, t.id.start);
                        if (this.isRelational("<")) {
                            t.typeParameters = this.flowParseTypeParameterDeclaration();
                        } else {
                            t.typeParameters = null;
                        }
                        t.supertype = null;
                        if (this.match(b.colon)) {
                            t.supertype = this.flowParseTypeInitialiser(b.colon);
                        }
                        t.impltype = null;
                        if (!i) {
                            t.impltype = this.flowParseTypeInitialiser(b.eq);
                        }
                        this.semicolon();
                        return this.finishNode(t, "OpaqueType");
                    }
                }, {
                    key: "flowParseTypeParameter",
                    value: function e() {
                        var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
                        var i = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
                        if (!t && i) {
                            throw new Error("Cannot disallow a default value (`allowDefault`) while also requiring it (`requireDefault`).");
                        }
                        var r = this.state.start;
                        var s = this.startNode();
                        var a = this.flowParseVariance();
                        var n = this.flowParseTypeAnnotatableIdentifier();
                        s.name = n.name;
                        s.variance = a;
                        s.bound = n.typeAnnotation;
                        if (this.match(b.eq)) {
                            if (t) {
                                this.eat(b.eq);
                                s.default = this.flowParseType();
                            } else {
                                this.unexpected();
                            }
                        } else {
                            if (i) {
                                this.unexpected(r, "Type parameter declaration needs a default, since a preceding type parameter declaration has a default.");
                            }
                        }
                        return this.finishNode(s, "TypeParameter");
                    }
                }, {
                    key: "flowParseTypeParameterDeclaration",
                    value: function e() {
                        var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
                        var i = this.state.inType;
                        var r = this.startNode();
                        r.params = [];
                        this.state.inType = true;
                        if (this.isRelational("<") || this.match(b.jsxTagStart)) {
                            this.next();
                        } else {
                            this.unexpected();
                        }
                        var s = false;
                        do {
                            var a = this.flowParseTypeParameter(t, s);
                            r.params.push(a);
                            if (a.default) {
                                s = true;
                            }
                            if (!this.isRelational(">")) {
                                this.expect(b.comma);
                            }
                        } while (!this.isRelational(">"));
                        this.expectRelational(">");
                        this.state.inType = i;
                        return this.finishNode(r, "TypeParameterDeclaration");
                    }
                }, {
                    key: "flowParseTypeParameterInstantiation",
                    value: function e() {
                        var t = this.startNode();
                        var i = this.state.inType;
                        t.params = [];
                        this.state.inType = true;
                        this.expectRelational("<");
                        var r = this.state.noAnonFunctionType;
                        this.state.noAnonFunctionType = false;
                        while (!this.isRelational(">")) {
                            t.params.push(this.flowParseType());
                            if (!this.isRelational(">")) {
                                this.expect(b.comma);
                            }
                        }
                        this.state.noAnonFunctionType = r;
                        this.expectRelational(">");
                        this.state.inType = i;
                        return this.finishNode(t, "TypeParameterInstantiation");
                    }
                }, {
                    key: "flowParseTypeParameterInstantiationCallOrNew",
                    value: function e() {
                        var t = this.startNode();
                        var i = this.state.inType;
                        t.params = [];
                        this.state.inType = true;
                        this.expectRelational("<");
                        while (!this.isRelational(">")) {
                            t.params.push(this.flowParseTypeOrImplicitInstantiation());
                            if (!this.isRelational(">")) {
                                this.expect(b.comma);
                            }
                        }
                        this.expectRelational(">");
                        this.state.inType = i;
                        return this.finishNode(t, "TypeParameterInstantiation");
                    }
                }, {
                    key: "flowParseInterfaceType",
                    value: function e() {
                        var t = this.startNode();
                        this.expectContextual("interface");
                        t.extends = [];
                        if (this.eat(b._extends)) {
                            do {
                                t.extends.push(this.flowParseInterfaceExtends());
                            } while (this.eat(b.comma));
                        }
                        t.body = this.flowParseObjectType({
                            allowStatic: false,
                            allowExact: false,
                            allowSpread: false,
                            allowProto: false,
                            allowInexact: false
                        });
                        return this.finishNode(t, "InterfaceTypeAnnotation");
                    }
                }, {
                    key: "flowParseObjectPropertyKey",
                    value: function e() {
                        return this.match(b.num) || this.match(b.string) ? this.parseExprAtom() : this.parseIdentifier(true);
                    }
                }, {
                    key: "flowParseObjectTypeIndexer",
                    value: function e(t, i, r) {
                        t.static = i;
                        if (this.lookahead().type === b.colon) {
                            t.id = this.flowParseObjectPropertyKey();
                            t.key = this.flowParseTypeInitialiser();
                        } else {
                            t.id = null;
                            t.key = this.flowParseType();
                        }
                        this.expect(b.bracketR);
                        t.value = this.flowParseTypeInitialiser();
                        t.variance = r;
                        return this.finishNode(t, "ObjectTypeIndexer");
                    }
                }, {
                    key: "flowParseObjectTypeInternalSlot",
                    value: function e(t, i) {
                        t.static = i;
                        t.id = this.flowParseObjectPropertyKey();
                        this.expect(b.bracketR);
                        this.expect(b.bracketR);
                        if (this.isRelational("<") || this.match(b.parenL)) {
                            t.method = true;
                            t.optional = false;
                            t.value = this.flowParseObjectTypeMethodish(this.startNodeAt(t.start, t.loc.start));
                        } else {
                            t.method = false;
                            if (this.eat(b.question)) {
                                t.optional = true;
                            }
                            t.value = this.flowParseTypeInitialiser();
                        }
                        return this.finishNode(t, "ObjectTypeInternalSlot");
                    }
                }, {
                    key: "flowParseObjectTypeMethodish",
                    value: function e(t) {
                        t.params = [];
                        t.rest = null;
                        t.typeParameters = null;
                        if (this.isRelational("<")) {
                            t.typeParameters = this.flowParseTypeParameterDeclaration(false);
                        }
                        this.expect(b.parenL);
                        while (!this.match(b.parenR) && !this.match(b.ellipsis)) {
                            t.params.push(this.flowParseFunctionTypeParam());
                            if (!this.match(b.parenR)) {
                                this.expect(b.comma);
                            }
                        }
                        if (this.eat(b.ellipsis)) {
                            t.rest = this.flowParseFunctionTypeParam();
                        }
                        this.expect(b.parenR);
                        t.returnType = this.flowParseTypeInitialiser();
                        return this.finishNode(t, "FunctionTypeAnnotation");
                    }
                }, {
                    key: "flowParseObjectTypeCallProperty",
                    value: function e(t, i) {
                        var r = this.startNode();
                        t.static = i;
                        t.value = this.flowParseObjectTypeMethodish(r);
                        return this.finishNode(t, "ObjectTypeCallProperty");
                    }
                }, {
                    key: "flowParseObjectType",
                    value: function e(t) {
                        var i = t.allowStatic, r = t.allowExact, s = t.allowSpread, a = t.allowProto, n = t.allowInexact;
                        var o = this.state.inType;
                        this.state.inType = true;
                        var l = this.startNode();
                        l.callProperties = [];
                        l.properties = [];
                        l.indexers = [];
                        l.internalSlots = [];
                        var u = void 0;
                        var c = void 0;
                        var h = false;
                        if (r && this.match(b.braceBarL)) {
                            this.expect(b.braceBarL);
                            u = b.braceBarR;
                            c = true;
                        } else {
                            this.expect(b.braceL);
                            u = b.braceR;
                            c = false;
                        }
                        l.exact = c;
                        while (!this.match(u)) {
                            var p = false;
                            var f = null;
                            var d = this.startNode();
                            if (a && this.isContextual("proto")) {
                                var m = this.lookahead();
                                if (m.type !== b.colon && m.type !== b.question) {
                                    this.next();
                                    f = this.state.start;
                                    i = false;
                                }
                            }
                            if (i && this.isContextual("static")) {
                                var y = this.lookahead();
                                if (y.type !== b.colon && y.type !== b.question) {
                                    this.next();
                                    p = true;
                                }
                            }
                            var v = this.flowParseVariance();
                            if (this.eat(b.bracketL)) {
                                if (f != null) {
                                    this.unexpected(f);
                                }
                                if (this.eat(b.bracketL)) {
                                    if (v) {
                                        this.unexpected(v.start);
                                    }
                                    l.internalSlots.push(this.flowParseObjectTypeInternalSlot(d, p));
                                } else {
                                    l.indexers.push(this.flowParseObjectTypeIndexer(d, p, v));
                                }
                            } else if (this.match(b.parenL) || this.isRelational("<")) {
                                if (f != null) {
                                    this.unexpected(f);
                                }
                                if (v) {
                                    this.unexpected(v.start);
                                }
                                l.callProperties.push(this.flowParseObjectTypeCallProperty(d, p));
                            } else {
                                var x = "init";
                                if (this.isContextual("get") || this.isContextual("set")) {
                                    var g = this.lookahead();
                                    if (g.type === b.name || g.type === b.string || g.type === b.num) {
                                        x = this.state.value;
                                        this.next();
                                    }
                                }
                                var E = this.flowParseObjectTypeProperty(d, p, f, v, x, s, n);
                                if (E === null) {
                                    h = true;
                                } else {
                                    l.properties.push(E);
                                }
                            }
                            this.flowObjectTypeSemicolon();
                        }
                        this.expect(u);
                        if (s) {
                            l.inexact = h;
                        }
                        var k = this.finishNode(l, "ObjectTypeAnnotation");
                        this.state.inType = o;
                        return k;
                    }
                }, {
                    key: "flowParseObjectTypeProperty",
                    value: function e(t, i, r, s, a, n, o) {
                        if (this.match(b.ellipsis)) {
                            if (!n) {
                                this.unexpected(null, "Spread operator cannot appear in class or interface definitions");
                            }
                            if (r != null) {
                                this.unexpected(r);
                            }
                            if (s) {
                                this.unexpected(s.start, "Spread properties cannot have variance");
                            }
                            this.expect(b.ellipsis);
                            var l = this.eat(b.comma) || this.eat(b.semi);
                            if (this.match(b.braceR)) {
                                if (o) return null;
                                this.unexpected(null, "Explicit inexact syntax is only allowed inside inexact objects");
                            }
                            if (this.match(b.braceBarR)) {
                                this.unexpected(null, "Explicit inexact syntax cannot appear inside an explicit exact object type");
                            }
                            if (l) {
                                this.unexpected(null, "Explicit inexact syntax must appear at the end of an inexact object");
                            }
                            t.argument = this.flowParseType();
                            return this.finishNode(t, "ObjectTypeSpreadProperty");
                        } else {
                            t.key = this.flowParseObjectPropertyKey();
                            t.static = i;
                            t.proto = r != null;
                            t.kind = a;
                            var u = false;
                            if (this.isRelational("<") || this.match(b.parenL)) {
                                t.method = true;
                                if (r != null) {
                                    this.unexpected(r);
                                }
                                if (s) {
                                    this.unexpected(s.start);
                                }
                                t.value = this.flowParseObjectTypeMethodish(this.startNodeAt(t.start, t.loc.start));
                                if (a === "get" || a === "set") {
                                    this.flowCheckGetterSetterParams(t);
                                }
                            } else {
                                if (a !== "init") this.unexpected();
                                t.method = false;
                                if (this.eat(b.question)) {
                                    u = true;
                                }
                                t.value = this.flowParseTypeInitialiser();
                                t.variance = s;
                            }
                            t.optional = u;
                            return this.finishNode(t, "ObjectTypeProperty");
                        }
                    }
                }, {
                    key: "flowCheckGetterSetterParams",
                    value: function e(t) {
                        var i = t.kind === "get" ? 0 : 1;
                        var r = t.start;
                        var s = t.value.params.length + (t.value.rest ? 1 : 0);
                        if (s !== i) {
                            if (t.kind === "get") {
                                this.raise(r, "getter must not have any formal parameters");
                            } else {
                                this.raise(r, "setter must have exactly one formal parameter");
                            }
                        }
                        if (t.kind === "set" && t.value.rest) {
                            this.raise(r, "setter function argument must not be a rest parameter");
                        }
                    }
                }, {
                    key: "flowObjectTypeSemicolon",
                    value: function e() {
                        if (!this.eat(b.semi) && !this.eat(b.comma) && !this.match(b.braceR) && !this.match(b.braceBarR)) {
                            this.unexpected();
                        }
                    }
                }, {
                    key: "flowParseQualifiedTypeIdentifier",
                    value: function e(t, i, r) {
                        t = t || this.state.start;
                        i = i || this.state.startLoc;
                        var s = r || this.parseIdentifier();
                        while (this.eat(b.dot)) {
                            var a = this.startNodeAt(t, i);
                            a.qualification = s;
                            a.id = this.parseIdentifier();
                            s = this.finishNode(a, "QualifiedTypeIdentifier");
                        }
                        return s;
                    }
                }, {
                    key: "flowParseGenericType",
                    value: function e(t, i, r) {
                        var s = this.startNodeAt(t, i);
                        s.typeParameters = null;
                        s.id = this.flowParseQualifiedTypeIdentifier(t, i, r);
                        if (this.isRelational("<")) {
                            s.typeParameters = this.flowParseTypeParameterInstantiation();
                        }
                        return this.finishNode(s, "GenericTypeAnnotation");
                    }
                }, {
                    key: "flowParseTypeofType",
                    value: function e() {
                        var t = this.startNode();
                        this.expect(b._typeof);
                        t.argument = this.flowParsePrimaryType();
                        return this.finishNode(t, "TypeofTypeAnnotation");
                    }
                }, {
                    key: "flowParseTupleType",
                    value: function e() {
                        var t = this.startNode();
                        t.types = [];
                        this.expect(b.bracketL);
                        while (this.state.pos < this.length && !this.match(b.bracketR)) {
                            t.types.push(this.flowParseType());
                            if (this.match(b.bracketR)) break;
                            this.expect(b.comma);
                        }
                        this.expect(b.bracketR);
                        return this.finishNode(t, "TupleTypeAnnotation");
                    }
                }, {
                    key: "flowParseFunctionTypeParam",
                    value: function e() {
                        var t = null;
                        var i = false;
                        var r = null;
                        var s = this.startNode();
                        var a = this.lookahead();
                        if (a.type === b.colon || a.type === b.question) {
                            t = this.parseIdentifier();
                            if (this.eat(b.question)) {
                                i = true;
                            }
                            r = this.flowParseTypeInitialiser();
                        } else {
                            r = this.flowParseType();
                        }
                        s.name = t;
                        s.optional = i;
                        s.typeAnnotation = r;
                        return this.finishNode(s, "FunctionTypeParam");
                    }
                }, {
                    key: "reinterpretTypeAsFunctionTypeParam",
                    value: function e(t) {
                        var i = this.startNodeAt(t.start, t.loc.start);
                        i.name = null;
                        i.optional = false;
                        i.typeAnnotation = t;
                        return this.finishNode(i, "FunctionTypeParam");
                    }
                }, {
                    key: "flowParseFunctionTypeParams",
                    value: function e() {
                        var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
                        var i = null;
                        while (!this.match(b.parenR) && !this.match(b.ellipsis)) {
                            t.push(this.flowParseFunctionTypeParam());
                            if (!this.match(b.parenR)) {
                                this.expect(b.comma);
                            }
                        }
                        if (this.eat(b.ellipsis)) {
                            i = this.flowParseFunctionTypeParam();
                        }
                        return {
                            params: t,
                            rest: i
                        };
                    }
                }, {
                    key: "flowIdentToTypeAnnotation",
                    value: function e(t, i, r, s) {
                        switch (s.name) {
                          case "any":
                            return this.finishNode(r, "AnyTypeAnnotation");

                          case "bool":
                          case "boolean":
                            return this.finishNode(r, "BooleanTypeAnnotation");

                          case "mixed":
                            return this.finishNode(r, "MixedTypeAnnotation");

                          case "empty":
                            return this.finishNode(r, "EmptyTypeAnnotation");

                          case "number":
                            return this.finishNode(r, "NumberTypeAnnotation");

                          case "string":
                            return this.finishNode(r, "StringTypeAnnotation");

                          default:
                            this.checkNotUnderscore(s.name);
                            return this.flowParseGenericType(t, i, s);
                        }
                    }
                }, {
                    key: "flowParsePrimaryType",
                    value: function e() {
                        var i = this.state.start;
                        var r = this.state.startLoc;
                        var s = this.startNode();
                        var n = void 0;
                        var o = void 0;
                        var l = false;
                        var u = this.state.noAnonFunctionType;
                        switch (this.state.type) {
                          case b.name:
                            if (this.isContextual("interface")) {
                                return this.flowParseInterfaceType();
                            }
                            return this.flowIdentToTypeAnnotation(i, r, s, this.parseIdentifier());

                          case b.braceL:
                            return this.flowParseObjectType({
                                allowStatic: false,
                                allowExact: false,
                                allowSpread: true,
                                allowProto: false,
                                allowInexact: true
                            });

                          case b.braceBarL:
                            return this.flowParseObjectType({
                                allowStatic: false,
                                allowExact: true,
                                allowSpread: true,
                                allowProto: false,
                                allowInexact: false
                            });

                          case b.bracketL:
                            return this.flowParseTupleType();

                          case b.relational:
                            if (this.state.value === "<") {
                                s.typeParameters = this.flowParseTypeParameterDeclaration(false);
                                this.expect(b.parenL);
                                n = this.flowParseFunctionTypeParams();
                                s.params = n.params;
                                s.rest = n.rest;
                                this.expect(b.parenR);
                                this.expect(b.arrow);
                                s.returnType = this.flowParseType();
                                return this.finishNode(s, "FunctionTypeAnnotation");
                            }
                            break;

                          case b.parenL:
                            this.next();
                            if (!this.match(b.parenR) && !this.match(b.ellipsis)) {
                                if (this.match(b.name)) {
                                    var c = this.lookahead().type;
                                    l = c !== b.question && c !== b.colon;
                                } else {
                                    l = true;
                                }
                            }
                            if (l) {
                                this.state.noAnonFunctionType = false;
                                o = this.flowParseType();
                                this.state.noAnonFunctionType = u;
                                if (this.state.noAnonFunctionType || !(this.match(b.comma) || this.match(b.parenR) && this.lookahead().type === b.arrow)) {
                                    this.expect(b.parenR);
                                    return o;
                                } else {
                                    this.eat(b.comma);
                                }
                            }
                            if (o) {
                                n = this.flowParseFunctionTypeParams([ this.reinterpretTypeAsFunctionTypeParam(o) ]);
                            } else {
                                n = this.flowParseFunctionTypeParams();
                            }
                            s.params = n.params;
                            s.rest = n.rest;
                            this.expect(b.parenR);
                            this.expect(b.arrow);
                            s.returnType = this.flowParseType();
                            s.typeParameters = null;
                            return this.finishNode(s, "FunctionTypeAnnotation");

                          case b.string:
                            return this.parseLiteral(this.state.value, "StringLiteralTypeAnnotation");

                          case b._true:
                          case b._false:
                            s.value = this.match(b._true);
                            this.next();
                            return this.finishNode(s, "BooleanLiteralTypeAnnotation");

                          case b.plusMin:
                            if (this.state.value === "-") {
                                this.next();
                                if (!this.match(b.num)) {
                                    this.unexpected(null, 'Unexpected token, expected "number"');
                                }
                                return this.parseLiteral(-this.state.value, "NumberLiteralTypeAnnotation", s.start, s.loc.start);
                            }
                            this.unexpected();

                          case b.num:
                            return this.parseLiteral(this.state.value, "NumberLiteralTypeAnnotation");

                          case b._void:
                            this.next();
                            return this.finishNode(s, "VoidTypeAnnotation");

                          case b._null:
                            this.next();
                            return this.finishNode(s, "NullLiteralTypeAnnotation");

                          case b._this:
                            this.next();
                            return this.finishNode(s, "ThisTypeAnnotation");

                          case b.star:
                            this.next();
                            return this.finishNode(s, "ExistsTypeAnnotation");

                          default:
                            if (this.state.type.keyword === "typeof") {
                                return this.flowParseTypeofType();
                            } else if (this.state.type.keyword) {
                                var h = this.state.type.label;
                                this.next();
                                return a(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), "createIdentifier", this).call(this, s, h);
                            }
                        }
                        throw this.unexpected();
                    }
                }, {
                    key: "flowParsePostfixType",
                    value: function e() {
                        var t = this.state.start, i = this.state.startLoc;
                        var r = this.flowParsePrimaryType();
                        while (this.match(b.bracketL) && !this.canInsertSemicolon()) {
                            var s = this.startNodeAt(t, i);
                            s.elementType = r;
                            this.expect(b.bracketL);
                            this.expect(b.bracketR);
                            r = this.finishNode(s, "ArrayTypeAnnotation");
                        }
                        return r;
                    }
                }, {
                    key: "flowParsePrefixType",
                    value: function e() {
                        var t = this.startNode();
                        if (this.eat(b.question)) {
                            t.typeAnnotation = this.flowParsePrefixType();
                            return this.finishNode(t, "NullableTypeAnnotation");
                        } else {
                            return this.flowParsePostfixType();
                        }
                    }
                }, {
                    key: "flowParseAnonFunctionWithoutParens",
                    value: function e() {
                        var t = this.flowParsePrefixType();
                        if (!this.state.noAnonFunctionType && this.eat(b.arrow)) {
                            var i = this.startNodeAt(t.start, t.loc.start);
                            i.params = [ this.reinterpretTypeAsFunctionTypeParam(t) ];
                            i.rest = null;
                            i.returnType = this.flowParseType();
                            i.typeParameters = null;
                            return this.finishNode(i, "FunctionTypeAnnotation");
                        }
                        return t;
                    }
                }, {
                    key: "flowParseIntersectionType",
                    value: function e() {
                        var t = this.startNode();
                        this.eat(b.bitwiseAND);
                        var i = this.flowParseAnonFunctionWithoutParens();
                        t.types = [ i ];
                        while (this.eat(b.bitwiseAND)) {
                            t.types.push(this.flowParseAnonFunctionWithoutParens());
                        }
                        return t.types.length === 1 ? i : this.finishNode(t, "IntersectionTypeAnnotation");
                    }
                }, {
                    key: "flowParseUnionType",
                    value: function e() {
                        var t = this.startNode();
                        this.eat(b.bitwiseOR);
                        var i = this.flowParseIntersectionType();
                        t.types = [ i ];
                        while (this.eat(b.bitwiseOR)) {
                            t.types.push(this.flowParseIntersectionType());
                        }
                        return t.types.length === 1 ? i : this.finishNode(t, "UnionTypeAnnotation");
                    }
                }, {
                    key: "flowParseType",
                    value: function e() {
                        var t = this.state.inType;
                        this.state.inType = true;
                        var i = this.flowParseUnionType();
                        this.state.inType = t;
                        this.state.exprAllowed = this.state.exprAllowed || this.state.noAnonFunctionType;
                        return i;
                    }
                }, {
                    key: "flowParseTypeOrImplicitInstantiation",
                    value: function e() {
                        if (this.state.type === b.name && this.state.value === "_") {
                            var t = this.state.start;
                            var i = this.state.startLoc;
                            var r = this.parseIdentifier();
                            return this.flowParseGenericType(t, i, r);
                        } else {
                            return this.flowParseType();
                        }
                    }
                }, {
                    key: "flowParseTypeAnnotation",
                    value: function e() {
                        var t = this.startNode();
                        t.typeAnnotation = this.flowParseTypeInitialiser();
                        return this.finishNode(t, "TypeAnnotation");
                    }
                }, {
                    key: "flowParseTypeAnnotatableIdentifier",
                    value: function e(t) {
                        var i = t ? this.parseIdentifier() : this.flowParseRestrictedIdentifier();
                        if (this.match(b.colon)) {
                            i.typeAnnotation = this.flowParseTypeAnnotation();
                            this.resetEndLocation(i);
                        }
                        return i;
                    }
                }, {
                    key: "typeCastToParameter",
                    value: function e(t) {
                        t.expression.typeAnnotation = t.typeAnnotation;
                        this.resetEndLocation(t.expression, t.typeAnnotation.end, t.typeAnnotation.loc.end);
                        return t.expression;
                    }
                }, {
                    key: "flowParseVariance",
                    value: function e() {
                        var t = null;
                        if (this.match(b.plusMin)) {
                            t = this.startNode();
                            if (this.state.value === "+") {
                                t.kind = "plus";
                            } else {
                                t.kind = "minus";
                            }
                            this.next();
                            this.finishNode(t, "Variance");
                        }
                        return t;
                    }
                }, {
                    key: "parseFunctionBody",
                    value: function e(i, r) {
                        var s = this;
                        var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
                        if (r) {
                            return this.forwardNoArrowParamsConversionAt(i, function() {
                                return a(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), "parseFunctionBody", s).call(s, i, true, n);
                            });
                        }
                        return a(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), "parseFunctionBody", this).call(this, i, false, n);
                    }
                }, {
                    key: "parseFunctionBodyAndFinish",
                    value: function e(i, s) {
                        var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
                        if (this.match(b.colon)) {
                            var o = this.startNode();
                            var l = this.flowParseTypeAndPredicateInitialiser();
                            var u = r(l, 2);
                            o.typeAnnotation = u[0];
                            i.predicate = u[1];
                            i.returnType = o.typeAnnotation ? this.finishNode(o, "TypeAnnotation") : null;
                        }
                        a(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), "parseFunctionBodyAndFinish", this).call(this, i, s, n);
                    }
                }, {
                    key: "parseStatement",
                    value: function e(i, r) {
                        if (this.state.strict && this.match(b.name) && this.state.value === "interface") {
                            var s = this.startNode();
                            this.next();
                            return this.flowParseInterface(s);
                        } else {
                            var n = a(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), "parseStatement", this).call(this, i, r);
                            if (this.flowPragma === undefined && !this.isValidDirective(n)) {
                                this.flowPragma = null;
                            }
                            return n;
                        }
                    }
                }, {
                    key: "parseExpressionStatement",
                    value: function e(i, r) {
                        if (r.type === "Identifier") {
                            if (r.name === "declare") {
                                if (this.match(b._class) || this.match(b.name) || this.match(b._function) || this.match(b._var) || this.match(b._export)) {
                                    return this.flowParseDeclare(i);
                                }
                            } else if (this.match(b.name)) {
                                if (r.name === "interface") {
                                    return this.flowParseInterface(i);
                                } else if (r.name === "type") {
                                    return this.flowParseTypeAlias(i);
                                } else if (r.name === "opaque") {
                                    return this.flowParseOpaqueType(i, false);
                                }
                            }
                        }
                        return a(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), "parseExpressionStatement", this).call(this, i, r);
                    }
                }, {
                    key: "shouldParseExportDeclaration",
                    value: function e() {
                        return this.isContextual("type") || this.isContextual("interface") || this.isContextual("opaque") || a(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), "shouldParseExportDeclaration", this).call(this);
                    }
                }, {
                    key: "isExportDefaultSpecifier",
                    value: function e() {
                        if (this.match(b.name) && (this.state.value === "type" || this.state.value === "interface" || this.state.value === "opaque")) {
                            return false;
                        }
                        return a(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), "isExportDefaultSpecifier", this).call(this);
                    }
                }, {
                    key: "parseConditional",
                    value: function e(i, s, o, l, u) {
                        var c = this;
                        if (!this.match(b.question)) return i;
                        if (u) {
                            var h = this.state.clone();
                            try {
                                return a(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), "parseConditional", this).call(this, i, s, o, l);
                            } catch (e) {
                                if (e instanceof SyntaxError) {
                                    this.state = h;
                                    u.start = e.pos || this.state.start;
                                    return i;
                                } else {
                                    throw e;
                                }
                            }
                        }
                        this.expect(b.question);
                        var p = this.state.clone();
                        var f = this.state.noArrowAt;
                        var d = this.startNodeAt(o, l);
                        var m = this.tryParseConditionalConsequent(), y = m.consequent, v = m.failed;
                        var x = this.getArrowLikeExpressions(y), g = r(x, 2), E = g[0], k = g[1];
                        if (v || k.length > 0) {
                            var S = [].concat(n(f));
                            if (k.length > 0) {
                                this.state = p;
                                this.state.noArrowAt = S;
                                for (var w = 0; w < k.length; w++) {
                                    S.push(k[w].start);
                                }
                                var A = this.tryParseConditionalConsequent();
                                y = A.consequent;
                                v = A.failed;
                                var C = this.getArrowLikeExpressions(y);
                                var T = r(C, 2);
                                E = T[0];
                                k = T[1];
                            }
                            if (v && E.length > 1) {
                                this.raise(p.start, "Ambiguous expression: wrap the arrow functions in parentheses to disambiguate.");
                            }
                            if (v && E.length === 1) {
                                this.state = p;
                                this.state.noArrowAt = S.concat(E[0].start);
                                var P = this.tryParseConditionalConsequent();
                                y = P.consequent;
                                v = P.failed;
                            }
                            this.getArrowLikeExpressions(y, true);
                        }
                        this.state.noArrowAt = f;
                        this.expect(b.colon);
                        d.test = i;
                        d.consequent = y;
                        d.alternate = this.forwardNoArrowParamsConversionAt(d, function() {
                            return c.parseMaybeAssign(s, undefined, undefined, undefined);
                        });
                        return this.finishNode(d, "ConditionalExpression");
                    }
                }, {
                    key: "tryParseConditionalConsequent",
                    value: function e() {
                        this.state.noArrowParamsConversionAt.push(this.state.start);
                        var t = this.parseMaybeAssign();
                        var i = !this.match(b.colon);
                        this.state.noArrowParamsConversionAt.pop();
                        return {
                            consequent: t,
                            failed: i
                        };
                    }
                }, {
                    key: "getArrowLikeExpressions",
                    value: function e(i, r) {
                        var s = this;
                        var n = [ i ];
                        var o = [];
                        while (n.length !== 0) {
                            var l = n.pop();
                            if (l.type === "ArrowFunctionExpression") {
                                if (l.typeParameters || !l.returnType) {
                                    this.toAssignableList(l.params, true, "arrow function parameters");
                                    this.scope.enter(F(false, false) | C);
                                    a(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), "checkParams", this).call(this, l, false, true);
                                    this.scope.exit();
                                } else {
                                    o.push(l);
                                }
                                n.push(l.body);
                            } else if (l.type === "ConditionalExpression") {
                                n.push(l.consequent);
                                n.push(l.alternate);
                            }
                        }
                        if (r) {
                            for (var u = 0; u < o.length; u++) {
                                this.toAssignableList(i.params, true, "arrow function parameters");
                            }
                            return [ o, [] ];
                        }
                        return Ie(o, function(e) {
                            try {
                                s.toAssignableList(e.params, true, "arrow function parameters");
                                return true;
                            } catch (e) {
                                return false;
                            }
                        });
                    }
                }, {
                    key: "forwardNoArrowParamsConversionAt",
                    value: function e(t, i) {
                        var r = void 0;
                        if (this.state.noArrowParamsConversionAt.indexOf(t.start) !== -1) {
                            this.state.noArrowParamsConversionAt.push(this.state.start);
                            r = i();
                            this.state.noArrowParamsConversionAt.pop();
                        } else {
                            r = i();
                        }
                        return r;
                    }
                }, {
                    key: "parseParenItem",
                    value: function e(i, r, s) {
                        i = a(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), "parseParenItem", this).call(this, i, r, s);
                        if (this.eat(b.question)) {
                            i.optional = true;
                            this.resetEndLocation(i);
                        }
                        if (this.match(b.colon)) {
                            var n = this.startNodeAt(r, s);
                            n.expression = i;
                            n.typeAnnotation = this.flowParseTypeAnnotation();
                            return this.finishNode(n, "TypeCastExpression");
                        }
                        return i;
                    }
                }, {
                    key: "assertModuleNodeAllowed",
                    value: function e(i) {
                        if (i.type === "ImportDeclaration" && (i.importKind === "type" || i.importKind === "typeof") || i.type === "ExportNamedDeclaration" && i.exportKind === "type" || i.type === "ExportAllDeclaration" && i.exportKind === "type") {
                            return;
                        }
                        a(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), "assertModuleNodeAllowed", this).call(this, i);
                    }
                }, {
                    key: "parseExport",
                    value: function e(i) {
                        var r = a(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), "parseExport", this).call(this, i);
                        if (r.type === "ExportNamedDeclaration" || r.type === "ExportAllDeclaration") {
                            r.exportKind = r.exportKind || "value";
                        }
                        return r;
                    }
                }, {
                    key: "parseExportDeclaration",
                    value: function e(i) {
                        if (this.isContextual("type")) {
                            i.exportKind = "type";
                            var r = this.startNode();
                            this.next();
                            if (this.match(b.braceL)) {
                                i.specifiers = this.parseExportSpecifiers();
                                this.parseExportFrom(i);
                                return null;
                            } else {
                                return this.flowParseTypeAlias(r);
                            }
                        } else if (this.isContextual("opaque")) {
                            i.exportKind = "type";
                            var s = this.startNode();
                            this.next();
                            return this.flowParseOpaqueType(s, false);
                        } else if (this.isContextual("interface")) {
                            i.exportKind = "type";
                            var n = this.startNode();
                            this.next();
                            return this.flowParseInterface(n);
                        } else {
                            return a(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), "parseExportDeclaration", this).call(this, i);
                        }
                    }
                }, {
                    key: "eatExportStar",
                    value: function e(i) {
                        if (a(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), "eatExportStar", this).apply(this, arguments)) return true;
                        if (this.isContextual("type") && this.lookahead().type === b.star) {
                            i.exportKind = "type";
                            this.next();
                            this.next();
                            return true;
                        }
                        return false;
                    }
                }, {
                    key: "maybeParseExportNamespaceSpecifier",
                    value: function e(i) {
                        var r = this.state.start;
                        var s = a(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), "maybeParseExportNamespaceSpecifier", this).call(this, i);
                        if (s && i.exportKind === "type") {
                            this.unexpected(r);
                        }
                        return s;
                    }
                }, {
                    key: "parseClassId",
                    value: function e(i, r, s) {
                        a(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), "parseClassId", this).call(this, i, r, s);
                        if (this.isRelational("<")) {
                            i.typeParameters = this.flowParseTypeParameterDeclaration();
                        }
                    }
                }, {
                    key: "getTokenFromCode",
                    value: function e(i) {
                        var r = this.input.charCodeAt(this.state.pos + 1);
                        if (i === 123 && r === 124) {
                            return this.finishOp(b.braceBarL, 2);
                        } else if (this.state.inType && (i === 62 || i === 60)) {
                            return this.finishOp(b.relational, 1);
                        } else if (Ce(i, r)) {
                            this.state.isIterator = true;
                            return a(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), "readWord", this).call(this);
                        } else {
                            return a(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), "getTokenFromCode", this).call(this, i);
                        }
                    }
                }, {
                    key: "toAssignable",
                    value: function e(i, r, s) {
                        if (i.type === "TypeCastExpression") {
                            return a(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), "toAssignable", this).call(this, this.typeCastToParameter(i), r, s);
                        } else {
                            return a(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), "toAssignable", this).call(this, i, r, s);
                        }
                    }
                }, {
                    key: "toAssignableList",
                    value: function e(i, r, s) {
                        for (var n = 0; n < i.length; n++) {
                            var o = i[n];
                            if (o && o.type === "TypeCastExpression") {
                                i[n] = this.typeCastToParameter(o);
                            }
                        }
                        return a(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), "toAssignableList", this).call(this, i, r, s);
                    }
                }, {
                    key: "toReferencedList",
                    value: function e(t, i) {
                        for (var r = 0; r < t.length; r++) {
                            var s = t[r];
                            if (s && s.type === "TypeCastExpression" && (!s.extra || !s.extra.parenthesized) && (t.length > 1 || !i)) {
                                this.raise(s.typeAnnotation.start, "The type cast expression is expected to be wrapped with parenthesis");
                            }
                        }
                        return t;
                    }
                }, {
                    key: "checkLVal",
                    value: function e(i) {
                        var r = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Q;
                        var s = arguments[2];
                        var n = arguments[3];
                        if (i.type !== "TypeCastExpression") {
                            return a(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), "checkLVal", this).call(this, i, r, s, n);
                        }
                    }
                }, {
                    key: "parseClassProperty",
                    value: function e(i) {
                        if (this.match(b.colon)) {
                            i.typeAnnotation = this.flowParseTypeAnnotation();
                        }
                        return a(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), "parseClassProperty", this).call(this, i);
                    }
                }, {
                    key: "parseClassPrivateProperty",
                    value: function e(i) {
                        if (this.match(b.colon)) {
                            i.typeAnnotation = this.flowParseTypeAnnotation();
                        }
                        return a(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), "parseClassPrivateProperty", this).call(this, i);
                    }
                }, {
                    key: "isClassMethod",
                    value: function e() {
                        return this.isRelational("<") || a(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), "isClassMethod", this).call(this);
                    }
                }, {
                    key: "isClassProperty",
                    value: function e() {
                        return this.match(b.colon) || a(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), "isClassProperty", this).call(this);
                    }
                }, {
                    key: "isNonstaticConstructor",
                    value: function e(i) {
                        return !this.match(b.colon) && a(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), "isNonstaticConstructor", this).call(this, i);
                    }
                }, {
                    key: "pushClassMethod",
                    value: function e(i, r, s, n, o, l) {
                        if (r.variance) {
                            this.unexpected(r.variance.start);
                        }
                        delete r.variance;
                        if (this.isRelational("<")) {
                            r.typeParameters = this.flowParseTypeParameterDeclaration(false);
                        }
                        a(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), "pushClassMethod", this).call(this, i, r, s, n, o, l);
                    }
                }, {
                    key: "pushClassPrivateMethod",
                    value: function e(i, r, s, n) {
                        if (r.variance) {
                            this.unexpected(r.variance.start);
                        }
                        delete r.variance;
                        if (this.isRelational("<")) {
                            r.typeParameters = this.flowParseTypeParameterDeclaration();
                        }
                        a(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), "pushClassPrivateMethod", this).call(this, i, r, s, n);
                    }
                }, {
                    key: "parseClassSuper",
                    value: function e(i) {
                        a(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), "parseClassSuper", this).call(this, i);
                        if (i.superClass && this.isRelational("<")) {
                            i.superTypeParameters = this.flowParseTypeParameterInstantiation();
                        }
                        if (this.isContextual("implements")) {
                            this.next();
                            var r = i.implements = [];
                            do {
                                var s = this.startNode();
                                s.id = this.flowParseRestrictedIdentifier(true);
                                if (this.isRelational("<")) {
                                    s.typeParameters = this.flowParseTypeParameterInstantiation();
                                } else {
                                    s.typeParameters = null;
                                }
                                r.push(this.finishNode(s, "ClassImplements"));
                            } while (this.eat(b.comma));
                        }
                    }
                }, {
                    key: "parsePropertyName",
                    value: function e(i) {
                        var r = this.flowParseVariance();
                        var s = a(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), "parsePropertyName", this).call(this, i);
                        i.variance = r;
                        return s;
                    }
                }, {
                    key: "parseObjPropValue",
                    value: function e(i, r, s, n, o, l, u, c) {
                        if (i.variance) {
                            this.unexpected(i.variance.start);
                        }
                        delete i.variance;
                        var h = void 0;
                        if (this.isRelational("<")) {
                            h = this.flowParseTypeParameterDeclaration(false);
                            if (!this.match(b.parenL)) this.unexpected();
                        }
                        a(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), "parseObjPropValue", this).call(this, i, r, s, n, o, l, u, c);
                        if (h) {
                            (i.value || i).typeParameters = h;
                        }
                    }
                }, {
                    key: "parseAssignableListItemTypes",
                    value: function e(t) {
                        if (this.eat(b.question)) {
                            if (t.type !== "Identifier") {
                                throw this.raise(t.start, "A binding pattern parameter cannot be optional in an implementation signature.");
                            }
                            t.optional = true;
                        }
                        if (this.match(b.colon)) {
                            t.typeAnnotation = this.flowParseTypeAnnotation();
                        }
                        this.resetEndLocation(t);
                        return t;
                    }
                }, {
                    key: "parseMaybeDefault",
                    value: function e(i, r, s) {
                        var n = a(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), "parseMaybeDefault", this).call(this, i, r, s);
                        if (n.type === "AssignmentPattern" && n.typeAnnotation && n.right.start < n.typeAnnotation.start) {
                            this.raise(n.typeAnnotation.start, "Type annotations must come before default assignments, " + "e.g. instead of `age = 25: number` use `age: number = 25`");
                        }
                        return n;
                    }
                }, {
                    key: "shouldParseDefaultImport",
                    value: function e(i) {
                        if (!_e(i)) {
                            return a(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), "shouldParseDefaultImport", this).call(this, i);
                        }
                        return Ne(this.state);
                    }
                }, {
                    key: "parseImportSpecifierLocal",
                    value: function e(t, i, r, s) {
                        i.local = _e(t) ? this.flowParseRestrictedIdentifier(true) : this.parseIdentifier();
                        this.checkLVal(i.local, J, undefined, s);
                        t.specifiers.push(this.finishNode(i, r));
                    }
                }, {
                    key: "maybeParseDefaultImportSpecifier",
                    value: function e(i) {
                        i.importKind = "value";
                        var r = null;
                        if (this.match(b._typeof)) {
                            r = "typeof";
                        } else if (this.isContextual("type")) {
                            r = "type";
                        }
                        if (r) {
                            var s = this.lookahead();
                            if (r === "type" && s.type === b.star) {
                                this.unexpected(s.start);
                            }
                            if (Ne(s) || s.type === b.braceL || s.type === b.star) {
                                this.next();
                                i.importKind = r;
                            }
                        }
                        return a(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), "maybeParseDefaultImportSpecifier", this).call(this, i);
                    }
                }, {
                    key: "parseImportSpecifier",
                    value: function e(t) {
                        var i = this.startNode();
                        var r = this.state.start;
                        var s = this.parseIdentifier(true);
                        var a = null;
                        if (s.name === "type") {
                            a = "type";
                        } else if (s.name === "typeof") {
                            a = "typeof";
                        }
                        var n = false;
                        if (this.isContextual("as") && !this.isLookaheadContextual("as")) {
                            var o = this.parseIdentifier(true);
                            if (a !== null && !this.match(b.name) && !this.state.type.keyword) {
                                i.imported = o;
                                i.importKind = a;
                                i.local = o.__clone();
                            } else {
                                i.imported = s;
                                i.importKind = null;
                                i.local = this.parseIdentifier();
                            }
                        } else if (a !== null && (this.match(b.name) || this.state.type.keyword)) {
                            i.imported = this.parseIdentifier(true);
                            i.importKind = a;
                            if (this.eatContextual("as")) {
                                i.local = this.parseIdentifier();
                            } else {
                                n = true;
                                i.local = i.imported.__clone();
                            }
                        } else {
                            n = true;
                            i.imported = s;
                            i.importKind = null;
                            i.local = i.imported.__clone();
                        }
                        var l = _e(t);
                        var u = _e(i);
                        if (l && u) {
                            this.raise(r, "The `type` and `typeof` keywords on named imports can only be used on regular " + "`import` statements. It cannot be used with `import type` or `import typeof` statements");
                        }
                        if (l || u) {
                            this.checkReservedType(i.local.name, i.local.start);
                        }
                        if (n && !l && !u) {
                            this.checkReservedWord(i.local.name, i.start, true, true);
                        }
                        this.checkLVal(i.local, J, undefined, "import specifier");
                        t.specifiers.push(this.finishNode(i, "ImportSpecifier"));
                    }
                }, {
                    key: "parseFunctionParams",
                    value: function e(i, r) {
                        var s = i.kind;
                        if (s !== "get" && s !== "set" && this.isRelational("<")) {
                            i.typeParameters = this.flowParseTypeParameterDeclaration(false);
                        }
                        a(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), "parseFunctionParams", this).call(this, i, r);
                    }
                }, {
                    key: "parseVarId",
                    value: function e(i, r) {
                        a(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), "parseVarId", this).call(this, i, r);
                        if (this.match(b.colon)) {
                            i.id.typeAnnotation = this.flowParseTypeAnnotation();
                            this.resetEndLocation(i.id);
                        }
                    }
                }, {
                    key: "parseAsyncArrowFromCallExpression",
                    value: function e(i, r) {
                        if (this.match(b.colon)) {
                            var s = this.state.noAnonFunctionType;
                            this.state.noAnonFunctionType = true;
                            i.returnType = this.flowParseTypeAnnotation();
                            this.state.noAnonFunctionType = s;
                        }
                        return a(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), "parseAsyncArrowFromCallExpression", this).call(this, i, r);
                    }
                }, {
                    key: "shouldParseAsyncArrow",
                    value: function e() {
                        return this.match(b.colon) || a(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), "shouldParseAsyncArrow", this).call(this);
                    }
                }, {
                    key: "parseMaybeAssign",
                    value: function e(i, r, s, n) {
                        var o = this;
                        var l = null;
                        if (this.hasPlugin("jsx") && (this.match(b.jsxTagStart) || this.isRelational("<"))) {
                            var u = this.state.clone();
                            try {
                                return a(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), "parseMaybeAssign", this).call(this, i, r, s, n);
                            } catch (e) {
                                if (e instanceof SyntaxError) {
                                    this.state = u;
                                    var c = this.state.context.length;
                                    if (this.state.context[c - 1] === ue.j_oTag) {
                                        this.state.context.length -= 2;
                                    }
                                    l = e;
                                } else {
                                    throw e;
                                }
                            }
                        }
                        if (l != null || this.isRelational("<")) {
                            var h = void 0;
                            var p = void 0;
                            try {
                                p = this.flowParseTypeParameterDeclaration();
                                h = this.forwardNoArrowParamsConversionAt(p, function() {
                                    return a(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), "parseMaybeAssign", o).call(o, i, r, s, n);
                                });
                                h.typeParameters = p;
                                this.resetStartLocationFromNode(h, p);
                            } catch (e) {
                                throw l || e;
                            }
                            if (h.type === "ArrowFunctionExpression") {
                                return h;
                            } else if (l != null) {
                                throw l;
                            } else {
                                this.raise(p.start, "Expected an arrow function after this type parameter declaration");
                            }
                        }
                        return a(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), "parseMaybeAssign", this).call(this, i, r, s, n);
                    }
                }, {
                    key: "parseArrow",
                    value: function e(i) {
                        if (this.match(b.colon)) {
                            var s = this.state.clone();
                            try {
                                var n = this.state.noAnonFunctionType;
                                this.state.noAnonFunctionType = true;
                                var o = this.startNode();
                                var l = this.flowParseTypeAndPredicateInitialiser();
                                var u = r(l, 2);
                                o.typeAnnotation = u[0];
                                i.predicate = u[1];
                                this.state.noAnonFunctionType = n;
                                if (this.canInsertSemicolon()) this.unexpected();
                                if (!this.match(b.arrow)) this.unexpected();
                                i.returnType = o.typeAnnotation ? this.finishNode(o, "TypeAnnotation") : null;
                            } catch (e) {
                                if (e instanceof SyntaxError) {
                                    this.state = s;
                                } else {
                                    throw e;
                                }
                            }
                        }
                        return a(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), "parseArrow", this).call(this, i);
                    }
                }, {
                    key: "shouldParseArrow",
                    value: function e() {
                        return this.match(b.colon) || a(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), "shouldParseArrow", this).call(this);
                    }
                }, {
                    key: "setArrowFunctionParameters",
                    value: function e(i, r) {
                        if (this.state.noArrowParamsConversionAt.indexOf(i.start) !== -1) {
                            i.params = r;
                        } else {
                            a(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), "setArrowFunctionParameters", this).call(this, i, r);
                        }
                    }
                }, {
                    key: "checkParams",
                    value: function e(i, r, s) {
                        if (s && this.state.noArrowParamsConversionAt.indexOf(i.start) !== -1) {
                            return;
                        }
                        return a(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), "checkParams", this).call(this, i, r, s);
                    }
                }, {
                    key: "parseParenAndDistinguishExpression",
                    value: function e(i) {
                        return a(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), "parseParenAndDistinguishExpression", this).call(this, i && this.state.noArrowAt.indexOf(this.state.start) === -1);
                    }
                }, {
                    key: "parseSubscripts",
                    value: function e(i, r, s, n) {
                        if (i.type === "Identifier" && i.name === "async" && this.state.noArrowAt.indexOf(r) !== -1) {
                            this.next();
                            var o = this.startNodeAt(r, s);
                            o.callee = i;
                            o.arguments = this.parseCallExpressionArguments(b.parenR, false);
                            i = this.finishNode(o, "CallExpression");
                        } else if (i.type === "Identifier" && i.name === "async" && this.isRelational("<")) {
                            var l = this.state.clone();
                            var u = void 0;
                            try {
                                var c = this.parseAsyncArrowWithTypeParameters(r, s);
                                if (c) return c;
                            } catch (e) {
                                u = e;
                            }
                            this.state = l;
                            try {
                                return a(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), "parseSubscripts", this).call(this, i, r, s, n);
                            } catch (e) {
                                throw u || e;
                            }
                        }
                        return a(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), "parseSubscripts", this).call(this, i, r, s, n);
                    }
                }, {
                    key: "parseSubscript",
                    value: function e(i, r, s, n, o, l) {
                        if (this.match(b.questionDot) && this.isLookaheadRelational("<")) {
                            this.expectPlugin("optionalChaining");
                            o.optionalChainMember = true;
                            if (n) {
                                o.stop = true;
                                return i;
                            }
                            this.next();
                            var u = this.startNodeAt(r, s);
                            u.callee = i;
                            u.typeArguments = this.flowParseTypeParameterInstantiation();
                            this.expect(b.parenL);
                            u.arguments = this.parseCallExpressionArguments(b.parenR, false);
                            u.optional = true;
                            return this.finishNode(u, "OptionalCallExpression");
                        } else if (!n && this.shouldParseTypes() && this.isRelational("<")) {
                            var c = this.startNodeAt(r, s);
                            c.callee = i;
                            var h = this.state.clone();
                            try {
                                c.typeArguments = this.flowParseTypeParameterInstantiationCallOrNew();
                                this.expect(b.parenL);
                                c.arguments = this.parseCallExpressionArguments(b.parenR, false);
                                if (o.optionalChainMember) {
                                    c.optional = false;
                                    return this.finishNode(c, "OptionalCallExpression");
                                }
                                return this.finishNode(c, "CallExpression");
                            } catch (e) {
                                if (e instanceof SyntaxError) {
                                    this.state = h;
                                } else {
                                    throw e;
                                }
                            }
                        }
                        return a(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), "parseSubscript", this).call(this, i, r, s, n, o, l);
                    }
                }, {
                    key: "parseNewArguments",
                    value: function e(i) {
                        var r = null;
                        if (this.shouldParseTypes() && this.isRelational("<")) {
                            var s = this.state.clone();
                            try {
                                r = this.flowParseTypeParameterInstantiationCallOrNew();
                            } catch (e) {
                                if (e instanceof SyntaxError) {
                                    this.state = s;
                                } else {
                                    throw e;
                                }
                            }
                        }
                        i.typeArguments = r;
                        a(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), "parseNewArguments", this).call(this, i);
                    }
                }, {
                    key: "parseAsyncArrowWithTypeParameters",
                    value: function e(t, i) {
                        var r = this.startNodeAt(t, i);
                        this.parseFunctionParams(r);
                        if (!this.parseArrow(r)) return;
                        return this.parseArrowExpression(r, undefined, true);
                    }
                }, {
                    key: "readToken_mult_modulo",
                    value: function e(i) {
                        var r = this.input.charCodeAt(this.state.pos + 1);
                        if (i === 42 && r === 47 && this.state.hasFlowComment) {
                            this.state.hasFlowComment = false;
                            this.state.pos += 2;
                            this.nextToken();
                            return;
                        }
                        a(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), "readToken_mult_modulo", this).call(this, i);
                    }
                }, {
                    key: "readToken_pipe_amp",
                    value: function e(i) {
                        var r = this.input.charCodeAt(this.state.pos + 1);
                        if (i === 124 && r === 125) {
                            this.finishOp(b.braceBarR, 2);
                            return;
                        }
                        a(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), "readToken_pipe_amp", this).call(this, i);
                    }
                }, {
                    key: "parseTopLevel",
                    value: function e(i, r) {
                        var s = a(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), "parseTopLevel", this).call(this, i, r);
                        if (this.state.hasFlowComment) {
                            this.unexpected(null, "Unterminated flow-comment");
                        }
                        return s;
                    }
                }, {
                    key: "skipBlockComment",
                    value: function e() {
                        if (this.hasPlugin("flowComments") && this.skipFlowComment()) {
                            if (this.state.hasFlowComment) {
                                this.unexpected(null, "Cannot have a flow comment inside another flow comment");
                            }
                            this.hasFlowCommentCompletion();
                            this.state.pos += this.skipFlowComment();
                            this.state.hasFlowComment = true;
                            return;
                        }
                        if (this.state.hasFlowComment) {
                            var i = this.input.indexOf("*-/", this.state.pos += 2);
                            if (i === -1) this.raise(this.state.pos - 2, "Unterminated comment");
                            this.state.pos = i + 3;
                            return;
                        }
                        a(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), "skipBlockComment", this).call(this);
                    }
                }, {
                    key: "skipFlowComment",
                    value: function e() {
                        var t = this.state.pos;
                        var i = 2;
                        while ([ 32, 9 ].includes(this.input.charCodeAt(t + i))) {
                            i++;
                        }
                        var r = this.input.charCodeAt(i + t);
                        var s = this.input.charCodeAt(i + t + 1);
                        if (r === 58 && s === 58) {
                            return i + 2;
                        }
                        if (this.input.slice(i + t, i + t + 12) === "flow-include") {
                            return i + 12;
                        }
                        if (r === 58 && s !== 58) {
                            return i;
                        }
                        return false;
                    }
                }, {
                    key: "hasFlowCommentCompletion",
                    value: function e() {
                        var t = this.input.indexOf("*/", this.state.pos);
                        if (t === -1) {
                            this.raise(this.state.pos, "Unterminated comment");
                        }
                    }
                } ]);
                return t;
            }(t);
        };
        var Be = {
            quot: '"',
            amp: "&",
            apos: "'",
            lt: "<",
            gt: ">",
            nbsp: " ",
            iexcl: "¡",
            cent: "¢",
            pound: "£",
            curren: "¤",
            yen: "¥",
            brvbar: "¦",
            sect: "§",
            uml: "¨",
            copy: "©",
            ordf: "ª",
            laquo: "«",
            not: "¬",
            shy: "­",
            reg: "®",
            macr: "¯",
            deg: "°",
            plusmn: "±",
            sup2: "²",
            sup3: "³",
            acute: "´",
            micro: "µ",
            para: "¶",
            middot: "·",
            cedil: "¸",
            sup1: "¹",
            ordm: "º",
            raquo: "»",
            frac14: "¼",
            frac12: "½",
            frac34: "¾",
            iquest: "¿",
            Agrave: "À",
            Aacute: "Á",
            Acirc: "Â",
            Atilde: "Ã",
            Auml: "Ä",
            Aring: "Å",
            AElig: "Æ",
            Ccedil: "Ç",
            Egrave: "È",
            Eacute: "É",
            Ecirc: "Ê",
            Euml: "Ë",
            Igrave: "Ì",
            Iacute: "Í",
            Icirc: "Î",
            Iuml: "Ï",
            ETH: "Ð",
            Ntilde: "Ñ",
            Ograve: "Ò",
            Oacute: "Ó",
            Ocirc: "Ô",
            Otilde: "Õ",
            Ouml: "Ö",
            times: "×",
            Oslash: "Ø",
            Ugrave: "Ù",
            Uacute: "Ú",
            Ucirc: "Û",
            Uuml: "Ü",
            Yacute: "Ý",
            THORN: "Þ",
            szlig: "ß",
            agrave: "à",
            aacute: "á",
            acirc: "â",
            atilde: "ã",
            auml: "ä",
            aring: "å",
            aelig: "æ",
            ccedil: "ç",
            egrave: "è",
            eacute: "é",
            ecirc: "ê",
            euml: "ë",
            igrave: "ì",
            iacute: "í",
            icirc: "î",
            iuml: "ï",
            eth: "ð",
            ntilde: "ñ",
            ograve: "ò",
            oacute: "ó",
            ocirc: "ô",
            otilde: "õ",
            ouml: "ö",
            divide: "÷",
            oslash: "ø",
            ugrave: "ù",
            uacute: "ú",
            ucirc: "û",
            uuml: "ü",
            yacute: "ý",
            thorn: "þ",
            yuml: "ÿ",
            OElig: "Œ",
            oelig: "œ",
            Scaron: "Š",
            scaron: "š",
            Yuml: "Ÿ",
            fnof: "ƒ",
            circ: "ˆ",
            tilde: "˜",
            Alpha: "Α",
            Beta: "Β",
            Gamma: "Γ",
            Delta: "Δ",
            Epsilon: "Ε",
            Zeta: "Ζ",
            Eta: "Η",
            Theta: "Θ",
            Iota: "Ι",
            Kappa: "Κ",
            Lambda: "Λ",
            Mu: "Μ",
            Nu: "Ν",
            Xi: "Ξ",
            Omicron: "Ο",
            Pi: "Π",
            Rho: "Ρ",
            Sigma: "Σ",
            Tau: "Τ",
            Upsilon: "Υ",
            Phi: "Φ",
            Chi: "Χ",
            Psi: "Ψ",
            Omega: "Ω",
            alpha: "α",
            beta: "β",
            gamma: "γ",
            delta: "δ",
            epsilon: "ε",
            zeta: "ζ",
            eta: "η",
            theta: "θ",
            iota: "ι",
            kappa: "κ",
            lambda: "λ",
            mu: "μ",
            nu: "ν",
            xi: "ξ",
            omicron: "ο",
            pi: "π",
            rho: "ρ",
            sigmaf: "ς",
            sigma: "σ",
            tau: "τ",
            upsilon: "υ",
            phi: "φ",
            chi: "χ",
            psi: "ψ",
            omega: "ω",
            thetasym: "ϑ",
            upsih: "ϒ",
            piv: "ϖ",
            ensp: " ",
            emsp: " ",
            thinsp: " ",
            zwnj: "‌",
            zwj: "‍",
            lrm: "‎",
            rlm: "‏",
            ndash: "–",
            mdash: "—",
            lsquo: "‘",
            rsquo: "’",
            sbquo: "‚",
            ldquo: "“",
            rdquo: "”",
            bdquo: "„",
            dagger: "†",
            Dagger: "‡",
            bull: "•",
            hellip: "…",
            permil: "‰",
            prime: "′",
            Prime: "″",
            lsaquo: "‹",
            rsaquo: "›",
            oline: "‾",
            frasl: "⁄",
            euro: "€",
            image: "ℑ",
            weierp: "℘",
            real: "ℜ",
            trade: "™",
            alefsym: "ℵ",
            larr: "←",
            uarr: "↑",
            rarr: "→",
            darr: "↓",
            harr: "↔",
            crarr: "↵",
            lArr: "⇐",
            uArr: "⇑",
            rArr: "⇒",
            dArr: "⇓",
            hArr: "⇔",
            forall: "∀",
            part: "∂",
            exist: "∃",
            empty: "∅",
            nabla: "∇",
            isin: "∈",
            notin: "∉",
            ni: "∋",
            prod: "∏",
            sum: "∑",
            minus: "−",
            lowast: "∗",
            radic: "√",
            prop: "∝",
            infin: "∞",
            ang: "∠",
            and: "∧",
            or: "∨",
            cap: "∩",
            cup: "∪",
            int: "∫",
            there4: "∴",
            sim: "∼",
            cong: "≅",
            asymp: "≈",
            ne: "≠",
            equiv: "≡",
            le: "≤",
            ge: "≥",
            sub: "⊂",
            sup: "⊃",
            nsub: "⊄",
            sube: "⊆",
            supe: "⊇",
            oplus: "⊕",
            otimes: "⊗",
            perp: "⊥",
            sdot: "⋅",
            lceil: "⌈",
            rceil: "⌉",
            lfloor: "⌊",
            rfloor: "⌋",
            lang: "〈",
            rang: "〉",
            loz: "◊",
            spades: "♠",
            clubs: "♣",
            hearts: "♥",
            diams: "♦"
        };
        var Me = /^[\da-fA-F]+$/;
        var je = /^\d+$/;
        ue.j_oTag = new le("<tag", false);
        ue.j_cTag = new le("</tag", false);
        ue.j_expr = new le("<tag>...</tag>", true, true);
        b.jsxName = new y("jsxName");
        b.jsxText = new y("jsxText", {
            beforeExpr: true
        });
        b.jsxTagStart = new y("jsxTagStart", {
            startsExpr: true
        });
        b.jsxTagEnd = new y("jsxTagEnd");
        b.jsxTagStart.updateContext = function() {
            this.state.context.push(ue.j_expr);
            this.state.context.push(ue.j_oTag);
            this.state.exprAllowed = false;
        };
        b.jsxTagEnd.updateContext = function(e) {
            var t = this.state.context.pop();
            if (t === ue.j_oTag && e === b.slash || t === ue.j_cTag) {
                this.state.context.pop();
                this.state.exprAllowed = this.curContext() === ue.j_expr;
            } else {
                this.state.exprAllowed = true;
            }
        };
        function Re(e) {
            return e ? e.type === "JSXOpeningFragment" || e.type === "JSXClosingFragment" : false;
        }
        function Ve(e) {
            if (e.type === "JSXIdentifier") {
                return e.name;
            }
            if (e.type === "JSXNamespacedName") {
                return e.namespace.name + ":" + e.name.name;
            }
            if (e.type === "JSXMemberExpression") {
                return Ve(e.object) + "." + Ve(e.property);
            }
            throw new Error("Node had unexpected type: " + e.type);
        }
        var Ue = function e(t) {
            return function(e) {
                l(t, e);
                function t() {
                    u(this, t);
                    return o(this, (t.__proto__ || Object.getPrototypeOf(t)).apply(this, arguments));
                }
                s(t, [ {
                    key: "jsxReadToken",
                    value: function e() {
                        var i = "";
                        var r = this.state.pos;
                        for (;;) {
                            if (this.state.pos >= this.length) {
                                this.raise(this.state.start, "Unterminated JSX contents");
                            }
                            var s = this.input.charCodeAt(this.state.pos);
                            switch (s) {
                              case 60:
                              case 123:
                                if (this.state.pos === this.state.start) {
                                    if (s === 60 && this.state.exprAllowed) {
                                        ++this.state.pos;
                                        return this.finishToken(b.jsxTagStart);
                                    }
                                    return a(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), "getTokenFromCode", this).call(this, s);
                                }
                                i += this.input.slice(r, this.state.pos);
                                return this.finishToken(b.jsxText, i);

                              case 38:
                                i += this.input.slice(r, this.state.pos);
                                i += this.jsxReadEntity();
                                r = this.state.pos;
                                break;

                              default:
                                if (ae(s)) {
                                    i += this.input.slice(r, this.state.pos);
                                    i += this.jsxReadNewLine(true);
                                    r = this.state.pos;
                                } else {
                                    ++this.state.pos;
                                }
                            }
                        }
                    }
                }, {
                    key: "jsxReadNewLine",
                    value: function e(t) {
                        var i = this.input.charCodeAt(this.state.pos);
                        var r = void 0;
                        ++this.state.pos;
                        if (i === 13 && this.input.charCodeAt(this.state.pos) === 10) {
                            ++this.state.pos;
                            r = t ? "\n" : "\r\n";
                        } else {
                            r = String.fromCharCode(i);
                        }
                        ++this.state.curLine;
                        this.state.lineStart = this.state.pos;
                        return r;
                    }
                }, {
                    key: "jsxReadString",
                    value: function e(t) {
                        var i = "";
                        var r = ++this.state.pos;
                        for (;;) {
                            if (this.state.pos >= this.length) {
                                this.raise(this.state.start, "Unterminated string constant");
                            }
                            var s = this.input.charCodeAt(this.state.pos);
                            if (s === t) break;
                            if (s === 38) {
                                i += this.input.slice(r, this.state.pos);
                                i += this.jsxReadEntity();
                                r = this.state.pos;
                            } else if (ae(s)) {
                                i += this.input.slice(r, this.state.pos);
                                i += this.jsxReadNewLine(false);
                                r = this.state.pos;
                            } else {
                                ++this.state.pos;
                            }
                        }
                        i += this.input.slice(r, this.state.pos++);
                        return this.finishToken(b.string, i);
                    }
                }, {
                    key: "jsxReadEntity",
                    value: function e() {
                        var t = "";
                        var i = 0;
                        var r = void 0;
                        var s = this.input[this.state.pos];
                        var a = ++this.state.pos;
                        while (this.state.pos < this.length && i++ < 10) {
                            s = this.input[this.state.pos++];
                            if (s === ";") {
                                if (t[0] === "#") {
                                    if (t[1] === "x") {
                                        t = t.substr(2);
                                        if (Me.test(t)) {
                                            r = String.fromCodePoint(parseInt(t, 16));
                                        }
                                    } else {
                                        t = t.substr(1);
                                        if (je.test(t)) {
                                            r = String.fromCodePoint(parseInt(t, 10));
                                        }
                                    }
                                } else {
                                    r = Be[t];
                                }
                                break;
                            }
                            t += s;
                        }
                        if (!r) {
                            this.state.pos = a;
                            return "&";
                        }
                        return r;
                    }
                }, {
                    key: "jsxReadWord",
                    value: function e() {
                        var t = void 0;
                        var i = this.state.pos;
                        do {
                            t = this.input.charCodeAt(++this.state.pos);
                        } while (Te(t) || t === 45);
                        return this.finishToken(b.jsxName, this.input.slice(i, this.state.pos));
                    }
                }, {
                    key: "jsxParseIdentifier",
                    value: function e() {
                        var t = this.startNode();
                        if (this.match(b.jsxName)) {
                            t.name = this.state.value;
                        } else if (this.state.type.keyword) {
                            t.name = this.state.type.keyword;
                        } else {
                            this.unexpected();
                        }
                        this.next();
                        return this.finishNode(t, "JSXIdentifier");
                    }
                }, {
                    key: "jsxParseNamespacedName",
                    value: function e() {
                        var t = this.state.start;
                        var i = this.state.startLoc;
                        var r = this.jsxParseIdentifier();
                        if (!this.eat(b.colon)) return r;
                        var s = this.startNodeAt(t, i);
                        s.namespace = r;
                        s.name = this.jsxParseIdentifier();
                        return this.finishNode(s, "JSXNamespacedName");
                    }
                }, {
                    key: "jsxParseElementName",
                    value: function e() {
                        var t = this.state.start;
                        var i = this.state.startLoc;
                        var r = this.jsxParseNamespacedName();
                        while (this.eat(b.dot)) {
                            var s = this.startNodeAt(t, i);
                            s.object = r;
                            s.property = this.jsxParseIdentifier();
                            r = this.finishNode(s, "JSXMemberExpression");
                        }
                        return r;
                    }
                }, {
                    key: "jsxParseAttributeValue",
                    value: function e() {
                        var t = void 0;
                        switch (this.state.type) {
                          case b.braceL:
                            t = this.startNode();
                            this.next();
                            t = this.jsxParseExpressionContainer(t);
                            if (t.expression.type === "JSXEmptyExpression") {
                                throw this.raise(t.start, "JSX attributes must only be assigned a non-empty expression");
                            } else {
                                return t;
                            }

                          case b.jsxTagStart:
                          case b.string:
                            return this.parseExprAtom();

                          default:
                            throw this.raise(this.state.start, "JSX value should be either an expression or a quoted JSX text");
                        }
                    }
                }, {
                    key: "jsxParseEmptyExpression",
                    value: function e() {
                        var t = this.startNodeAt(this.state.lastTokEnd, this.state.lastTokEndLoc);
                        return this.finishNodeAt(t, "JSXEmptyExpression", this.state.start, this.state.startLoc);
                    }
                }, {
                    key: "jsxParseSpreadChild",
                    value: function e(t) {
                        this.next();
                        t.expression = this.parseExpression();
                        this.expect(b.braceR);
                        return this.finishNode(t, "JSXSpreadChild");
                    }
                }, {
                    key: "jsxParseExpressionContainer",
                    value: function e(t) {
                        if (this.match(b.braceR)) {
                            t.expression = this.jsxParseEmptyExpression();
                        } else {
                            t.expression = this.parseExpression();
                        }
                        this.expect(b.braceR);
                        return this.finishNode(t, "JSXExpressionContainer");
                    }
                }, {
                    key: "jsxParseAttribute",
                    value: function e() {
                        var t = this.startNode();
                        if (this.eat(b.braceL)) {
                            this.expect(b.ellipsis);
                            t.argument = this.parseMaybeAssign();
                            this.expect(b.braceR);
                            return this.finishNode(t, "JSXSpreadAttribute");
                        }
                        t.name = this.jsxParseNamespacedName();
                        t.value = this.eat(b.eq) ? this.jsxParseAttributeValue() : null;
                        return this.finishNode(t, "JSXAttribute");
                    }
                }, {
                    key: "jsxParseOpeningElementAt",
                    value: function e(t, i) {
                        var r = this.startNodeAt(t, i);
                        if (this.match(b.jsxTagEnd)) {
                            this.expect(b.jsxTagEnd);
                            return this.finishNode(r, "JSXOpeningFragment");
                        }
                        r.name = this.jsxParseElementName();
                        return this.jsxParseOpeningElementAfterName(r);
                    }
                }, {
                    key: "jsxParseOpeningElementAfterName",
                    value: function e(t) {
                        var i = [];
                        while (!this.match(b.slash) && !this.match(b.jsxTagEnd)) {
                            i.push(this.jsxParseAttribute());
                        }
                        t.attributes = i;
                        t.selfClosing = this.eat(b.slash);
                        this.expect(b.jsxTagEnd);
                        return this.finishNode(t, "JSXOpeningElement");
                    }
                }, {
                    key: "jsxParseClosingElementAt",
                    value: function e(t, i) {
                        var r = this.startNodeAt(t, i);
                        if (this.match(b.jsxTagEnd)) {
                            this.expect(b.jsxTagEnd);
                            return this.finishNode(r, "JSXClosingFragment");
                        }
                        r.name = this.jsxParseElementName();
                        this.expect(b.jsxTagEnd);
                        return this.finishNode(r, "JSXClosingElement");
                    }
                }, {
                    key: "jsxParseElementAt",
                    value: function e(t, i) {
                        var r = this.startNodeAt(t, i);
                        var s = [];
                        var a = this.jsxParseOpeningElementAt(t, i);
                        var n = null;
                        if (!a.selfClosing) {
                            e: for (;;) {
                                switch (this.state.type) {
                                  case b.jsxTagStart:
                                    t = this.state.start;
                                    i = this.state.startLoc;
                                    this.next();
                                    if (this.eat(b.slash)) {
                                        n = this.jsxParseClosingElementAt(t, i);
                                        break e;
                                    }
                                    s.push(this.jsxParseElementAt(t, i));
                                    break;

                                  case b.jsxText:
                                    s.push(this.parseExprAtom());
                                    break;

                                  case b.braceL:
                                    {
                                        var o = this.startNode();
                                        this.next();
                                        if (this.match(b.ellipsis)) {
                                            s.push(this.jsxParseSpreadChild(o));
                                        } else {
                                            s.push(this.jsxParseExpressionContainer(o));
                                        }
                                        break;
                                    }

                                  default:
                                    throw this.unexpected();
                                }
                            }
                            if (Re(a) && !Re(n)) {
                                this.raise(n.start, "Expected corresponding JSX closing tag for <>");
                            } else if (!Re(a) && Re(n)) {
                                this.raise(n.start, "Expected corresponding JSX closing tag for <" + Ve(a.name) + ">");
                            } else if (!Re(a) && !Re(n)) {
                                if (Ve(n.name) !== Ve(a.name)) {
                                    this.raise(n.start, "Expected corresponding JSX closing tag for <" + Ve(a.name) + ">");
                                }
                            }
                        }
                        if (Re(a)) {
                            r.openingFragment = a;
                            r.closingFragment = n;
                        } else {
                            r.openingElement = a;
                            r.closingElement = n;
                        }
                        r.children = s;
                        if (this.match(b.relational) && this.state.value === "<") {
                            this.raise(this.state.start, "Adjacent JSX elements must be wrapped in an enclosing tag. " + "Did you want a JSX fragment <>...</>?");
                        }
                        return Re(a) ? this.finishNode(r, "JSXFragment") : this.finishNode(r, "JSXElement");
                    }
                }, {
                    key: "jsxParseElement",
                    value: function e() {
                        var t = this.state.start;
                        var i = this.state.startLoc;
                        this.next();
                        return this.jsxParseElementAt(t, i);
                    }
                }, {
                    key: "parseExprAtom",
                    value: function e(i) {
                        if (this.match(b.jsxText)) {
                            return this.parseLiteral(this.state.value, "JSXText");
                        } else if (this.match(b.jsxTagStart)) {
                            return this.jsxParseElement();
                        } else if (this.isRelational("<") && this.input.charCodeAt(this.state.pos) !== 33) {
                            this.finishToken(b.jsxTagStart);
                            return this.jsxParseElement();
                        } else {
                            return a(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), "parseExprAtom", this).call(this, i);
                        }
                    }
                }, {
                    key: "getTokenFromCode",
                    value: function e(i) {
                        if (this.state.inPropertyName) return a(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), "getTokenFromCode", this).call(this, i);
                        var r = this.curContext();
                        if (r === ue.j_expr) {
                            return this.jsxReadToken();
                        }
                        if (r === ue.j_oTag || r === ue.j_cTag) {
                            if (Ae(i)) {
                                return this.jsxReadWord();
                            }
                            if (i === 62) {
                                ++this.state.pos;
                                return this.finishToken(b.jsxTagEnd);
                            }
                            if ((i === 34 || i === 39) && r === ue.j_oTag) {
                                return this.jsxReadString(i);
                            }
                        }
                        if (i === 60 && this.state.exprAllowed && this.input.charCodeAt(this.state.pos + 1) !== 33) {
                            ++this.state.pos;
                            return this.finishToken(b.jsxTagStart);
                        }
                        return a(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), "getTokenFromCode", this).call(this, i);
                    }
                }, {
                    key: "updateContext",
                    value: function e(i) {
                        if (this.match(b.braceL)) {
                            var r = this.curContext();
                            if (r === ue.j_oTag) {
                                this.state.context.push(ue.braceExpression);
                            } else if (r === ue.j_expr) {
                                this.state.context.push(ue.templateQuasi);
                            } else {
                                a(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), "updateContext", this).call(this, i);
                            }
                            this.state.exprAllowed = true;
                        } else if (this.match(b.slash) && i === b.jsxTagStart) {
                            this.state.context.length -= 2;
                            this.state.context.push(ue.j_cTag);
                            this.state.exprAllowed = false;
                        } else {
                            return a(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), "updateContext", this).call(this, i);
                        }
                    }
                } ]);
                return t;
            }(t);
        };
        var Xe = function e(t) {
            u(this, e);
            this.var = [];
            this.lexical = [];
            this.functions = [];
            this.flags = t;
        };
        var qe = function() {
            function e(t, i) {
                u(this, e);
                this.scopeStack = [];
                this.undefinedExports = new Map();
                this.raise = t;
                this.inModule = i;
            }
            s(e, [ {
                key: "createScope",
                value: function e(t) {
                    return new Xe(t);
                }
            }, {
                key: "enter",
                value: function e(t) {
                    this.scopeStack.push(this.createScope(t));
                }
            }, {
                key: "exit",
                value: function e() {
                    this.scopeStack.pop();
                }
            }, {
                key: "treatFunctionsAsVarInScope",
                value: function e(t) {
                    return !!(t.flags & S || !this.inModule && t.flags & k);
                }
            }, {
                key: "declareName",
                value: function e(t, i, r) {
                    var s = this.currentScope();
                    if (i & B || i & M) {
                        this.checkRedeclarationInScope(s, t, i, r);
                        if (i & M) {
                            s.functions.push(t);
                        } else {
                            s.lexical.push(t);
                        }
                        if (i & B) {
                            this.maybeExportDefined(s, t);
                        }
                    } else if (i & L) {
                        for (var a = this.scopeStack.length - 1; a >= 0; --a) {
                            s = this.scopeStack[a];
                            this.checkRedeclarationInScope(s, t, i, r);
                            s.var.push(t);
                            this.maybeExportDefined(s, t);
                            if (s.flags & N) break;
                        }
                    }
                    if (this.inModule && s.flags & k) {
                        this.undefinedExports.delete(t);
                    }
                }
            }, {
                key: "maybeExportDefined",
                value: function e(t, i) {
                    if (this.inModule && t.flags & k) {
                        this.undefinedExports.delete(i);
                    }
                }
            }, {
                key: "checkRedeclarationInScope",
                value: function e(t, i, r, s) {
                    if (this.isRedeclaredInScope(t, i, r)) {
                        this.raise(s, "Identifier '" + i + "' has already been declared");
                    }
                }
            }, {
                key: "isRedeclaredInScope",
                value: function e(t, i, r) {
                    if (!(r & I)) return false;
                    if (r & B) {
                        return t.lexical.indexOf(i) > -1 || t.functions.indexOf(i) > -1 || t.var.indexOf(i) > -1;
                    }
                    if (r & M) {
                        return t.lexical.indexOf(i) > -1 || !this.treatFunctionsAsVarInScope(t) && t.var.indexOf(i) > -1;
                    }
                    return t.lexical.indexOf(i) > -1 && !(t.flags & T && t.lexical[0] === i) || !this.treatFunctionsAsVarInScope(t) && t.functions.indexOf(i) > -1;
                }
            }, {
                key: "checkLocalExport",
                value: function e(t) {
                    if (this.scopeStack[0].lexical.indexOf(t.name) === -1 && this.scopeStack[0].var.indexOf(t.name) === -1 && this.scopeStack[0].functions.indexOf(t.name) === -1) {
                        this.undefinedExports.set(t.name, t.start);
                    }
                }
            }, {
                key: "currentScope",
                value: function e() {
                    return this.scopeStack[this.scopeStack.length - 1];
                }
            }, {
                key: "currentVarScope",
                value: function e() {
                    for (var t = this.scopeStack.length - 1; ;t--) {
                        var i = this.scopeStack[t];
                        if (i.flags & N) {
                            return i;
                        }
                    }
                }
            }, {
                key: "currentThisScope",
                value: function e() {
                    for (var t = this.scopeStack.length - 1; ;t--) {
                        var i = this.scopeStack[t];
                        if ((i.flags & N || i.flags & _) && !(i.flags & C)) {
                            return i;
                        }
                    }
                }
            }, {
                key: "inFunction",
                get: function e() {
                    return (this.currentVarScope().flags & S) > 0;
                }
            }, {
                key: "inGenerator",
                get: function e() {
                    return (this.currentVarScope().flags & A) > 0;
                }
            }, {
                key: "inAsync",
                get: function e() {
                    return (this.currentVarScope().flags & w) > 0;
                }
            }, {
                key: "allowSuper",
                get: function e() {
                    return (this.currentThisScope().flags & P) > 0;
                }
            }, {
                key: "allowDirectSuper",
                get: function e() {
                    return (this.currentThisScope().flags & D) > 0;
                }
            }, {
                key: "inNonArrowFunction",
                get: function e() {
                    return (this.currentThisScope().flags & S) > 0;
                }
            }, {
                key: "treatFunctionsAsVar",
                get: function e() {
                    return this.treatFunctionsAsVarInScope(this.currentScope());
                }
            } ]);
            return e;
        }();
        var Je = function(e) {
            l(t, e);
            function t() {
                var e;
                u(this, t);
                for (var i = arguments.length, r = Array(i), s = 0; s < i; s++) {
                    r[s] = arguments[s];
                }
                var a = o(this, (e = t.__proto__ || Object.getPrototypeOf(t)).call.apply(e, [ this ].concat(r)));
                a.types = [];
                a.enums = [];
                a.constEnums = [];
                a.classes = [];
                a.exportOnlyBindings = [];
                return a;
            }
            return t;
        }(Xe);
        var ze = function(e) {
            l(t, e);
            function t() {
                u(this, t);
                return o(this, (t.__proto__ || Object.getPrototypeOf(t)).apply(this, arguments));
            }
            s(t, [ {
                key: "createScope",
                value: function e(t) {
                    return new Je(t);
                }
            }, {
                key: "declareName",
                value: function e(i, r, s) {
                    var n = this.currentScope();
                    if (r & X) {
                        this.maybeExportDefined(n, i);
                        n.exportOnlyBindings.push(i);
                        return;
                    }
                    a(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), "declareName", this).apply(this, arguments);
                    if (r & O) {
                        if (!(r & I)) {
                            this.checkRedeclarationInScope(n, i, r, s);
                            this.maybeExportDefined(n, i);
                        }
                        n.types.push(i);
                    }
                    if (r & V) n.enums.push(i);
                    if (r & U) n.constEnums.push(i);
                    if (r & R) n.classes.push(i);
                }
            }, {
                key: "isRedeclaredInScope",
                value: function e(i, r, s) {
                    if (i.enums.indexOf(r) > -1) {
                        if (s & V) {
                            var n = !!(s & U);
                            var o = i.constEnums.indexOf(r) > -1;
                            return n !== o;
                        }
                        return true;
                    }
                    if (s & R && i.classes.indexOf(r) > -1) {
                        if (i.lexical.indexOf(r) > -1) {
                            return !!(s & I);
                        } else {
                            return false;
                        }
                    }
                    if (s & O && i.types.indexOf(r) > -1) {
                        return true;
                    }
                    return a(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), "isRedeclaredInScope", this).apply(this, arguments);
                }
            }, {
                key: "checkLocalExport",
                value: function e(i) {
                    if (this.scopeStack[0].types.indexOf(i.name) === -1 && this.scopeStack[0].exportOnlyBindings.indexOf(i.name) === -1) {
                        a(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), "checkLocalExport", this).call(this, i);
                    }
                }
            } ]);
            return t;
        }(qe);
        function We(e) {
            if (e == null) {
                throw new Error("Unexpected " + e + " value.");
            }
            return e;
        }
        function Ke(e) {
            if (!e) {
                throw new Error("Assert fail");
            }
        }
        function Ge(e) {
            switch (e) {
              case "any":
                return "TSAnyKeyword";

              case "boolean":
                return "TSBooleanKeyword";

              case "bigint":
                return "TSBigIntKeyword";

              case "never":
                return "TSNeverKeyword";

              case "number":
                return "TSNumberKeyword";

              case "object":
                return "TSObjectKeyword";

              case "string":
                return "TSStringKeyword";

              case "symbol":
                return "TSSymbolKeyword";

              case "undefined":
                return "TSUndefinedKeyword";

              case "unknown":
                return "TSUnknownKeyword";

              default:
                return undefined;
            }
        }
        var He = function e(t) {
            return function(e) {
                l(t, e);
                function t() {
                    u(this, t);
                    return o(this, (t.__proto__ || Object.getPrototypeOf(t)).apply(this, arguments));
                }
                s(t, [ {
                    key: "getScopeHandler",
                    value: function e() {
                        return ze;
                    }
                }, {
                    key: "tsIsIdentifier",
                    value: function e() {
                        return this.match(b.name);
                    }
                }, {
                    key: "tsNextTokenCanFollowModifier",
                    value: function e() {
                        this.next();
                        return !this.hasPrecedingLineBreak() && !this.match(b.parenL) && !this.match(b.parenR) && !this.match(b.colon) && !this.match(b.eq) && !this.match(b.question) && !this.match(b.bang);
                    }
                }, {
                    key: "tsParseModifier",
                    value: function e(t) {
                        if (!this.match(b.name)) {
                            return undefined;
                        }
                        var i = this.state.value;
                        if (t.indexOf(i) !== -1 && this.tsTryParse(this.tsNextTokenCanFollowModifier.bind(this))) {
                            return i;
                        }
                        return undefined;
                    }
                }, {
                    key: "tsIsListTerminator",
                    value: function e(t) {
                        switch (t) {
                          case "EnumMembers":
                          case "TypeMembers":
                            return this.match(b.braceR);

                          case "HeritageClauseElement":
                            return this.match(b.braceL);

                          case "TupleElementTypes":
                            return this.match(b.bracketR);

                          case "TypeParametersOrArguments":
                            return this.isRelational(">");
                        }
                        throw new Error("Unreachable");
                    }
                }, {
                    key: "tsParseList",
                    value: function e(t, i) {
                        var r = [];
                        while (!this.tsIsListTerminator(t)) {
                            r.push(i());
                        }
                        return r;
                    }
                }, {
                    key: "tsParseDelimitedList",
                    value: function e(t, i) {
                        return We(this.tsParseDelimitedListWorker(t, i, true));
                    }
                }, {
                    key: "tsTryParseDelimitedList",
                    value: function e(t, i) {
                        return this.tsParseDelimitedListWorker(t, i, false);
                    }
                }, {
                    key: "tsParseDelimitedListWorker",
                    value: function e(t, i, r) {
                        var s = [];
                        while (true) {
                            if (this.tsIsListTerminator(t)) {
                                break;
                            }
                            var a = i();
                            if (a == null) {
                                return undefined;
                            }
                            s.push(a);
                            if (this.eat(b.comma)) {
                                continue;
                            }
                            if (this.tsIsListTerminator(t)) {
                                break;
                            }
                            if (r) {
                                this.expect(b.comma);
                            }
                            return undefined;
                        }
                        return s;
                    }
                }, {
                    key: "tsParseBracketedList",
                    value: function e(t, i, r, s) {
                        if (!s) {
                            if (r) {
                                this.expect(b.bracketL);
                            } else {
                                this.expectRelational("<");
                            }
                        }
                        var a = this.tsParseDelimitedList(t, i);
                        if (r) {
                            this.expect(b.bracketR);
                        } else {
                            this.expectRelational(">");
                        }
                        return a;
                    }
                }, {
                    key: "tsParseImportType",
                    value: function e() {
                        var t = this.startNode();
                        this.expect(b._import);
                        this.expect(b.parenL);
                        if (!this.match(b.string)) {
                            throw this.unexpected(null, "Argument in a type import must be a string literal");
                        }
                        t.argument = this.parseExprAtom();
                        this.expect(b.parenR);
                        if (this.eat(b.dot)) {
                            t.qualifier = this.tsParseEntityName(true);
                        }
                        if (this.isRelational("<")) {
                            t.typeParameters = this.tsParseTypeArguments();
                        }
                        return this.finishNode(t, "TSImportType");
                    }
                }, {
                    key: "tsParseEntityName",
                    value: function e(t) {
                        var i = this.parseIdentifier();
                        while (this.eat(b.dot)) {
                            var r = this.startNodeAtNode(i);
                            r.left = i;
                            r.right = this.parseIdentifier(t);
                            i = this.finishNode(r, "TSQualifiedName");
                        }
                        return i;
                    }
                }, {
                    key: "tsParseTypeReference",
                    value: function e() {
                        var t = this.startNode();
                        t.typeName = this.tsParseEntityName(false);
                        if (!this.hasPrecedingLineBreak() && this.isRelational("<")) {
                            t.typeParameters = this.tsParseTypeArguments();
                        }
                        return this.finishNode(t, "TSTypeReference");
                    }
                }, {
                    key: "tsParseThisTypePredicate",
                    value: function e(t) {
                        this.next();
                        var i = this.startNodeAtNode(t);
                        i.parameterName = t;
                        i.typeAnnotation = this.tsParseTypeAnnotation(false);
                        return this.finishNode(i, "TSTypePredicate");
                    }
                }, {
                    key: "tsParseThisTypeNode",
                    value: function e() {
                        var t = this.startNode();
                        this.next();
                        return this.finishNode(t, "TSThisType");
                    }
                }, {
                    key: "tsParseTypeQuery",
                    value: function e() {
                        var t = this.startNode();
                        this.expect(b._typeof);
                        if (this.match(b._import)) {
                            t.exprName = this.tsParseImportType();
                        } else {
                            t.exprName = this.tsParseEntityName(true);
                        }
                        return this.finishNode(t, "TSTypeQuery");
                    }
                }, {
                    key: "tsParseTypeParameter",
                    value: function e() {
                        var t = this.startNode();
                        t.name = this.parseIdentifierName(t.start);
                        t.constraint = this.tsEatThenParseType(b._extends);
                        t.default = this.tsEatThenParseType(b.eq);
                        return this.finishNode(t, "TSTypeParameter");
                    }
                }, {
                    key: "tsTryParseTypeParameters",
                    value: function e() {
                        if (this.isRelational("<")) {
                            return this.tsParseTypeParameters();
                        }
                    }
                }, {
                    key: "tsParseTypeParameters",
                    value: function e() {
                        var t = this.startNode();
                        if (this.isRelational("<") || this.match(b.jsxTagStart)) {
                            this.next();
                        } else {
                            this.unexpected();
                        }
                        t.params = this.tsParseBracketedList("TypeParametersOrArguments", this.tsParseTypeParameter.bind(this), false, true);
                        return this.finishNode(t, "TSTypeParameterDeclaration");
                    }
                }, {
                    key: "tsTryNextParseConstantContext",
                    value: function e() {
                        if (this.lookahead().type === b._const) {
                            this.next();
                            return this.tsParseTypeReference();
                        }
                        return null;
                    }
                }, {
                    key: "tsFillSignature",
                    value: function e(t, i) {
                        var r = t === b.arrow;
                        i.typeParameters = this.tsTryParseTypeParameters();
                        this.expect(b.parenL);
                        i.parameters = this.tsParseBindingListForSignature();
                        if (r) {
                            i.typeAnnotation = this.tsParseTypeOrTypePredicateAnnotation(t);
                        } else if (this.match(t)) {
                            i.typeAnnotation = this.tsParseTypeOrTypePredicateAnnotation(t);
                        }
                    }
                }, {
                    key: "tsParseBindingListForSignature",
                    value: function e() {
                        var t = this;
                        return this.parseBindingList(b.parenR).map(function(e) {
                            if (e.type !== "Identifier" && e.type !== "RestElement" && e.type !== "ObjectPattern" && e.type !== "ArrayPattern") {
                                throw t.unexpected(e.start, "Name in a signature must be an Identifier, ObjectPattern or ArrayPattern, instead got " + e.type);
                            }
                            return e;
                        });
                    }
                }, {
                    key: "tsParseTypeMemberSemicolon",
                    value: function e() {
                        if (!this.eat(b.comma)) {
                            this.semicolon();
                        }
                    }
                }, {
                    key: "tsParseSignatureMember",
                    value: function e(t, i) {
                        this.tsFillSignature(b.colon, i);
                        this.tsParseTypeMemberSemicolon();
                        return this.finishNode(i, t);
                    }
                }, {
                    key: "tsIsUnambiguouslyIndexSignature",
                    value: function e() {
                        this.next();
                        return this.eat(b.name) && this.match(b.colon);
                    }
                }, {
                    key: "tsTryParseIndexSignature",
                    value: function e(t) {
                        if (!(this.match(b.bracketL) && this.tsLookAhead(this.tsIsUnambiguouslyIndexSignature.bind(this)))) {
                            return undefined;
                        }
                        this.expect(b.bracketL);
                        var i = this.parseIdentifier();
                        i.typeAnnotation = this.tsParseTypeAnnotation();
                        this.resetEndLocation(i);
                        this.expect(b.bracketR);
                        t.parameters = [ i ];
                        var r = this.tsTryParseTypeAnnotation();
                        if (r) t.typeAnnotation = r;
                        this.tsParseTypeMemberSemicolon();
                        return this.finishNode(t, "TSIndexSignature");
                    }
                }, {
                    key: "tsParsePropertyOrMethodSignature",
                    value: function e(t, i) {
                        if (this.eat(b.question)) t.optional = true;
                        var r = t;
                        if (!i && (this.match(b.parenL) || this.isRelational("<"))) {
                            var s = r;
                            this.tsFillSignature(b.colon, s);
                            this.tsParseTypeMemberSemicolon();
                            return this.finishNode(s, "TSMethodSignature");
                        } else {
                            var a = r;
                            if (i) a.readonly = true;
                            var n = this.tsTryParseTypeAnnotation();
                            if (n) a.typeAnnotation = n;
                            this.tsParseTypeMemberSemicolon();
                            return this.finishNode(a, "TSPropertySignature");
                        }
                    }
                }, {
                    key: "tsParseTypeMember",
                    value: function e() {
                        var t = this.startNode();
                        if (this.match(b.parenL) || this.isRelational("<")) {
                            return this.tsParseSignatureMember("TSCallSignatureDeclaration", t);
                        }
                        if (this.match(b._new)) {
                            var i = this.startNode();
                            this.next();
                            if (this.match(b.parenL) || this.isRelational("<")) {
                                return this.tsParseSignatureMember("TSConstructSignatureDeclaration", t);
                            } else {
                                t.key = this.createIdentifier(i, "new");
                                return this.tsParsePropertyOrMethodSignature(t, false);
                            }
                        }
                        var r = !!this.tsParseModifier([ "readonly" ]);
                        var s = this.tsTryParseIndexSignature(t);
                        if (s) {
                            if (r) t.readonly = true;
                            return s;
                        }
                        this.parsePropertyName(t);
                        return this.tsParsePropertyOrMethodSignature(t, r);
                    }
                }, {
                    key: "tsParseTypeLiteral",
                    value: function e() {
                        var t = this.startNode();
                        t.members = this.tsParseObjectTypeMembers();
                        return this.finishNode(t, "TSTypeLiteral");
                    }
                }, {
                    key: "tsParseObjectTypeMembers",
                    value: function e() {
                        this.expect(b.braceL);
                        var t = this.tsParseList("TypeMembers", this.tsParseTypeMember.bind(this));
                        this.expect(b.braceR);
                        return t;
                    }
                }, {
                    key: "tsIsStartOfMappedType",
                    value: function e() {
                        this.next();
                        if (this.eat(b.plusMin)) {
                            return this.isContextual("readonly");
                        }
                        if (this.isContextual("readonly")) {
                            this.next();
                        }
                        if (!this.match(b.bracketL)) {
                            return false;
                        }
                        this.next();
                        if (!this.tsIsIdentifier()) {
                            return false;
                        }
                        this.next();
                        return this.match(b._in);
                    }
                }, {
                    key: "tsParseMappedTypeParameter",
                    value: function e() {
                        var t = this.startNode();
                        t.name = this.parseIdentifierName(t.start);
                        t.constraint = this.tsExpectThenParseType(b._in);
                        return this.finishNode(t, "TSTypeParameter");
                    }
                }, {
                    key: "tsParseMappedType",
                    value: function e() {
                        var t = this.startNode();
                        this.expect(b.braceL);
                        if (this.match(b.plusMin)) {
                            t.readonly = this.state.value;
                            this.next();
                            this.expectContextual("readonly");
                        } else if (this.eatContextual("readonly")) {
                            t.readonly = true;
                        }
                        this.expect(b.bracketL);
                        t.typeParameter = this.tsParseMappedTypeParameter();
                        this.expect(b.bracketR);
                        if (this.match(b.plusMin)) {
                            t.optional = this.state.value;
                            this.next();
                            this.expect(b.question);
                        } else if (this.eat(b.question)) {
                            t.optional = true;
                        }
                        t.typeAnnotation = this.tsTryParseType();
                        this.semicolon();
                        this.expect(b.braceR);
                        return this.finishNode(t, "TSMappedType");
                    }
                }, {
                    key: "tsParseTupleType",
                    value: function e() {
                        var t = this;
                        var i = this.startNode();
                        i.elementTypes = this.tsParseBracketedList("TupleElementTypes", this.tsParseTupleElementType.bind(this), true, false);
                        var r = false;
                        i.elementTypes.forEach(function(e) {
                            if (e.type === "TSOptionalType") {
                                r = true;
                            } else if (r && e.type !== "TSRestType") {
                                t.raise(e.start, "A required element cannot follow an optional element.");
                            }
                        });
                        return this.finishNode(i, "TSTupleType");
                    }
                }, {
                    key: "tsParseTupleElementType",
                    value: function e() {
                        if (this.match(b.ellipsis)) {
                            var t = this.startNode();
                            this.next();
                            t.typeAnnotation = this.tsParseType();
                            this.checkCommaAfterRest();
                            return this.finishNode(t, "TSRestType");
                        }
                        var i = this.tsParseType();
                        if (this.eat(b.question)) {
                            var r = this.startNodeAtNode(i);
                            r.typeAnnotation = i;
                            return this.finishNode(r, "TSOptionalType");
                        }
                        return i;
                    }
                }, {
                    key: "tsParseParenthesizedType",
                    value: function e() {
                        var t = this.startNode();
                        this.expect(b.parenL);
                        t.typeAnnotation = this.tsParseType();
                        this.expect(b.parenR);
                        return this.finishNode(t, "TSParenthesizedType");
                    }
                }, {
                    key: "tsParseFunctionOrConstructorType",
                    value: function e(t) {
                        var i = this.startNode();
                        if (t === "TSConstructorType") {
                            this.expect(b._new);
                        }
                        this.tsFillSignature(b.arrow, i);
                        return this.finishNode(i, t);
                    }
                }, {
                    key: "tsParseLiteralTypeNode",
                    value: function e() {
                        var t = this;
                        var i = this.startNode();
                        i.literal = function() {
                            switch (t.state.type) {
                              case b.num:
                              case b.string:
                              case b._true:
                              case b._false:
                                return t.parseExprAtom();

                              default:
                                throw t.unexpected();
                            }
                        }();
                        return this.finishNode(i, "TSLiteralType");
                    }
                }, {
                    key: "tsParseTemplateLiteralType",
                    value: function e() {
                        var t = this.startNode();
                        var i = this.parseTemplate(false);
                        if (i.expressions.length > 0) {
                            throw this.raise(i.expressions[0].start, "Template literal types cannot have any substitution");
                        }
                        t.literal = i;
                        return this.finishNode(t, "TSLiteralType");
                    }
                }, {
                    key: "tsParseNonArrayType",
                    value: function e() {
                        switch (this.state.type) {
                          case b.name:
                          case b._void:
                          case b._null:
                            {
                                var t = this.match(b._void) ? "TSVoidKeyword" : this.match(b._null) ? "TSNullKeyword" : Ge(this.state.value);
                                if (t !== undefined && this.lookahead().type !== b.dot) {
                                    var i = this.startNode();
                                    this.next();
                                    return this.finishNode(i, t);
                                }
                                return this.tsParseTypeReference();
                            }

                          case b.string:
                          case b.num:
                          case b._true:
                          case b._false:
                            return this.tsParseLiteralTypeNode();

                          case b.plusMin:
                            if (this.state.value === "-") {
                                var r = this.startNode();
                                if (this.lookahead().type !== b.num) {
                                    throw this.unexpected();
                                }
                                r.literal = this.parseMaybeUnary();
                                return this.finishNode(r, "TSLiteralType");
                            }
                            break;

                          case b._this:
                            {
                                var s = this.tsParseThisTypeNode();
                                if (this.isContextual("is") && !this.hasPrecedingLineBreak()) {
                                    return this.tsParseThisTypePredicate(s);
                                } else {
                                    return s;
                                }
                            }

                          case b._typeof:
                            return this.tsParseTypeQuery();

                          case b._import:
                            return this.tsParseImportType();

                          case b.braceL:
                            return this.tsLookAhead(this.tsIsStartOfMappedType.bind(this)) ? this.tsParseMappedType() : this.tsParseTypeLiteral();

                          case b.bracketL:
                            return this.tsParseTupleType();

                          case b.parenL:
                            return this.tsParseParenthesizedType();

                          case b.backQuote:
                            return this.tsParseTemplateLiteralType();
                        }
                        throw this.unexpected();
                    }
                }, {
                    key: "tsParseArrayTypeOrHigher",
                    value: function e() {
                        var t = this.tsParseNonArrayType();
                        while (!this.hasPrecedingLineBreak() && this.eat(b.bracketL)) {
                            if (this.match(b.bracketR)) {
                                var i = this.startNodeAtNode(t);
                                i.elementType = t;
                                this.expect(b.bracketR);
                                t = this.finishNode(i, "TSArrayType");
                            } else {
                                var r = this.startNodeAtNode(t);
                                r.objectType = t;
                                r.indexType = this.tsParseType();
                                this.expect(b.bracketR);
                                t = this.finishNode(r, "TSIndexedAccessType");
                            }
                        }
                        return t;
                    }
                }, {
                    key: "tsParseTypeOperator",
                    value: function e(t) {
                        var i = this.startNode();
                        this.expectContextual(t);
                        i.operator = t;
                        i.typeAnnotation = this.tsParseTypeOperatorOrHigher();
                        if (t === "readonly") {
                            this.tsCheckTypeAnnotationForReadOnly(i);
                        }
                        return this.finishNode(i, "TSTypeOperator");
                    }
                }, {
                    key: "tsCheckTypeAnnotationForReadOnly",
                    value: function e(t) {
                        switch (t.typeAnnotation.type) {
                          case "TSTupleType":
                          case "TSArrayType":
                            return;

                          default:
                            this.raise(t.start, "'readonly' type modifier is only permitted on array and tuple literal types.");
                        }
                    }
                }, {
                    key: "tsParseInferType",
                    value: function e() {
                        var t = this.startNode();
                        this.expectContextual("infer");
                        var i = this.startNode();
                        i.name = this.parseIdentifierName(i.start);
                        t.typeParameter = this.finishNode(i, "TSTypeParameter");
                        return this.finishNode(t, "TSInferType");
                    }
                }, {
                    key: "tsParseTypeOperatorOrHigher",
                    value: function e() {
                        var t = this;
                        var i = [ "keyof", "unique", "readonly" ].find(function(e) {
                            return t.isContextual(e);
                        });
                        return i ? this.tsParseTypeOperator(i) : this.isContextual("infer") ? this.tsParseInferType() : this.tsParseArrayTypeOrHigher();
                    }
                }, {
                    key: "tsParseUnionOrIntersectionType",
                    value: function e(t, i, r) {
                        this.eat(r);
                        var s = i();
                        if (this.match(r)) {
                            var a = [ s ];
                            while (this.eat(r)) {
                                a.push(i());
                            }
                            var n = this.startNodeAtNode(s);
                            n.types = a;
                            s = this.finishNode(n, t);
                        }
                        return s;
                    }
                }, {
                    key: "tsParseIntersectionTypeOrHigher",
                    value: function e() {
                        return this.tsParseUnionOrIntersectionType("TSIntersectionType", this.tsParseTypeOperatorOrHigher.bind(this), b.bitwiseAND);
                    }
                }, {
                    key: "tsParseUnionTypeOrHigher",
                    value: function e() {
                        return this.tsParseUnionOrIntersectionType("TSUnionType", this.tsParseIntersectionTypeOrHigher.bind(this), b.bitwiseOR);
                    }
                }, {
                    key: "tsIsStartOfFunctionType",
                    value: function e() {
                        if (this.isRelational("<")) {
                            return true;
                        }
                        return this.match(b.parenL) && this.tsLookAhead(this.tsIsUnambiguouslyStartOfFunctionType.bind(this));
                    }
                }, {
                    key: "tsSkipParameterStart",
                    value: function e() {
                        if (this.match(b.name) || this.match(b._this)) {
                            this.next();
                            return true;
                        }
                        if (this.match(b.braceL)) {
                            var t = 1;
                            this.next();
                            while (t > 0) {
                                if (this.match(b.braceL)) {
                                    ++t;
                                } else if (this.match(b.braceR)) {
                                    --t;
                                }
                                this.next();
                            }
                            return true;
                        }
                        if (this.match(b.bracketL)) {
                            var i = 1;
                            this.next();
                            while (i > 0) {
                                if (this.match(b.bracketL)) {
                                    ++i;
                                } else if (this.match(b.bracketR)) {
                                    --i;
                                }
                                this.next();
                            }
                            return true;
                        }
                        return false;
                    }
                }, {
                    key: "tsIsUnambiguouslyStartOfFunctionType",
                    value: function e() {
                        this.next();
                        if (this.match(b.parenR) || this.match(b.ellipsis)) {
                            return true;
                        }
                        if (this.tsSkipParameterStart()) {
                            if (this.match(b.colon) || this.match(b.comma) || this.match(b.question) || this.match(b.eq)) {
                                return true;
                            }
                            if (this.match(b.parenR)) {
                                this.next();
                                if (this.match(b.arrow)) {
                                    return true;
                                }
                            }
                        }
                        return false;
                    }
                }, {
                    key: "tsParseTypeOrTypePredicateAnnotation",
                    value: function e(t) {
                        var i = this;
                        return this.tsInType(function() {
                            var e = i.startNode();
                            i.expect(t);
                            var r = i.tsIsIdentifier() && i.tsTryParse(i.tsParseTypePredicatePrefix.bind(i));
                            if (!r) {
                                return i.tsParseTypeAnnotation(false, e);
                            }
                            var s = i.tsParseTypeAnnotation(false);
                            var a = i.startNodeAtNode(r);
                            a.parameterName = r;
                            a.typeAnnotation = s;
                            e.typeAnnotation = i.finishNode(a, "TSTypePredicate");
                            return i.finishNode(e, "TSTypeAnnotation");
                        });
                    }
                }, {
                    key: "tsTryParseTypeOrTypePredicateAnnotation",
                    value: function e() {
                        return this.match(b.colon) ? this.tsParseTypeOrTypePredicateAnnotation(b.colon) : undefined;
                    }
                }, {
                    key: "tsTryParseTypeAnnotation",
                    value: function e() {
                        return this.match(b.colon) ? this.tsParseTypeAnnotation() : undefined;
                    }
                }, {
                    key: "tsTryParseType",
                    value: function e() {
                        return this.tsEatThenParseType(b.colon);
                    }
                }, {
                    key: "tsParseTypePredicatePrefix",
                    value: function e() {
                        var t = this.parseIdentifier();
                        if (this.isContextual("is") && !this.hasPrecedingLineBreak()) {
                            this.next();
                            return t;
                        }
                    }
                }, {
                    key: "tsParseTypeAnnotation",
                    value: function e() {
                        var t = this;
                        var i = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
                        var r = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.startNode();
                        this.tsInType(function() {
                            if (i) t.expect(b.colon);
                            r.typeAnnotation = t.tsParseType();
                        });
                        return this.finishNode(r, "TSTypeAnnotation");
                    }
                }, {
                    key: "tsParseType",
                    value: function e() {
                        Ke(this.state.inType);
                        var t = this.tsParseNonConditionalType();
                        if (this.hasPrecedingLineBreak() || !this.eat(b._extends)) {
                            return t;
                        }
                        var i = this.startNodeAtNode(t);
                        i.checkType = t;
                        i.extendsType = this.tsParseNonConditionalType();
                        this.expect(b.question);
                        i.trueType = this.tsParseType();
                        this.expect(b.colon);
                        i.falseType = this.tsParseType();
                        return this.finishNode(i, "TSConditionalType");
                    }
                }, {
                    key: "tsParseNonConditionalType",
                    value: function e() {
                        if (this.tsIsStartOfFunctionType()) {
                            return this.tsParseFunctionOrConstructorType("TSFunctionType");
                        }
                        if (this.match(b._new)) {
                            return this.tsParseFunctionOrConstructorType("TSConstructorType");
                        }
                        return this.tsParseUnionTypeOrHigher();
                    }
                }, {
                    key: "tsParseTypeAssertion",
                    value: function e() {
                        var t = this.startNode();
                        var i = this.tsTryNextParseConstantContext();
                        t.typeAnnotation = i || this.tsNextThenParseType();
                        this.expectRelational(">");
                        t.expression = this.parseMaybeUnary();
                        return this.finishNode(t, "TSTypeAssertion");
                    }
                }, {
                    key: "tsParseHeritageClause",
                    value: function e(t) {
                        var i = this.state.start;
                        var r = this.tsParseDelimitedList("HeritageClauseElement", this.tsParseExpressionWithTypeArguments.bind(this));
                        if (!r.length) {
                            this.raise(i, "'" + t + "' list cannot be empty.");
                        }
                        return r;
                    }
                }, {
                    key: "tsParseExpressionWithTypeArguments",
                    value: function e() {
                        var t = this.startNode();
                        t.expression = this.tsParseEntityName(false);
                        if (this.isRelational("<")) {
                            t.typeParameters = this.tsParseTypeArguments();
                        }
                        return this.finishNode(t, "TSExpressionWithTypeArguments");
                    }
                }, {
                    key: "tsParseInterfaceDeclaration",
                    value: function e(t) {
                        t.id = this.parseIdentifier();
                        this.checkLVal(t.id, K, undefined, "typescript interface declaration");
                        t.typeParameters = this.tsTryParseTypeParameters();
                        if (this.eat(b._extends)) {
                            t.extends = this.tsParseHeritageClause("extends");
                        }
                        var i = this.startNode();
                        i.body = this.tsInType(this.tsParseObjectTypeMembers.bind(this));
                        t.body = this.finishNode(i, "TSInterfaceBody");
                        return this.finishNode(t, "TSInterfaceDeclaration");
                    }
                }, {
                    key: "tsParseTypeAliasDeclaration",
                    value: function e(t) {
                        t.id = this.parseIdentifier();
                        this.checkLVal(t.id, G, undefined, "typescript type alias");
                        t.typeParameters = this.tsTryParseTypeParameters();
                        t.typeAnnotation = this.tsExpectThenParseType(b.eq);
                        this.semicolon();
                        return this.finishNode(t, "TSTypeAliasDeclaration");
                    }
                }, {
                    key: "tsInNoContext",
                    value: function e(t) {
                        var i = this.state.context;
                        this.state.context = [ i[0] ];
                        try {
                            return t();
                        } finally {
                            this.state.context = i;
                        }
                    }
                }, {
                    key: "tsInType",
                    value: function e(t) {
                        var i = this.state.inType;
                        this.state.inType = true;
                        try {
                            return t();
                        } finally {
                            this.state.inType = i;
                        }
                    }
                }, {
                    key: "tsEatThenParseType",
                    value: function e(t) {
                        return !this.match(t) ? undefined : this.tsNextThenParseType();
                    }
                }, {
                    key: "tsExpectThenParseType",
                    value: function e(t) {
                        var i = this;
                        return this.tsDoThenParseType(function() {
                            return i.expect(t);
                        });
                    }
                }, {
                    key: "tsNextThenParseType",
                    value: function e() {
                        var t = this;
                        return this.tsDoThenParseType(function() {
                            return t.next();
                        });
                    }
                }, {
                    key: "tsDoThenParseType",
                    value: function e(t) {
                        var i = this;
                        return this.tsInType(function() {
                            t();
                            return i.tsParseType();
                        });
                    }
                }, {
                    key: "tsParseEnumMember",
                    value: function e() {
                        var t = this.startNode();
                        t.id = this.match(b.string) ? this.parseExprAtom() : this.parseIdentifier(true);
                        if (this.eat(b.eq)) {
                            t.initializer = this.parseMaybeAssign();
                        }
                        return this.finishNode(t, "TSEnumMember");
                    }
                }, {
                    key: "tsParseEnumDeclaration",
                    value: function e(t, i) {
                        if (i) t.const = true;
                        t.id = this.parseIdentifier();
                        this.checkLVal(t.id, i ? Z : H, undefined, "typescript enum declaration");
                        this.expect(b.braceL);
                        t.members = this.tsParseDelimitedList("EnumMembers", this.tsParseEnumMember.bind(this));
                        this.expect(b.braceR);
                        return this.finishNode(t, "TSEnumDeclaration");
                    }
                }, {
                    key: "tsParseModuleBlock",
                    value: function e() {
                        var t = this.startNode();
                        this.scope.enter(E);
                        this.expect(b.braceL);
                        this.parseBlockOrModuleBlockBody(t.body = [], undefined, true, b.braceR);
                        this.scope.exit();
                        return this.finishNode(t, "TSModuleBlock");
                    }
                }, {
                    key: "tsParseModuleOrNamespaceDeclaration",
                    value: function e(t) {
                        var i = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
                        t.id = this.parseIdentifier();
                        if (!i) {
                            this.checkLVal(t.id, ee, null, "module or namespace declaration");
                        }
                        if (this.eat(b.dot)) {
                            var r = this.startNode();
                            this.tsParseModuleOrNamespaceDeclaration(r, true);
                            t.body = r;
                        } else {
                            t.body = this.tsParseModuleBlock();
                        }
                        return this.finishNode(t, "TSModuleDeclaration");
                    }
                }, {
                    key: "tsParseAmbientExternalModuleDeclaration",
                    value: function e(t) {
                        if (this.isContextual("global")) {
                            t.global = true;
                            t.id = this.parseIdentifier();
                        } else if (this.match(b.string)) {
                            t.id = this.parseExprAtom();
                        } else {
                            this.unexpected();
                        }
                        if (this.match(b.braceL)) {
                            t.body = this.tsParseModuleBlock();
                        } else {
                            this.semicolon();
                        }
                        return this.finishNode(t, "TSModuleDeclaration");
                    }
                }, {
                    key: "tsParseImportEqualsDeclaration",
                    value: function e(t, i) {
                        t.isExport = i || false;
                        t.id = this.parseIdentifier();
                        this.expect(b.eq);
                        t.moduleReference = this.tsParseModuleReference();
                        this.semicolon();
                        return this.finishNode(t, "TSImportEqualsDeclaration");
                    }
                }, {
                    key: "tsIsExternalModuleReference",
                    value: function e() {
                        return this.isContextual("require") && this.lookahead().type === b.parenL;
                    }
                }, {
                    key: "tsParseModuleReference",
                    value: function e() {
                        return this.tsIsExternalModuleReference() ? this.tsParseExternalModuleReference() : this.tsParseEntityName(false);
                    }
                }, {
                    key: "tsParseExternalModuleReference",
                    value: function e() {
                        var t = this.startNode();
                        this.expectContextual("require");
                        this.expect(b.parenL);
                        if (!this.match(b.string)) {
                            throw this.unexpected();
                        }
                        t.expression = this.parseExprAtom();
                        this.expect(b.parenR);
                        return this.finishNode(t, "TSExternalModuleReference");
                    }
                }, {
                    key: "tsLookAhead",
                    value: function e(t) {
                        var i = this.state.clone();
                        var r = t();
                        this.state = i;
                        return r;
                    }
                }, {
                    key: "tsTryParseAndCatch",
                    value: function e(t) {
                        var i = this.state.clone();
                        try {
                            return t();
                        } catch (e) {
                            if (e instanceof SyntaxError) {
                                this.state = i;
                                return undefined;
                            }
                            throw e;
                        }
                    }
                }, {
                    key: "tsTryParse",
                    value: function e(t) {
                        var i = this.state.clone();
                        var r = t();
                        if (r !== undefined && r !== false) {
                            return r;
                        } else {
                            this.state = i;
                            return undefined;
                        }
                    }
                }, {
                    key: "nodeWithSamePosition",
                    value: function e(t, i) {
                        var r = this.startNodeAtNode(t);
                        r.type = i;
                        r.end = t.end;
                        r.loc.end = t.loc.end;
                        if (t.leadingComments) {
                            r.leadingComments = t.leadingComments;
                        }
                        if (t.trailingComments) {
                            r.trailingComments = t.trailingComments;
                        }
                        if (t.innerComments) r.innerComments = t.innerComments;
                        return r;
                    }
                }, {
                    key: "tsTryParseDeclare",
                    value: function e(t) {
                        if (this.isLineTerminator()) {
                            return;
                        }
                        var i = this.state.type;
                        var r = void 0;
                        if (this.isContextual("let")) {
                            i = b._var;
                            r = "let";
                        }
                        switch (i) {
                          case b._function:
                            return this.parseFunctionStatement(t, false, true);

                          case b._class:
                            return this.parseClass(t, true, false);

                          case b._const:
                            if (this.match(b._const) && this.isLookaheadContextual("enum")) {
                                this.expect(b._const);
                                this.expectContextual("enum");
                                return this.tsParseEnumDeclaration(t, true);
                            }

                          case b._var:
                            r = r || this.state.value;
                            return this.parseVarStatement(t, r);

                          case b.name:
                            {
                                var s = this.state.value;
                                if (s === "global") {
                                    return this.tsParseAmbientExternalModuleDeclaration(t);
                                } else {
                                    return this.tsParseDeclaration(t, s, true);
                                }
                            }
                        }
                    }
                }, {
                    key: "tsTryParseExportDeclaration",
                    value: function e() {
                        return this.tsParseDeclaration(this.startNode(), this.state.value, true);
                    }
                }, {
                    key: "tsParseExpressionStatement",
                    value: function e(t, i) {
                        switch (i.name) {
                          case "declare":
                            {
                                var r = this.tsTryParseDeclare(t);
                                if (r) {
                                    r.declare = true;
                                    return r;
                                }
                                break;
                            }

                          case "global":
                            if (this.match(b.braceL)) {
                                var s = t;
                                s.global = true;
                                s.id = i;
                                s.body = this.tsParseModuleBlock();
                                return this.finishNode(s, "TSModuleDeclaration");
                            }
                            break;

                          default:
                            return this.tsParseDeclaration(t, i.name, false);
                        }
                    }
                }, {
                    key: "tsParseDeclaration",
                    value: function e(t, i, r) {
                        switch (i) {
                          case "abstract":
                            if (this.tsCheckLineTerminatorAndMatch(b._class, r)) {
                                var s = t;
                                s.abstract = true;
                                if (r) {
                                    this.next();
                                    if (!this.match(b._class)) {
                                        this.unexpected(null, b._class);
                                    }
                                }
                                return this.parseClass(s, true, false);
                            }
                            break;

                          case "enum":
                            if (r || this.match(b.name)) {
                                if (r) this.next();
                                return this.tsParseEnumDeclaration(t, false);
                            }
                            break;

                          case "interface":
                            if (this.tsCheckLineTerminatorAndMatch(b.name, r)) {
                                if (r) this.next();
                                return this.tsParseInterfaceDeclaration(t);
                            }
                            break;

                          case "module":
                            if (r) this.next();
                            if (this.match(b.string)) {
                                return this.tsParseAmbientExternalModuleDeclaration(t);
                            } else if (this.tsCheckLineTerminatorAndMatch(b.name, r)) {
                                return this.tsParseModuleOrNamespaceDeclaration(t);
                            }
                            break;

                          case "namespace":
                            if (this.tsCheckLineTerminatorAndMatch(b.name, r)) {
                                if (r) this.next();
                                return this.tsParseModuleOrNamespaceDeclaration(t);
                            }
                            break;

                          case "type":
                            if (this.tsCheckLineTerminatorAndMatch(b.name, r)) {
                                if (r) this.next();
                                return this.tsParseTypeAliasDeclaration(t);
                            }
                            break;
                        }
                    }
                }, {
                    key: "tsCheckLineTerminatorAndMatch",
                    value: function e(t, i) {
                        return (i || this.match(t)) && !this.isLineTerminator();
                    }
                }, {
                    key: "tsTryParseGenericAsyncArrowFunction",
                    value: function e(i, r) {
                        var s = this;
                        if (!this.isRelational("<")) {
                            return undefined;
                        }
                        var n = this.tsTryParseAndCatch(function() {
                            var e = s.startNodeAt(i, r);
                            e.typeParameters = s.tsParseTypeParameters();
                            a(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), "parseFunctionParams", s).call(s, e);
                            e.returnType = s.tsTryParseTypeOrTypePredicateAnnotation();
                            s.expect(b.arrow);
                            return e;
                        });
                        if (!n) {
                            return undefined;
                        }
                        return this.parseArrowExpression(n, null, true);
                    }
                }, {
                    key: "tsParseTypeArguments",
                    value: function e() {
                        var t = this;
                        var i = this.startNode();
                        i.params = this.tsInType(function() {
                            return t.tsInNoContext(function() {
                                t.expectRelational("<");
                                return t.tsParseDelimitedList("TypeParametersOrArguments", t.tsParseType.bind(t));
                            });
                        });
                        this.state.exprAllowed = false;
                        this.expectRelational(">");
                        return this.finishNode(i, "TSTypeParameterInstantiation");
                    }
                }, {
                    key: "tsIsDeclarationStart",
                    value: function e() {
                        if (this.match(b.name)) {
                            switch (this.state.value) {
                              case "abstract":
                              case "declare":
                              case "enum":
                              case "interface":
                              case "module":
                              case "namespace":
                              case "type":
                                return true;
                            }
                        }
                        return false;
                    }
                }, {
                    key: "isExportDefaultSpecifier",
                    value: function e() {
                        if (this.tsIsDeclarationStart()) return false;
                        return a(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), "isExportDefaultSpecifier", this).call(this);
                    }
                }, {
                    key: "parseAssignableListItem",
                    value: function e(t, i) {
                        var r = this.state.start;
                        var s = this.state.startLoc;
                        var a = void 0;
                        var n = false;
                        if (t) {
                            a = this.parseAccessModifier();
                            n = !!this.tsParseModifier([ "readonly" ]);
                        }
                        var o = this.parseMaybeDefault();
                        this.parseAssignableListItemTypes(o);
                        var l = this.parseMaybeDefault(o.start, o.loc.start, o);
                        if (a || n) {
                            var u = this.startNodeAt(r, s);
                            if (i.length) {
                                u.decorators = i;
                            }
                            if (a) u.accessibility = a;
                            if (n) u.readonly = n;
                            if (l.type !== "Identifier" && l.type !== "AssignmentPattern") {
                                throw this.raise(u.start, "A parameter property may not be declared using a binding pattern.");
                            }
                            u.parameter = l;
                            return this.finishNode(u, "TSParameterProperty");
                        }
                        if (i.length) {
                            o.decorators = i;
                        }
                        return l;
                    }
                }, {
                    key: "parseFunctionBodyAndFinish",
                    value: function e(i, r) {
                        var s = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
                        if (this.match(b.colon)) {
                            i.returnType = this.tsParseTypeOrTypePredicateAnnotation(b.colon);
                        }
                        var n = r === "FunctionDeclaration" ? "TSDeclareFunction" : r === "ClassMethod" ? "TSDeclareMethod" : undefined;
                        if (n && !this.match(b.braceL) && this.isLineTerminator()) {
                            this.finishNode(i, n);
                            return;
                        }
                        a(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), "parseFunctionBodyAndFinish", this).call(this, i, r, s);
                    }
                }, {
                    key: "checkFunctionStatementId",
                    value: function e(i) {
                        if (!i.body && i.id) {
                            this.checkLVal(i.id, Y, null, "function name");
                        } else {
                            a(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), "checkFunctionStatementId", this).apply(this, arguments);
                        }
                    }
                }, {
                    key: "parseSubscript",
                    value: function e(i, r, s, n, o, l) {
                        var u = this;
                        if (!this.hasPrecedingLineBreak() && this.match(b.bang)) {
                            this.state.exprAllowed = false;
                            this.next();
                            var c = this.startNodeAt(r, s);
                            c.expression = i;
                            return this.finishNode(c, "TSNonNullExpression");
                        }
                        if (this.isRelational("<")) {
                            var h = this.tsTryParseAndCatch(function() {
                                if (!n && u.atPossibleAsync(i)) {
                                    var e = u.tsTryParseGenericAsyncArrowFunction(r, s);
                                    if (e) {
                                        return e;
                                    }
                                }
                                var t = u.startNodeAt(r, s);
                                t.callee = i;
                                var a = u.tsParseTypeArguments();
                                if (a) {
                                    if (!n && u.eat(b.parenL)) {
                                        t.arguments = u.parseCallExpressionArguments(b.parenR, false);
                                        t.typeParameters = a;
                                        return u.finishCallExpression(t);
                                    } else if (u.match(b.backQuote)) {
                                        return u.parseTaggedTemplateExpression(r, s, i, o, a);
                                    }
                                }
                                u.unexpected();
                            });
                            if (h) return h;
                        }
                        return a(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), "parseSubscript", this).call(this, i, r, s, n, o, l);
                    }
                }, {
                    key: "parseNewArguments",
                    value: function e(i) {
                        var r = this;
                        if (this.isRelational("<")) {
                            var s = this.tsTryParseAndCatch(function() {
                                var e = r.tsParseTypeArguments();
                                if (!r.match(b.parenL)) r.unexpected();
                                return e;
                            });
                            if (s) {
                                i.typeParameters = s;
                            }
                        }
                        a(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), "parseNewArguments", this).call(this, i);
                    }
                }, {
                    key: "parseExprOp",
                    value: function e(i, r, s, n, o) {
                        if (We(b._in.binop) > n && !this.hasPrecedingLineBreak() && this.isContextual("as")) {
                            var l = this.startNodeAt(r, s);
                            l.expression = i;
                            var u = this.tsTryNextParseConstantContext();
                            if (u) {
                                l.typeAnnotation = u;
                            } else {
                                l.typeAnnotation = this.tsNextThenParseType();
                            }
                            this.finishNode(l, "TSAsExpression");
                            return this.parseExprOp(l, r, s, n, o);
                        }
                        return a(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), "parseExprOp", this).call(this, i, r, s, n, o);
                    }
                }, {
                    key: "checkReservedWord",
                    value: function e(t, i, r, s) {}
                }, {
                    key: "checkDuplicateExports",
                    value: function e() {}
                }, {
                    key: "parseImport",
                    value: function e(i) {
                        if (this.match(b.name) && this.lookahead().type === b.eq) {
                            return this.tsParseImportEqualsDeclaration(i);
                        }
                        return a(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), "parseImport", this).call(this, i);
                    }
                }, {
                    key: "parseExport",
                    value: function e(i) {
                        if (this.match(b._import)) {
                            this.expect(b._import);
                            return this.tsParseImportEqualsDeclaration(i, true);
                        } else if (this.eat(b.eq)) {
                            var r = i;
                            r.expression = this.parseExpression();
                            this.semicolon();
                            return this.finishNode(r, "TSExportAssignment");
                        } else if (this.eatContextual("as")) {
                            var s = i;
                            this.expectContextual("namespace");
                            s.id = this.parseIdentifier();
                            this.semicolon();
                            return this.finishNode(s, "TSNamespaceExportDeclaration");
                        } else {
                            return a(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), "parseExport", this).call(this, i);
                        }
                    }
                }, {
                    key: "isAbstractClass",
                    value: function e() {
                        return this.isContextual("abstract") && this.lookahead().type === b._class;
                    }
                }, {
                    key: "parseExportDefaultExpression",
                    value: function e() {
                        if (this.isAbstractClass()) {
                            var i = this.startNode();
                            this.next();
                            this.parseClass(i, true, true);
                            i.abstract = true;
                            return i;
                        }
                        if (this.state.value === "interface") {
                            var r = this.tsParseDeclaration(this.startNode(), this.state.value, true);
                            if (r) return r;
                        }
                        return a(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), "parseExportDefaultExpression", this).call(this);
                    }
                }, {
                    key: "parseStatementContent",
                    value: function e(i, r) {
                        if (this.state.type === b._const) {
                            var s = this.lookahead();
                            if (s.type === b.name && s.value === "enum") {
                                var n = this.startNode();
                                this.expect(b._const);
                                this.expectContextual("enum");
                                return this.tsParseEnumDeclaration(n, true);
                            }
                        }
                        return a(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), "parseStatementContent", this).call(this, i, r);
                    }
                }, {
                    key: "parseAccessModifier",
                    value: function e() {
                        return this.tsParseModifier([ "public", "protected", "private" ]);
                    }
                }, {
                    key: "parseClassMember",
                    value: function e(i, r, s, n) {
                        var o = this.parseAccessModifier();
                        if (o) r.accessibility = o;
                        a(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), "parseClassMember", this).call(this, i, r, s, n);
                    }
                }, {
                    key: "parseClassMemberWithIsStatic",
                    value: function e(i, r, s, n, o) {
                        var l = r;
                        var u = r;
                        var c = r;
                        var h = false, p = false;
                        var f = this.tsParseModifier([ "abstract", "readonly" ]);
                        switch (f) {
                          case "readonly":
                            p = true;
                            h = !!this.tsParseModifier([ "abstract" ]);
                            break;

                          case "abstract":
                            h = true;
                            p = !!this.tsParseModifier([ "readonly" ]);
                            break;
                        }
                        if (h) l.abstract = true;
                        if (p) c.readonly = true;
                        if (!h && !n && !l.accessibility) {
                            var d = this.tsTryParseIndexSignature(r);
                            if (d) {
                                i.body.push(d);
                                return;
                            }
                        }
                        if (p) {
                            l.static = n;
                            this.parseClassPropertyName(u);
                            this.parsePostMemberNameModifiers(l);
                            this.pushClassProperty(i, u);
                            return;
                        }
                        a(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), "parseClassMemberWithIsStatic", this).call(this, i, r, s, n, o);
                    }
                }, {
                    key: "parsePostMemberNameModifiers",
                    value: function e(t) {
                        var i = this.eat(b.question);
                        if (i) t.optional = true;
                    }
                }, {
                    key: "parseExpressionStatement",
                    value: function e(i, r) {
                        var s = r.type === "Identifier" ? this.tsParseExpressionStatement(i, r) : undefined;
                        return s || a(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), "parseExpressionStatement", this).call(this, i, r);
                    }
                }, {
                    key: "shouldParseExportDeclaration",
                    value: function e() {
                        if (this.tsIsDeclarationStart()) return true;
                        return a(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), "shouldParseExportDeclaration", this).call(this);
                    }
                }, {
                    key: "parseConditional",
                    value: function e(i, r, s, n, o) {
                        if (!o || !this.match(b.question)) {
                            return a(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), "parseConditional", this).call(this, i, r, s, n, o);
                        }
                        var l = this.state.clone();
                        try {
                            return a(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), "parseConditional", this).call(this, i, r, s, n);
                        } catch (e) {
                            if (!(e instanceof SyntaxError)) {
                                throw e;
                            }
                            this.state = l;
                            o.start = e.pos || this.state.start;
                            return i;
                        }
                    }
                }, {
                    key: "parseParenItem",
                    value: function e(i, r, s) {
                        i = a(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), "parseParenItem", this).call(this, i, r, s);
                        if (this.eat(b.question)) {
                            i.optional = true;
                            this.resetEndLocation(i);
                        }
                        if (this.match(b.colon)) {
                            var n = this.startNodeAt(r, s);
                            n.expression = i;
                            n.typeAnnotation = this.tsParseTypeAnnotation();
                            return this.finishNode(n, "TSTypeCastExpression");
                        }
                        return i;
                    }
                }, {
                    key: "parseExportDeclaration",
                    value: function e(i) {
                        var r = this.state.start;
                        var s = this.state.startLoc;
                        var n = this.eatContextual("declare");
                        var o = void 0;
                        if (this.match(b.name)) {
                            o = this.tsTryParseExportDeclaration();
                        }
                        if (!o) {
                            o = a(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), "parseExportDeclaration", this).call(this, i);
                        }
                        if (o && n) {
                            this.resetStartLocation(o, r, s);
                            o.declare = true;
                        }
                        return o;
                    }
                }, {
                    key: "parseClassId",
                    value: function e(i, r, s) {
                        if ((!r || s) && this.isContextual("implements")) {
                            return;
                        }
                        a(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), "parseClassId", this).apply(this, arguments);
                        var n = this.tsTryParseTypeParameters();
                        if (n) i.typeParameters = n;
                    }
                }, {
                    key: "parseClassProperty",
                    value: function e(i) {
                        if (!i.optional && this.eat(b.bang)) {
                            i.definite = true;
                        }
                        var r = this.tsTryParseTypeAnnotation();
                        if (r) i.typeAnnotation = r;
                        return a(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), "parseClassProperty", this).call(this, i);
                    }
                }, {
                    key: "pushClassMethod",
                    value: function e(i, r, s, n, o, l) {
                        var u = this.tsTryParseTypeParameters();
                        if (u) r.typeParameters = u;
                        a(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), "pushClassMethod", this).call(this, i, r, s, n, o, l);
                    }
                }, {
                    key: "pushClassPrivateMethod",
                    value: function e(i, r, s, n) {
                        var o = this.tsTryParseTypeParameters();
                        if (o) r.typeParameters = o;
                        a(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), "pushClassPrivateMethod", this).call(this, i, r, s, n);
                    }
                }, {
                    key: "parseClassSuper",
                    value: function e(i) {
                        a(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), "parseClassSuper", this).call(this, i);
                        if (i.superClass && this.isRelational("<")) {
                            i.superTypeParameters = this.tsParseTypeArguments();
                        }
                        if (this.eatContextual("implements")) {
                            i.implements = this.tsParseHeritageClause("implements");
                        }
                    }
                }, {
                    key: "parseObjPropValue",
                    value: function e(i) {
                        var r;
                        var s = this.tsTryParseTypeParameters();
                        if (s) i.typeParameters = s;
                        for (var n = arguments.length, o = Array(n > 1 ? n - 1 : 0), l = 1; l < n; l++) {
                            o[l - 1] = arguments[l];
                        }
                        (r = a(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), "parseObjPropValue", this)).call.apply(r, [ this, i ].concat(o));
                    }
                }, {
                    key: "parseFunctionParams",
                    value: function e(i, r) {
                        var s = this.tsTryParseTypeParameters();
                        if (s) i.typeParameters = s;
                        a(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), "parseFunctionParams", this).call(this, i, r);
                    }
                }, {
                    key: "parseVarId",
                    value: function e(i, r) {
                        a(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), "parseVarId", this).call(this, i, r);
                        if (i.id.type === "Identifier" && this.eat(b.bang)) {
                            i.definite = true;
                        }
                        var s = this.tsTryParseTypeAnnotation();
                        if (s) {
                            i.id.typeAnnotation = s;
                            this.resetEndLocation(i.id);
                        }
                    }
                }, {
                    key: "parseAsyncArrowFromCallExpression",
                    value: function e(i, r) {
                        if (this.match(b.colon)) {
                            i.returnType = this.tsParseTypeAnnotation();
                        }
                        return a(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), "parseAsyncArrowFromCallExpression", this).call(this, i, r);
                    }
                }, {
                    key: "parseMaybeAssign",
                    value: function e() {
                        var i = void 0;
                        for (var r = arguments.length, s = Array(r), n = 0; n < r; n++) {
                            s[n] = arguments[n];
                        }
                        if (this.match(b.jsxTagStart)) {
                            var o = this.curContext();
                            Ke(o === ue.j_oTag);
                            Ke(this.state.context[this.state.context.length - 2] === ue.j_expr);
                            var l = this.state.clone();
                            try {
                                var u;
                                return (u = a(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), "parseMaybeAssign", this)).call.apply(u, [ this ].concat(s));
                            } catch (e) {
                                if (!(e instanceof SyntaxError)) {
                                    throw e;
                                }
                                this.state = l;
                                Ke(this.curContext() === ue.j_oTag);
                                this.state.context.pop();
                                Ke(this.curContext() === ue.j_expr);
                                this.state.context.pop();
                                i = e;
                            }
                        }
                        if (i === undefined && !this.isRelational("<")) {
                            var c;
                            return (c = a(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), "parseMaybeAssign", this)).call.apply(c, [ this ].concat(s));
                        }
                        var h = void 0;
                        var p = void 0;
                        var f = this.state.clone();
                        try {
                            var d;
                            p = this.tsParseTypeParameters();
                            h = (d = a(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), "parseMaybeAssign", this)).call.apply(d, [ this ].concat(s));
                            if (h.type !== "ArrowFunctionExpression" || h.extra && h.extra.parenthesized) {
                                this.unexpected();
                            }
                        } catch (e) {
                            var m;
                            if (!(e instanceof SyntaxError)) {
                                throw e;
                            }
                            if (i) {
                                throw i;
                            }
                            Ke(!this.hasPlugin("jsx"));
                            this.state = f;
                            return (m = a(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), "parseMaybeAssign", this)).call.apply(m, [ this ].concat(s));
                        }
                        if (p && p.params.length !== 0) {
                            this.resetStartLocationFromNode(h, p);
                        }
                        h.typeParameters = p;
                        return h;
                    }
                }, {
                    key: "parseMaybeUnary",
                    value: function e(i) {
                        if (!this.hasPlugin("jsx") && this.isRelational("<")) {
                            return this.tsParseTypeAssertion();
                        } else {
                            return a(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), "parseMaybeUnary", this).call(this, i);
                        }
                    }
                }, {
                    key: "parseArrow",
                    value: function e(i) {
                        if (this.match(b.colon)) {
                            var r = this.state.clone();
                            try {
                                var s = this.tsParseTypeOrTypePredicateAnnotation(b.colon);
                                if (this.canInsertSemicolon() || !this.match(b.arrow)) {
                                    this.state = r;
                                    return undefined;
                                }
                                i.returnType = s;
                            } catch (e) {
                                if (e instanceof SyntaxError) {
                                    this.state = r;
                                } else {
                                    throw e;
                                }
                            }
                        }
                        return a(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), "parseArrow", this).call(this, i);
                    }
                }, {
                    key: "parseAssignableListItemTypes",
                    value: function e(t) {
                        if (this.eat(b.question)) {
                            if (t.type !== "Identifier") {
                                throw this.raise(t.start, "A binding pattern parameter cannot be optional in an implementation signature.");
                            }
                            t.optional = true;
                        }
                        var i = this.tsTryParseTypeAnnotation();
                        if (i) t.typeAnnotation = i;
                        this.resetEndLocation(t);
                        return t;
                    }
                }, {
                    key: "toAssignable",
                    value: function e(i, r, s) {
                        switch (i.type) {
                          case "TSTypeCastExpression":
                            return a(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), "toAssignable", this).call(this, this.typeCastToParameter(i), r, s);

                          case "TSParameterProperty":
                            return a(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), "toAssignable", this).call(this, i, r, s);

                          case "TSAsExpression":
                          case "TSNonNullExpression":
                          case "TSTypeAssertion":
                            i.expression = this.toAssignable(i.expression, r, s);
                            return i;

                          default:
                            return a(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), "toAssignable", this).call(this, i, r, s);
                        }
                    }
                }, {
                    key: "checkLVal",
                    value: function e(i) {
                        var r = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Q;
                        var s = arguments[2];
                        var n = arguments[3];
                        switch (i.type) {
                          case "TSTypeCastExpression":
                            return;

                          case "TSParameterProperty":
                            this.checkLVal(i.parameter, r, s, "parameter property");
                            return;

                          case "TSAsExpression":
                          case "TSNonNullExpression":
                          case "TSTypeAssertion":
                            this.checkLVal(i.expression, r, s, n);
                            return;

                          default:
                            a(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), "checkLVal", this).call(this, i, r, s, n);
                            return;
                        }
                    }
                }, {
                    key: "parseBindingAtom",
                    value: function e() {
                        switch (this.state.type) {
                          case b._this:
                            return this.parseIdentifier(true);

                          default:
                            return a(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), "parseBindingAtom", this).call(this);
                        }
                    }
                }, {
                    key: "parseMaybeDecoratorArguments",
                    value: function e(i) {
                        if (this.isRelational("<")) {
                            var r = this.tsParseTypeArguments();
                            if (this.match(b.parenL)) {
                                var s = a(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), "parseMaybeDecoratorArguments", this).call(this, i);
                                s.typeParameters = r;
                                return s;
                            }
                            this.unexpected(this.state.start, b.parenL);
                        }
                        return a(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), "parseMaybeDecoratorArguments", this).call(this, i);
                    }
                }, {
                    key: "isClassMethod",
                    value: function e() {
                        return this.isRelational("<") || a(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), "isClassMethod", this).call(this);
                    }
                }, {
                    key: "isClassProperty",
                    value: function e() {
                        return this.match(b.bang) || this.match(b.colon) || a(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), "isClassProperty", this).call(this);
                    }
                }, {
                    key: "parseMaybeDefault",
                    value: function e() {
                        var i;
                        for (var r = arguments.length, s = Array(r), n = 0; n < r; n++) {
                            s[n] = arguments[n];
                        }
                        var o = (i = a(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), "parseMaybeDefault", this)).call.apply(i, [ this ].concat(s));
                        if (o.type === "AssignmentPattern" && o.typeAnnotation && o.right.start < o.typeAnnotation.start) {
                            this.raise(o.typeAnnotation.start, "Type annotations must come before default assignments, " + "e.g. instead of `age = 25: number` use `age: number = 25`");
                        }
                        return o;
                    }
                }, {
                    key: "getTokenFromCode",
                    value: function e(i) {
                        if (this.state.inType && (i === 62 || i === 60)) {
                            return this.finishOp(b.relational, 1);
                        } else {
                            return a(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), "getTokenFromCode", this).call(this, i);
                        }
                    }
                }, {
                    key: "toAssignableList",
                    value: function e(i, r, s) {
                        for (var n = 0; n < i.length; n++) {
                            var o = i[n];
                            if (!o) continue;
                            switch (o.type) {
                              case "TSTypeCastExpression":
                                i[n] = this.typeCastToParameter(o);
                                break;

                              case "TSAsExpression":
                              case "TSTypeAssertion":
                                this.raise(o.start, "Unexpected type cast in parameter position.");
                                break;
                            }
                        }
                        return a(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), "toAssignableList", this).call(this, i, r, s);
                    }
                }, {
                    key: "typeCastToParameter",
                    value: function e(t) {
                        t.expression.typeAnnotation = t.typeAnnotation;
                        this.resetEndLocation(t.expression, t.typeAnnotation.end, t.typeAnnotation.loc.end);
                        return t.expression;
                    }
                }, {
                    key: "toReferencedList",
                    value: function e(t, i) {
                        for (var r = 0; r < t.length; r++) {
                            var s = t[r];
                            if (s && s._exprListItem && s.type === "TsTypeCastExpression") {
                                this.raise(s.start, "Did not expect a type annotation here.");
                            }
                        }
                        return t;
                    }
                }, {
                    key: "shouldParseArrow",
                    value: function e() {
                        return this.match(b.colon) || a(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), "shouldParseArrow", this).call(this);
                    }
                }, {
                    key: "shouldParseAsyncArrow",
                    value: function e() {
                        return this.match(b.colon) || a(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), "shouldParseAsyncArrow", this).call(this);
                    }
                }, {
                    key: "canHaveLeadingDecorator",
                    value: function e() {
                        return a(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), "canHaveLeadingDecorator", this).call(this) || this.isAbstractClass();
                    }
                }, {
                    key: "jsxParseOpeningElementAfterName",
                    value: function e(i) {
                        var r = this;
                        if (this.isRelational("<")) {
                            var s = this.tsTryParseAndCatch(function() {
                                return r.tsParseTypeArguments();
                            });
                            if (s) i.typeParameters = s;
                        }
                        return a(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), "jsxParseOpeningElementAfterName", this).call(this, i);
                    }
                }, {
                    key: "getGetterSetterExpectedParamCount",
                    value: function e(i) {
                        var r = a(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), "getGetterSetterExpectedParamCount", this).call(this, i);
                        var s = i.params[0];
                        var n = s && s.type === "Identifier" && s.name === "this";
                        return n ? r + 1 : r;
                    }
                } ]);
                return t;
            }(t);
        };
        b.placeholder = new y("%%", {
            startsExpr: true
        });
        var Ye = function e(t) {
            return function(e) {
                l(t, e);
                function t() {
                    u(this, t);
                    return o(this, (t.__proto__ || Object.getPrototypeOf(t)).apply(this, arguments));
                }
                s(t, [ {
                    key: "parsePlaceholder",
                    value: function e(i) {
                        if (this.match(b.placeholder)) {
                            var r = this.startNode();
                            this.next();
                            this.assertNoSpace("Unexpected space in placeholder.");
                            r.name = a(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), "parseIdentifier", this).call(this, true);
                            this.assertNoSpace("Unexpected space in placeholder.");
                            this.expect(b.placeholder);
                            return this.finishPlaceholder(r, i);
                        }
                    }
                }, {
                    key: "finishPlaceholder",
                    value: function e(t, i) {
                        var r = !!(t.expectedNode && t.type === "Placeholder");
                        t.expectedNode = i;
                        return r ? t : this.finishNode(t, "Placeholder");
                    }
                }, {
                    key: "getTokenFromCode",
                    value: function e(i) {
                        if (i === 37 && this.input.charCodeAt(this.state.pos + 1) === 37) {
                            return this.finishOp(b.placeholder, 2);
                        }
                        return a(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), "getTokenFromCode", this).apply(this, arguments);
                    }
                }, {
                    key: "parseExprAtom",
                    value: function e() {
                        return this.parsePlaceholder("Expression") || a(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), "parseExprAtom", this).apply(this, arguments);
                    }
                }, {
                    key: "parseIdentifier",
                    value: function e() {
                        return this.parsePlaceholder("Identifier") || a(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), "parseIdentifier", this).apply(this, arguments);
                    }
                }, {
                    key: "checkReservedWord",
                    value: function e(i) {
                        if (i !== undefined) a(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), "checkReservedWord", this).apply(this, arguments);
                    }
                }, {
                    key: "parseBindingAtom",
                    value: function e() {
                        return this.parsePlaceholder("Pattern") || a(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), "parseBindingAtom", this).apply(this, arguments);
                    }
                }, {
                    key: "checkLVal",
                    value: function e(i) {
                        if (i.type !== "Placeholder") a(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), "checkLVal", this).apply(this, arguments);
                    }
                }, {
                    key: "toAssignable",
                    value: function e(i) {
                        if (i && i.type === "Placeholder" && i.expectedNode === "Expression") {
                            i.expectedNode = "Pattern";
                            return i;
                        }
                        return a(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), "toAssignable", this).apply(this, arguments);
                    }
                }, {
                    key: "verifyBreakContinue",
                    value: function e(i) {
                        if (i.label && i.label.type === "Placeholder") return;
                        a(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), "verifyBreakContinue", this).apply(this, arguments);
                    }
                }, {
                    key: "parseExpressionStatement",
                    value: function e(i, r) {
                        if (r.type !== "Placeholder" || r.extra && r.extra.parenthesized) {
                            return a(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), "parseExpressionStatement", this).apply(this, arguments);
                        }
                        if (this.match(b.colon)) {
                            var s = i;
                            s.label = this.finishPlaceholder(r, "Identifier");
                            this.next();
                            s.body = this.parseStatement("label");
                            return this.finishNode(s, "LabeledStatement");
                        }
                        this.semicolon();
                        i.name = r.name;
                        return this.finishPlaceholder(i, "Statement");
                    }
                }, {
                    key: "parseBlock",
                    value: function e() {
                        return this.parsePlaceholder("BlockStatement") || a(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), "parseBlock", this).apply(this, arguments);
                    }
                }, {
                    key: "parseFunctionId",
                    value: function e() {
                        return this.parsePlaceholder("Identifier") || a(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), "parseFunctionId", this).apply(this, arguments);
                    }
                }, {
                    key: "parseClass",
                    value: function e(t, i, r) {
                        var s = i ? "ClassDeclaration" : "ClassExpression";
                        this.next();
                        this.takeDecorators(t);
                        var a = this.parsePlaceholder("Identifier");
                        if (a) {
                            if (this.match(b._extends) || this.match(b.placeholder) || this.match(b.braceL)) {
                                t.id = a;
                            } else if (r || !i) {
                                t.id = null;
                                t.body = this.finishPlaceholder(a, "ClassBody");
                                return this.finishNode(t, s);
                            } else {
                                this.unexpected(null, "A class name is required");
                            }
                        } else {
                            this.parseClassId(t, i, r);
                        }
                        this.parseClassSuper(t);
                        t.body = this.parsePlaceholder("ClassBody") || this.parseClassBody(!!t.superClass);
                        return this.finishNode(t, s);
                    }
                }, {
                    key: "parseExport",
                    value: function e(i) {
                        var r = this.parsePlaceholder("Identifier");
                        if (!r) return a(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), "parseExport", this).apply(this, arguments);
                        if (!this.isContextual("from") && !this.match(b.comma)) {
                            i.specifiers = [];
                            i.source = null;
                            i.declaration = this.finishPlaceholder(r, "Declaration");
                            return this.finishNode(i, "ExportNamedDeclaration");
                        }
                        this.expectPlugin("exportDefaultFrom");
                        var s = this.startNode();
                        s.exported = r;
                        i.specifiers = [ this.finishNode(s, "ExportDefaultSpecifier") ];
                        return a(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), "parseExport", this).call(this, i);
                    }
                }, {
                    key: "maybeParseExportDefaultSpecifier",
                    value: function e(i) {
                        if (i.specifiers && i.specifiers.length > 0) {
                            return true;
                        }
                        return a(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), "maybeParseExportDefaultSpecifier", this).apply(this, arguments);
                    }
                }, {
                    key: "checkExport",
                    value: function e(i) {
                        var r = i.specifiers;
                        if (r && r.length) {
                            i.specifiers = r.filter(function(e) {
                                return e.exported.type === "Placeholder";
                            });
                        }
                        a(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), "checkExport", this).call(this, i);
                        i.specifiers = r;
                    }
                }, {
                    key: "parseImport",
                    value: function e(i) {
                        var r = this.parsePlaceholder("Identifier");
                        if (!r) return a(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), "parseImport", this).apply(this, arguments);
                        i.specifiers = [];
                        if (!this.isContextual("from") && !this.match(b.comma)) {
                            i.source = this.finishPlaceholder(r, "StringLiteral");
                            this.semicolon();
                            return this.finishNode(i, "ImportDeclaration");
                        }
                        var s = this.startNodeAtNode(r);
                        s.local = r;
                        this.finishNode(s, "ImportDefaultSpecifier");
                        i.specifiers.push(s);
                        if (this.eat(b.comma)) {
                            var n = this.maybeParseStarImportSpecifier(i);
                            if (!n) this.parseNamedImportSpecifiers(i);
                        }
                        this.expectContextual("from");
                        i.source = this.parseImportSource();
                        this.semicolon();
                        return this.finishNode(i, "ImportDeclaration");
                    }
                }, {
                    key: "parseImportSource",
                    value: function e() {
                        return this.parsePlaceholder("StringLiteral") || a(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), "parseImportSource", this).apply(this, arguments);
                    }
                } ]);
                return t;
            }(t);
        };
        function Qe(e, t) {
            return e.some(function(e) {
                if (Array.isArray(e)) {
                    return e[0] === t;
                } else {
                    return e === t;
                }
            });
        }
        function $e(e, t, i) {
            var r = e.find(function(e) {
                if (Array.isArray(e)) {
                    return e[0] === t;
                } else {
                    return e === t;
                }
            });
            if (r && Array.isArray(r)) {
                return r[1][i];
            }
            return null;
        }
        var Ze = [ "minimal", "smart" ];
        function et(e) {
            if (Qe(e, "decorators")) {
                if (Qe(e, "decorators-legacy")) {
                    throw new Error("Cannot use the decorators and decorators-legacy plugin together");
                }
                var t = $e(e, "decorators", "decoratorsBeforeExport");
                if (t == null) {
                    throw new Error("The 'decorators' plugin requires a 'decoratorsBeforeExport' option," + " whose value must be a boolean. If you are migrating from" + " Babylon/Babel 6 or want to use the old decorators proposal, you" + " should use the 'decorators-legacy' plugin instead of 'decorators'.");
                } else if (typeof t !== "boolean") {
                    throw new Error("'decoratorsBeforeExport' must be a boolean.");
                }
            }
            if (Qe(e, "flow") && Qe(e, "typescript")) {
                throw new Error("Cannot combine flow and typescript plugins.");
            }
            if (Qe(e, "pipelineOperator") && !Ze.includes($e(e, "pipelineOperator", "proposal"))) {
                throw new Error("'pipelineOperator' requires 'proposal' option whose value should be one of: " + Ze.map(function(e) {
                    return "'" + e + "'";
                }).join(", "));
            }
        }
        var tt = {
            estree: ie,
            jsx: Ue,
            flow: Le,
            typescript: He,
            placeholders: Ye
        };
        var it = Object.keys(tt);
        var rt = {
            sourceType: "script",
            sourceFilename: undefined,
            startLine: 1,
            allowAwaitOutsideFunction: false,
            allowReturnOutsideFunction: false,
            allowImportExportEverywhere: false,
            allowSuperOutsideMethod: false,
            plugins: [],
            strictMode: null,
            ranges: false,
            tokens: false,
            createParenthesizedExpressions: false
        };
        function st(e) {
            var t = {};
            for (var i = 0, r = Object.keys(rt); i < r.length; i++) {
                var s = r[i];
                t[s] = e && e[s] != null ? e[s] : rt[s];
            }
            return t;
        }
        var at = function e(t, i) {
            u(this, e);
            this.line = t;
            this.column = i;
        };
        var nt = function e(t, i) {
            u(this, e);
            this.start = t;
            this.end = i;
        };
        function ot(e, t) {
            var i = 1;
            var r = 0;
            var s = void 0;
            se.lastIndex = 0;
            while ((s = se.exec(e)) && s.index < t) {
                i++;
                r = se.lastIndex;
            }
            return new at(i, t - r);
        }
        var lt = function() {
            function e() {
                u(this, e);
                this.sawUnambiguousESM = false;
            }
            s(e, [ {
                key: "hasPlugin",
                value: function e(t) {
                    return this.plugins.has(t);
                }
            }, {
                key: "getPluginOption",
                value: function e(t, i) {
                    if (this.hasPlugin(t)) return this.plugins.get(t)[i];
                }
            } ]);
            return e;
        }();
        function ut(e) {
            return e[e.length - 1];
        }
        var ct = function(e) {
            l(t, e);
            function t() {
                u(this, t);
                return o(this, (t.__proto__ || Object.getPrototypeOf(t)).apply(this, arguments));
            }
            s(t, [ {
                key: "addComment",
                value: function e(t) {
                    if (this.filename) t.loc.filename = this.filename;
                    this.state.trailingComments.push(t);
                    this.state.leadingComments.push(t);
                }
            }, {
                key: "processComment",
                value: function e(t) {
                    if (t.type === "Program" && t.body.length > 0) return;
                    var i = this.state.commentStack;
                    var r = void 0, s = void 0, a = void 0, n = void 0, o = void 0;
                    if (this.state.trailingComments.length > 0) {
                        if (this.state.trailingComments[0].start >= t.end) {
                            a = this.state.trailingComments;
                            this.state.trailingComments = [];
                        } else {
                            this.state.trailingComments.length = 0;
                        }
                    } else if (i.length > 0) {
                        var l = ut(i);
                        if (l.trailingComments && l.trailingComments[0].start >= t.end) {
                            a = l.trailingComments;
                            delete l.trailingComments;
                        }
                    }
                    if (i.length > 0 && ut(i).start >= t.start) {
                        r = i.pop();
                    }
                    while (i.length > 0 && ut(i).start >= t.start) {
                        s = i.pop();
                    }
                    if (!s && r) s = r;
                    if (r && this.state.leadingComments.length > 0) {
                        var u = ut(this.state.leadingComments);
                        if (r.type === "ObjectProperty") {
                            if (u.start >= t.start) {
                                if (this.state.commentPreviousNode) {
                                    for (o = 0; o < this.state.leadingComments.length; o++) {
                                        if (this.state.leadingComments[o].end < this.state.commentPreviousNode.end) {
                                            this.state.leadingComments.splice(o, 1);
                                            o--;
                                        }
                                    }
                                    if (this.state.leadingComments.length > 0) {
                                        r.trailingComments = this.state.leadingComments;
                                        this.state.leadingComments = [];
                                    }
                                }
                            }
                        } else if (t.type === "CallExpression" && t.arguments && t.arguments.length) {
                            var c = ut(t.arguments);
                            if (c && u.start >= c.start && u.end <= t.end) {
                                if (this.state.commentPreviousNode) {
                                    for (o = 0; o < this.state.leadingComments.length; o++) {
                                        if (this.state.leadingComments[o].end < this.state.commentPreviousNode.end) {
                                            this.state.leadingComments.splice(o, 1);
                                            o--;
                                        }
                                    }
                                    if (this.state.leadingComments.length > 0) {
                                        c.trailingComments = this.state.leadingComments;
                                        this.state.leadingComments = [];
                                    }
                                }
                            }
                        }
                    }
                    if (s) {
                        if (s.leadingComments) {
                            if (s !== t && s.leadingComments.length > 0 && ut(s.leadingComments).end <= t.start) {
                                t.leadingComments = s.leadingComments;
                                delete s.leadingComments;
                            } else {
                                for (n = s.leadingComments.length - 2; n >= 0; --n) {
                                    if (s.leadingComments[n].end <= t.start) {
                                        t.leadingComments = s.leadingComments.splice(0, n + 1);
                                        break;
                                    }
                                }
                            }
                        }
                    } else if (this.state.leadingComments.length > 0) {
                        if (ut(this.state.leadingComments).end <= t.start) {
                            if (this.state.commentPreviousNode) {
                                for (o = 0; o < this.state.leadingComments.length; o++) {
                                    if (this.state.leadingComments[o].end < this.state.commentPreviousNode.end) {
                                        this.state.leadingComments.splice(o, 1);
                                        o--;
                                    }
                                }
                            }
                            if (this.state.leadingComments.length > 0) {
                                t.leadingComments = this.state.leadingComments;
                                this.state.leadingComments = [];
                            }
                        } else {
                            for (n = 0; n < this.state.leadingComments.length; n++) {
                                if (this.state.leadingComments[n].end > t.start) {
                                    break;
                                }
                            }
                            var h = this.state.leadingComments.slice(0, n);
                            if (h.length) {
                                t.leadingComments = h;
                            }
                            a = this.state.leadingComments.slice(n);
                            if (a.length === 0) {
                                a = null;
                            }
                        }
                    }
                    this.state.commentPreviousNode = t;
                    if (a) {
                        if (a.length && a[0].start >= t.start && ut(a).end <= t.end) {
                            t.innerComments = a;
                        } else {
                            t.trailingComments = a;
                        }
                    }
                    i.push(t);
                }
            } ]);
            return t;
        }(lt);
        var ht = function(e) {
            l(t, e);
            function t() {
                u(this, t);
                return o(this, (t.__proto__ || Object.getPrototypeOf(t)).apply(this, arguments));
            }
            s(t, [ {
                key: "getLocationForPosition",
                value: function e(t) {
                    var i = void 0;
                    if (t === this.state.start) i = this.state.startLoc; else if (t === this.state.lastTokStart) i = this.state.lastTokStartLoc; else if (t === this.state.end) i = this.state.endLoc; else if (t === this.state.lastTokEnd) i = this.state.lastTokEndLoc; else i = ot(this.input, t);
                    return i;
                }
            }, {
                key: "raise",
                value: function e(t, i) {
                    var r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {}, s = r.missingPluginNames, a = r.code;
                    var n = this.getLocationForPosition(t);
                    i += " (" + n.line + ":" + n.column + ")";
                    var o = new SyntaxError(i);
                    o.pos = t;
                    o.loc = n;
                    if (s) {
                        o.missingPlugin = s;
                    }
                    if (a !== undefined) {
                        o.code = a;
                    }
                    throw o;
                }
            } ]);
            return t;
        }(ct);
        var pt = function() {
            function e() {
                u(this, e);
                this.potentialArrowAt = -1;
                this.noArrowAt = [];
                this.noArrowParamsConversionAt = [];
                this.commaAfterSpreadAt = -1;
                this.inParameters = false;
                this.maybeInArrowParameters = false;
                this.inPipeline = false;
                this.inType = false;
                this.noAnonFunctionType = false;
                this.inPropertyName = false;
                this.inClassProperty = false;
                this.hasFlowComment = false;
                this.isIterator = false;
                this.topicContext = {
                    maxNumOfResolvableTopics: 0,
                    maxTopicIndex: null
                };
                this.classLevel = 0;
                this.labels = [];
                this.decoratorStack = [ [] ];
                this.yieldPos = 0;
                this.awaitPos = 0;
                this.tokens = [];
                this.comments = [];
                this.trailingComments = [];
                this.leadingComments = [];
                this.commentStack = [];
                this.commentPreviousNode = null;
                this.pos = 0;
                this.lineStart = 0;
                this.type = b.eof;
                this.value = null;
                this.start = 0;
                this.end = 0;
                this.lastTokEndLoc = null;
                this.lastTokStartLoc = null;
                this.lastTokStart = 0;
                this.lastTokEnd = 0;
                this.context = [ ue.braceStatement ];
                this.exprAllowed = true;
                this.containsEsc = false;
                this.containsOctal = false;
                this.octalPosition = null;
                this.exportedIdentifiers = [];
                this.invalidTemplateEscapePosition = null;
            }
            s(e, [ {
                key: "init",
                value: function e(t) {
                    this.strict = t.strictMode === false ? false : t.sourceType === "module";
                    this.curLine = t.startLine;
                    this.startLoc = this.endLoc = this.curPosition();
                }
            }, {
                key: "curPosition",
                value: function e() {
                    return new at(this.curLine, this.pos - this.lineStart);
                }
            }, {
                key: "clone",
                value: function t(i) {
                    var r = new e();
                    var s = Object.keys(this);
                    for (var a = 0, n = s.length; a < n; a++) {
                        var o = s[a];
                        var l = this[o];
                        if (!i && Array.isArray(l)) {
                            l = l.slice();
                        }
                        r[o] = l;
                    }
                    return r;
                }
            } ]);
            return e;
        }();
        var ft = function e(t) {
            return t >= 48 && t <= 57;
        };
        var dt = new Set([ "g", "m", "s", "i", "y", "u" ]);
        var mt = {
            decBinOct: [ 46, 66, 69, 79, 95, 98, 101, 111 ],
            hex: [ 46, 88, 95, 120 ]
        };
        var yt = {};
        yt.bin = [ 48, 49 ];
        yt.oct = [].concat(n(yt.bin), [ 50, 51, 52, 53, 54, 55 ]);
        yt.dec = [].concat(n(yt.oct), [ 56, 57 ]);
        yt.hex = [].concat(n(yt.dec), [ 65, 66, 67, 68, 69, 70, 97, 98, 99, 100, 101, 102 ]);
        var vt = function e(t) {
            u(this, e);
            this.type = t.type;
            this.value = t.value;
            this.start = t.start;
            this.end = t.end;
            this.loc = new nt(t.startLoc, t.endLoc);
        };
        var xt = function(e) {
            l(t, e);
            function t(e, i) {
                u(this, t);
                var r = o(this, (t.__proto__ || Object.getPrototypeOf(t)).call(this));
                r.state = new pt();
                r.state.init(e);
                r.input = i;
                r.length = i.length;
                r.isLookahead = false;
                return r;
            }
            s(t, [ {
                key: "next",
                value: function e() {
                    if (this.options.tokens && !this.isLookahead) {
                        this.state.tokens.push(new vt(this.state));
                    }
                    this.state.lastTokEnd = this.state.end;
                    this.state.lastTokStart = this.state.start;
                    this.state.lastTokEndLoc = this.state.endLoc;
                    this.state.lastTokStartLoc = this.state.startLoc;
                    this.nextToken();
                }
            }, {
                key: "eat",
                value: function e(t) {
                    if (this.match(t)) {
                        this.next();
                        return true;
                    } else {
                        return false;
                    }
                }
            }, {
                key: "match",
                value: function e(t) {
                    return this.state.type === t;
                }
            }, {
                key: "lookahead",
                value: function e() {
                    var t = this.state;
                    this.state = t.clone(true);
                    this.isLookahead = true;
                    this.next();
                    this.isLookahead = false;
                    var i = this.state;
                    this.state = t;
                    return i;
                }
            }, {
                key: "setStrict",
                value: function e(t) {
                    this.state.strict = t;
                    if (!this.match(b.num) && !this.match(b.string)) return;
                    this.state.pos = this.state.start;
                    while (this.state.pos < this.state.lineStart) {
                        this.state.lineStart = this.input.lastIndexOf("\n", this.state.lineStart - 2) + 1;
                        --this.state.curLine;
                    }
                    this.nextToken();
                }
            }, {
                key: "curContext",
                value: function e() {
                    return this.state.context[this.state.context.length - 1];
                }
            }, {
                key: "nextToken",
                value: function e() {
                    var t = this.curContext();
                    if (!t || !t.preserveSpace) this.skipSpace();
                    this.state.containsOctal = false;
                    this.state.octalPosition = null;
                    this.state.start = this.state.pos;
                    this.state.startLoc = this.state.curPosition();
                    if (this.state.pos >= this.length) {
                        this.finishToken(b.eof);
                        return;
                    }
                    if (t.override) {
                        t.override(this);
                    } else {
                        this.getTokenFromCode(this.input.codePointAt(this.state.pos));
                    }
                }
            }, {
                key: "pushComment",
                value: function e(t, i, r, s, a, n) {
                    var o = {
                        type: t ? "CommentBlock" : "CommentLine",
                        value: i,
                        start: r,
                        end: s,
                        loc: new nt(a, n)
                    };
                    if (this.options.tokens) this.state.tokens.push(o);
                    this.state.comments.push(o);
                    this.addComment(o);
                }
            }, {
                key: "skipBlockComment",
                value: function e() {
                    var t = this.state.curPosition();
                    var i = this.state.pos;
                    var r = this.input.indexOf("*/", this.state.pos += 2);
                    if (r === -1) this.raise(this.state.pos - 2, "Unterminated comment");
                    this.state.pos = r + 2;
                    se.lastIndex = i;
                    var s = void 0;
                    while ((s = se.exec(this.input)) && s.index < this.state.pos) {
                        ++this.state.curLine;
                        this.state.lineStart = s.index + s[0].length;
                    }
                    if (this.isLookahead) return;
                    this.pushComment(true, this.input.slice(i + 2, r), i, this.state.pos, t, this.state.curPosition());
                }
            }, {
                key: "skipLineComment",
                value: function e(t) {
                    var i = this.state.pos;
                    var r = this.state.curPosition();
                    var s = this.input.charCodeAt(this.state.pos += t);
                    if (this.state.pos < this.length) {
                        while (s !== 10 && s !== 13 && s !== 8232 && s !== 8233 && ++this.state.pos < this.length) {
                            s = this.input.charCodeAt(this.state.pos);
                        }
                    }
                    if (this.isLookahead) return;
                    this.pushComment(false, this.input.slice(i + t, this.state.pos), i, this.state.pos, r, this.state.curPosition());
                }
            }, {
                key: "skipSpace",
                value: function e() {
                    e: while (this.state.pos < this.length) {
                        var t = this.input.charCodeAt(this.state.pos);
                        switch (t) {
                          case 32:
                          case 160:
                          case 9:
                            ++this.state.pos;
                            break;

                          case 13:
                            if (this.input.charCodeAt(this.state.pos + 1) === 10) {
                                ++this.state.pos;
                            }

                          case 10:
                          case 8232:
                          case 8233:
                            ++this.state.pos;
                            ++this.state.curLine;
                            this.state.lineStart = this.state.pos;
                            break;

                          case 47:
                            switch (this.input.charCodeAt(this.state.pos + 1)) {
                              case 42:
                                this.skipBlockComment();
                                break;

                              case 47:
                                this.skipLineComment(2);
                                break;

                              default:
                                break e;
                            }
                            break;

                          default:
                            if (oe(t)) {
                                ++this.state.pos;
                            } else {
                                break e;
                            }
                        }
                    }
                }
            }, {
                key: "finishToken",
                value: function e(t, i) {
                    this.state.end = this.state.pos;
                    this.state.endLoc = this.state.curPosition();
                    var r = this.state.type;
                    this.state.type = t;
                    this.state.value = i;
                    if (!this.isLookahead) this.updateContext(r);
                }
            }, {
                key: "readToken_numberSign",
                value: function e() {
                    if (this.state.pos === 0 && this.readToken_interpreter()) {
                        return;
                    }
                    var t = this.state.pos + 1;
                    var i = this.input.charCodeAt(t);
                    if (i >= 48 && i <= 57) {
                        this.raise(this.state.pos, "Unexpected digit after hash token");
                    }
                    if ((this.hasPlugin("classPrivateProperties") || this.hasPlugin("classPrivateMethods")) && this.state.classLevel > 0) {
                        ++this.state.pos;
                        this.finishToken(b.hash);
                        return;
                    } else if (this.getPluginOption("pipelineOperator", "proposal") === "smart") {
                        this.finishOp(b.hash, 1);
                    } else {
                        this.raise(this.state.pos, "Unexpected character '#'");
                    }
                }
            }, {
                key: "readToken_dot",
                value: function e() {
                    var t = this.input.charCodeAt(this.state.pos + 1);
                    if (t >= 48 && t <= 57) {
                        this.readNumber(true);
                        return;
                    }
                    var i = this.input.charCodeAt(this.state.pos + 2);
                    if (t === 46 && i === 46) {
                        this.state.pos += 3;
                        this.finishToken(b.ellipsis);
                    } else {
                        ++this.state.pos;
                        this.finishToken(b.dot);
                    }
                }
            }, {
                key: "readToken_slash",
                value: function e() {
                    if (this.state.exprAllowed && !this.state.inType) {
                        ++this.state.pos;
                        this.readRegexp();
                        return;
                    }
                    var t = this.input.charCodeAt(this.state.pos + 1);
                    if (t === 61) {
                        this.finishOp(b.assign, 2);
                    } else {
                        this.finishOp(b.slash, 1);
                    }
                }
            }, {
                key: "readToken_interpreter",
                value: function e() {
                    if (this.state.pos !== 0 || this.length < 2) return false;
                    var t = this.state.pos;
                    this.state.pos += 1;
                    var i = this.input.charCodeAt(this.state.pos);
                    if (i !== 33) return false;
                    while (i !== 10 && i !== 13 && i !== 8232 && i !== 8233 && ++this.state.pos < this.length) {
                        i = this.input.charCodeAt(this.state.pos);
                    }
                    var r = this.input.slice(t + 2, this.state.pos);
                    this.finishToken(b.interpreterDirective, r);
                    return true;
                }
            }, {
                key: "readToken_mult_modulo",
                value: function e(t) {
                    var i = t === 42 ? b.star : b.modulo;
                    var r = 1;
                    var s = this.input.charCodeAt(this.state.pos + 1);
                    var a = this.state.exprAllowed;
                    if (t === 42 && s === 42) {
                        r++;
                        s = this.input.charCodeAt(this.state.pos + 2);
                        i = b.exponent;
                    }
                    if (s === 61 && !a) {
                        r++;
                        i = b.assign;
                    }
                    this.finishOp(i, r);
                }
            }, {
                key: "readToken_pipe_amp",
                value: function e(t) {
                    var i = this.input.charCodeAt(this.state.pos + 1);
                    if (i === t) {
                        if (this.input.charCodeAt(this.state.pos + 2) === 61) {
                            this.finishOp(b.assign, 3);
                        } else {
                            this.finishOp(t === 124 ? b.logicalOR : b.logicalAND, 2);
                        }
                        return;
                    }
                    if (t === 124) {
                        if (i === 62) {
                            this.finishOp(b.pipeline, 2);
                            return;
                        }
                    }
                    if (i === 61) {
                        this.finishOp(b.assign, 2);
                        return;
                    }
                    this.finishOp(t === 124 ? b.bitwiseOR : b.bitwiseAND, 1);
                }
            }, {
                key: "readToken_caret",
                value: function e() {
                    var t = this.input.charCodeAt(this.state.pos + 1);
                    if (t === 61) {
                        this.finishOp(b.assign, 2);
                    } else {
                        this.finishOp(b.bitwiseXOR, 1);
                    }
                }
            }, {
                key: "readToken_plus_min",
                value: function e(t) {
                    var i = this.input.charCodeAt(this.state.pos + 1);
                    if (i === t) {
                        if (i === 45 && !this.inModule && this.input.charCodeAt(this.state.pos + 2) === 62 && (this.state.lastTokEnd === 0 || re.test(this.input.slice(this.state.lastTokEnd, this.state.pos)))) {
                            this.skipLineComment(3);
                            this.skipSpace();
                            this.nextToken();
                            return;
                        }
                        this.finishOp(b.incDec, 2);
                        return;
                    }
                    if (i === 61) {
                        this.finishOp(b.assign, 2);
                    } else {
                        this.finishOp(b.plusMin, 1);
                    }
                }
            }, {
                key: "readToken_lt_gt",
                value: function e(t) {
                    var i = this.input.charCodeAt(this.state.pos + 1);
                    var r = 1;
                    if (i === t) {
                        r = t === 62 && this.input.charCodeAt(this.state.pos + 2) === 62 ? 3 : 2;
                        if (this.input.charCodeAt(this.state.pos + r) === 61) {
                            this.finishOp(b.assign, r + 1);
                            return;
                        }
                        this.finishOp(b.bitShift, r);
                        return;
                    }
                    if (i === 33 && t === 60 && !this.inModule && this.input.charCodeAt(this.state.pos + 2) === 45 && this.input.charCodeAt(this.state.pos + 3) === 45) {
                        this.skipLineComment(4);
                        this.skipSpace();
                        this.nextToken();
                        return;
                    }
                    if (i === 61) {
                        r = 2;
                    }
                    this.finishOp(b.relational, r);
                }
            }, {
                key: "readToken_eq_excl",
                value: function e(t) {
                    var i = this.input.charCodeAt(this.state.pos + 1);
                    if (i === 61) {
                        this.finishOp(b.equality, this.input.charCodeAt(this.state.pos + 2) === 61 ? 3 : 2);
                        return;
                    }
                    if (t === 61 && i === 62) {
                        this.state.pos += 2;
                        this.finishToken(b.arrow);
                        return;
                    }
                    this.finishOp(t === 61 ? b.eq : b.bang, 1);
                }
            }, {
                key: "readToken_question",
                value: function e() {
                    var t = this.input.charCodeAt(this.state.pos + 1);
                    var i = this.input.charCodeAt(this.state.pos + 2);
                    if (t === 63 && !this.state.inType) {
                        if (i === 61) {
                            this.finishOp(b.assign, 3);
                        } else {
                            this.finishOp(b.nullishCoalescing, 2);
                        }
                    } else if (t === 46 && !(i >= 48 && i <= 57)) {
                        this.state.pos += 2;
                        this.finishToken(b.questionDot);
                    } else {
                        ++this.state.pos;
                        this.finishToken(b.question);
                    }
                }
            }, {
                key: "getTokenFromCode",
                value: function e(t) {
                    switch (t) {
                      case 46:
                        this.readToken_dot();
                        return;

                      case 40:
                        ++this.state.pos;
                        this.finishToken(b.parenL);
                        return;

                      case 41:
                        ++this.state.pos;
                        this.finishToken(b.parenR);
                        return;

                      case 59:
                        ++this.state.pos;
                        this.finishToken(b.semi);
                        return;

                      case 44:
                        ++this.state.pos;
                        this.finishToken(b.comma);
                        return;

                      case 91:
                        ++this.state.pos;
                        this.finishToken(b.bracketL);
                        return;

                      case 93:
                        ++this.state.pos;
                        this.finishToken(b.bracketR);
                        return;

                      case 123:
                        ++this.state.pos;
                        this.finishToken(b.braceL);
                        return;

                      case 125:
                        ++this.state.pos;
                        this.finishToken(b.braceR);
                        return;

                      case 58:
                        if (this.hasPlugin("functionBind") && this.input.charCodeAt(this.state.pos + 1) === 58) {
                            this.finishOp(b.doubleColon, 2);
                        } else {
                            ++this.state.pos;
                            this.finishToken(b.colon);
                        }
                        return;

                      case 63:
                        this.readToken_question();
                        return;

                      case 96:
                        ++this.state.pos;
                        this.finishToken(b.backQuote);
                        return;

                      case 48:
                        {
                            var i = this.input.charCodeAt(this.state.pos + 1);
                            if (i === 120 || i === 88) {
                                this.readRadixNumber(16);
                                return;
                            }
                            if (i === 111 || i === 79) {
                                this.readRadixNumber(8);
                                return;
                            }
                            if (i === 98 || i === 66) {
                                this.readRadixNumber(2);
                                return;
                            }
                        }

                      case 49:
                      case 50:
                      case 51:
                      case 52:
                      case 53:
                      case 54:
                      case 55:
                      case 56:
                      case 57:
                        this.readNumber(false);
                        return;

                      case 34:
                      case 39:
                        this.readString(t);
                        return;

                      case 47:
                        this.readToken_slash();
                        return;

                      case 37:
                      case 42:
                        this.readToken_mult_modulo(t);
                        return;

                      case 124:
                      case 38:
                        this.readToken_pipe_amp(t);
                        return;

                      case 94:
                        this.readToken_caret();
                        return;

                      case 43:
                      case 45:
                        this.readToken_plus_min(t);
                        return;

                      case 60:
                      case 62:
                        this.readToken_lt_gt(t);
                        return;

                      case 61:
                      case 33:
                        this.readToken_eq_excl(t);
                        return;

                      case 126:
                        this.finishOp(b.tilde, 1);
                        return;

                      case 64:
                        ++this.state.pos;
                        this.finishToken(b.at);
                        return;

                      case 35:
                        this.readToken_numberSign();
                        return;

                      case 92:
                        this.readWord();
                        return;

                      default:
                        if (Ae(t)) {
                            this.readWord();
                            return;
                        }
                    }
                    this.raise(this.state.pos, "Unexpected character '" + String.fromCodePoint(t) + "'");
                }
            }, {
                key: "finishOp",
                value: function e(t, i) {
                    var r = this.input.slice(this.state.pos, this.state.pos + i);
                    this.state.pos += i;
                    this.finishToken(t, r);
                }
            }, {
                key: "readRegexp",
                value: function e() {
                    var t = this.state.pos;
                    var i = void 0, r = void 0;
                    for (;;) {
                        if (this.state.pos >= this.length) {
                            this.raise(t, "Unterminated regular expression");
                        }
                        var s = this.input.charAt(this.state.pos);
                        if (re.test(s)) {
                            this.raise(t, "Unterminated regular expression");
                        }
                        if (i) {
                            i = false;
                        } else {
                            if (s === "[") {
                                r = true;
                            } else if (s === "]" && r) {
                                r = false;
                            } else if (s === "/" && !r) {
                                break;
                            }
                            i = s === "\\";
                        }
                        ++this.state.pos;
                    }
                    var a = this.input.slice(t, this.state.pos);
                    ++this.state.pos;
                    var n = "";
                    while (this.state.pos < this.length) {
                        var o = this.input[this.state.pos];
                        var l = this.input.codePointAt(this.state.pos);
                        if (dt.has(o)) {
                            if (n.indexOf(o) > -1) {
                                this.raise(this.state.pos + 1, "Duplicate regular expression flag");
                            }
                            ++this.state.pos;
                            n += o;
                        } else if (Te(l) || l === 92) {
                            this.raise(this.state.pos + 1, "Invalid regular expression flag");
                        } else {
                            break;
                        }
                    }
                    this.finishToken(b.regexp, {
                        pattern: a,
                        flags: n
                    });
                }
            }, {
                key: "readInt",
                value: function e(t, i) {
                    var r = this.state.pos;
                    var s = t === 16 ? mt.hex : mt.decBinOct;
                    var a = t === 16 ? yt.hex : t === 10 ? yt.dec : t === 8 ? yt.oct : yt.bin;
                    var n = 0;
                    for (var o = 0, l = i == null ? Infinity : i; o < l; ++o) {
                        var u = this.input.charCodeAt(this.state.pos);
                        var c = void 0;
                        if (this.hasPlugin("numericSeparator")) {
                            var h = this.input.charCodeAt(this.state.pos - 1);
                            var p = this.input.charCodeAt(this.state.pos + 1);
                            if (u === 95) {
                                if (a.indexOf(p) === -1) {
                                    this.raise(this.state.pos, "Invalid or unexpected token");
                                }
                                if (s.indexOf(h) > -1 || s.indexOf(p) > -1 || Number.isNaN(p)) {
                                    this.raise(this.state.pos, "Invalid or unexpected token");
                                }
                                ++this.state.pos;
                                continue;
                            }
                        }
                        if (u >= 97) {
                            c = u - 97 + 10;
                        } else if (u >= 65) {
                            c = u - 65 + 10;
                        } else if (ft(u)) {
                            c = u - 48;
                        } else {
                            c = Infinity;
                        }
                        if (c >= t) break;
                        ++this.state.pos;
                        n = n * t + c;
                    }
                    if (this.state.pos === r || i != null && this.state.pos - r !== i) {
                        return null;
                    }
                    return n;
                }
            }, {
                key: "readRadixNumber",
                value: function e(t) {
                    var i = this.state.pos;
                    var r = false;
                    this.state.pos += 2;
                    var s = this.readInt(t);
                    if (s == null) {
                        this.raise(this.state.start + 2, "Expected number in radix " + t);
                    }
                    if (this.hasPlugin("bigInt")) {
                        if (this.input.charCodeAt(this.state.pos) === 110) {
                            ++this.state.pos;
                            r = true;
                        }
                    }
                    if (Ae(this.input.codePointAt(this.state.pos))) {
                        this.raise(this.state.pos, "Identifier directly after number");
                    }
                    if (r) {
                        var a = this.input.slice(i, this.state.pos).replace(/[_n]/g, "");
                        this.finishToken(b.bigint, a);
                        return;
                    }
                    this.finishToken(b.num, s);
                }
            }, {
                key: "readNumber",
                value: function e(t) {
                    var i = this.state.pos;
                    var r = false;
                    var s = false;
                    if (!t && this.readInt(10) === null) {
                        this.raise(i, "Invalid number");
                    }
                    var a = this.state.pos - i >= 2 && this.input.charCodeAt(i) === 48;
                    if (a) {
                        if (this.state.strict) {
                            this.raise(i, "Legacy octal literals are not allowed in strict mode");
                        }
                        if (/[89]/.test(this.input.slice(i, this.state.pos))) {
                            a = false;
                        }
                    }
                    var n = this.input.charCodeAt(this.state.pos);
                    if (n === 46 && !a) {
                        ++this.state.pos;
                        this.readInt(10);
                        r = true;
                        n = this.input.charCodeAt(this.state.pos);
                    }
                    if ((n === 69 || n === 101) && !a) {
                        n = this.input.charCodeAt(++this.state.pos);
                        if (n === 43 || n === 45) {
                            ++this.state.pos;
                        }
                        if (this.readInt(10) === null) this.raise(i, "Invalid number");
                        r = true;
                        n = this.input.charCodeAt(this.state.pos);
                    }
                    if (this.hasPlugin("bigInt")) {
                        if (n === 110) {
                            if (r || a) this.raise(i, "Invalid BigIntLiteral");
                            ++this.state.pos;
                            s = true;
                        }
                    }
                    if (Ae(this.input.codePointAt(this.state.pos))) {
                        this.raise(this.state.pos, "Identifier directly after number");
                    }
                    var o = this.input.slice(i, this.state.pos).replace(/[_n]/g, "");
                    if (s) {
                        this.finishToken(b.bigint, o);
                        return;
                    }
                    var l = a ? parseInt(o, 8) : parseFloat(o);
                    this.finishToken(b.num, l);
                }
            }, {
                key: "readCodePoint",
                value: function e(t) {
                    var i = this.input.charCodeAt(this.state.pos);
                    var r = void 0;
                    if (i === 123) {
                        var s = ++this.state.pos;
                        r = this.readHexChar(this.input.indexOf("}", this.state.pos) - this.state.pos, t);
                        ++this.state.pos;
                        if (r === null) {
                            --this.state.invalidTemplateEscapePosition;
                        } else if (r > 1114111) {
                            if (t) {
                                this.raise(s, "Code point out of bounds");
                            } else {
                                this.state.invalidTemplateEscapePosition = s - 2;
                                return null;
                            }
                        }
                    } else {
                        r = this.readHexChar(4, t);
                    }
                    return r;
                }
            }, {
                key: "readString",
                value: function e(t) {
                    var i = "", r = ++this.state.pos;
                    for (;;) {
                        if (this.state.pos >= this.length) {
                            this.raise(this.state.start, "Unterminated string constant");
                        }
                        var s = this.input.charCodeAt(this.state.pos);
                        if (s === t) break;
                        if (s === 92) {
                            i += this.input.slice(r, this.state.pos);
                            i += this.readEscapedChar(false);
                            r = this.state.pos;
                        } else if (s === 8232 || s === 8233) {
                            ++this.state.pos;
                            ++this.state.curLine;
                        } else if (ae(s)) {
                            this.raise(this.state.start, "Unterminated string constant");
                        } else {
                            ++this.state.pos;
                        }
                    }
                    i += this.input.slice(r, this.state.pos++);
                    this.finishToken(b.string, i);
                }
            }, {
                key: "readTmplToken",
                value: function e() {
                    var t = "", i = this.state.pos, r = false;
                    for (;;) {
                        if (this.state.pos >= this.length) {
                            this.raise(this.state.start, "Unterminated template");
                        }
                        var s = this.input.charCodeAt(this.state.pos);
                        if (s === 96 || s === 36 && this.input.charCodeAt(this.state.pos + 1) === 123) {
                            if (this.state.pos === this.state.start && this.match(b.template)) {
                                if (s === 36) {
                                    this.state.pos += 2;
                                    this.finishToken(b.dollarBraceL);
                                    return;
                                } else {
                                    ++this.state.pos;
                                    this.finishToken(b.backQuote);
                                    return;
                                }
                            }
                            t += this.input.slice(i, this.state.pos);
                            this.finishToken(b.template, r ? null : t);
                            return;
                        }
                        if (s === 92) {
                            t += this.input.slice(i, this.state.pos);
                            var a = this.readEscapedChar(true);
                            if (a === null) {
                                r = true;
                            } else {
                                t += a;
                            }
                            i = this.state.pos;
                        } else if (ae(s)) {
                            t += this.input.slice(i, this.state.pos);
                            ++this.state.pos;
                            switch (s) {
                              case 13:
                                if (this.input.charCodeAt(this.state.pos) === 10) {
                                    ++this.state.pos;
                                }

                              case 10:
                                t += "\n";
                                break;

                              default:
                                t += String.fromCharCode(s);
                                break;
                            }
                            ++this.state.curLine;
                            this.state.lineStart = this.state.pos;
                            i = this.state.pos;
                        } else {
                            ++this.state.pos;
                        }
                    }
                }
            }, {
                key: "readEscapedChar",
                value: function e(t) {
                    var i = !t;
                    var r = this.input.charCodeAt(++this.state.pos);
                    ++this.state.pos;
                    switch (r) {
                      case 110:
                        return "\n";

                      case 114:
                        return "\r";

                      case 120:
                        {
                            var s = this.readHexChar(2, i);
                            return s === null ? null : String.fromCharCode(s);
                        }

                      case 117:
                        {
                            var a = this.readCodePoint(i);
                            return a === null ? null : String.fromCodePoint(a);
                        }

                      case 116:
                        return "\t";

                      case 98:
                        return "\b";

                      case 118:
                        return "\v";

                      case 102:
                        return "\f";

                      case 13:
                        if (this.input.charCodeAt(this.state.pos) === 10) {
                            ++this.state.pos;
                        }

                      case 10:
                        this.state.lineStart = this.state.pos;
                        ++this.state.curLine;

                      case 8232:
                      case 8233:
                        return "";

                      default:
                        if (r >= 48 && r <= 55) {
                            var n = this.state.pos - 1;
                            var o = this.input.substr(this.state.pos - 1, 3).match(/^[0-7]+/)[0];
                            var l = parseInt(o, 8);
                            if (l > 255) {
                                o = o.slice(0, -1);
                                l = parseInt(o, 8);
                            }
                            this.state.pos += o.length - 1;
                            var u = this.input.charCodeAt(this.state.pos);
                            if (o !== "0" || u === 56 || u === 57) {
                                if (t) {
                                    this.state.invalidTemplateEscapePosition = n;
                                    return null;
                                } else if (this.state.strict) {
                                    this.raise(n, "Octal literal in strict mode");
                                } else if (!this.state.containsOctal) {
                                    this.state.containsOctal = true;
                                    this.state.octalPosition = n;
                                }
                            }
                            return String.fromCharCode(l);
                        }
                        return String.fromCharCode(r);
                    }
                }
            }, {
                key: "readHexChar",
                value: function e(t, i) {
                    var r = this.state.pos;
                    var s = this.readInt(16, t);
                    if (s === null) {
                        if (i) {
                            this.raise(r, "Bad character escape sequence");
                        } else {
                            this.state.pos = r - 1;
                            this.state.invalidTemplateEscapePosition = r - 1;
                        }
                    }
                    return s;
                }
            }, {
                key: "readWord1",
                value: function e() {
                    var t = "";
                    this.state.containsEsc = false;
                    var i = this.state.pos;
                    var r = this.state.pos;
                    while (this.state.pos < this.length) {
                        var s = this.input.codePointAt(this.state.pos);
                        if (Te(s)) {
                            this.state.pos += s <= 65535 ? 1 : 2;
                        } else if (this.state.isIterator && s === 64) {
                            ++this.state.pos;
                        } else if (s === 92) {
                            this.state.containsEsc = true;
                            t += this.input.slice(r, this.state.pos);
                            var a = this.state.pos;
                            var n = this.state.pos === i ? Ae : Te;
                            if (this.input.charCodeAt(++this.state.pos) !== 117) {
                                this.raise(this.state.pos, "Expecting Unicode escape sequence \\uXXXX");
                            }
                            ++this.state.pos;
                            var o = this.readCodePoint(true);
                            if (!n(o, true)) {
                                this.raise(a, "Invalid Unicode escape");
                            }
                            t += String.fromCodePoint(o);
                            r = this.state.pos;
                        } else {
                            break;
                        }
                    }
                    return t + this.input.slice(r, this.state.pos);
                }
            }, {
                key: "isIterator",
                value: function e(t) {
                    return t === "@@iterator" || t === "@@asyncIterator";
                }
            }, {
                key: "readWord",
                value: function e() {
                    var t = this.readWord1();
                    var i = v.get(t) || b.name;
                    if (i.keyword && this.state.containsEsc) {
                        this.raise(this.state.pos, "Escape sequence in keyword " + t);
                    }
                    if (this.state.isIterator && (!this.isIterator(t) || !this.state.inType)) {
                        this.raise(this.state.pos, "Invalid identifier " + t);
                    }
                    this.finishToken(i, t);
                }
            }, {
                key: "braceIsBlock",
                value: function e(t) {
                    var i = this.curContext();
                    if (i === ue.functionExpression || i === ue.functionStatement) {
                        return true;
                    }
                    if (t === b.colon && (i === ue.braceStatement || i === ue.braceExpression)) {
                        return !i.isExpr;
                    }
                    if (t === b._return || t === b.name && this.state.exprAllowed) {
                        return re.test(this.input.slice(this.state.lastTokEnd, this.state.start));
                    }
                    if (t === b._else || t === b.semi || t === b.eof || t === b.parenR || t === b.arrow) {
                        return true;
                    }
                    if (t === b.braceL) {
                        return i === ue.braceStatement;
                    }
                    if (t === b._var || t === b._const || t === b.name) {
                        return false;
                    }
                    if (t === b.relational) {
                        return true;
                    }
                    return !this.state.exprAllowed;
                }
            }, {
                key: "updateContext",
                value: function e(t) {
                    var i = this.state.type;
                    var r = void 0;
                    if (i.keyword && (t === b.dot || t === b.questionDot)) {
                        this.state.exprAllowed = false;
                    } else if (r = i.updateContext) {
                        r.call(this, t);
                    } else {
                        this.state.exprAllowed = i.beforeExpr;
                    }
                }
            } ]);
            return t;
        }(ht);
        var gt = /^('|")((?:\\?.)*?)\1/;
        var bt = function(e) {
            l(t, e);
            function t() {
                u(this, t);
                return o(this, (t.__proto__ || Object.getPrototypeOf(t)).apply(this, arguments));
            }
            s(t, [ {
                key: "addExtra",
                value: function e(t, i, r) {
                    if (!t) return;
                    var s = t.extra = t.extra || {};
                    s[i] = r;
                }
            }, {
                key: "isRelational",
                value: function e(t) {
                    return this.match(b.relational) && this.state.value === t;
                }
            }, {
                key: "isLookaheadRelational",
                value: function e(t) {
                    var i = this.lookahead();
                    return i.type === b.relational && i.value === t;
                }
            }, {
                key: "expectRelational",
                value: function e(t) {
                    if (this.isRelational(t)) {
                        this.next();
                    } else {
                        this.unexpected(null, b.relational);
                    }
                }
            }, {
                key: "eatRelational",
                value: function e(t) {
                    if (this.isRelational(t)) {
                        this.next();
                        return true;
                    }
                    return false;
                }
            }, {
                key: "isContextual",
                value: function e(t) {
                    return this.match(b.name) && this.state.value === t && !this.state.containsEsc;
                }
            }, {
                key: "isLookaheadContextual",
                value: function e(t) {
                    var i = this.lookahead();
                    return i.type === b.name && i.value === t;
                }
            }, {
                key: "eatContextual",
                value: function e(t) {
                    return this.isContextual(t) && this.eat(b.name);
                }
            }, {
                key: "expectContextual",
                value: function e(t, i) {
                    if (!this.eatContextual(t)) this.unexpected(null, i);
                }
            }, {
                key: "canInsertSemicolon",
                value: function e() {
                    return this.match(b.eof) || this.match(b.braceR) || this.hasPrecedingLineBreak();
                }
            }, {
                key: "hasPrecedingLineBreak",
                value: function e() {
                    return re.test(this.input.slice(this.state.lastTokEnd, this.state.start));
                }
            }, {
                key: "isLineTerminator",
                value: function e() {
                    return this.eat(b.semi) || this.canInsertSemicolon();
                }
            }, {
                key: "semicolon",
                value: function e() {
                    if (!this.isLineTerminator()) this.unexpected(null, b.semi);
                }
            }, {
                key: "expect",
                value: function e(t, i) {
                    this.eat(t) || this.unexpected(i, t);
                }
            }, {
                key: "assertNoSpace",
                value: function e() {
                    var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "Unexpected space.";
                    if (this.state.start > this.state.lastTokEnd) {
                        this.raise(this.state.lastTokEnd, t);
                    }
                }
            }, {
                key: "unexpected",
                value: function e(t) {
                    var i = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "Unexpected token";
                    if (typeof i !== "string") {
                        i = 'Unexpected token, expected "' + i.label + '"';
                    }
                    throw this.raise(t != null ? t : this.state.start, i);
                }
            }, {
                key: "expectPlugin",
                value: function e(t, i) {
                    if (!this.hasPlugin(t)) {
                        throw this.raise(i != null ? i : this.state.start, "This experimental syntax requires enabling the parser plugin: '" + t + "'", {
                            missingPluginNames: [ t ]
                        });
                    }
                    return true;
                }
            }, {
                key: "expectOnePlugin",
                value: function e(t, i) {
                    var r = this;
                    if (!t.some(function(e) {
                        return r.hasPlugin(e);
                    })) {
                        throw this.raise(i != null ? i : this.state.start, "This experimental syntax requires enabling one of the following parser plugin(s): '" + t.join(", ") + "'", {
                            missingPluginNames: t
                        });
                    }
                }
            }, {
                key: "checkYieldAwaitInDefaultParams",
                value: function e() {
                    if (this.state.yieldPos && (!this.state.awaitPos || this.state.yieldPos < this.state.awaitPos)) {
                        this.raise(this.state.yieldPos, "Yield cannot be used as name inside a generator function");
                    }
                    if (this.state.awaitPos) {
                        this.raise(this.state.awaitPos, "Await cannot be used as name inside an async function");
                    }
                }
            }, {
                key: "strictDirective",
                value: function e(t) {
                    for (;;) {
                        ne.lastIndex = t;
                        t += ne.exec(this.input)[0].length;
                        var i = gt.exec(this.input.slice(t));
                        if (!i) break;
                        if (i[2] === "use strict") return true;
                        t += i[0].length;
                        ne.lastIndex = t;
                        t += ne.exec(this.input)[0].length;
                        if (this.input[t] === ";") {
                            t++;
                        }
                    }
                    return false;
                }
            } ]);
            return t;
        }(xt);
        var Et = function() {
            function e(t, i, r) {
                u(this, e);
                this.type = "";
                this.start = i;
                this.end = 0;
                this.loc = new nt(r);
                if (t && t.options.ranges) this.range = [ i, 0 ];
                if (t && t.filename) this.loc.filename = t.filename;
            }
            s(e, [ {
                key: "__clone",
                value: function t() {
                    var i = new e();
                    var r = Object.keys(this);
                    for (var s = 0, a = r.length; s < a; s++) {
                        var n = r[s];
                        if (n !== "leadingComments" && n !== "trailingComments" && n !== "innerComments") {
                            i[n] = this[n];
                        }
                    }
                    return i;
                }
            } ]);
            return e;
        }();
        var kt = function(e) {
            l(t, e);
            function t() {
                u(this, t);
                return o(this, (t.__proto__ || Object.getPrototypeOf(t)).apply(this, arguments));
            }
            s(t, [ {
                key: "startNode",
                value: function e() {
                    return new Et(this, this.state.start, this.state.startLoc);
                }
            }, {
                key: "startNodeAt",
                value: function e(t, i) {
                    return new Et(this, t, i);
                }
            }, {
                key: "startNodeAtNode",
                value: function e(t) {
                    return this.startNodeAt(t.start, t.loc.start);
                }
            }, {
                key: "finishNode",
                value: function e(t, i) {
                    return this.finishNodeAt(t, i, this.state.lastTokEnd, this.state.lastTokEndLoc);
                }
            }, {
                key: "finishNodeAt",
                value: function e(t, i, r, s) {
                    t.type = i;
                    t.end = r;
                    t.loc.end = s;
                    if (this.options.ranges) t.range[1] = r;
                    this.processComment(t);
                    return t;
                }
            }, {
                key: "resetStartLocation",
                value: function e(t, i, r) {
                    t.start = i;
                    t.loc.start = r;
                    if (this.options.ranges) t.range[0] = i;
                }
            }, {
                key: "resetEndLocation",
                value: function e(t) {
                    var i = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.state.lastTokEnd;
                    var r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.state.lastTokEndLoc;
                    t.end = i;
                    t.loc.end = r;
                    if (this.options.ranges) t.range[1] = i;
                }
            }, {
                key: "resetStartLocationFromNode",
                value: function e(t, i) {
                    this.resetStartLocation(t, i.start, i.loc.start);
                }
            } ]);
            return t;
        }(bt);
        var St = function(e) {
            l(t, e);
            function t() {
                u(this, t);
                return o(this, (t.__proto__ || Object.getPrototypeOf(t)).apply(this, arguments));
            }
            s(t, [ {
                key: "toAssignable",
                value: function e(t, i, r) {
                    if (t) {
                        switch (t.type) {
                          case "Identifier":
                          case "ObjectPattern":
                          case "ArrayPattern":
                          case "AssignmentPattern":
                            break;

                          case "ObjectExpression":
                            t.type = "ObjectPattern";
                            for (var s = 0, a = t.properties.length, n = a - 1; s < a; s++) {
                                var o = t.properties[s];
                                var l = s === n;
                                this.toAssignableObjectExpressionProp(o, i, l);
                            }
                            break;

                          case "ObjectProperty":
                            this.toAssignable(t.value, i, r);
                            break;

                          case "SpreadElement":
                            {
                                this.checkToRestConversion(t);
                                t.type = "RestElement";
                                var u = t.argument;
                                this.toAssignable(u, i, r);
                                break;
                            }

                          case "ArrayExpression":
                            t.type = "ArrayPattern";
                            this.toAssignableList(t.elements, i, r);
                            break;

                          case "AssignmentExpression":
                            if (t.operator === "=") {
                                t.type = "AssignmentPattern";
                                delete t.operator;
                            } else {
                                this.raise(t.left.end, "Only '=' operator can be used for specifying default value.");
                            }
                            break;

                          case "ParenthesizedExpression":
                            t.expression = this.toAssignable(t.expression, i, r);
                            break;

                          case "MemberExpression":
                            if (!i) break;

                          default:
                            {
                                var c = "Invalid left-hand side" + (r ? " in " + r : "expression");
                                this.raise(t.start, c);
                            }
                        }
                    }
                    return t;
                }
            }, {
                key: "toAssignableObjectExpressionProp",
                value: function e(t, i, r) {
                    if (t.type === "ObjectMethod") {
                        var s = t.kind === "get" || t.kind === "set" ? "Object pattern can't contain getter or setter" : "Object pattern can't contain methods";
                        this.raise(t.key.start, s);
                    } else if (t.type === "SpreadElement" && !r) {
                        this.raiseRestNotLast(t.start);
                    } else {
                        this.toAssignable(t, i, "object destructuring pattern");
                    }
                }
            }, {
                key: "toAssignableList",
                value: function e(t, i, r) {
                    var s = t.length;
                    if (s) {
                        var a = t[s - 1];
                        if (a && a.type === "RestElement") {
                            --s;
                        } else if (a && a.type === "SpreadElement") {
                            a.type = "RestElement";
                            var n = a.argument;
                            this.toAssignable(n, i, r);
                            if (n.type !== "Identifier" && n.type !== "MemberExpression" && n.type !== "ArrayPattern" && n.type !== "ObjectPattern") {
                                this.unexpected(n.start);
                            }
                            --s;
                        }
                    }
                    for (var o = 0; o < s; o++) {
                        var l = t[o];
                        if (l) {
                            this.toAssignable(l, i, r);
                            if (l.type === "RestElement") {
                                this.raiseRestNotLast(l.start);
                            }
                        }
                    }
                    return t;
                }
            }, {
                key: "toReferencedList",
                value: function e(t, i) {
                    return t;
                }
            }, {
                key: "toReferencedListDeep",
                value: function e(t, i) {
                    this.toReferencedList(t, i);
                    for (var r = 0; r < t.length; r++) {
                        var s = t[r];
                        if (s && s.type === "ArrayExpression") {
                            this.toReferencedListDeep(s.elements);
                        }
                    }
                    return t;
                }
            }, {
                key: "parseSpread",
                value: function e(t, i) {
                    var r = this.startNode();
                    this.next();
                    r.argument = this.parseMaybeAssign(false, t, undefined, i);
                    if (this.state.commaAfterSpreadAt === -1 && this.match(b.comma)) {
                        this.state.commaAfterSpreadAt = this.state.start;
                    }
                    return this.finishNode(r, "SpreadElement");
                }
            }, {
                key: "parseRestBinding",
                value: function e() {
                    var t = this.startNode();
                    this.next();
                    t.argument = this.parseBindingAtom();
                    return this.finishNode(t, "RestElement");
                }
            }, {
                key: "parseBindingAtom",
                value: function e() {
                    switch (this.state.type) {
                      case b.bracketL:
                        {
                            var t = this.startNode();
                            this.next();
                            t.elements = this.parseBindingList(b.bracketR, true);
                            return this.finishNode(t, "ArrayPattern");
                        }

                      case b.braceL:
                        return this.parseObj(true);
                    }
                    return this.parseIdentifier();
                }
            }, {
                key: "parseBindingList",
                value: function e(t, i, r) {
                    var s = [];
                    var a = true;
                    while (!this.eat(t)) {
                        if (a) {
                            a = false;
                        } else {
                            this.expect(b.comma);
                        }
                        if (i && this.match(b.comma)) {
                            s.push(null);
                        } else if (this.eat(t)) {
                            break;
                        } else if (this.match(b.ellipsis)) {
                            s.push(this.parseAssignableListItemTypes(this.parseRestBinding()));
                            this.checkCommaAfterRest();
                            this.expect(t);
                            break;
                        } else {
                            var n = [];
                            if (this.match(b.at) && this.hasPlugin("decorators")) {
                                this.raise(this.state.start, "Stage 2 decorators cannot be used to decorate parameters");
                            }
                            while (this.match(b.at)) {
                                n.push(this.parseDecorator());
                            }
                            s.push(this.parseAssignableListItem(r, n));
                        }
                    }
                    return s;
                }
            }, {
                key: "parseAssignableListItem",
                value: function e(t, i) {
                    var r = this.parseMaybeDefault();
                    this.parseAssignableListItemTypes(r);
                    var s = this.parseMaybeDefault(r.start, r.loc.start, r);
                    if (i.length) {
                        r.decorators = i;
                    }
                    return s;
                }
            }, {
                key: "parseAssignableListItemTypes",
                value: function e(t) {
                    return t;
                }
            }, {
                key: "parseMaybeDefault",
                value: function e(t, i, r) {
                    i = i || this.state.startLoc;
                    t = t || this.state.start;
                    r = r || this.parseBindingAtom();
                    if (!this.eat(b.eq)) return r;
                    var s = this.startNodeAt(t, i);
                    s.left = r;
                    s.right = this.parseMaybeAssign();
                    return this.finishNode(s, "AssignmentPattern");
                }
            }, {
                key: "checkLVal",
                value: function e(t) {
                    var i = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Q;
                    var r = arguments[2];
                    var s = arguments[3];
                    switch (t.type) {
                      case "Identifier":
                        if (this.state.strict && me(t.name, this.inModule)) {
                            this.raise(t.start, (i === Q ? "Assigning to" : "Binding") + " '" + t.name + "' in strict mode");
                        }
                        if (r) {
                            var a = "_" + t.name;
                            if (r[a]) {
                                this.raise(t.start, "Argument name clash");
                            } else {
                                r[a] = true;
                            }
                        }
                        if (!(i & Q)) {
                            this.scope.declareName(t.name, i, t.start);
                        }
                        break;

                      case "MemberExpression":
                        if (i !== Q) {
                            this.raise(t.start, "Binding member expression");
                        }
                        break;

                      case "ObjectPattern":
                        for (var n = 0, o = t.properties; n < o.length; n++) {
                            var l = o[n];
                            if (l.type === "ObjectProperty") l = l.value;
                            this.checkLVal(l, i, r, "object destructuring pattern");
                        }
                        break;

                      case "ArrayPattern":
                        for (var u = 0, c = t.elements; u < c.length; u++) {
                            var h = c[u];
                            if (h) {
                                this.checkLVal(h, i, r, "array destructuring pattern");
                            }
                        }
                        break;

                      case "AssignmentPattern":
                        this.checkLVal(t.left, i, r, "assignment pattern");
                        break;

                      case "RestElement":
                        this.checkLVal(t.argument, i, r, "rest element");
                        break;

                      case "ParenthesizedExpression":
                        this.checkLVal(t.expression, i, r, "parenthesized expression");
                        break;

                      default:
                        {
                            var p = (i === Q ? "Invalid" : "Binding invalid") + " left-hand side" + (s ? " in " + s : "expression");
                            this.raise(t.start, p);
                        }
                    }
                }
            }, {
                key: "checkToRestConversion",
                value: function e(t) {
                    if (t.argument.type !== "Identifier" && t.argument.type !== "MemberExpression") {
                        this.raise(t.argument.start, "Invalid rest operator's argument");
                    }
                }
            }, {
                key: "checkCommaAfterRest",
                value: function e() {
                    if (this.match(b.comma)) {
                        this.raiseRestNotLast(this.state.start);
                    }
                }
            }, {
                key: "checkCommaAfterRestFromSpread",
                value: function e() {
                    if (this.state.commaAfterSpreadAt > -1) {
                        this.raiseRestNotLast(this.state.commaAfterSpreadAt);
                    }
                }
            }, {
                key: "raiseRestNotLast",
                value: function e(t) {
                    this.raise(t, "Rest element must be last element");
                }
            } ]);
            return t;
        }(kt);
        var wt = function e(t) {
            return t.type === "ParenthesizedExpression" ? e(t.expression) : t;
        };
        var At = function(e) {
            l(t, e);
            function t() {
                u(this, t);
                return o(this, (t.__proto__ || Object.getPrototypeOf(t)).apply(this, arguments));
            }
            s(t, [ {
                key: "checkPropClash",
                value: function e(t, i) {
                    if (t.type === "SpreadElement" || t.computed || t.kind || t.shorthand) {
                        return;
                    }
                    var r = t.key;
                    var s = r.type === "Identifier" ? r.name : String(r.value);
                    if (s === "__proto__") {
                        if (i.proto) {
                            this.raise(r.start, "Redefinition of __proto__ property");
                        }
                        i.proto = true;
                    }
                }
            }, {
                key: "getExpression",
                value: function e() {
                    this.scope.enter(k);
                    this.nextToken();
                    var t = this.parseExpression();
                    if (!this.match(b.eof)) {
                        this.unexpected();
                    }
                    t.comments = this.state.comments;
                    return t;
                }
            }, {
                key: "parseExpression",
                value: function e(t, i) {
                    var r = this.state.start;
                    var s = this.state.startLoc;
                    var a = this.parseMaybeAssign(t, i);
                    if (this.match(b.comma)) {
                        var n = this.startNodeAt(r, s);
                        n.expressions = [ a ];
                        while (this.eat(b.comma)) {
                            n.expressions.push(this.parseMaybeAssign(t, i));
                        }
                        this.toReferencedList(n.expressions);
                        return this.finishNode(n, "SequenceExpression");
                    }
                    return a;
                }
            }, {
                key: "parseMaybeAssign",
                value: function e(t, i, r, s) {
                    var a = this.state.start;
                    var n = this.state.startLoc;
                    if (this.isContextual("yield")) {
                        if (this.scope.inGenerator) {
                            var o = this.parseYield(t);
                            if (r) {
                                o = r.call(this, o, a, n);
                            }
                            return o;
                        } else {
                            this.state.exprAllowed = false;
                        }
                    }
                    var l = this.state.commaAfterSpreadAt;
                    this.state.commaAfterSpreadAt = -1;
                    var u = void 0;
                    if (i) {
                        u = false;
                    } else {
                        i = {
                            start: 0
                        };
                        u = true;
                    }
                    if (this.match(b.parenL) || this.match(b.name)) {
                        this.state.potentialArrowAt = this.state.start;
                    }
                    var c = this.parseMaybeConditional(t, i, s);
                    if (r) {
                        c = r.call(this, c, a, n);
                    }
                    if (this.state.type.isAssign) {
                        var h = this.startNodeAt(a, n);
                        var p = this.state.value;
                        h.operator = p;
                        if (p === "??=") {
                            this.expectPlugin("nullishCoalescingOperator");
                            this.expectPlugin("logicalAssignment");
                        }
                        if (p === "||=" || p === "&&=") {
                            this.expectPlugin("logicalAssignment");
                        }
                        h.left = this.match(b.eq) ? this.toAssignable(c, undefined, "assignment expression") : c;
                        i.start = 0;
                        this.checkLVal(c, undefined, undefined, "assignment expression");
                        var f = wt(c);
                        var d = void 0;
                        if (f.type === "ObjectPattern") {
                            d = "`({a}) = 0` use `({a} = 0)`";
                        } else if (f.type === "ArrayPattern") {
                            d = "`([a]) = 0` use `([a] = 0)`";
                        }
                        if (d && (c.extra && c.extra.parenthesized || c.type === "ParenthesizedExpression")) {
                            this.raise(f.start, "You're trying to assign to a parenthesized expression, eg. instead of " + d);
                        }
                        if (d) this.checkCommaAfterRestFromSpread();
                        this.state.commaAfterSpreadAt = l;
                        this.next();
                        h.right = this.parseMaybeAssign(t);
                        return this.finishNode(h, "AssignmentExpression");
                    } else if (u && i.start) {
                        this.unexpected(i.start);
                    }
                    this.state.commaAfterSpreadAt = l;
                    return c;
                }
            }, {
                key: "parseMaybeConditional",
                value: function e(t, i, r) {
                    var s = this.state.start;
                    var a = this.state.startLoc;
                    var n = this.state.potentialArrowAt;
                    var o = this.parseExprOps(t, i);
                    if (o.type === "ArrowFunctionExpression" && o.start === n) {
                        return o;
                    }
                    if (i && i.start) return o;
                    return this.parseConditional(o, t, s, a, r);
                }
            }, {
                key: "parseConditional",
                value: function e(t, i, r, s, a) {
                    if (this.eat(b.question)) {
                        var n = this.startNodeAt(r, s);
                        n.test = t;
                        n.consequent = this.parseMaybeAssign();
                        this.expect(b.colon);
                        n.alternate = this.parseMaybeAssign(i);
                        return this.finishNode(n, "ConditionalExpression");
                    }
                    return t;
                }
            }, {
                key: "parseExprOps",
                value: function e(t, i) {
                    var r = this.state.start;
                    var s = this.state.startLoc;
                    var a = this.state.potentialArrowAt;
                    var n = this.parseMaybeUnary(i);
                    if (n.type === "ArrowFunctionExpression" && n.start === a) {
                        return n;
                    }
                    if (i && i.start) {
                        return n;
                    }
                    return this.parseExprOp(n, r, s, -1, t);
                }
            }, {
                key: "parseExprOp",
                value: function e(t, i, r, s, a) {
                    var n = this.state.type.binop;
                    if (n != null && (!a || !this.match(b._in))) {
                        if (n > s) {
                            var o = this.startNodeAt(i, r);
                            var l = this.state.value;
                            o.left = t;
                            o.operator = l;
                            if (l === "**" && t.type === "UnaryExpression" && (this.options.createParenthesizedExpressions || !(t.extra && t.extra.parenthesized))) {
                                this.raise(t.argument.start, "Illegal expression. Wrap left hand side or entire exponentiation in parentheses.");
                            }
                            var u = this.state.type;
                            if (u === b.pipeline) {
                                this.expectPlugin("pipelineOperator");
                                this.state.inPipeline = true;
                                this.checkPipelineAtInfixOperator(t, i);
                            } else if (u === b.nullishCoalescing) {
                                this.expectPlugin("nullishCoalescingOperator");
                            }
                            this.next();
                            if (u === b.pipeline && this.getPluginOption("pipelineOperator", "proposal") === "minimal") {
                                if (this.match(b.name) && this.state.value === "await" && this.scope.inAsync) {
                                    throw this.raise(this.state.start, 'Unexpected "await" after pipeline body; await must have parentheses in minimal proposal');
                                }
                            }
                            o.right = this.parseExprOpRightExpr(u, n, a);
                            this.finishNode(o, u === b.logicalOR || u === b.logicalAND || u === b.nullishCoalescing ? "LogicalExpression" : "BinaryExpression");
                            return this.parseExprOp(o, i, r, s, a);
                        }
                    }
                    return t;
                }
            }, {
                key: "parseExprOpRightExpr",
                value: function e(t, i, r) {
                    var s = this;
                    switch (t) {
                      case b.pipeline:
                        if (this.getPluginOption("pipelineOperator", "proposal") === "smart") {
                            var a = this.state.start;
                            var n = this.state.startLoc;
                            return this.withTopicPermittingContext(function() {
                                return s.parseSmartPipelineBody(s.parseExprOpBaseRightExpr(t, i, r), a, n);
                            });
                        }

                      default:
                        return this.parseExprOpBaseRightExpr(t, i, r);
                    }
                }
            }, {
                key: "parseExprOpBaseRightExpr",
                value: function e(t, i, r) {
                    var s = this.state.start;
                    var a = this.state.startLoc;
                    return this.parseExprOp(this.parseMaybeUnary(), s, a, t.rightAssociative ? i - 1 : i, r);
                }
            }, {
                key: "parseMaybeUnary",
                value: function e(t) {
                    if (this.isContextual("await") && (this.scope.inAsync || !this.scope.inFunction && this.options.allowAwaitOutsideFunction)) {
                        return this.parseAwait();
                    } else if (this.state.type.prefix) {
                        var i = this.startNode();
                        var r = this.match(b.incDec);
                        i.operator = this.state.value;
                        i.prefix = true;
                        if (i.operator === "throw") {
                            this.expectPlugin("throwExpressions");
                        }
                        this.next();
                        i.argument = this.parseMaybeUnary();
                        if (t && t.start) {
                            this.unexpected(t.start);
                        }
                        if (r) {
                            this.checkLVal(i.argument, undefined, undefined, "prefix operation");
                        } else if (this.state.strict && i.operator === "delete") {
                            var s = i.argument;
                            if (s.type === "Identifier") {
                                this.raise(i.start, "Deleting local variable in strict mode");
                            } else if (s.type === "MemberExpression" && s.property.type === "PrivateName") {
                                this.raise(i.start, "Deleting a private field is not allowed");
                            }
                        }
                        return this.finishNode(i, r ? "UpdateExpression" : "UnaryExpression");
                    }
                    var a = this.state.start;
                    var n = this.state.startLoc;
                    var o = this.parseExprSubscripts(t);
                    if (t && t.start) return o;
                    while (this.state.type.postfix && !this.canInsertSemicolon()) {
                        var l = this.startNodeAt(a, n);
                        l.operator = this.state.value;
                        l.prefix = false;
                        l.argument = o;
                        this.checkLVal(o, undefined, undefined, "postfix operation");
                        this.next();
                        o = this.finishNode(l, "UpdateExpression");
                    }
                    return o;
                }
            }, {
                key: "parseExprSubscripts",
                value: function e(t) {
                    var i = this.state.start;
                    var r = this.state.startLoc;
                    var s = this.state.potentialArrowAt;
                    var a = this.parseExprAtom(t);
                    if (a.type === "ArrowFunctionExpression" && a.start === s) {
                        return a;
                    }
                    if (t && t.start) {
                        return a;
                    }
                    return this.parseSubscripts(a, i, r);
                }
            }, {
                key: "parseSubscripts",
                value: function e(t, i, r, s) {
                    var a = this.atPossibleAsync(t);
                    var n = {
                        optionalChainMember: false,
                        stop: false
                    };
                    do {
                        t = this.parseSubscript(t, i, r, s, n, a);
                    } while (!n.stop);
                    return t;
                }
            }, {
                key: "parseSubscript",
                value: function e(t, i, r, s, a, n) {
                    if (!s && this.eat(b.doubleColon)) {
                        var o = this.startNodeAt(i, r);
                        o.object = t;
                        o.callee = this.parseNoCallExpr();
                        a.stop = true;
                        return this.parseSubscripts(this.finishNode(o, "BindExpression"), i, r, s);
                    } else if (this.match(b.questionDot)) {
                        this.expectPlugin("optionalChaining");
                        a.optionalChainMember = true;
                        if (s && this.lookahead().type === b.parenL) {
                            a.stop = true;
                            return t;
                        }
                        this.next();
                        var l = this.startNodeAt(i, r);
                        if (this.eat(b.bracketL)) {
                            l.object = t;
                            l.property = this.parseExpression();
                            l.computed = true;
                            l.optional = true;
                            this.expect(b.bracketR);
                            return this.finishNode(l, "OptionalMemberExpression");
                        } else if (this.eat(b.parenL)) {
                            l.callee = t;
                            l.arguments = this.parseCallExpressionArguments(b.parenR, false);
                            l.optional = true;
                            return this.finishNode(l, "OptionalCallExpression");
                        } else {
                            l.object = t;
                            l.property = this.parseIdentifier(true);
                            l.computed = false;
                            l.optional = true;
                            return this.finishNode(l, "OptionalMemberExpression");
                        }
                    } else if (this.eat(b.dot)) {
                        var u = this.startNodeAt(i, r);
                        u.object = t;
                        u.property = this.parseMaybePrivateName();
                        u.computed = false;
                        if (a.optionalChainMember) {
                            u.optional = false;
                            return this.finishNode(u, "OptionalMemberExpression");
                        }
                        return this.finishNode(u, "MemberExpression");
                    } else if (this.eat(b.bracketL)) {
                        var c = this.startNodeAt(i, r);
                        c.object = t;
                        c.property = this.parseExpression();
                        c.computed = true;
                        this.expect(b.bracketR);
                        if (a.optionalChainMember) {
                            c.optional = false;
                            return this.finishNode(c, "OptionalMemberExpression");
                        }
                        return this.finishNode(c, "MemberExpression");
                    } else if (!s && this.match(b.parenL)) {
                        var h = this.state.maybeInArrowParameters;
                        var p = this.state.yieldPos;
                        var f = this.state.awaitPos;
                        this.state.maybeInArrowParameters = true;
                        this.state.yieldPos = 0;
                        this.state.awaitPos = 0;
                        this.next();
                        var d = this.startNodeAt(i, r);
                        d.callee = t;
                        var m = this.state.commaAfterSpreadAt;
                        this.state.commaAfterSpreadAt = -1;
                        d.arguments = this.parseCallExpressionArguments(b.parenR, n, t.type === "Import", t.type !== "Super");
                        if (!a.optionalChainMember) {
                            this.finishCallExpression(d);
                        } else {
                            this.finishOptionalCallExpression(d);
                        }
                        if (n && this.shouldParseAsyncArrow()) {
                            a.stop = true;
                            this.checkCommaAfterRestFromSpread();
                            d = this.parseAsyncArrowFromCallExpression(this.startNodeAt(i, r), d);
                            this.checkYieldAwaitInDefaultParams();
                            this.state.yieldPos = p;
                            this.state.awaitPos = f;
                        } else {
                            this.toReferencedListDeep(d.arguments);
                            this.state.yieldPos = p || this.state.yieldPos;
                            this.state.awaitPos = f || this.state.awaitPos;
                        }
                        this.state.maybeInArrowParameters = h;
                        this.state.commaAfterSpreadAt = m;
                        return d;
                    } else if (this.match(b.backQuote)) {
                        return this.parseTaggedTemplateExpression(i, r, t, a);
                    } else {
                        a.stop = true;
                        return t;
                    }
                }
            }, {
                key: "parseTaggedTemplateExpression",
                value: function e(t, i, r, s, a) {
                    var n = this.startNodeAt(t, i);
                    n.tag = r;
                    n.quasi = this.parseTemplate(true);
                    if (a) n.typeParameters = a;
                    if (s.optionalChainMember) {
                        this.raise(t, "Tagged Template Literals are not allowed in optionalChain");
                    }
                    return this.finishNode(n, "TaggedTemplateExpression");
                }
            }, {
                key: "atPossibleAsync",
                value: function e(t) {
                    return t.type === "Identifier" && t.name === "async" && this.state.lastTokEnd === t.end && !this.canInsertSemicolon() && this.input.slice(t.start, t.end) === "async";
                }
            }, {
                key: "finishCallExpression",
                value: function e(t) {
                    if (t.callee.type === "Import") {
                        if (t.arguments.length !== 1) {
                            this.raise(t.start, "import() requires exactly one argument");
                        }
                        var i = t.arguments[0];
                        if (i && i.type === "SpreadElement") {
                            this.raise(i.start, "... is not allowed in import()");
                        }
                    }
                    return this.finishNode(t, "CallExpression");
                }
            }, {
                key: "finishOptionalCallExpression",
                value: function e(t) {
                    if (t.callee.type === "Import") {
                        if (t.arguments.length !== 1) {
                            this.raise(t.start, "import() requires exactly one argument");
                        }
                        var i = t.arguments[0];
                        if (i && i.type === "SpreadElement") {
                            this.raise(i.start, "... is not allowed in import()");
                        }
                    }
                    return this.finishNode(t, "OptionalCallExpression");
                }
            }, {
                key: "parseCallExpressionArguments",
                value: function e(t, i, r, s) {
                    var a = [];
                    var n = void 0;
                    var o = true;
                    while (!this.eat(t)) {
                        if (o) {
                            o = false;
                        } else {
                            this.expect(b.comma);
                            if (this.eat(t)) {
                                if (r) {
                                    this.raise(this.state.lastTokStart, "Trailing comma is disallowed inside import(...) arguments");
                                }
                                break;
                            }
                        }
                        if (this.match(b.parenL) && !n) {
                            n = this.state.start;
                        }
                        a.push(this.parseExprListItem(false, i ? {
                            start: 0
                        } : undefined, i ? {
                            start: 0
                        } : undefined, s));
                    }
                    if (i && n && this.shouldParseAsyncArrow()) {
                        this.unexpected();
                    }
                    return a;
                }
            }, {
                key: "shouldParseAsyncArrow",
                value: function e() {
                    return this.match(b.arrow) && !this.canInsertSemicolon();
                }
            }, {
                key: "parseAsyncArrowFromCallExpression",
                value: function e(t, i) {
                    this.expect(b.arrow);
                    this.parseArrowExpression(t, i.arguments, true);
                    return t;
                }
            }, {
                key: "parseNoCallExpr",
                value: function e() {
                    var t = this.state.start;
                    var i = this.state.startLoc;
                    return this.parseSubscripts(this.parseExprAtom(), t, i, true);
                }
            }, {
                key: "parseExprAtom",
                value: function e(t) {
                    if (this.state.type === b.slash) this.readRegexp();
                    var i = this.state.potentialArrowAt === this.state.start;
                    var r = void 0;
                    switch (this.state.type) {
                      case b._super:
                        if (!this.scope.allowSuper && !this.options.allowSuperOutsideMethod) {
                            this.raise(this.state.start, "super is only allowed in object methods and classes");
                        }
                        r = this.startNode();
                        this.next();
                        if (this.match(b.parenL) && !this.scope.allowDirectSuper && !this.options.allowSuperOutsideMethod) {
                            this.raise(r.start, "super() is only valid inside a class constructor of a subclass. " + "Maybe a typo in the method name ('constructor') or not extending another class?");
                        }
                        if (!this.match(b.parenL) && !this.match(b.bracketL) && !this.match(b.dot)) {
                            this.unexpected();
                        }
                        return this.finishNode(r, "Super");

                      case b._import:
                        r = this.startNode();
                        this.next();
                        if (this.match(b.dot)) {
                            return this.parseImportMetaProperty(r);
                        }
                        this.expectPlugin("dynamicImport", r.start);
                        if (!this.match(b.parenL)) {
                            this.unexpected(null, b.parenL);
                        }
                        return this.finishNode(r, "Import");

                      case b._this:
                        r = this.startNode();
                        this.next();
                        return this.finishNode(r, "ThisExpression");

                      case b.name:
                        {
                            r = this.startNode();
                            var s = this.state.containsEsc;
                            var a = this.parseIdentifier();
                            if (!s && a.name === "async" && this.match(b._function) && !this.canInsertSemicolon()) {
                                this.next();
                                return this.parseFunction(r, undefined, true);
                            } else if (i && !s && a.name === "async" && this.match(b.name) && !this.canInsertSemicolon()) {
                                var n = [ this.parseIdentifier() ];
                                this.expect(b.arrow);
                                this.parseArrowExpression(r, n, true);
                                return r;
                            }
                            if (i && this.match(b.arrow) && !this.canInsertSemicolon()) {
                                this.next();
                                this.parseArrowExpression(r, [ a ], false);
                                return r;
                            }
                            return a;
                        }

                      case b._do:
                        {
                            this.expectPlugin("doExpressions");
                            var o = this.startNode();
                            this.next();
                            var l = this.state.labels;
                            this.state.labels = [];
                            o.body = this.parseBlock();
                            this.state.labels = l;
                            return this.finishNode(o, "DoExpression");
                        }

                      case b.regexp:
                        {
                            var u = this.state.value;
                            r = this.parseLiteral(u.value, "RegExpLiteral");
                            r.pattern = u.pattern;
                            r.flags = u.flags;
                            return r;
                        }

                      case b.num:
                        return this.parseLiteral(this.state.value, "NumericLiteral");

                      case b.bigint:
                        return this.parseLiteral(this.state.value, "BigIntLiteral");

                      case b.string:
                        return this.parseLiteral(this.state.value, "StringLiteral");

                      case b._null:
                        r = this.startNode();
                        this.next();
                        return this.finishNode(r, "NullLiteral");

                      case b._true:
                      case b._false:
                        return this.parseBooleanLiteral();

                      case b.parenL:
                        return this.parseParenAndDistinguishExpression(i);

                      case b.bracketL:
                        r = this.startNode();
                        this.next();
                        r.elements = this.parseExprList(b.bracketR, true, t);
                        if (!this.state.maybeInArrowParameters) {
                            this.toReferencedList(r.elements);
                        }
                        return this.finishNode(r, "ArrayExpression");

                      case b.braceL:
                        return this.parseObj(false, t);

                      case b._function:
                        return this.parseFunctionExpression();

                      case b.at:
                        this.parseDecorators();

                      case b._class:
                        r = this.startNode();
                        this.takeDecorators(r);
                        return this.parseClass(r, false);

                      case b._new:
                        return this.parseNew();

                      case b.backQuote:
                        return this.parseTemplate(false);

                      case b.doubleColon:
                        {
                            r = this.startNode();
                            this.next();
                            r.object = null;
                            var c = r.callee = this.parseNoCallExpr();
                            if (c.type === "MemberExpression") {
                                return this.finishNode(r, "BindExpression");
                            } else {
                                throw this.raise(c.start, "Binding should be performed on object property.");
                            }
                        }

                      case b.hash:
                        {
                            if (this.state.inPipeline) {
                                r = this.startNode();
                                if (this.getPluginOption("pipelineOperator", "proposal") !== "smart") {
                                    this.raise(r.start, "Primary Topic Reference found but pipelineOperator not passed 'smart' for 'proposal' option.");
                                }
                                this.next();
                                if (this.primaryTopicReferenceIsAllowedInCurrentTopicContext()) {
                                    this.registerTopicReference();
                                    return this.finishNode(r, "PipelinePrimaryTopicReference");
                                } else {
                                    throw this.raise(r.start, "Topic reference was used in a lexical context without topic binding");
                                }
                            }
                        }

                      default:
                        throw this.unexpected();
                    }
                }
            }, {
                key: "parseBooleanLiteral",
                value: function e() {
                    var t = this.startNode();
                    t.value = this.match(b._true);
                    this.next();
                    return this.finishNode(t, "BooleanLiteral");
                }
            }, {
                key: "parseMaybePrivateName",
                value: function e() {
                    var t = this.match(b.hash);
                    if (t) {
                        this.expectOnePlugin([ "classPrivateProperties", "classPrivateMethods" ]);
                        var i = this.startNode();
                        this.next();
                        this.assertNoSpace("Unexpected space between # and identifier");
                        i.id = this.parseIdentifier(true);
                        return this.finishNode(i, "PrivateName");
                    } else {
                        return this.parseIdentifier(true);
                    }
                }
            }, {
                key: "parseFunctionExpression",
                value: function e() {
                    var t = this.startNode();
                    var i = this.startNode();
                    this.next();
                    i = this.createIdentifier(i, "function");
                    if (this.scope.inGenerator && this.eat(b.dot)) {
                        return this.parseMetaProperty(t, i, "sent");
                    }
                    return this.parseFunction(t);
                }
            }, {
                key: "parseMetaProperty",
                value: function e(t, i, r) {
                    t.meta = i;
                    if (i.name === "function" && r === "sent") {
                        if (this.isContextual(r)) {
                            this.expectPlugin("functionSent");
                        } else if (!this.hasPlugin("functionSent")) {
                            this.unexpected();
                        }
                    }
                    var s = this.state.containsEsc;
                    t.property = this.parseIdentifier(true);
                    if (t.property.name !== r || s) {
                        this.raise(t.property.start, "The only valid meta property for " + i.name + " is " + i.name + "." + r);
                    }
                    return this.finishNode(t, "MetaProperty");
                }
            }, {
                key: "parseImportMetaProperty",
                value: function e(t) {
                    var i = this.createIdentifier(this.startNodeAtNode(t), "import");
                    this.expect(b.dot);
                    if (this.isContextual("meta")) {
                        this.expectPlugin("importMeta");
                    } else if (!this.hasPlugin("importMeta")) {
                        this.raise(i.start, "Dynamic imports require a parameter: import('a.js')");
                    }
                    if (!this.inModule) {
                        this.raise(i.start, "import.meta may appear only with 'sourceType: \"module\"'", {
                            code: "BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED"
                        });
                    }
                    this.sawUnambiguousESM = true;
                    return this.parseMetaProperty(t, i, "meta");
                }
            }, {
                key: "parseLiteral",
                value: function e(t, i, r, s) {
                    r = r || this.state.start;
                    s = s || this.state.startLoc;
                    var a = this.startNodeAt(r, s);
                    this.addExtra(a, "rawValue", t);
                    this.addExtra(a, "raw", this.input.slice(r, this.state.end));
                    a.value = t;
                    this.next();
                    return this.finishNode(a, i);
                }
            }, {
                key: "parseParenAndDistinguishExpression",
                value: function e(t) {
                    var i = this.state.start;
                    var r = this.state.startLoc;
                    var s = void 0;
                    this.expect(b.parenL);
                    var a = this.state.maybeInArrowParameters;
                    var n = this.state.yieldPos;
                    var o = this.state.awaitPos;
                    this.state.maybeInArrowParameters = true;
                    this.state.yieldPos = 0;
                    this.state.awaitPos = 0;
                    var l = this.state.start;
                    var u = this.state.startLoc;
                    var c = [];
                    var h = {
                        start: 0
                    };
                    var p = {
                        start: 0
                    };
                    var f = true;
                    var d = void 0;
                    var m = void 0;
                    while (!this.match(b.parenR)) {
                        if (f) {
                            f = false;
                        } else {
                            this.expect(b.comma, p.start || null);
                            if (this.match(b.parenR)) {
                                m = this.state.start;
                                break;
                            }
                        }
                        if (this.match(b.ellipsis)) {
                            var y = this.state.start;
                            var v = this.state.startLoc;
                            d = this.state.start;
                            c.push(this.parseParenItem(this.parseRestBinding(), y, v));
                            this.checkCommaAfterRest();
                            break;
                        } else {
                            c.push(this.parseMaybeAssign(false, h, this.parseParenItem, p));
                        }
                    }
                    var x = this.state.start;
                    var g = this.state.startLoc;
                    this.expect(b.parenR);
                    this.state.maybeInArrowParameters = a;
                    var E = this.startNodeAt(i, r);
                    if (t && this.shouldParseArrow() && (E = this.parseArrow(E))) {
                        this.checkYieldAwaitInDefaultParams();
                        this.state.yieldPos = n;
                        this.state.awaitPos = o;
                        for (var k = 0; k < c.length; k++) {
                            var S = c[k];
                            if (S.extra && S.extra.parenthesized) {
                                this.unexpected(S.extra.parenStart);
                            }
                        }
                        this.parseArrowExpression(E, c, false);
                        return E;
                    }
                    this.state.yieldPos = n || this.state.yieldPos;
                    this.state.awaitPos = o || this.state.awaitPos;
                    if (!c.length) {
                        this.unexpected(this.state.lastTokStart);
                    }
                    if (m) this.unexpected(m);
                    if (d) this.unexpected(d);
                    if (h.start) {
                        this.unexpected(h.start);
                    }
                    if (p.start) this.unexpected(p.start);
                    this.toReferencedListDeep(c, true);
                    if (c.length > 1) {
                        s = this.startNodeAt(l, u);
                        s.expressions = c;
                        this.finishNodeAt(s, "SequenceExpression", x, g);
                    } else {
                        s = c[0];
                    }
                    if (!this.options.createParenthesizedExpressions) {
                        this.addExtra(s, "parenthesized", true);
                        this.addExtra(s, "parenStart", i);
                        return s;
                    }
                    var w = this.startNodeAt(i, r);
                    w.expression = s;
                    this.finishNode(w, "ParenthesizedExpression");
                    return w;
                }
            }, {
                key: "shouldParseArrow",
                value: function e() {
                    return !this.canInsertSemicolon();
                }
            }, {
                key: "parseArrow",
                value: function e(t) {
                    if (this.eat(b.arrow)) {
                        return t;
                    }
                }
            }, {
                key: "parseParenItem",
                value: function e(t, i, r) {
                    return t;
                }
            }, {
                key: "parseNew",
                value: function e() {
                    var t = this.startNode();
                    var i = this.parseIdentifier(true);
                    if (this.eat(b.dot)) {
                        var r = this.parseMetaProperty(t, i, "target");
                        if (!this.scope.inNonArrowFunction && !this.state.inClassProperty) {
                            var s = "new.target can only be used in functions";
                            if (this.hasPlugin("classProperties")) {
                                s += " or class properties";
                            }
                            this.raise(r.start, s);
                        }
                        return r;
                    }
                    t.callee = this.parseNoCallExpr();
                    if (t.callee.type === "Import") {
                        this.raise(t.callee.start, "Cannot use new with import(...)");
                    } else if (t.callee.type === "OptionalMemberExpression" || t.callee.type === "OptionalCallExpression") {
                        this.raise(this.state.lastTokEnd, "constructors in/after an Optional Chain are not allowed");
                    } else if (this.eat(b.questionDot)) {
                        this.raise(this.state.start, "constructors in/after an Optional Chain are not allowed");
                    }
                    this.parseNewArguments(t);
                    return this.finishNode(t, "NewExpression");
                }
            }, {
                key: "parseNewArguments",
                value: function e(t) {
                    if (this.eat(b.parenL)) {
                        var i = this.parseExprList(b.parenR);
                        this.toReferencedList(i);
                        t.arguments = i;
                    } else {
                        t.arguments = [];
                    }
                }
            }, {
                key: "parseTemplateElement",
                value: function e(t) {
                    var i = this.startNode();
                    if (this.state.value === null) {
                        if (!t) {
                            this.raise(this.state.invalidTemplateEscapePosition || 0, "Invalid escape sequence in template");
                        } else {
                            this.state.invalidTemplateEscapePosition = null;
                        }
                    }
                    i.value = {
                        raw: this.input.slice(this.state.start, this.state.end).replace(/\r\n?/g, "\n"),
                        cooked: this.state.value
                    };
                    this.next();
                    i.tail = this.match(b.backQuote);
                    return this.finishNode(i, "TemplateElement");
                }
            }, {
                key: "parseTemplate",
                value: function e(t) {
                    var i = this.startNode();
                    this.next();
                    i.expressions = [];
                    var r = this.parseTemplateElement(t);
                    i.quasis = [ r ];
                    while (!r.tail) {
                        this.expect(b.dollarBraceL);
                        i.expressions.push(this.parseExpression());
                        this.expect(b.braceR);
                        i.quasis.push(r = this.parseTemplateElement(t));
                    }
                    this.next();
                    return this.finishNode(i, "TemplateLiteral");
                }
            }, {
                key: "parseObj",
                value: function e(t, i) {
                    var r = Object.create(null);
                    var s = true;
                    var a = this.startNode();
                    a.properties = [];
                    this.next();
                    while (!this.eat(b.braceR)) {
                        if (s) {
                            s = false;
                        } else {
                            this.expect(b.comma);
                            if (this.eat(b.braceR)) break;
                        }
                        var n = this.parseObjectMember(t, i);
                        if (!t) this.checkPropClash(n, r);
                        if (n.shorthand) {
                            this.addExtra(n, "shorthand", true);
                        }
                        a.properties.push(n);
                    }
                    return this.finishNode(a, t ? "ObjectPattern" : "ObjectExpression");
                }
            }, {
                key: "isAsyncProp",
                value: function e(t) {
                    return !t.computed && t.key.type === "Identifier" && t.key.name === "async" && (this.match(b.name) || this.match(b.num) || this.match(b.string) || this.match(b.bracketL) || this.state.type.keyword || this.match(b.star)) && !this.hasPrecedingLineBreak();
                }
            }, {
                key: "parseObjectMember",
                value: function e(t, i) {
                    var r = [];
                    if (this.match(b.at)) {
                        if (this.hasPlugin("decorators")) {
                            this.raise(this.state.start, "Stage 2 decorators disallow object literal property decorators");
                        } else {
                            while (this.match(b.at)) {
                                r.push(this.parseDecorator());
                            }
                        }
                    }
                    var s = this.startNode();
                    var a = false;
                    var n = false;
                    var o = void 0;
                    var l = void 0;
                    if (this.match(b.ellipsis)) {
                        if (r.length) this.unexpected();
                        if (t) {
                            this.next();
                            s.argument = this.parseIdentifier();
                            this.checkCommaAfterRest();
                            return this.finishNode(s, "RestElement");
                        }
                        return this.parseSpread();
                    }
                    if (r.length) {
                        s.decorators = r;
                        r = [];
                    }
                    s.method = false;
                    if (t || i) {
                        o = this.state.start;
                        l = this.state.startLoc;
                    }
                    if (!t) {
                        a = this.eat(b.star);
                    }
                    var u = this.state.containsEsc;
                    this.parsePropertyName(s);
                    if (!t && !u && !a && this.isAsyncProp(s)) {
                        n = true;
                        a = this.eat(b.star);
                        this.parsePropertyName(s);
                    } else {
                        n = false;
                    }
                    this.parseObjPropValue(s, o, l, a, n, t, i, u);
                    return s;
                }
            }, {
                key: "isGetterOrSetterMethod",
                value: function e(t, i) {
                    return !i && !t.computed && t.key.type === "Identifier" && (t.key.name === "get" || t.key.name === "set") && (this.match(b.string) || this.match(b.num) || this.match(b.bracketL) || this.match(b.name) || !!this.state.type.keyword);
                }
            }, {
                key: "getGetterSetterExpectedParamCount",
                value: function e(t) {
                    return t.kind === "get" ? 0 : 1;
                }
            }, {
                key: "checkGetterSetterParams",
                value: function e(t) {
                    var i = this.getGetterSetterExpectedParamCount(t);
                    var r = t.start;
                    if (t.params.length !== i) {
                        if (t.kind === "get") {
                            this.raise(r, "getter must not have any formal parameters");
                        } else {
                            this.raise(r, "setter must have exactly one formal parameter");
                        }
                    }
                    if (t.kind === "set" && t.params[t.params.length - 1].type === "RestElement") {
                        this.raise(r, "setter function argument must not be a rest parameter");
                    }
                }
            }, {
                key: "parseObjectMethod",
                value: function e(t, i, r, s, a) {
                    if (r || i || this.match(b.parenL)) {
                        if (s) this.unexpected();
                        t.kind = "method";
                        t.method = true;
                        return this.parseMethod(t, i, r, false, false, "ObjectMethod");
                    }
                    if (!a && this.isGetterOrSetterMethod(t, s)) {
                        if (i || r) this.unexpected();
                        t.kind = t.key.name;
                        this.parsePropertyName(t);
                        this.parseMethod(t, false, false, false, false, "ObjectMethod");
                        this.checkGetterSetterParams(t);
                        return t;
                    }
                }
            }, {
                key: "parseObjectProperty",
                value: function e(t, i, r, s, a) {
                    t.shorthand = false;
                    if (this.eat(b.colon)) {
                        t.value = s ? this.parseMaybeDefault(this.state.start, this.state.startLoc) : this.parseMaybeAssign(false, a);
                        return this.finishNode(t, "ObjectProperty");
                    }
                    if (!t.computed && t.key.type === "Identifier") {
                        this.checkReservedWord(t.key.name, t.key.start, true, true);
                        if (s) {
                            t.value = this.parseMaybeDefault(i, r, t.key.__clone());
                        } else if (this.match(b.eq) && a) {
                            if (!a.start) {
                                a.start = this.state.start;
                            }
                            t.value = this.parseMaybeDefault(i, r, t.key.__clone());
                        } else {
                            t.value = t.key.__clone();
                        }
                        t.shorthand = true;
                        return this.finishNode(t, "ObjectProperty");
                    }
                }
            }, {
                key: "parseObjPropValue",
                value: function e(t, i, r, s, a, n, o, l) {
                    var u = this.parseObjectMethod(t, s, a, n, l) || this.parseObjectProperty(t, i, r, n, o);
                    if (!u) this.unexpected();
                    return u;
                }
            }, {
                key: "parsePropertyName",
                value: function e(t) {
                    if (this.eat(b.bracketL)) {
                        t.computed = true;
                        t.key = this.parseMaybeAssign();
                        this.expect(b.bracketR);
                    } else {
                        var i = this.state.inPropertyName;
                        this.state.inPropertyName = true;
                        t.key = this.match(b.num) || this.match(b.string) ? this.parseExprAtom() : this.parseMaybePrivateName();
                        if (t.key.type !== "PrivateName") {
                            t.computed = false;
                        }
                        this.state.inPropertyName = i;
                    }
                    return t.key;
                }
            }, {
                key: "initFunction",
                value: function e(t, i) {
                    t.id = null;
                    t.generator = false;
                    t.async = !!i;
                }
            }, {
                key: "parseMethod",
                value: function e(t, i, r, s, a, n) {
                    var o = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : false;
                    var l = this.state.yieldPos;
                    var u = this.state.awaitPos;
                    this.state.yieldPos = 0;
                    this.state.awaitPos = 0;
                    this.initFunction(t, r);
                    t.generator = !!i;
                    var c = s;
                    this.scope.enter(F(r, t.generator) | P | (o ? _ : 0) | (a ? D : 0));
                    this.parseFunctionParams(t, c);
                    this.checkYieldAwaitInDefaultParams();
                    this.parseFunctionBodyAndFinish(t, n, true);
                    this.scope.exit();
                    this.state.yieldPos = l;
                    this.state.awaitPos = u;
                    return t;
                }
            }, {
                key: "parseArrowExpression",
                value: function e(t, i, r) {
                    this.scope.enter(F(r, false) | C);
                    this.initFunction(t, r);
                    var s = this.state.maybeInArrowParameters;
                    var a = this.state.yieldPos;
                    var n = this.state.awaitPos;
                    this.state.maybeInArrowParameters = false;
                    this.state.yieldPos = 0;
                    this.state.awaitPos = 0;
                    if (i) this.setArrowFunctionParameters(t, i);
                    this.parseFunctionBody(t, true);
                    this.scope.exit();
                    this.state.maybeInArrowParameters = s;
                    this.state.yieldPos = a;
                    this.state.awaitPos = n;
                    return this.finishNode(t, "ArrowFunctionExpression");
                }
            }, {
                key: "setArrowFunctionParameters",
                value: function e(t, i) {
                    t.params = this.toAssignableList(i, true, "arrow function parameters");
                }
            }, {
                key: "isStrictBody",
                value: function e(t) {
                    var i = t.body.type === "BlockStatement";
                    if (i && t.body.directives.length) {
                        for (var r = 0, s = t.body.directives; r < s.length; r++) {
                            var a = s[r];
                            if (a.value.value === "use strict") {
                                return true;
                            }
                        }
                    }
                    return false;
                }
            }, {
                key: "parseFunctionBodyAndFinish",
                value: function e(t, i) {
                    var r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
                    this.parseFunctionBody(t, false, r);
                    this.finishNode(t, i);
                }
            }, {
                key: "parseFunctionBody",
                value: function e(t, i) {
                    var r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
                    var s = i && !this.match(b.braceL);
                    var a = this.state.strict;
                    var n = false;
                    var o = this.state.inParameters;
                    this.state.inParameters = false;
                    if (s) {
                        t.body = this.parseMaybeAssign();
                        this.checkParams(t, false, i);
                    } else {
                        var l = !this.isSimpleParamList(t.params);
                        if (!a || l) {
                            n = this.strictDirective(this.state.end);
                            if (n && l) {
                                var u = (t.kind === "method" || t.kind === "constructor") && !!t.key ? t.key.end : t.start;
                                this.raise(u, "Illegal 'use strict' directive in function with non-simple parameter list");
                            }
                        }
                        var c = this.state.labels;
                        this.state.labels = [];
                        if (n) this.state.strict = true;
                        this.checkParams(t, !a && !n && !i && !r && !l, i);
                        t.body = this.parseBlock(true, false);
                        this.state.labels = c;
                    }
                    this.state.inParameters = o;
                    if (this.state.strict && t.id) {
                        this.checkLVal(t.id, $, undefined, "function name");
                    }
                    this.state.strict = a;
                }
            }, {
                key: "isSimpleParamList",
                value: function e(t) {
                    for (var i = 0, r = t.length; i < r; i++) {
                        if (t[i].type !== "Identifier") return false;
                    }
                    return true;
                }
            }, {
                key: "checkParams",
                value: function e(t, i, r) {
                    var s = Object.create(null);
                    for (var a = 0; a < t.params.length; a++) {
                        this.checkLVal(t.params[a], z, i ? null : s, "function paramter list");
                    }
                }
            }, {
                key: "parseExprList",
                value: function e(t, i, r) {
                    var s = [];
                    var a = true;
                    while (!this.eat(t)) {
                        if (a) {
                            a = false;
                        } else {
                            this.expect(b.comma);
                            if (this.eat(t)) break;
                        }
                        s.push(this.parseExprListItem(i, r));
                    }
                    return s;
                }
            }, {
                key: "parseExprListItem",
                value: function e(t, i, r, s) {
                    var a = void 0;
                    if (t && this.match(b.comma)) {
                        a = null;
                    } else if (this.match(b.ellipsis)) {
                        var n = this.state.start;
                        var o = this.state.startLoc;
                        a = this.parseParenItem(this.parseSpread(i, r), n, o);
                    } else if (this.match(b.question)) {
                        this.expectPlugin("partialApplication");
                        if (!s) {
                            this.raise(this.state.start, "Unexpected argument placeholder");
                        }
                        var l = this.startNode();
                        this.next();
                        a = this.finishNode(l, "ArgumentPlaceholder");
                    } else {
                        a = this.parseMaybeAssign(false, i, this.parseParenItem, r);
                    }
                    return a;
                }
            }, {
                key: "parseIdentifier",
                value: function e(t) {
                    var i = this.startNode();
                    var r = this.parseIdentifierName(i.start, t);
                    return this.createIdentifier(i, r);
                }
            }, {
                key: "createIdentifier",
                value: function e(t, i) {
                    t.name = i;
                    t.loc.identifierName = i;
                    return this.finishNode(t, "Identifier");
                }
            }, {
                key: "parseIdentifierName",
                value: function e(t, i) {
                    var r = void 0;
                    if (this.match(b.name)) {
                        r = this.state.value;
                    } else if (this.state.type.keyword) {
                        r = this.state.type.keyword;
                        if ((r === "class" || r === "function") && (this.state.lastTokEnd !== this.state.lastTokStart + 1 || this.input.charCodeAt(this.state.lastTokStart) !== 46)) {
                            this.state.context.pop();
                        }
                    } else {
                        throw this.unexpected();
                    }
                    if (!i) {
                        this.checkReservedWord(r, this.state.start, !!this.state.type.keyword, false);
                    }
                    this.next();
                    return r;
                }
            }, {
                key: "checkReservedWord",
                value: function e(t, i, r, s) {
                    if (this.scope.inGenerator && t === "yield") {
                        this.raise(i, "Can not use 'yield' as identifier inside a generator");
                    }
                    if (this.scope.inAsync && t === "await") {
                        this.raise(i, "Can not use 'await' as identifier inside an async function");
                    }
                    if (this.state.inClassProperty && t === "arguments") {
                        this.raise(i, "'arguments' is not allowed in class field initializer");
                    }
                    if (r && ye(t)) {
                        this.raise(i, "Unexpected keyword '" + t + "'");
                    }
                    var a = !this.state.strict ? fe : s ? me : de;
                    if (a(t, this.inModule)) {
                        if (!this.scope.inAsync && t === "await") {
                            this.raise(i, "Can not use keyword 'await' outside an async function");
                        }
                        this.raise(i, "Unexpected reserved word '" + t + "'");
                    }
                }
            }, {
                key: "parseAwait",
                value: function e() {
                    if (!this.state.awaitPos) {
                        this.state.awaitPos = this.state.start;
                    }
                    var t = this.startNode();
                    this.next();
                    if (this.state.inParameters) {
                        this.raise(t.start, "await is not allowed in async function parameters");
                    }
                    if (this.match(b.star)) {
                        this.raise(t.start, "await* has been removed from the async functions proposal. Use Promise.all() instead.");
                    }
                    t.argument = this.parseMaybeUnary();
                    return this.finishNode(t, "AwaitExpression");
                }
            }, {
                key: "parseYield",
                value: function e(t) {
                    if (!this.state.yieldPos) {
                        this.state.yieldPos = this.state.start;
                    }
                    var i = this.startNode();
                    if (this.state.inParameters) {
                        this.raise(i.start, "yield is not allowed in generator parameters");
                    }
                    this.next();
                    if (this.match(b.semi) || !this.match(b.star) && !this.state.type.startsExpr || this.canInsertSemicolon()) {
                        i.delegate = false;
                        i.argument = null;
                    } else {
                        i.delegate = this.eat(b.star);
                        i.argument = this.parseMaybeAssign(t);
                    }
                    return this.finishNode(i, "YieldExpression");
                }
            }, {
                key: "checkPipelineAtInfixOperator",
                value: function e(t, i) {
                    if (this.getPluginOption("pipelineOperator", "proposal") === "smart") {
                        if (t.type === "SequenceExpression") {
                            throw this.raise(i, "Pipeline head should not be a comma-separated sequence expression");
                        }
                    }
                }
            }, {
                key: "parseSmartPipelineBody",
                value: function e(t, i, r) {
                    var s = this.checkSmartPipelineBodyStyle(t);
                    this.checkSmartPipelineBodyEarlyErrors(t, s, i);
                    return this.parseSmartPipelineBodyInStyle(t, s, i, r);
                }
            }, {
                key: "checkSmartPipelineBodyEarlyErrors",
                value: function e(t, i, r) {
                    if (this.match(b.arrow)) {
                        throw this.raise(this.state.start, 'Unexpected arrow "=>" after pipeline body; arrow function in pipeline body must be parenthesized');
                    } else if (i === "PipelineTopicExpression" && t.type === "SequenceExpression") {
                        throw this.raise(r, "Pipeline body may not be a comma-separated sequence expression");
                    }
                }
            }, {
                key: "parseSmartPipelineBodyInStyle",
                value: function e(t, i, r, s) {
                    var a = this.startNodeAt(r, s);
                    switch (i) {
                      case "PipelineBareFunction":
                        a.callee = t;
                        break;

                      case "PipelineBareConstructor":
                        a.callee = t.callee;
                        break;

                      case "PipelineBareAwaitedFunction":
                        a.callee = t.argument;
                        break;

                      case "PipelineTopicExpression":
                        if (!this.topicReferenceWasUsedInCurrentTopicContext()) {
                            throw this.raise(r, "Pipeline is in topic style but does not use topic reference");
                        }
                        a.expression = t;
                        break;

                      default:
                        throw this.raise(r, "Unknown pipeline style " + i);
                    }
                    return this.finishNode(a, i);
                }
            }, {
                key: "checkSmartPipelineBodyStyle",
                value: function e(t) {
                    switch (t.type) {
                      default:
                        return this.isSimpleReference(t) ? "PipelineBareFunction" : "PipelineTopicExpression";
                    }
                }
            }, {
                key: "isSimpleReference",
                value: function e(t) {
                    switch (t.type) {
                      case "MemberExpression":
                        return !t.computed && this.isSimpleReference(t.object);

                      case "Identifier":
                        return true;

                      default:
                        return false;
                    }
                }
            }, {
                key: "withTopicPermittingContext",
                value: function e(t) {
                    var i = this.state.topicContext;
                    this.state.topicContext = {
                        maxNumOfResolvableTopics: 1,
                        maxTopicIndex: null
                    };
                    try {
                        return t();
                    } finally {
                        this.state.topicContext = i;
                    }
                }
            }, {
                key: "withTopicForbiddingContext",
                value: function e(t) {
                    var i = this.state.topicContext;
                    this.state.topicContext = {
                        maxNumOfResolvableTopics: 0,
                        maxTopicIndex: null
                    };
                    try {
                        return t();
                    } finally {
                        this.state.topicContext = i;
                    }
                }
            }, {
                key: "registerTopicReference",
                value: function e() {
                    this.state.topicContext.maxTopicIndex = 0;
                }
            }, {
                key: "primaryTopicReferenceIsAllowedInCurrentTopicContext",
                value: function e() {
                    return this.state.topicContext.maxNumOfResolvableTopics >= 1;
                }
            }, {
                key: "topicReferenceWasUsedInCurrentTopicContext",
                value: function e() {
                    return this.state.topicContext.maxTopicIndex != null && this.state.topicContext.maxTopicIndex >= 0;
                }
            } ]);
            return t;
        }(St);
        var Ct = {
            kind: "loop"
        }, Tt = {
            kind: "switch"
        };
        var Pt = 0, Dt = 1, _t = 2, Nt = 4;
        var Ft = function(e) {
            l(t, e);
            function t() {
                u(this, t);
                return o(this, (t.__proto__ || Object.getPrototypeOf(t)).apply(this, arguments));
            }
            s(t, [ {
                key: "parseTopLevel",
                value: function e(t, i) {
                    i.sourceType = this.options.sourceType;
                    i.interpreter = this.parseInterpreterDirective();
                    this.parseBlockBody(i, true, true, b.eof);
                    if (this.inModule && this.scope.undefinedExports.size > 0) {
                        for (var s = 0, a = Array.from(this.scope.undefinedExports); s < a.length; s++) {
                            var n = r(a[s], 1), o = n[0];
                            var l = this.scope.undefinedExports.get(o);
                            this.raise(l, "Export '" + o + "' is not defined");
                        }
                    }
                    t.program = this.finishNode(i, "Program");
                    t.comments = this.state.comments;
                    if (this.options.tokens) t.tokens = this.state.tokens;
                    return this.finishNode(t, "File");
                }
            }, {
                key: "stmtToDirective",
                value: function e(t) {
                    var i = t.expression;
                    var r = this.startNodeAt(i.start, i.loc.start);
                    var s = this.startNodeAt(t.start, t.loc.start);
                    var a = this.input.slice(i.start, i.end);
                    var n = r.value = a.slice(1, -1);
                    this.addExtra(r, "raw", a);
                    this.addExtra(r, "rawValue", n);
                    s.value = this.finishNodeAt(r, "DirectiveLiteral", i.end, i.loc.end);
                    return this.finishNodeAt(s, "Directive", t.end, t.loc.end);
                }
            }, {
                key: "parseInterpreterDirective",
                value: function e() {
                    if (!this.match(b.interpreterDirective)) {
                        return null;
                    }
                    var t = this.startNode();
                    t.value = this.state.value;
                    this.next();
                    return this.finishNode(t, "InterpreterDirective");
                }
            }, {
                key: "isLet",
                value: function e(t) {
                    if (!this.isContextual("let")) {
                        return false;
                    }
                    ne.lastIndex = this.state.pos;
                    var i = ne.exec(this.input);
                    var r = this.state.pos + i[0].length;
                    var s = this.input.charCodeAt(r);
                    if (s === 91) return true;
                    if (t) return false;
                    if (s === 123) return true;
                    if (Ae(s)) {
                        var a = r + 1;
                        while (Te(this.input.charCodeAt(a))) {
                            ++a;
                        }
                        var n = this.input.slice(r, a);
                        if (!ve.test(n)) return true;
                    }
                    return false;
                }
            }, {
                key: "parseStatement",
                value: function e(t, i) {
                    if (this.match(b.at)) {
                        this.parseDecorators(true);
                    }
                    return this.parseStatementContent(t, i);
                }
            }, {
                key: "parseStatementContent",
                value: function e(t, i) {
                    var r = this.state.type;
                    var s = this.startNode();
                    var a = void 0;
                    if (this.isLet(t)) {
                        r = b._var;
                        a = "let";
                    }
                    switch (r) {
                      case b._break:
                      case b._continue:
                        return this.parseBreakContinueStatement(s, r.keyword);

                      case b._debugger:
                        return this.parseDebuggerStatement(s);

                      case b._do:
                        return this.parseDoStatement(s);

                      case b._for:
                        return this.parseForStatement(s);

                      case b._function:
                        if (this.lookahead().type === b.dot) break;
                        if (t) {
                            if (this.state.strict) {
                                this.raise(this.state.start, "In strict mode code, functions can only be declared at top level or inside a block");
                            } else if (t !== "if" && t !== "label") {
                                this.raise(this.state.start, "In non-strict mode code, functions can only be declared at top level, " + "inside a block, or as the body of an if statement");
                            }
                        }
                        return this.parseFunctionStatement(s, false, !t);

                      case b._class:
                        if (t) this.unexpected();
                        return this.parseClass(s, true);

                      case b._if:
                        return this.parseIfStatement(s);

                      case b._return:
                        return this.parseReturnStatement(s);

                      case b._switch:
                        return this.parseSwitchStatement(s);

                      case b._throw:
                        return this.parseThrowStatement(s);

                      case b._try:
                        return this.parseTryStatement(s);

                      case b._const:
                      case b._var:
                        a = a || this.state.value;
                        if (t && a !== "var") {
                            this.unexpected(this.state.start, "Lexical declaration cannot appear in a single-statement context");
                        }
                        return this.parseVarStatement(s, a);

                      case b._while:
                        return this.parseWhileStatement(s);

                      case b._with:
                        return this.parseWithStatement(s);

                      case b.braceL:
                        return this.parseBlock();

                      case b.semi:
                        return this.parseEmptyStatement(s);

                      case b._export:
                      case b._import:
                        {
                            var n = this.lookahead();
                            if (n.type === b.parenL || n.type === b.dot) {
                                break;
                            }
                            if (!this.options.allowImportExportEverywhere && !i) {
                                this.raise(this.state.start, "'import' and 'export' may only appear at the top level");
                            }
                            this.next();
                            var o = void 0;
                            if (r === b._import) {
                                o = this.parseImport(s);
                                if (o.type === "ImportDeclaration" && (!o.importKind || o.importKind === "value")) {
                                    this.sawUnambiguousESM = true;
                                }
                            } else {
                                o = this.parseExport(s);
                                if (o.type === "ExportNamedDeclaration" && (!o.exportKind || o.exportKind === "value") || o.type === "ExportAllDeclaration" && (!o.exportKind || o.exportKind === "value") || o.type === "ExportDefaultDeclaration") {
                                    this.sawUnambiguousESM = true;
                                }
                            }
                            this.assertModuleNodeAllowed(s);
                            return o;
                        }

                      default:
                        {
                            if (this.isAsyncFunction()) {
                                if (t) {
                                    this.unexpected(null, "Async functions can only be declared at the top level or inside a block");
                                }
                                this.next();
                                return this.parseFunctionStatement(s, true, !t);
                            }
                        }
                    }
                    var l = this.state.value;
                    var u = this.parseExpression();
                    if (r === b.name && u.type === "Identifier" && this.eat(b.colon)) {
                        return this.parseLabeledStatement(s, l, u, t);
                    } else {
                        return this.parseExpressionStatement(s, u);
                    }
                }
            }, {
                key: "assertModuleNodeAllowed",
                value: function e(t) {
                    if (!this.options.allowImportExportEverywhere && !this.inModule) {
                        this.raise(t.start, "'import' and 'export' may appear only with 'sourceType: \"module\"'", {
                            code: "BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED"
                        });
                    }
                }
            }, {
                key: "takeDecorators",
                value: function e(t) {
                    var i = this.state.decoratorStack[this.state.decoratorStack.length - 1];
                    if (i.length) {
                        t.decorators = i;
                        this.resetStartLocationFromNode(t, i[0]);
                        this.state.decoratorStack[this.state.decoratorStack.length - 1] = [];
                    }
                }
            }, {
                key: "canHaveLeadingDecorator",
                value: function e() {
                    return this.match(b._class);
                }
            }, {
                key: "parseDecorators",
                value: function e(t) {
                    var i = this.state.decoratorStack[this.state.decoratorStack.length - 1];
                    while (this.match(b.at)) {
                        var r = this.parseDecorator();
                        i.push(r);
                    }
                    if (this.match(b._export)) {
                        if (!t) {
                            this.unexpected();
                        }
                        if (this.hasPlugin("decorators") && !this.getPluginOption("decorators", "decoratorsBeforeExport")) {
                            this.raise(this.state.start, "Using the export keyword between a decorator and a class is not allowed. " + "Please use `export @dec class` instead.");
                        }
                    } else if (!this.canHaveLeadingDecorator()) {
                        this.raise(this.state.start, "Leading decorators must be attached to a class declaration");
                    }
                }
            }, {
                key: "parseDecorator",
                value: function e() {
                    this.expectOnePlugin([ "decorators-legacy", "decorators" ]);
                    var t = this.startNode();
                    this.next();
                    if (this.hasPlugin("decorators")) {
                        this.state.decoratorStack.push([]);
                        var i = this.state.start;
                        var r = this.state.startLoc;
                        var s = void 0;
                        if (this.eat(b.parenL)) {
                            s = this.parseExpression();
                            this.expect(b.parenR);
                        } else {
                            s = this.parseIdentifier(false);
                            while (this.eat(b.dot)) {
                                var a = this.startNodeAt(i, r);
                                a.object = s;
                                a.property = this.parseIdentifier(true);
                                a.computed = false;
                                s = this.finishNode(a, "MemberExpression");
                            }
                        }
                        t.expression = this.parseMaybeDecoratorArguments(s);
                        this.state.decoratorStack.pop();
                    } else {
                        t.expression = this.parseMaybeAssign();
                    }
                    return this.finishNode(t, "Decorator");
                }
            }, {
                key: "parseMaybeDecoratorArguments",
                value: function e(t) {
                    if (this.eat(b.parenL)) {
                        var i = this.startNodeAtNode(t);
                        i.callee = t;
                        i.arguments = this.parseCallExpressionArguments(b.parenR, false);
                        this.toReferencedList(i.arguments);
                        return this.finishNode(i, "CallExpression");
                    }
                    return t;
                }
            }, {
                key: "parseBreakContinueStatement",
                value: function e(t, i) {
                    var r = i === "break";
                    this.next();
                    if (this.isLineTerminator()) {
                        t.label = null;
                    } else {
                        t.label = this.parseIdentifier();
                        this.semicolon();
                    }
                    this.verifyBreakContinue(t, i);
                    return this.finishNode(t, r ? "BreakStatement" : "ContinueStatement");
                }
            }, {
                key: "verifyBreakContinue",
                value: function e(t, i) {
                    var r = i === "break";
                    var s = void 0;
                    for (s = 0; s < this.state.labels.length; ++s) {
                        var a = this.state.labels[s];
                        if (t.label == null || a.name === t.label.name) {
                            if (a.kind != null && (r || a.kind === "loop")) break;
                            if (t.label && r) break;
                        }
                    }
                    if (s === this.state.labels.length) {
                        this.raise(t.start, "Unsyntactic " + i);
                    }
                }
            }, {
                key: "parseDebuggerStatement",
                value: function e(t) {
                    this.next();
                    this.semicolon();
                    return this.finishNode(t, "DebuggerStatement");
                }
            }, {
                key: "parseHeaderExpression",
                value: function e() {
                    this.expect(b.parenL);
                    var t = this.parseExpression();
                    this.expect(b.parenR);
                    return t;
                }
            }, {
                key: "parseDoStatement",
                value: function e(t) {
                    var i = this;
                    this.next();
                    this.state.labels.push(Ct);
                    t.body = this.withTopicForbiddingContext(function() {
                        return i.parseStatement("do");
                    });
                    this.state.labels.pop();
                    this.expect(b._while);
                    t.test = this.parseHeaderExpression();
                    this.eat(b.semi);
                    return this.finishNode(t, "DoWhileStatement");
                }
            }, {
                key: "parseForStatement",
                value: function e(t) {
                    this.next();
                    this.state.labels.push(Ct);
                    var i = -1;
                    if ((this.scope.inAsync || !this.scope.inFunction && this.options.allowAwaitOutsideFunction) && this.eatContextual("await")) {
                        i = this.state.lastTokStart;
                    }
                    this.scope.enter(E);
                    this.expect(b.parenL);
                    if (this.match(b.semi)) {
                        if (i > -1) {
                            this.unexpected(i);
                        }
                        return this.parseFor(t, null);
                    }
                    var r = this.isLet();
                    if (this.match(b._var) || this.match(b._const) || r) {
                        var s = this.startNode();
                        var a = r ? "let" : this.state.value;
                        this.next();
                        this.parseVar(s, true, a);
                        this.finishNode(s, "VariableDeclaration");
                        if ((this.match(b._in) || this.isContextual("of")) && s.declarations.length === 1) {
                            return this.parseForIn(t, s, i);
                        }
                        if (i > -1) {
                            this.unexpected(i);
                        }
                        return this.parseFor(t, s);
                    }
                    var n = {
                        start: 0
                    };
                    var o = this.parseExpression(true, n);
                    if (this.match(b._in) || this.isContextual("of")) {
                        var l = this.isContextual("of") ? "for-of statement" : "for-in statement";
                        this.toAssignable(o, undefined, l);
                        this.checkLVal(o, undefined, undefined, l);
                        return this.parseForIn(t, o, i);
                    } else if (n.start) {
                        this.unexpected(n.start);
                    }
                    if (i > -1) {
                        this.unexpected(i);
                    }
                    return this.parseFor(t, o);
                }
            }, {
                key: "parseFunctionStatement",
                value: function e(t, i, r) {
                    this.next();
                    return this.parseFunction(t, Dt | (r ? 0 : _t), i);
                }
            }, {
                key: "parseIfStatement",
                value: function e(t) {
                    this.next();
                    t.test = this.parseHeaderExpression();
                    t.consequent = this.parseStatement("if");
                    t.alternate = this.eat(b._else) ? this.parseStatement("if") : null;
                    return this.finishNode(t, "IfStatement");
                }
            }, {
                key: "parseReturnStatement",
                value: function e(t) {
                    if (!this.scope.inFunction && !this.options.allowReturnOutsideFunction) {
                        this.raise(this.state.start, "'return' outside of function");
                    }
                    this.next();
                    if (this.isLineTerminator()) {
                        t.argument = null;
                    } else {
                        t.argument = this.parseExpression();
                        this.semicolon();
                    }
                    return this.finishNode(t, "ReturnStatement");
                }
            }, {
                key: "parseSwitchStatement",
                value: function e(t) {
                    this.next();
                    t.discriminant = this.parseHeaderExpression();
                    var i = t.cases = [];
                    this.expect(b.braceL);
                    this.state.labels.push(Tt);
                    this.scope.enter(E);
                    var r = void 0;
                    for (var s; !this.match(b.braceR); ) {
                        if (this.match(b._case) || this.match(b._default)) {
                            var a = this.match(b._case);
                            if (r) this.finishNode(r, "SwitchCase");
                            i.push(r = this.startNode());
                            r.consequent = [];
                            this.next();
                            if (a) {
                                r.test = this.parseExpression();
                            } else {
                                if (s) {
                                    this.raise(this.state.lastTokStart, "Multiple default clauses");
                                }
                                s = true;
                                r.test = null;
                            }
                            this.expect(b.colon);
                        } else {
                            if (r) {
                                r.consequent.push(this.parseStatement(null));
                            } else {
                                this.unexpected();
                            }
                        }
                    }
                    this.scope.exit();
                    if (r) this.finishNode(r, "SwitchCase");
                    this.next();
                    this.state.labels.pop();
                    return this.finishNode(t, "SwitchStatement");
                }
            }, {
                key: "parseThrowStatement",
                value: function e(t) {
                    this.next();
                    if (re.test(this.input.slice(this.state.lastTokEnd, this.state.start))) {
                        this.raise(this.state.lastTokEnd, "Illegal newline after throw");
                    }
                    t.argument = this.parseExpression();
                    this.semicolon();
                    return this.finishNode(t, "ThrowStatement");
                }
            }, {
                key: "parseTryStatement",
                value: function e(t) {
                    var i = this;
                    this.next();
                    t.block = this.parseBlock();
                    t.handler = null;
                    if (this.match(b._catch)) {
                        var r = this.startNode();
                        this.next();
                        if (this.match(b.parenL)) {
                            this.expect(b.parenL);
                            r.param = this.parseBindingAtom();
                            var s = r.param.type === "Identifier";
                            this.scope.enter(s ? T : 0);
                            this.checkLVal(r.param, J, null, "catch clause");
                            this.expect(b.parenR);
                        } else {
                            r.param = null;
                            this.scope.enter(E);
                        }
                        r.body = this.withTopicForbiddingContext(function() {
                            return i.parseBlock(false, false);
                        });
                        this.scope.exit();
                        t.handler = this.finishNode(r, "CatchClause");
                    }
                    t.finalizer = this.eat(b._finally) ? this.parseBlock() : null;
                    if (!t.handler && !t.finalizer) {
                        this.raise(t.start, "Missing catch or finally clause");
                    }
                    return this.finishNode(t, "TryStatement");
                }
            }, {
                key: "parseVarStatement",
                value: function e(t, i) {
                    this.next();
                    this.parseVar(t, false, i);
                    this.semicolon();
                    return this.finishNode(t, "VariableDeclaration");
                }
            }, {
                key: "parseWhileStatement",
                value: function e(t) {
                    var i = this;
                    this.next();
                    t.test = this.parseHeaderExpression();
                    this.state.labels.push(Ct);
                    t.body = this.withTopicForbiddingContext(function() {
                        return i.parseStatement("while");
                    });
                    this.state.labels.pop();
                    return this.finishNode(t, "WhileStatement");
                }
            }, {
                key: "parseWithStatement",
                value: function e(t) {
                    var i = this;
                    if (this.state.strict) {
                        this.raise(this.state.start, "'with' in strict mode");
                    }
                    this.next();
                    t.object = this.parseHeaderExpression();
                    t.body = this.withTopicForbiddingContext(function() {
                        return i.parseStatement("with");
                    });
                    return this.finishNode(t, "WithStatement");
                }
            }, {
                key: "parseEmptyStatement",
                value: function e(t) {
                    this.next();
                    return this.finishNode(t, "EmptyStatement");
                }
            }, {
                key: "parseLabeledStatement",
                value: function e(t, i, r, s) {
                    for (var a = 0, n = this.state.labels; a < n.length; a++) {
                        var o = n[a];
                        if (o.name === i) {
                            this.raise(r.start, "Label '" + i + "' is already declared");
                        }
                    }
                    var l = this.state.type.isLoop ? "loop" : this.match(b._switch) ? "switch" : null;
                    for (var u = this.state.labels.length - 1; u >= 0; u--) {
                        var c = this.state.labels[u];
                        if (c.statementStart === t.start) {
                            c.statementStart = this.state.start;
                            c.kind = l;
                        } else {
                            break;
                        }
                    }
                    this.state.labels.push({
                        name: i,
                        kind: l,
                        statementStart: this.state.start
                    });
                    t.body = this.parseStatement(s ? s.indexOf("label") === -1 ? s + "label" : s : "label");
                    this.state.labels.pop();
                    t.label = r;
                    return this.finishNode(t, "LabeledStatement");
                }
            }, {
                key: "parseExpressionStatement",
                value: function e(t, i) {
                    t.expression = i;
                    this.semicolon();
                    return this.finishNode(t, "ExpressionStatement");
                }
            }, {
                key: "parseBlock",
                value: function e() {
                    var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
                    var i = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
                    var r = this.startNode();
                    this.expect(b.braceL);
                    if (i) {
                        this.scope.enter(E);
                    }
                    this.parseBlockBody(r, t, false, b.braceR);
                    if (i) {
                        this.scope.exit();
                    }
                    return this.finishNode(r, "BlockStatement");
                }
            }, {
                key: "isValidDirective",
                value: function e(t) {
                    return t.type === "ExpressionStatement" && t.expression.type === "StringLiteral" && !t.expression.extra.parenthesized;
                }
            }, {
                key: "parseBlockBody",
                value: function e(t, i, r, s) {
                    var a = t.body = [];
                    var n = t.directives = [];
                    this.parseBlockOrModuleBlockBody(a, i ? n : undefined, r, s);
                }
            }, {
                key: "parseBlockOrModuleBlockBody",
                value: function e(t, i, r, s) {
                    var a = false;
                    var n = void 0;
                    var o = void 0;
                    while (!this.eat(s)) {
                        if (!a && this.state.containsOctal && !o) {
                            o = this.state.octalPosition;
                        }
                        var l = this.parseStatement(null, r);
                        if (i && !a && this.isValidDirective(l)) {
                            var u = this.stmtToDirective(l);
                            i.push(u);
                            if (n === undefined && u.value.value === "use strict") {
                                n = this.state.strict;
                                this.setStrict(true);
                                if (o) {
                                    this.raise(o, "Octal literal in strict mode");
                                }
                            }
                            continue;
                        }
                        a = true;
                        t.push(l);
                    }
                    if (n === false) {
                        this.setStrict(false);
                    }
                }
            }, {
                key: "parseFor",
                value: function e(t, i) {
                    var r = this;
                    t.init = i;
                    this.expect(b.semi);
                    t.test = this.match(b.semi) ? null : this.parseExpression();
                    this.expect(b.semi);
                    t.update = this.match(b.parenR) ? null : this.parseExpression();
                    this.expect(b.parenR);
                    t.body = this.withTopicForbiddingContext(function() {
                        return r.parseStatement("for");
                    });
                    this.scope.exit();
                    this.state.labels.pop();
                    return this.finishNode(t, "ForStatement");
                }
            }, {
                key: "parseForIn",
                value: function e(t, i, r) {
                    var s = this;
                    var a = this.match(b._in);
                    this.next();
                    if (a) {
                        if (r > -1) this.unexpected(r);
                    } else {
                        t.await = r > -1;
                    }
                    if (i.type === "VariableDeclaration" && i.declarations[0].init != null && (!a || this.state.strict || i.kind !== "var" || i.declarations[0].id.type !== "Identifier")) {
                        this.raise(i.start, (a ? "for-in" : "for-of") + " loop variable declaration may not have an initializer");
                    } else if (i.type === "AssignmentPattern") {
                        this.raise(i.start, "Invalid left-hand side in for-loop");
                    }
                    t.left = i;
                    t.right = a ? this.parseExpression() : this.parseMaybeAssign();
                    this.expect(b.parenR);
                    t.body = this.withTopicForbiddingContext(function() {
                        return s.parseStatement("for");
                    });
                    this.scope.exit();
                    this.state.labels.pop();
                    return this.finishNode(t, a ? "ForInStatement" : "ForOfStatement");
                }
            }, {
                key: "parseVar",
                value: function e(t, i, r) {
                    var s = t.declarations = [];
                    var a = this.hasPlugin("typescript");
                    t.kind = r;
                    for (;;) {
                        var n = this.startNode();
                        this.parseVarId(n, r);
                        if (this.eat(b.eq)) {
                            n.init = this.parseMaybeAssign(i);
                        } else {
                            if (r === "const" && !(this.match(b._in) || this.isContextual("of"))) {
                                if (!a) {
                                    this.unexpected();
                                }
                            } else if (n.id.type !== "Identifier" && !(i && (this.match(b._in) || this.isContextual("of")))) {
                                this.raise(this.state.lastTokEnd, "Complex binding patterns require an initialization value");
                            }
                            n.init = null;
                        }
                        s.push(this.finishNode(n, "VariableDeclarator"));
                        if (!this.eat(b.comma)) break;
                    }
                    return t;
                }
            }, {
                key: "parseVarId",
                value: function e(t, i) {
                    if ((i === "const" || i === "let") && this.isContextual("let")) {
                        this.unexpected(null, "let is disallowed as a lexically bound name");
                    }
                    t.id = this.parseBindingAtom();
                    this.checkLVal(t.id, i === "var" ? z : J, undefined, "variable declaration");
                }
            }, {
                key: "parseFunction",
                value: function e(t) {
                    var i = this;
                    var r = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Pt;
                    var s = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
                    var a = r & Dt;
                    var n = r & _t;
                    var o = !!a && !(r & Nt);
                    this.initFunction(t, s);
                    if (this.match(b.star) && n) {
                        this.unexpected(this.state.start, "Generators can only be declared at the top level or inside a block");
                    }
                    t.generator = this.eat(b.star);
                    if (a) {
                        t.id = this.parseFunctionId(o);
                    }
                    var l = this.state.inClassProperty;
                    var u = this.state.yieldPos;
                    var c = this.state.awaitPos;
                    this.state.inClassProperty = false;
                    this.state.yieldPos = 0;
                    this.state.awaitPos = 0;
                    this.scope.enter(F(t.async, t.generator));
                    if (!a) {
                        t.id = this.parseFunctionId();
                    }
                    this.parseFunctionParams(t);
                    this.withTopicForbiddingContext(function() {
                        i.parseFunctionBodyAndFinish(t, a ? "FunctionDeclaration" : "FunctionExpression");
                    });
                    this.scope.exit();
                    if (a && !n) {
                        this.checkFunctionStatementId(t);
                    }
                    this.state.inClassProperty = l;
                    this.state.yieldPos = u;
                    this.state.awaitPos = c;
                    return t;
                }
            }, {
                key: "parseFunctionId",
                value: function e(t) {
                    return t || this.match(b.name) ? this.parseIdentifier() : null;
                }
            }, {
                key: "parseFunctionParams",
                value: function e(t, i) {
                    var r = this.state.inParameters;
                    this.state.inParameters = true;
                    this.expect(b.parenL);
                    t.params = this.parseBindingList(b.parenR, false, i);
                    this.state.inParameters = r;
                    this.checkYieldAwaitInDefaultParams();
                }
            }, {
                key: "checkFunctionStatementId",
                value: function e(t) {
                    if (!t.id) return;
                    this.checkLVal(t.id, this.state.strict || t.generator || t.async ? this.scope.treatFunctionsAsVar ? z : J : W, null, "function name");
                }
            }, {
                key: "parseClass",
                value: function e(t, i, r) {
                    this.next();
                    this.takeDecorators(t);
                    var s = this.state.strict;
                    this.state.strict = true;
                    this.parseClassId(t, i, r);
                    this.parseClassSuper(t);
                    t.body = this.parseClassBody(!!t.superClass);
                    this.state.strict = s;
                    return this.finishNode(t, i ? "ClassDeclaration" : "ClassExpression");
                }
            }, {
                key: "isClassProperty",
                value: function e() {
                    return this.match(b.eq) || this.match(b.semi) || this.match(b.braceR);
                }
            }, {
                key: "isClassMethod",
                value: function e() {
                    return this.match(b.parenL);
                }
            }, {
                key: "isNonstaticConstructor",
                value: function e(t) {
                    return !t.computed && !t.static && (t.key.name === "constructor" || t.key.value === "constructor");
                }
            }, {
                key: "parseClassBody",
                value: function e(t) {
                    var i = this;
                    this.state.classLevel++;
                    var r = {
                        hadConstructor: false
                    };
                    var s = [];
                    var a = this.startNode();
                    a.body = [];
                    this.expect(b.braceL);
                    this.withTopicForbiddingContext(function() {
                        while (!i.eat(b.braceR)) {
                            if (i.eat(b.semi)) {
                                if (s.length > 0) {
                                    i.raise(i.state.lastTokEnd, "Decorators must not be followed by a semicolon");
                                }
                                continue;
                            }
                            if (i.match(b.at)) {
                                s.push(i.parseDecorator());
                                continue;
                            }
                            var e = i.startNode();
                            if (s.length) {
                                e.decorators = s;
                                i.resetStartLocationFromNode(e, s[0]);
                                s = [];
                            }
                            i.parseClassMember(a, e, r, t);
                            if (e.kind === "constructor" && e.decorators && e.decorators.length > 0) {
                                i.raise(e.start, "Decorators can't be used with a constructor. Did you mean '@dec class { ... }'?");
                            }
                        }
                    });
                    if (s.length) {
                        this.raise(this.state.start, "You have trailing decorators with no method");
                    }
                    this.state.classLevel--;
                    return this.finishNode(a, "ClassBody");
                }
            }, {
                key: "parseClassMember",
                value: function e(t, i, r, s) {
                    var a = false;
                    var n = this.state.containsEsc;
                    if (this.match(b.name) && this.state.value === "static") {
                        var o = this.parseIdentifier(true);
                        if (this.isClassMethod()) {
                            var l = i;
                            l.kind = "method";
                            l.computed = false;
                            l.key = o;
                            l.static = false;
                            this.pushClassMethod(t, l, false, false, false, false);
                            return;
                        } else if (this.isClassProperty()) {
                            var u = i;
                            u.computed = false;
                            u.key = o;
                            u.static = false;
                            t.body.push(this.parseClassProperty(u));
                            return;
                        } else if (n) {
                            throw this.unexpected();
                        }
                        a = true;
                    }
                    this.parseClassMemberWithIsStatic(t, i, r, a, s);
                }
            }, {
                key: "parseClassMemberWithIsStatic",
                value: function e(t, i, r, s, a) {
                    var n = i;
                    var o = i;
                    var l = i;
                    var u = i;
                    var c = n;
                    var h = n;
                    i.static = s;
                    if (this.eat(b.star)) {
                        c.kind = "method";
                        this.parseClassPropertyName(c);
                        if (c.key.type === "PrivateName") {
                            this.pushClassPrivateMethod(t, o, true, false);
                            return;
                        }
                        if (this.isNonstaticConstructor(n)) {
                            this.raise(n.key.start, "Constructor can't be a generator");
                        }
                        this.pushClassMethod(t, n, true, false, false, false);
                        return;
                    }
                    var p = this.state.containsEsc;
                    var f = this.parseClassPropertyName(i);
                    var d = f.type === "PrivateName";
                    var m = f.type === "Identifier";
                    this.parsePostMemberNameModifiers(h);
                    if (this.isClassMethod()) {
                        c.kind = "method";
                        if (d) {
                            this.pushClassPrivateMethod(t, o, false, false);
                            return;
                        }
                        var y = this.isNonstaticConstructor(n);
                        var v = false;
                        if (y) {
                            n.kind = "constructor";
                            if (n.decorators) {
                                this.raise(n.start, "You can't attach decorators to a class constructor");
                            }
                            if (r.hadConstructor && !this.hasPlugin("typescript")) {
                                this.raise(f.start, "Duplicate constructor in the same class");
                            }
                            r.hadConstructor = true;
                            v = a;
                        }
                        this.pushClassMethod(t, n, false, false, y, v);
                    } else if (this.isClassProperty()) {
                        if (d) {
                            this.pushClassPrivateProperty(t, u);
                        } else {
                            this.pushClassProperty(t, l);
                        }
                    } else if (m && f.name === "async" && !p && !this.isLineTerminator()) {
                        var x = this.eat(b.star);
                        c.kind = "method";
                        this.parseClassPropertyName(c);
                        if (c.key.type === "PrivateName") {
                            this.pushClassPrivateMethod(t, o, x, true);
                        } else {
                            if (this.isNonstaticConstructor(n)) {
                                this.raise(n.key.start, "Constructor can't be an async function");
                            }
                            this.pushClassMethod(t, n, x, true, false, false);
                        }
                    } else if (m && (f.name === "get" || f.name === "set") && !p && !(this.match(b.star) && this.isLineTerminator())) {
                        c.kind = f.name;
                        this.parseClassPropertyName(n);
                        if (c.key.type === "PrivateName") {
                            this.pushClassPrivateMethod(t, o, false, false);
                        } else {
                            if (this.isNonstaticConstructor(n)) {
                                this.raise(n.key.start, "Constructor can't have get/set modifier");
                            }
                            this.pushClassMethod(t, n, false, false, false, false);
                        }
                        this.checkGetterSetterParams(n);
                    } else if (this.isLineTerminator()) {
                        if (d) {
                            this.pushClassPrivateProperty(t, u);
                        } else {
                            this.pushClassProperty(t, l);
                        }
                    } else {
                        this.unexpected();
                    }
                }
            }, {
                key: "parseClassPropertyName",
                value: function e(t) {
                    var i = this.parsePropertyName(t);
                    if (!t.computed && t.static && (i.name === "prototype" || i.value === "prototype")) {
                        this.raise(i.start, "Classes may not have static property named prototype");
                    }
                    if (i.type === "PrivateName" && i.id.name === "constructor") {
                        this.raise(i.start, "Classes may not have a private field named '#constructor'");
                    }
                    return i;
                }
            }, {
                key: "pushClassProperty",
                value: function e(t, i) {
                    if (this.isNonstaticConstructor(i)) {
                        this.raise(i.key.start, "Classes may not have a non-static field named 'constructor'");
                    }
                    t.body.push(this.parseClassProperty(i));
                }
            }, {
                key: "pushClassPrivateProperty",
                value: function e(t, i) {
                    this.expectPlugin("classPrivateProperties", i.key.start);
                    t.body.push(this.parseClassPrivateProperty(i));
                }
            }, {
                key: "pushClassMethod",
                value: function e(t, i, r, s, a, n) {
                    t.body.push(this.parseMethod(i, r, s, a, n, "ClassMethod", true));
                }
            }, {
                key: "pushClassPrivateMethod",
                value: function e(t, i, r, s) {
                    this.expectPlugin("classPrivateMethods", i.key.start);
                    t.body.push(this.parseMethod(i, r, s, false, false, "ClassPrivateMethod", true));
                }
            }, {
                key: "parsePostMemberNameModifiers",
                value: function e(t) {}
            }, {
                key: "parseAccessModifier",
                value: function e() {
                    return undefined;
                }
            }, {
                key: "parseClassPrivateProperty",
                value: function e(t) {
                    this.state.inClassProperty = true;
                    this.scope.enter(_ | P);
                    t.value = this.eat(b.eq) ? this.parseMaybeAssign() : null;
                    this.semicolon();
                    this.state.inClassProperty = false;
                    this.scope.exit();
                    return this.finishNode(t, "ClassPrivateProperty");
                }
            }, {
                key: "parseClassProperty",
                value: function e(t) {
                    if (!t.typeAnnotation) {
                        this.expectPlugin("classProperties");
                    }
                    this.state.inClassProperty = true;
                    this.scope.enter(_ | P);
                    if (this.match(b.eq)) {
                        this.expectPlugin("classProperties");
                        this.next();
                        t.value = this.parseMaybeAssign();
                    } else {
                        t.value = null;
                    }
                    this.semicolon();
                    this.state.inClassProperty = false;
                    this.scope.exit();
                    return this.finishNode(t, "ClassProperty");
                }
            }, {
                key: "parseClassId",
                value: function e(t, i, r) {
                    if (this.match(b.name)) {
                        t.id = this.parseIdentifier();
                        if (i) {
                            this.checkLVal(t.id, q, undefined, "class name");
                        }
                    } else {
                        if (r || !i) {
                            t.id = null;
                        } else {
                            this.unexpected(null, "A class name is required");
                        }
                    }
                }
            }, {
                key: "parseClassSuper",
                value: function e(t) {
                    t.superClass = this.eat(b._extends) ? this.parseExprSubscripts() : null;
                }
            }, {
                key: "parseExport",
                value: function e(t) {
                    var i = this.maybeParseExportDefaultSpecifier(t);
                    var r = !i || this.eat(b.comma);
                    var s = r && this.eatExportStar(t);
                    var a = s && this.maybeParseExportNamespaceSpecifier(t);
                    var n = r && (!a || this.eat(b.comma));
                    var o = i || s;
                    if (s && !a) {
                        if (i) this.unexpected();
                        this.parseExportFrom(t, true);
                        return this.finishNode(t, "ExportAllDeclaration");
                    }
                    var l = this.maybeParseExportNamedSpecifiers(t);
                    if (i && r && !s && !l || a && n && !l) {
                        throw this.unexpected(null, b.braceL);
                    }
                    var u = void 0;
                    if (o || l) {
                        u = false;
                        this.parseExportFrom(t, o);
                    } else {
                        u = this.maybeParseExportDeclaration(t);
                    }
                    if (o || l || u) {
                        this.checkExport(t, true, false, !!t.source);
                        return this.finishNode(t, "ExportNamedDeclaration");
                    }
                    if (this.eat(b._default)) {
                        t.declaration = this.parseExportDefaultExpression();
                        this.checkExport(t, true, true);
                        return this.finishNode(t, "ExportDefaultDeclaration");
                    }
                    throw this.unexpected(null, b.braceL);
                }
            }, {
                key: "eatExportStar",
                value: function e(t) {
                    return this.eat(b.star);
                }
            }, {
                key: "maybeParseExportDefaultSpecifier",
                value: function e(t) {
                    if (this.isExportDefaultSpecifier()) {
                        this.expectPlugin("exportDefaultFrom");
                        var i = this.startNode();
                        i.exported = this.parseIdentifier(true);
                        t.specifiers = [ this.finishNode(i, "ExportDefaultSpecifier") ];
                        return true;
                    }
                    return false;
                }
            }, {
                key: "maybeParseExportNamespaceSpecifier",
                value: function e(t) {
                    if (this.isContextual("as")) {
                        if (!t.specifiers) t.specifiers = [];
                        this.expectPlugin("exportNamespaceFrom");
                        var i = this.startNodeAt(this.state.lastTokStart, this.state.lastTokStartLoc);
                        this.next();
                        i.exported = this.parseIdentifier(true);
                        t.specifiers.push(this.finishNode(i, "ExportNamespaceSpecifier"));
                        return true;
                    }
                    return false;
                }
            }, {
                key: "maybeParseExportNamedSpecifiers",
                value: function e(t) {
                    if (this.match(b.braceL)) {
                        var i;
                        if (!t.specifiers) t.specifiers = [];
                        (i = t.specifiers).push.apply(i, n(this.parseExportSpecifiers()));
                        t.source = null;
                        t.declaration = null;
                        return true;
                    }
                    return false;
                }
            }, {
                key: "maybeParseExportDeclaration",
                value: function e(t) {
                    if (this.shouldParseExportDeclaration()) {
                        if (this.isContextual("async")) {
                            var i = this.lookahead();
                            if (i.type !== b._function) {
                                this.unexpected(i.start, 'Unexpected token, expected "function"');
                            }
                        }
                        t.specifiers = [];
                        t.source = null;
                        t.declaration = this.parseExportDeclaration(t);
                        return true;
                    }
                    return false;
                }
            }, {
                key: "isAsyncFunction",
                value: function e() {
                    if (!this.isContextual("async")) return false;
                    var t = this.state.pos;
                    ne.lastIndex = t;
                    var i = ne.exec(this.input);
                    if (!i || !i.length) return false;
                    var r = t + i[0].length;
                    return !re.test(this.input.slice(t, r)) && this.input.slice(r, r + 8) === "function" && (r + 8 === this.length || !Te(this.input.charCodeAt(r + 8)));
                }
            }, {
                key: "parseExportDefaultExpression",
                value: function e() {
                    var t = this.startNode();
                    var i = this.isAsyncFunction();
                    if (this.match(b._function) || i) {
                        this.next();
                        if (i) {
                            this.next();
                        }
                        return this.parseFunction(t, Dt | Nt, i);
                    } else if (this.match(b._class)) {
                        return this.parseClass(t, true, true);
                    } else if (this.match(b.at)) {
                        if (this.hasPlugin("decorators") && this.getPluginOption("decorators", "decoratorsBeforeExport")) {
                            this.unexpected(this.state.start, "Decorators must be placed *before* the 'export' keyword." + " You can set the 'decoratorsBeforeExport' option to false to use" + " the 'export @decorator class {}' syntax");
                        }
                        this.parseDecorators(false);
                        return this.parseClass(t, true, true);
                    } else if (this.match(b._const) || this.match(b._var) || this.isLet()) {
                        return this.raise(this.state.start, "Only expressions, functions or classes are allowed as the `default` export.");
                    } else {
                        var r = this.parseMaybeAssign();
                        this.semicolon();
                        return r;
                    }
                }
            }, {
                key: "parseExportDeclaration",
                value: function e(t) {
                    return this.parseStatement(null);
                }
            }, {
                key: "isExportDefaultSpecifier",
                value: function e() {
                    if (this.match(b.name)) {
                        return this.state.value !== "async" && this.state.value !== "let";
                    }
                    if (!this.match(b._default)) {
                        return false;
                    }
                    var t = this.lookahead();
                    return t.type === b.comma || t.type === b.name && t.value === "from";
                }
            }, {
                key: "parseExportFrom",
                value: function e(t, i) {
                    if (this.eatContextual("from")) {
                        t.source = this.parseImportSource();
                        this.checkExport(t);
                    } else {
                        if (i) {
                            this.unexpected();
                        } else {
                            t.source = null;
                        }
                    }
                    this.semicolon();
                }
            }, {
                key: "shouldParseExportDeclaration",
                value: function e() {
                    if (this.match(b.at)) {
                        this.expectOnePlugin([ "decorators", "decorators-legacy" ]);
                        if (this.hasPlugin("decorators")) {
                            if (this.getPluginOption("decorators", "decoratorsBeforeExport")) {
                                this.unexpected(this.state.start, "Decorators must be placed *before* the 'export' keyword." + " You can set the 'decoratorsBeforeExport' option to false to use" + " the 'export @decorator class {}' syntax");
                            } else {
                                return true;
                            }
                        }
                    }
                    return this.state.type.keyword === "var" || this.state.type.keyword === "const" || this.state.type.keyword === "function" || this.state.type.keyword === "class" || this.isLet() || this.isAsyncFunction();
                }
            }, {
                key: "checkExport",
                value: function e(t, i, r, s) {
                    if (i) {
                        if (r) {
                            this.checkDuplicateExports(t, "default");
                        } else if (t.specifiers && t.specifiers.length) {
                            for (var a = 0, n = t.specifiers; a < n.length; a++) {
                                var o = n[a];
                                this.checkDuplicateExports(o, o.exported.name);
                                if (!s && o.local) {
                                    this.checkReservedWord(o.local.name, o.local.start, true, false);
                                    this.scope.checkLocalExport(o.local);
                                }
                            }
                        } else if (t.declaration) {
                            if (t.declaration.type === "FunctionDeclaration" || t.declaration.type === "ClassDeclaration") {
                                var l = t.declaration.id;
                                if (!l) throw new Error("Assertion failure");
                                this.checkDuplicateExports(t, l.name);
                            } else if (t.declaration.type === "VariableDeclaration") {
                                for (var u = 0, c = t.declaration.declarations; u < c.length; u++) {
                                    var h = c[u];
                                    this.checkDeclaration(h.id);
                                }
                            }
                        }
                    }
                    var p = this.state.decoratorStack[this.state.decoratorStack.length - 1];
                    if (p.length) {
                        var f = t.declaration && (t.declaration.type === "ClassDeclaration" || t.declaration.type === "ClassExpression");
                        if (!t.declaration || !f) {
                            throw this.raise(t.start, "You can only use decorators on an export when exporting a class");
                        }
                        this.takeDecorators(t.declaration);
                    }
                }
            }, {
                key: "checkDeclaration",
                value: function e(t) {
                    if (t.type === "Identifier") {
                        this.checkDuplicateExports(t, t.name);
                    } else if (t.type === "ObjectPattern") {
                        for (var i = 0, r = t.properties; i < r.length; i++) {
                            var s = r[i];
                            this.checkDeclaration(s);
                        }
                    } else if (t.type === "ArrayPattern") {
                        for (var a = 0, n = t.elements; a < n.length; a++) {
                            var o = n[a];
                            if (o) {
                                this.checkDeclaration(o);
                            }
                        }
                    } else if (t.type === "ObjectProperty") {
                        this.checkDeclaration(t.value);
                    } else if (t.type === "RestElement") {
                        this.checkDeclaration(t.argument);
                    } else if (t.type === "AssignmentPattern") {
                        this.checkDeclaration(t.left);
                    }
                }
            }, {
                key: "checkDuplicateExports",
                value: function e(t, i) {
                    if (this.state.exportedIdentifiers.indexOf(i) > -1) {
                        throw this.raise(t.start, i === "default" ? "Only one default export allowed per module." : "`" + i + "` has already been exported. Exported identifiers must be unique.");
                    }
                    this.state.exportedIdentifiers.push(i);
                }
            }, {
                key: "parseExportSpecifiers",
                value: function e() {
                    var t = [];
                    var i = true;
                    this.expect(b.braceL);
                    while (!this.eat(b.braceR)) {
                        if (i) {
                            i = false;
                        } else {
                            this.expect(b.comma);
                            if (this.eat(b.braceR)) break;
                        }
                        var r = this.startNode();
                        r.local = this.parseIdentifier(true);
                        r.exported = this.eatContextual("as") ? this.parseIdentifier(true) : r.local.__clone();
                        t.push(this.finishNode(r, "ExportSpecifier"));
                    }
                    return t;
                }
            }, {
                key: "parseImport",
                value: function e(t) {
                    t.specifiers = [];
                    if (!this.match(b.string)) {
                        var i = this.maybeParseDefaultImportSpecifier(t);
                        var r = !i || this.eat(b.comma);
                        var s = r && this.maybeParseStarImportSpecifier(t);
                        if (r && !s) this.parseNamedImportSpecifiers(t);
                        this.expectContextual("from");
                    }
                    t.source = this.parseImportSource();
                    this.semicolon();
                    return this.finishNode(t, "ImportDeclaration");
                }
            }, {
                key: "parseImportSource",
                value: function e() {
                    if (!this.match(b.string)) this.unexpected();
                    return this.parseExprAtom();
                }
            }, {
                key: "shouldParseDefaultImport",
                value: function e(t) {
                    return this.match(b.name);
                }
            }, {
                key: "parseImportSpecifierLocal",
                value: function e(t, i, r, s) {
                    i.local = this.parseIdentifier();
                    this.checkLVal(i.local, J, undefined, s);
                    t.specifiers.push(this.finishNode(i, r));
                }
            }, {
                key: "maybeParseDefaultImportSpecifier",
                value: function e(t) {
                    if (this.shouldParseDefaultImport(t)) {
                        this.parseImportSpecifierLocal(t, this.startNode(), "ImportDefaultSpecifier", "default import specifier");
                        return true;
                    }
                    return false;
                }
            }, {
                key: "maybeParseStarImportSpecifier",
                value: function e(t) {
                    if (this.match(b.star)) {
                        var i = this.startNode();
                        this.next();
                        this.expectContextual("as");
                        this.parseImportSpecifierLocal(t, i, "ImportNamespaceSpecifier", "import namespace specifier");
                        return true;
                    }
                    return false;
                }
            }, {
                key: "parseNamedImportSpecifiers",
                value: function e(t) {
                    var i = true;
                    this.expect(b.braceL);
                    while (!this.eat(b.braceR)) {
                        if (i) {
                            i = false;
                        } else {
                            if (this.eat(b.colon)) {
                                this.unexpected(null, "ES2015 named imports do not destructure. " + "Use another statement for destructuring after the import.");
                            }
                            this.expect(b.comma);
                            if (this.eat(b.braceR)) break;
                        }
                        this.parseImportSpecifier(t);
                    }
                }
            }, {
                key: "parseImportSpecifier",
                value: function e(t) {
                    var i = this.startNode();
                    i.imported = this.parseIdentifier(true);
                    if (this.eatContextual("as")) {
                        i.local = this.parseIdentifier();
                    } else {
                        this.checkReservedWord(i.imported.name, i.start, true, true);
                        i.local = i.imported.__clone();
                    }
                    this.checkLVal(i.local, J, undefined, "import specifier");
                    t.specifiers.push(this.finishNode(i, "ImportSpecifier"));
                }
            } ]);
            return t;
        }(At);
        var It = function(e) {
            l(t, e);
            function t(e, i) {
                u(this, t);
                e = st(e);
                var r = o(this, (t.__proto__ || Object.getPrototypeOf(t)).call(this, e, i));
                var s = r.getScopeHandler();
                r.options = e;
                r.inModule = r.options.sourceType === "module";
                r.scope = new s(r.raise.bind(r), r.inModule);
                r.plugins = Ot(r.options.plugins);
                r.filename = e.sourceFilename;
                return r;
            }
            s(t, [ {
                key: "getScopeHandler",
                value: function e() {
                    return qe;
                }
            }, {
                key: "parse",
                value: function e() {
                    this.scope.enter(k);
                    var t = this.startNode();
                    var i = this.startNode();
                    this.nextToken();
                    return this.parseTopLevel(t, i);
                }
            } ]);
            return t;
        }(Ft);
        function Ot(e) {
            var t = new Map();
            for (var i = 0; i < e.length; i++) {
                var s = e[i];
                var a = Array.isArray(s) ? s : [ s, {} ], n = r(a, 2), o = n[0], l = n[1];
                if (!t.has(o)) t.set(o, l || {});
            }
            return t;
        }
        function Lt(e, t) {
            if (t && t.sourceType === "unambiguous") {
                t = i({}, t);
                try {
                    t.sourceType = "module";
                    var r = Mt(t, e);
                    var s = r.parse();
                    if (!r.sawUnambiguousESM) s.program.sourceType = "script";
                    return s;
                } catch (i) {
                    try {
                        t.sourceType = "script";
                        return Mt(t, e).parse();
                    } catch (e) {}
                    throw i;
                }
            } else {
                return Mt(t, e).parse();
            }
        }
        function Bt(e, t) {
            var i = Mt(t, e);
            if (i.options.strictMode) {
                i.state.strict = true;
            }
            return i.getExpression();
        }
        function Mt(e, t) {
            var i = It;
            if (e && e.plugins) {
                et(e.plugins);
                i = Rt(e.plugins);
            }
            return new i(e, t);
        }
        var jt = {};
        function Rt(e) {
            var t = it.filter(function(t) {
                return Qe(e, t);
            });
            var i = t.join("/");
            var r = jt[i];
            if (!r) {
                r = It;
                for (var s = 0; s < t.length; s++) {
                    var a = t[s];
                    r = tt[a](r);
                }
                jt[i] = r;
            }
            return r;
        }
        t.parse = Lt;
        t.parseExpression = Bt;
        t.tokTypes = b;
    }, function(e, t, i) {
        var r, s, a;
        "use strict";
        var n = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(e) {
            return typeof e;
        } : function(e) {
            return e && typeof Symbol === "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
        };
        (function(i, o) {
            (false ? "undefined" : n(t)) === "object" && typeof e !== "undefined" ? o(t) : true ? !(s = [ t ], 
            r = o, a = typeof r === "function" ? r.apply(t, s) : r, a !== undefined && (e.exports = a)) : o(i.acorn = {});
        })(undefined, function(e) {
            "use strict";
            var t = {
                3: "abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile",
                5: "class enum extends super const export import",
                6: "enum",
                strict: "implements interface let package private protected public static yield",
                strictBind: "eval arguments"
            };
            var i = "break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this";
            var r = {
                5: i,
                6: i + " const class extends export import super"
            };
            var s = /^in(stanceof)?$/;
            var a = "ªµºÀ-ÖØ-öø-ˁˆ-ˑˠ-ˤˬˮͰ-ʹͶͷͺ-ͽͿΆΈ-ΊΌΎ-ΡΣ-ϵϷ-ҁҊ-ԯԱ-Ֆՙՠ-ֈא-תׯ-ײؠ-يٮٯٱ-ۓەۥۦۮۯۺ-ۼۿܐܒ-ܯݍ-ޥޱߊ-ߪߴߵߺࠀ-ࠕࠚࠤࠨࡀ-ࡘࡠ-ࡪࢠ-ࢴࢶ-ࢽऄ-हऽॐक़-ॡॱ-ঀঅ-ঌএঐও-নপ-রলশ-হঽৎড়ঢ়য়-ৡৰৱৼਅ-ਊਏਐਓ-ਨਪ-ਰਲਲ਼ਵਸ਼ਸਹਖ਼-ੜਫ਼ੲ-ੴઅ-ઍએ-ઑઓ-નપ-રલળવ-હઽૐૠૡૹଅ-ଌଏଐଓ-ନପ-ରଲଳଵ-ହଽଡ଼ଢ଼ୟ-ୡୱஃஅ-ஊஎ-ஐஒ-கஙசஜஞடணதந-பம-ஹௐఅ-ఌఎ-ఐఒ-నప-హఽౘ-ౚౠౡಀಅ-ಌಎ-ಐಒ-ನಪ-ಳವ-ಹಽೞೠೡೱೲഅ-ഌഎ-ഐഒ-ഺഽൎൔ-ൖൟ-ൡൺ-ൿඅ-ඖක-නඳ-රලව-ෆก-ะาำเ-ๆກຂຄງຈຊຍດ-ທນ-ຟມ-ຣລວສຫອ-ະາຳຽເ-ໄໆໜ-ໟༀཀ-ཇཉ-ཬྈ-ྌက-ဪဿၐ-ၕၚ-ၝၡၥၦၮ-ၰၵ-ႁႎႠ-ჅჇჍა-ჺჼ-ቈቊ-ቍቐ-ቖቘቚ-ቝበ-ኈኊ-ኍነ-ኰኲ-ኵኸ-ኾዀዂ-ዅወ-ዖዘ-ጐጒ-ጕጘ-ፚᎀ-ᎏᎠ-Ᏽᏸ-ᏽᐁ-ᙬᙯ-ᙿᚁ-ᚚᚠ-ᛪᛮ-ᛸᜀ-ᜌᜎ-ᜑᜠ-ᜱᝀ-ᝑᝠ-ᝬᝮ-ᝰក-ឳៗៜᠠ-ᡸᢀ-ᢨᢪᢰ-ᣵᤀ-ᤞᥐ-ᥭᥰ-ᥴᦀ-ᦫᦰ-ᧉᨀ-ᨖᨠ-ᩔᪧᬅ-ᬳᭅ-ᭋᮃ-ᮠᮮᮯᮺ-ᯥᰀ-ᰣᱍ-ᱏᱚ-ᱽᲀ-ᲈᲐ-ᲺᲽ-Ჿᳩ-ᳬᳮ-ᳱᳵᳶᴀ-ᶿḀ-ἕἘ-Ἕἠ-ὅὈ-Ὅὐ-ὗὙὛὝὟ-ώᾀ-ᾴᾶ-ᾼιῂ-ῄῆ-ῌῐ-ΐῖ-Ίῠ-Ῥῲ-ῴῶ-ῼⁱⁿₐ-ₜℂℇℊ-ℓℕ℘-ℝℤΩℨK-ℹℼ-ℿⅅ-ⅉⅎⅠ-ↈⰀ-Ⱞⰰ-ⱞⱠ-ⳤⳫ-ⳮⳲⳳⴀ-ⴥⴧⴭⴰ-ⵧⵯⶀ-ⶖⶠ-ⶦⶨ-ⶮⶰ-ⶶⶸ-ⶾⷀ-ⷆⷈ-ⷎⷐ-ⷖⷘ-ⷞ々-〇〡-〩〱-〵〸-〼ぁ-ゖ゛-ゟァ-ヺー-ヿㄅ-ㄯㄱ-ㆎㆠ-ㆺㇰ-ㇿ㐀-䶵一-鿯ꀀ-ꒌꓐ-ꓽꔀ-ꘌꘐ-ꘟꘪꘫꙀ-ꙮꙿ-ꚝꚠ-ꛯꜗ-ꜟꜢ-ꞈꞋ-ꞹꟷ-ꠁꠃ-ꠅꠇ-ꠊꠌ-ꠢꡀ-ꡳꢂ-ꢳꣲ-ꣷꣻꣽꣾꤊ-ꤥꤰ-ꥆꥠ-ꥼꦄ-ꦲꧏꧠ-ꧤꧦ-ꧯꧺ-ꧾꨀ-ꨨꩀ-ꩂꩄ-ꩋꩠ-ꩶꩺꩾ-ꪯꪱꪵꪶꪹ-ꪽꫀꫂꫛ-ꫝꫠ-ꫪꫲ-ꫴꬁ-ꬆꬉ-ꬎꬑ-ꬖꬠ-ꬦꬨ-ꬮꬰ-ꭚꭜ-ꭥꭰ-ꯢ가-힣ힰ-ퟆퟋ-ퟻ豈-舘並-龎ﬀ-ﬆﬓ-ﬗיִײַ-ﬨשׁ-זּטּ-לּמּנּסּףּפּצּ-ﮱﯓ-ﴽﵐ-ﶏﶒ-ﷇﷰ-ﷻﹰ-ﹴﹶ-ﻼＡ-Ｚａ-ｚｦ-ﾾￂ-ￇￊ-ￏￒ-ￗￚ-ￜ";
            var n = "‌‍·̀-ͯ·҃-֑҇-ׇֽֿׁׂׅׄؐ-ًؚ-٩ٰۖ-ۜ۟-۪ۤۧۨ-ۭ۰-۹ܑܰ-݊ަ-ް߀-߉߫-߽߳ࠖ-࠙ࠛ-ࠣࠥ-ࠧࠩ-࡙࠭-࡛࣓-ࣣ࣡-ःऺ-़ा-ॏ॑-ॗॢॣ०-९ঁ-ঃ়া-ৄেৈো-্ৗৢৣ০-৯৾ਁ-ਃ਼ਾ-ੂੇੈੋ-੍ੑ੦-ੱੵઁ-ઃ઼ા-ૅે-ૉો-્ૢૣ૦-૯ૺ-૿ଁ-ଃ଼ା-ୄେୈୋ-୍ୖୗୢୣ୦-୯ஂா-ூெ-ைொ-்ௗ௦-௯ఀ-ఄా-ౄె-ైొ-్ౕౖౢౣ౦-౯ಁ-ಃ಼ಾ-ೄೆ-ೈೊ-್ೕೖೢೣ೦-೯ഀ-ഃ഻഼ാ-ൄെ-ൈൊ-്ൗൢൣ൦-൯ංඃ්ා-ුූෘ-ෟ෦-෯ෲෳัิ-ฺ็-๎๐-๙ັິ-ູົຼ່-ໍ໐-໙༘༙༠-༩༹༵༷༾༿ཱ-྄྆྇ྍ-ྗྙ-ྼ࿆ါ-ှ၀-၉ၖ-ၙၞ-ၠၢ-ၤၧ-ၭၱ-ၴႂ-ႍႏ-ႝ፝-፟፩-፱ᜒ-᜔ᜲ-᜴ᝒᝓᝲᝳ឴-៓៝០-៩᠋-᠍᠐-᠙ᢩᤠ-ᤫᤰ-᤻᥆-᥏᧐-᧚ᨗ-ᨛᩕ-ᩞ᩠-᩿᩼-᪉᪐-᪙᪰-᪽ᬀ-ᬄ᬴-᭄᭐-᭙᭫-᭳ᮀ-ᮂᮡ-ᮭ᮰-᮹᯦-᯳ᰤ-᰷᱀-᱉᱐-᱙᳐-᳔᳒-᳨᳭ᳲ-᳴᳷-᳹᷀-᷹᷻-᷿‿⁀⁔⃐-⃥⃜⃡-⃰⳯-⵿⳱ⷠ-〪ⷿ-゙゚〯꘠-꘩꙯ꙴ-꙽ꚞꚟ꛰꛱ꠂ꠆ꠋꠣ-ꠧꢀꢁꢴ-ꣅ꣐-꣙꣠-꣱ꣿ-꤉ꤦ-꤭ꥇ-꥓ꦀ-ꦃ꦳-꧀꧐-꧙ꧥ꧰-꧹ꨩ-ꨶꩃꩌꩍ꩐-꩙ꩻ-ꩽꪰꪲ-ꪴꪷꪸꪾ꪿꫁ꫫ-ꫯꫵ꫶ꯣ-ꯪ꯬꯭꯰-꯹ﬞ︀-️︠-︯︳︴﹍-﹏０-９＿";
            var o = new RegExp("[" + a + "]");
            var l = new RegExp("[" + a + n + "]");
            a = n = null;
            var u = [ 0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 157, 310, 10, 21, 11, 7, 153, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 477, 28, 11, 0, 9, 21, 190, 52, 76, 44, 33, 24, 27, 35, 30, 0, 12, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 85, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 54, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 86, 26, 230, 43, 117, 63, 32, 0, 257, 0, 11, 39, 8, 0, 22, 0, 12, 39, 3, 3, 20, 0, 35, 56, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 270, 921, 103, 110, 18, 195, 2749, 1070, 4050, 582, 8634, 568, 8, 30, 114, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 68, 12, 0, 67, 12, 65, 1, 31, 6129, 15, 754, 9486, 286, 82, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 4149, 196, 60, 67, 1213, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42710, 42, 4148, 12, 221, 3, 5761, 15, 7472, 3104, 541 ];
            var c = [ 509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 525, 10, 176, 2, 54, 14, 32, 9, 16, 3, 46, 10, 54, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 4, 9, 83, 11, 7, 0, 161, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 280, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 19306, 9, 135, 4, 60, 6, 26, 9, 1016, 45, 17, 3, 19723, 1, 5319, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 2214, 6, 110, 6, 6, 9, 792487, 239 ];
            function h(e, t) {
                var i = 65536;
                for (var r = 0; r < t.length; r += 2) {
                    i += t[r];
                    if (i > e) {
                        return false;
                    }
                    i += t[r + 1];
                    if (i >= e) {
                        return true;
                    }
                }
            }
            function p(e, t) {
                if (e < 65) {
                    return e === 36;
                }
                if (e < 91) {
                    return true;
                }
                if (e < 97) {
                    return e === 95;
                }
                if (e < 123) {
                    return true;
                }
                if (e <= 65535) {
                    return e >= 170 && o.test(String.fromCharCode(e));
                }
                if (t === false) {
                    return false;
                }
                return h(e, u);
            }
            function f(e, t) {
                if (e < 48) {
                    return e === 36;
                }
                if (e < 58) {
                    return true;
                }
                if (e < 65) {
                    return false;
                }
                if (e < 91) {
                    return true;
                }
                if (e < 97) {
                    return e === 95;
                }
                if (e < 123) {
                    return true;
                }
                if (e <= 65535) {
                    return e >= 170 && l.test(String.fromCharCode(e));
                }
                if (t === false) {
                    return false;
                }
                return h(e, u) || h(e, c);
            }
            var d = function e(t, i) {
                if (i === void 0) i = {};
                this.label = t;
                this.keyword = i.keyword;
                this.beforeExpr = !!i.beforeExpr;
                this.startsExpr = !!i.startsExpr;
                this.isLoop = !!i.isLoop;
                this.isAssign = !!i.isAssign;
                this.prefix = !!i.prefix;
                this.postfix = !!i.postfix;
                this.binop = i.binop || null;
                this.updateContext = null;
            };
            function m(e, t) {
                return new d(e, {
                    beforeExpr: true,
                    binop: t
                });
            }
            var y = {
                beforeExpr: true
            };
            var v = {
                startsExpr: true
            };
            var x = {};
            function g(e, t) {
                if (t === void 0) t = {};
                t.keyword = e;
                return x[e] = new d(e, t);
            }
            var b = {
                num: new d("num", v),
                regexp: new d("regexp", v),
                string: new d("string", v),
                name: new d("name", v),
                eof: new d("eof"),
                bracketL: new d("[", {
                    beforeExpr: true,
                    startsExpr: true
                }),
                bracketR: new d("]"),
                braceL: new d("{", {
                    beforeExpr: true,
                    startsExpr: true
                }),
                braceR: new d("}"),
                parenL: new d("(", {
                    beforeExpr: true,
                    startsExpr: true
                }),
                parenR: new d(")"),
                comma: new d(",", y),
                semi: new d(";", y),
                colon: new d(":", y),
                dot: new d("."),
                question: new d("?", y),
                arrow: new d("=>", y),
                template: new d("template"),
                invalidTemplate: new d("invalidTemplate"),
                ellipsis: new d("...", y),
                backQuote: new d("`", v),
                dollarBraceL: new d("${", {
                    beforeExpr: true,
                    startsExpr: true
                }),
                eq: new d("=", {
                    beforeExpr: true,
                    isAssign: true
                }),
                assign: new d("_=", {
                    beforeExpr: true,
                    isAssign: true
                }),
                incDec: new d("++/--", {
                    prefix: true,
                    postfix: true,
                    startsExpr: true
                }),
                prefix: new d("!/~", {
                    beforeExpr: true,
                    prefix: true,
                    startsExpr: true
                }),
                logicalOR: m("||", 1),
                logicalAND: m("&&", 2),
                bitwiseOR: m("|", 3),
                bitwiseXOR: m("^", 4),
                bitwiseAND: m("&", 5),
                equality: m("==/!=/===/!==", 6),
                relational: m("</>/<=/>=", 7),
                bitShift: m("<</>>/>>>", 8),
                plusMin: new d("+/-", {
                    beforeExpr: true,
                    binop: 9,
                    prefix: true,
                    startsExpr: true
                }),
                modulo: m("%", 10),
                star: m("*", 10),
                slash: m("/", 10),
                starstar: new d("**", {
                    beforeExpr: true
                }),
                _break: g("break"),
                _case: g("case", y),
                _catch: g("catch"),
                _continue: g("continue"),
                _debugger: g("debugger"),
                _default: g("default", y),
                _do: g("do", {
                    isLoop: true,
                    beforeExpr: true
                }),
                _else: g("else", y),
                _finally: g("finally"),
                _for: g("for", {
                    isLoop: true
                }),
                _function: g("function", v),
                _if: g("if"),
                _return: g("return", y),
                _switch: g("switch"),
                _throw: g("throw", y),
                _try: g("try"),
                _var: g("var"),
                _const: g("const"),
                _while: g("while", {
                    isLoop: true
                }),
                _with: g("with"),
                _new: g("new", {
                    beforeExpr: true,
                    startsExpr: true
                }),
                _this: g("this", v),
                _super: g("super", v),
                _class: g("class", v),
                _extends: g("extends", y),
                _export: g("export"),
                _import: g("import"),
                _null: g("null", v),
                _true: g("true", v),
                _false: g("false", v),
                _in: g("in", {
                    beforeExpr: true,
                    binop: 7
                }),
                _instanceof: g("instanceof", {
                    beforeExpr: true,
                    binop: 7
                }),
                _typeof: g("typeof", {
                    beforeExpr: true,
                    prefix: true,
                    startsExpr: true
                }),
                _void: g("void", {
                    beforeExpr: true,
                    prefix: true,
                    startsExpr: true
                }),
                _delete: g("delete", {
                    beforeExpr: true,
                    prefix: true,
                    startsExpr: true
                })
            };
            var E = /\r\n?|\n|\u2028|\u2029/;
            var k = new RegExp(E.source, "g");
            function S(e, t) {
                return e === 10 || e === 13 || !t && (e === 8232 || e === 8233);
            }
            var w = /[\u1680\u180e\u2000-\u200a\u202f\u205f\u3000\ufeff]/;
            var A = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;
            var C = Object.prototype;
            var T = C.hasOwnProperty;
            var P = C.toString;
            function D(e, t) {
                return T.call(e, t);
            }
            var _ = Array.isArray || function(e) {
                return P.call(e) === "[object Array]";
            };
            var N = function e(t, i) {
                this.line = t;
                this.column = i;
            };
            N.prototype.offset = function e(t) {
                return new N(this.line, this.column + t);
            };
            var F = function e(t, i, r) {
                this.start = i;
                this.end = r;
                if (t.sourceFile !== null) {
                    this.source = t.sourceFile;
                }
            };
            function I(e, t) {
                for (var i = 1, r = 0; ;) {
                    k.lastIndex = r;
                    var s = k.exec(e);
                    if (s && s.index < t) {
                        ++i;
                        r = s.index + s[0].length;
                    } else {
                        return new N(i, t - r);
                    }
                }
            }
            var O = {
                ecmaVersion: 9,
                sourceType: "script",
                onInsertedSemicolon: null,
                onTrailingComma: null,
                allowReserved: null,
                allowReturnOutsideFunction: false,
                allowImportExportEverywhere: false,
                allowAwaitOutsideFunction: false,
                allowHashBang: false,
                locations: false,
                onToken: null,
                onComment: null,
                ranges: false,
                program: null,
                sourceFile: null,
                directSourceFile: null,
                preserveParens: false
            };
            function L(e) {
                var t = {};
                for (var i in O) {
                    t[i] = e && D(e, i) ? e[i] : O[i];
                }
                if (t.ecmaVersion >= 2015) {
                    t.ecmaVersion -= 2009;
                }
                if (t.allowReserved == null) {
                    t.allowReserved = t.ecmaVersion < 5;
                }
                if (_(t.onToken)) {
                    var r = t.onToken;
                    t.onToken = function(e) {
                        return r.push(e);
                    };
                }
                if (_(t.onComment)) {
                    t.onComment = B(t, t.onComment);
                }
                return t;
            }
            function B(e, t) {
                return function(i, r, s, a, n, o) {
                    var l = {
                        type: i ? "Block" : "Line",
                        value: r,
                        start: s,
                        end: a
                    };
                    if (e.locations) {
                        l.loc = new F(this, n, o);
                    }
                    if (e.ranges) {
                        l.range = [ s, a ];
                    }
                    t.push(l);
                };
            }
            var M = 1;
            var j = 2;
            var R = M | j;
            var V = 4;
            var U = 8;
            var X = 16;
            var q = 32;
            var J = 64;
            var z = 128;
            function W(e, t) {
                return j | (e ? V : 0) | (t ? U : 0);
            }
            var K = 0;
            var G = 1;
            var H = 2;
            var Y = 3;
            var Q = 4;
            var $ = 5;
            function Z(e) {
                return new RegExp("^(?:" + e.replace(/ /g, "|") + ")$");
            }
            var ee = function e(i, s, a) {
                this.options = i = L(i);
                this.sourceFile = i.sourceFile;
                this.keywords = Z(r[i.ecmaVersion >= 6 ? 6 : 5]);
                var n = "";
                if (!i.allowReserved) {
                    for (var o = i.ecmaVersion; ;o--) {
                        if (n = t[o]) {
                            break;
                        }
                    }
                    if (i.sourceType === "module") {
                        n += " await";
                    }
                }
                this.reservedWords = Z(n);
                var l = (n ? n + " " : "") + t.strict;
                this.reservedWordsStrict = Z(l);
                this.reservedWordsStrictBind = Z(l + " " + t.strictBind);
                this.input = String(s);
                this.containsEsc = false;
                if (a) {
                    this.pos = a;
                    this.lineStart = this.input.lastIndexOf("\n", a - 1) + 1;
                    this.curLine = this.input.slice(0, this.lineStart).split(E).length;
                } else {
                    this.pos = this.lineStart = 0;
                    this.curLine = 1;
                }
                this.type = b.eof;
                this.value = null;
                this.start = this.end = this.pos;
                this.startLoc = this.endLoc = this.curPosition();
                this.lastTokEndLoc = this.lastTokStartLoc = null;
                this.lastTokStart = this.lastTokEnd = this.pos;
                this.context = this.initialContext();
                this.exprAllowed = true;
                this.inModule = i.sourceType === "module";
                this.strict = this.inModule || this.strictDirective(this.pos);
                this.potentialArrowAt = -1;
                this.yieldPos = this.awaitPos = 0;
                this.labels = [];
                if (this.pos === 0 && i.allowHashBang && this.input.slice(0, 2) === "#!") {
                    this.skipLineComment(2);
                }
                this.scopeStack = [];
                this.enterScope(M);
                this.regexpState = null;
            };
            var te = {
                inFunction: {
                    configurable: true
                },
                inGenerator: {
                    configurable: true
                },
                inAsync: {
                    configurable: true
                },
                allowSuper: {
                    configurable: true
                },
                allowDirectSuper: {
                    configurable: true
                }
            };
            ee.prototype.parse = function e() {
                var t = this.options.program || this.startNode();
                this.nextToken();
                return this.parseTopLevel(t);
            };
            te.inFunction.get = function() {
                return (this.currentVarScope().flags & j) > 0;
            };
            te.inGenerator.get = function() {
                return (this.currentVarScope().flags & U) > 0;
            };
            te.inAsync.get = function() {
                return (this.currentVarScope().flags & V) > 0;
            };
            te.allowSuper.get = function() {
                return (this.currentThisScope().flags & J) > 0;
            };
            te.allowDirectSuper.get = function() {
                return (this.currentThisScope().flags & z) > 0;
            };
            ee.prototype.inNonArrowFunction = function e() {
                return (this.currentThisScope().flags & j) > 0;
            };
            ee.extend = function e() {
                var t = [], i = arguments.length;
                while (i--) {
                    t[i] = arguments[i];
                }
                var r = this;
                for (var s = 0; s < t.length; s++) {
                    r = t[s](r);
                }
                return r;
            };
            ee.parse = function e(t, i) {
                return new this(i, t).parse();
            };
            ee.parseExpressionAt = function e(t, i, r) {
                var s = new this(r, t, i);
                s.nextToken();
                return s.parseExpression();
            };
            ee.tokenizer = function e(t, i) {
                return new this(i, t);
            };
            Object.defineProperties(ee.prototype, te);
            var ie = ee.prototype;
            var re = /^(?:'((?:\\.|[^'])*?)'|"((?:\\.|[^"])*?)"|;)/;
            ie.strictDirective = function(e) {
                var t = this;
                for (;;) {
                    A.lastIndex = e;
                    e += A.exec(t.input)[0].length;
                    var i = re.exec(t.input.slice(e));
                    if (!i) {
                        return false;
                    }
                    if ((i[1] || i[2]) === "use strict") {
                        return true;
                    }
                    e += i[0].length;
                }
            };
            ie.eat = function(e) {
                if (this.type === e) {
                    this.next();
                    return true;
                } else {
                    return false;
                }
            };
            ie.isContextual = function(e) {
                return this.type === b.name && this.value === e && !this.containsEsc;
            };
            ie.eatContextual = function(e) {
                if (!this.isContextual(e)) {
                    return false;
                }
                this.next();
                return true;
            };
            ie.expectContextual = function(e) {
                if (!this.eatContextual(e)) {
                    this.unexpected();
                }
            };
            ie.canInsertSemicolon = function() {
                return this.type === b.eof || this.type === b.braceR || E.test(this.input.slice(this.lastTokEnd, this.start));
            };
            ie.insertSemicolon = function() {
                if (this.canInsertSemicolon()) {
                    if (this.options.onInsertedSemicolon) {
                        this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc);
                    }
                    return true;
                }
            };
            ie.semicolon = function() {
                if (!this.eat(b.semi) && !this.insertSemicolon()) {
                    this.unexpected();
                }
            };
            ie.afterTrailingComma = function(e, t) {
                if (this.type === e) {
                    if (this.options.onTrailingComma) {
                        this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc);
                    }
                    if (!t) {
                        this.next();
                    }
                    return true;
                }
            };
            ie.expect = function(e) {
                this.eat(e) || this.unexpected();
            };
            ie.unexpected = function(e) {
                this.raise(e != null ? e : this.start, "Unexpected token");
            };
            function se() {
                this.shorthandAssign = this.trailingComma = this.parenthesizedAssign = this.parenthesizedBind = this.doubleProto = -1;
            }
            ie.checkPatternErrors = function(e, t) {
                if (!e) {
                    return;
                }
                if (e.trailingComma > -1) {
                    this.raiseRecoverable(e.trailingComma, "Comma is not permitted after the rest element");
                }
                var i = t ? e.parenthesizedAssign : e.parenthesizedBind;
                if (i > -1) {
                    this.raiseRecoverable(i, "Parenthesized pattern");
                }
            };
            ie.checkExpressionErrors = function(e, t) {
                if (!e) {
                    return false;
                }
                var i = e.shorthandAssign;
                var r = e.doubleProto;
                if (!t) {
                    return i >= 0 || r >= 0;
                }
                if (i >= 0) {
                    this.raise(i, "Shorthand property assignments are valid only in destructuring patterns");
                }
                if (r >= 0) {
                    this.raiseRecoverable(r, "Redefinition of __proto__ property");
                }
            };
            ie.checkYieldAwaitInDefaultParams = function() {
                if (this.yieldPos && (!this.awaitPos || this.yieldPos < this.awaitPos)) {
                    this.raise(this.yieldPos, "Yield expression cannot be a default value");
                }
                if (this.awaitPos) {
                    this.raise(this.awaitPos, "Await expression cannot be a default value");
                }
            };
            ie.isSimpleAssignTarget = function(e) {
                if (e.type === "ParenthesizedExpression") {
                    return this.isSimpleAssignTarget(e.expression);
                }
                return e.type === "Identifier" || e.type === "MemberExpression";
            };
            var ae = ee.prototype;
            ae.parseTopLevel = function(e) {
                var t = this;
                var i = {};
                if (!e.body) {
                    e.body = [];
                }
                while (this.type !== b.eof) {
                    var r = t.parseStatement(null, true, i);
                    e.body.push(r);
                }
                this.adaptDirectivePrologue(e.body);
                this.next();
                if (this.options.ecmaVersion >= 6) {
                    e.sourceType = this.options.sourceType;
                }
                return this.finishNode(e, "Program");
            };
            var ne = {
                kind: "loop"
            };
            var oe = {
                kind: "switch"
            };
            ae.isLet = function() {
                if (this.options.ecmaVersion < 6 || !this.isContextual("let")) {
                    return false;
                }
                A.lastIndex = this.pos;
                var e = A.exec(this.input);
                var t = this.pos + e[0].length, i = this.input.charCodeAt(t);
                if (i === 123 && !E.test(this.input.slice(this.end, t)) || i === 91) {
                    return true;
                }
                if (p(i, true)) {
                    var r = t + 1;
                    while (f(this.input.charCodeAt(r), true)) {
                        ++r;
                    }
                    var a = this.input.slice(t, r);
                    if (!s.test(a)) {
                        return true;
                    }
                }
                return false;
            };
            ae.isAsyncFunction = function() {
                if (this.options.ecmaVersion < 8 || !this.isContextual("async")) {
                    return false;
                }
                A.lastIndex = this.pos;
                var e = A.exec(this.input);
                var t = this.pos + e[0].length;
                return !E.test(this.input.slice(this.pos, t)) && this.input.slice(t, t + 8) === "function" && (t + 8 === this.input.length || !f(this.input.charAt(t + 8)));
            };
            ae.parseStatement = function(e, t, i) {
                var r = this.type, s = this.startNode(), a;
                if (this.isLet()) {
                    r = b._var;
                    a = "let";
                }
                switch (r) {
                  case b._break:
                  case b._continue:
                    return this.parseBreakContinueStatement(s, r.keyword);

                  case b._debugger:
                    return this.parseDebuggerStatement(s);

                  case b._do:
                    return this.parseDoStatement(s);

                  case b._for:
                    return this.parseForStatement(s);

                  case b._function:
                    if (e && (this.strict || e !== "if") && this.options.ecmaVersion >= 6) {
                        this.unexpected();
                    }
                    return this.parseFunctionStatement(s, false, !e);

                  case b._class:
                    if (e) {
                        this.unexpected();
                    }
                    return this.parseClass(s, true);

                  case b._if:
                    return this.parseIfStatement(s);

                  case b._return:
                    return this.parseReturnStatement(s);

                  case b._switch:
                    return this.parseSwitchStatement(s);

                  case b._throw:
                    return this.parseThrowStatement(s);

                  case b._try:
                    return this.parseTryStatement(s);

                  case b._const:
                  case b._var:
                    a = a || this.value;
                    if (e && a !== "var") {
                        this.unexpected();
                    }
                    return this.parseVarStatement(s, a);

                  case b._while:
                    return this.parseWhileStatement(s);

                  case b._with:
                    return this.parseWithStatement(s);

                  case b.braceL:
                    return this.parseBlock(true, s);

                  case b.semi:
                    return this.parseEmptyStatement(s);

                  case b._export:
                  case b._import:
                    if (!this.options.allowImportExportEverywhere) {
                        if (!t) {
                            this.raise(this.start, "'import' and 'export' may only appear at the top level");
                        }
                        if (!this.inModule) {
                            this.raise(this.start, "'import' and 'export' may appear only with 'sourceType: module'");
                        }
                    }
                    return r === b._import ? this.parseImport(s) : this.parseExport(s, i);

                  default:
                    if (this.isAsyncFunction()) {
                        if (e) {
                            this.unexpected();
                        }
                        this.next();
                        return this.parseFunctionStatement(s, true, !e);
                    }
                    var n = this.value, o = this.parseExpression();
                    if (r === b.name && o.type === "Identifier" && this.eat(b.colon)) {
                        return this.parseLabeledStatement(s, n, o, e);
                    } else {
                        return this.parseExpressionStatement(s, o);
                    }
                }
            };
            ae.parseBreakContinueStatement = function(e, t) {
                var i = this;
                var r = t === "break";
                this.next();
                if (this.eat(b.semi) || this.insertSemicolon()) {
                    e.label = null;
                } else if (this.type !== b.name) {
                    this.unexpected();
                } else {
                    e.label = this.parseIdent();
                    this.semicolon();
                }
                var s = 0;
                for (;s < this.labels.length; ++s) {
                    var a = i.labels[s];
                    if (e.label == null || a.name === e.label.name) {
                        if (a.kind != null && (r || a.kind === "loop")) {
                            break;
                        }
                        if (e.label && r) {
                            break;
                        }
                    }
                }
                if (s === this.labels.length) {
                    this.raise(e.start, "Unsyntactic " + t);
                }
                return this.finishNode(e, r ? "BreakStatement" : "ContinueStatement");
            };
            ae.parseDebuggerStatement = function(e) {
                this.next();
                this.semicolon();
                return this.finishNode(e, "DebuggerStatement");
            };
            ae.parseDoStatement = function(e) {
                this.next();
                this.labels.push(ne);
                e.body = this.parseStatement("do");
                this.labels.pop();
                this.expect(b._while);
                e.test = this.parseParenExpression();
                if (this.options.ecmaVersion >= 6) {
                    this.eat(b.semi);
                } else {
                    this.semicolon();
                }
                return this.finishNode(e, "DoWhileStatement");
            };
            ae.parseForStatement = function(e) {
                this.next();
                var t = this.options.ecmaVersion >= 9 && (this.inAsync || !this.inFunction && this.options.allowAwaitOutsideFunction) && this.eatContextual("await") ? this.lastTokStart : -1;
                this.labels.push(ne);
                this.enterScope(0);
                this.expect(b.parenL);
                if (this.type === b.semi) {
                    if (t > -1) {
                        this.unexpected(t);
                    }
                    return this.parseFor(e, null);
                }
                var i = this.isLet();
                if (this.type === b._var || this.type === b._const || i) {
                    var r = this.startNode(), s = i ? "let" : this.value;
                    this.next();
                    this.parseVar(r, true, s);
                    this.finishNode(r, "VariableDeclaration");
                    if ((this.type === b._in || this.options.ecmaVersion >= 6 && this.isContextual("of")) && r.declarations.length === 1 && !(s !== "var" && r.declarations[0].init)) {
                        if (this.options.ecmaVersion >= 9) {
                            if (this.type === b._in) {
                                if (t > -1) {
                                    this.unexpected(t);
                                }
                            } else {
                                e.await = t > -1;
                            }
                        }
                        return this.parseForIn(e, r);
                    }
                    if (t > -1) {
                        this.unexpected(t);
                    }
                    return this.parseFor(e, r);
                }
                var a = new se();
                var n = this.parseExpression(true, a);
                if (this.type === b._in || this.options.ecmaVersion >= 6 && this.isContextual("of")) {
                    if (this.options.ecmaVersion >= 9) {
                        if (this.type === b._in) {
                            if (t > -1) {
                                this.unexpected(t);
                            }
                        } else {
                            e.await = t > -1;
                        }
                    }
                    this.toAssignable(n, false, a);
                    this.checkLVal(n);
                    return this.parseForIn(e, n);
                } else {
                    this.checkExpressionErrors(a, true);
                }
                if (t > -1) {
                    this.unexpected(t);
                }
                return this.parseFor(e, n);
            };
            ae.parseFunctionStatement = function(e, t, i) {
                this.next();
                return this.parseFunction(e, ue | (i ? 0 : ce), false, t);
            };
            ae.parseIfStatement = function(e) {
                this.next();
                e.test = this.parseParenExpression();
                e.consequent = this.parseStatement("if");
                e.alternate = this.eat(b._else) ? this.parseStatement("if") : null;
                return this.finishNode(e, "IfStatement");
            };
            ae.parseReturnStatement = function(e) {
                if (!this.inFunction && !this.options.allowReturnOutsideFunction) {
                    this.raise(this.start, "'return' outside of function");
                }
                this.next();
                if (this.eat(b.semi) || this.insertSemicolon()) {
                    e.argument = null;
                } else {
                    e.argument = this.parseExpression();
                    this.semicolon();
                }
                return this.finishNode(e, "ReturnStatement");
            };
            ae.parseSwitchStatement = function(e) {
                var t = this;
                this.next();
                e.discriminant = this.parseParenExpression();
                e.cases = [];
                this.expect(b.braceL);
                this.labels.push(oe);
                this.enterScope(0);
                var i;
                for (var r = false; this.type !== b.braceR; ) {
                    if (t.type === b._case || t.type === b._default) {
                        var s = t.type === b._case;
                        if (i) {
                            t.finishNode(i, "SwitchCase");
                        }
                        e.cases.push(i = t.startNode());
                        i.consequent = [];
                        t.next();
                        if (s) {
                            i.test = t.parseExpression();
                        } else {
                            if (r) {
                                t.raiseRecoverable(t.lastTokStart, "Multiple default clauses");
                            }
                            r = true;
                            i.test = null;
                        }
                        t.expect(b.colon);
                    } else {
                        if (!i) {
                            t.unexpected();
                        }
                        i.consequent.push(t.parseStatement(null));
                    }
                }
                this.exitScope();
                if (i) {
                    this.finishNode(i, "SwitchCase");
                }
                this.next();
                this.labels.pop();
                return this.finishNode(e, "SwitchStatement");
            };
            ae.parseThrowStatement = function(e) {
                this.next();
                if (E.test(this.input.slice(this.lastTokEnd, this.start))) {
                    this.raise(this.lastTokEnd, "Illegal newline after throw");
                }
                e.argument = this.parseExpression();
                this.semicolon();
                return this.finishNode(e, "ThrowStatement");
            };
            var le = [];
            ae.parseTryStatement = function(e) {
                this.next();
                e.block = this.parseBlock();
                e.handler = null;
                if (this.type === b._catch) {
                    var t = this.startNode();
                    this.next();
                    if (this.eat(b.parenL)) {
                        t.param = this.parseBindingAtom();
                        var i = t.param.type === "Identifier";
                        this.enterScope(i ? q : 0);
                        this.checkLVal(t.param, i ? Q : H);
                        this.expect(b.parenR);
                    } else {
                        if (this.options.ecmaVersion < 10) {
                            this.unexpected();
                        }
                        t.param = null;
                        this.enterScope(0);
                    }
                    t.body = this.parseBlock(false);
                    this.exitScope();
                    e.handler = this.finishNode(t, "CatchClause");
                }
                e.finalizer = this.eat(b._finally) ? this.parseBlock() : null;
                if (!e.handler && !e.finalizer) {
                    this.raise(e.start, "Missing catch or finally clause");
                }
                return this.finishNode(e, "TryStatement");
            };
            ae.parseVarStatement = function(e, t) {
                this.next();
                this.parseVar(e, false, t);
                this.semicolon();
                return this.finishNode(e, "VariableDeclaration");
            };
            ae.parseWhileStatement = function(e) {
                this.next();
                e.test = this.parseParenExpression();
                this.labels.push(ne);
                e.body = this.parseStatement("while");
                this.labels.pop();
                return this.finishNode(e, "WhileStatement");
            };
            ae.parseWithStatement = function(e) {
                if (this.strict) {
                    this.raise(this.start, "'with' in strict mode");
                }
                this.next();
                e.object = this.parseParenExpression();
                e.body = this.parseStatement("with");
                return this.finishNode(e, "WithStatement");
            };
            ae.parseEmptyStatement = function(e) {
                this.next();
                return this.finishNode(e, "EmptyStatement");
            };
            ae.parseLabeledStatement = function(e, t, i, r) {
                var s = this;
                for (var a = 0, n = s.labels; a < n.length; a += 1) {
                    var o = n[a];
                    if (o.name === t) {
                        s.raise(i.start, "Label '" + t + "' is already declared");
                    }
                }
                var l = this.type.isLoop ? "loop" : this.type === b._switch ? "switch" : null;
                for (var u = this.labels.length - 1; u >= 0; u--) {
                    var c = s.labels[u];
                    if (c.statementStart === e.start) {
                        c.statementStart = s.start;
                        c.kind = l;
                    } else {
                        break;
                    }
                }
                this.labels.push({
                    name: t,
                    kind: l,
                    statementStart: this.start
                });
                e.body = this.parseStatement(r);
                if (e.body.type === "ClassDeclaration" || e.body.type === "VariableDeclaration" && e.body.kind !== "var" || e.body.type === "FunctionDeclaration" && (this.strict || e.body.generator || e.body.async)) {
                    this.raiseRecoverable(e.body.start, "Invalid labeled declaration");
                }
                this.labels.pop();
                e.label = i;
                return this.finishNode(e, "LabeledStatement");
            };
            ae.parseExpressionStatement = function(e, t) {
                e.expression = t;
                this.semicolon();
                return this.finishNode(e, "ExpressionStatement");
            };
            ae.parseBlock = function(e, t) {
                var i = this;
                if (e === void 0) e = true;
                if (t === void 0) t = this.startNode();
                t.body = [];
                this.expect(b.braceL);
                if (e) {
                    this.enterScope(0);
                }
                while (!this.eat(b.braceR)) {
                    var r = i.parseStatement(null);
                    t.body.push(r);
                }
                if (e) {
                    this.exitScope();
                }
                return this.finishNode(t, "BlockStatement");
            };
            ae.parseFor = function(e, t) {
                e.init = t;
                this.expect(b.semi);
                e.test = this.type === b.semi ? null : this.parseExpression();
                this.expect(b.semi);
                e.update = this.type === b.parenR ? null : this.parseExpression();
                this.expect(b.parenR);
                this.exitScope();
                e.body = this.parseStatement("for");
                this.labels.pop();
                return this.finishNode(e, "ForStatement");
            };
            ae.parseForIn = function(e, t) {
                var i = this.type === b._in ? "ForInStatement" : "ForOfStatement";
                this.next();
                if (i === "ForInStatement") {
                    if (t.type === "AssignmentPattern" || t.type === "VariableDeclaration" && t.declarations[0].init != null && (this.strict || t.declarations[0].id.type !== "Identifier")) {
                        this.raise(t.start, "Invalid assignment in for-in loop head");
                    }
                }
                e.left = t;
                e.right = i === "ForInStatement" ? this.parseExpression() : this.parseMaybeAssign();
                this.expect(b.parenR);
                this.exitScope();
                e.body = this.parseStatement("for");
                this.labels.pop();
                return this.finishNode(e, i);
            };
            ae.parseVar = function(e, t, i) {
                var r = this;
                e.declarations = [];
                e.kind = i;
                for (;;) {
                    var s = r.startNode();
                    r.parseVarId(s, i);
                    if (r.eat(b.eq)) {
                        s.init = r.parseMaybeAssign(t);
                    } else if (i === "const" && !(r.type === b._in || r.options.ecmaVersion >= 6 && r.isContextual("of"))) {
                        r.unexpected();
                    } else if (s.id.type !== "Identifier" && !(t && (r.type === b._in || r.isContextual("of")))) {
                        r.raise(r.lastTokEnd, "Complex binding patterns require an initialization value");
                    } else {
                        s.init = null;
                    }
                    e.declarations.push(r.finishNode(s, "VariableDeclarator"));
                    if (!r.eat(b.comma)) {
                        break;
                    }
                }
                return e;
            };
            ae.parseVarId = function(e, t) {
                e.id = this.parseBindingAtom(t);
                this.checkLVal(e.id, t === "var" ? G : H, false);
            };
            var ue = 1;
            var ce = 2;
            var he = 4;
            ae.parseFunction = function(e, t, i, r) {
                this.initFunction(e);
                if (this.options.ecmaVersion >= 9 || this.options.ecmaVersion >= 6 && !r) {
                    e.generator = this.eat(b.star);
                }
                if (this.options.ecmaVersion >= 8) {
                    e.async = !!r;
                }
                if (t & ue) {
                    e.id = t & he && this.type !== b.name ? null : this.parseIdent();
                    if (e.id && !(t & ce)) {
                        this.checkLVal(e.id, this.inModule && !this.inFunction ? H : Y);
                    }
                }
                var s = this.yieldPos, a = this.awaitPos;
                this.yieldPos = 0;
                this.awaitPos = 0;
                this.enterScope(W(e.async, e.generator));
                if (!(t & ue)) {
                    e.id = this.type === b.name ? this.parseIdent() : null;
                }
                this.parseFunctionParams(e);
                this.parseFunctionBody(e, i);
                this.yieldPos = s;
                this.awaitPos = a;
                return this.finishNode(e, t & ue ? "FunctionDeclaration" : "FunctionExpression");
            };
            ae.parseFunctionParams = function(e) {
                this.expect(b.parenL);
                e.params = this.parseBindingList(b.parenR, false, this.options.ecmaVersion >= 8);
                this.checkYieldAwaitInDefaultParams();
            };
            ae.parseClass = function(e, t) {
                var i = this;
                this.next();
                this.parseClassId(e, t);
                this.parseClassSuper(e);
                var r = this.startNode();
                var s = false;
                r.body = [];
                this.expect(b.braceL);
                while (!this.eat(b.braceR)) {
                    var a = i.parseClassElement(e.superClass !== null);
                    if (a) {
                        r.body.push(a);
                        if (a.type === "MethodDefinition" && a.kind === "constructor") {
                            if (s) {
                                i.raise(a.start, "Duplicate constructor in the same class");
                            }
                            s = true;
                        }
                    }
                }
                e.body = this.finishNode(r, "ClassBody");
                return this.finishNode(e, t ? "ClassDeclaration" : "ClassExpression");
            };
            ae.parseClassElement = function(e) {
                var t = this;
                if (this.eat(b.semi)) {
                    return null;
                }
                var i = this.startNode();
                var r = function e(r, s) {
                    if (s === void 0) s = false;
                    var a = t.start, n = t.startLoc;
                    if (!t.eatContextual(r)) {
                        return false;
                    }
                    if (t.type !== b.parenL && (!s || !t.canInsertSemicolon())) {
                        return true;
                    }
                    if (i.key) {
                        t.unexpected();
                    }
                    i.computed = false;
                    i.key = t.startNodeAt(a, n);
                    i.key.name = r;
                    t.finishNode(i.key, "Identifier");
                    return false;
                };
                i.kind = "method";
                i.static = r("static");
                var s = this.eat(b.star);
                var a = false;
                if (!s) {
                    if (this.options.ecmaVersion >= 8 && r("async", true)) {
                        a = true;
                        s = this.options.ecmaVersion >= 9 && this.eat(b.star);
                    } else if (r("get")) {
                        i.kind = "get";
                    } else if (r("set")) {
                        i.kind = "set";
                    }
                }
                if (!i.key) {
                    this.parsePropertyName(i);
                }
                var n = i.key;
                var o = false;
                if (!i.computed && !i.static && (n.type === "Identifier" && n.name === "constructor" || n.type === "Literal" && n.value === "constructor")) {
                    if (i.kind !== "method") {
                        this.raise(n.start, "Constructor can't have get/set modifier");
                    }
                    if (s) {
                        this.raise(n.start, "Constructor can't be a generator");
                    }
                    if (a) {
                        this.raise(n.start, "Constructor can't be an async method");
                    }
                    i.kind = "constructor";
                    o = e;
                } else if (i.static && n.type === "Identifier" && n.name === "prototype") {
                    this.raise(n.start, "Classes may not have a static property named prototype");
                }
                this.parseClassMethod(i, s, a, o);
                if (i.kind === "get" && i.value.params.length !== 0) {
                    this.raiseRecoverable(i.value.start, "getter should have no params");
                }
                if (i.kind === "set" && i.value.params.length !== 1) {
                    this.raiseRecoverable(i.value.start, "setter should have exactly one param");
                }
                if (i.kind === "set" && i.value.params[0].type === "RestElement") {
                    this.raiseRecoverable(i.value.params[0].start, "Setter cannot use rest params");
                }
                return i;
            };
            ae.parseClassMethod = function(e, t, i, r) {
                e.value = this.parseMethod(t, i, r);
                return this.finishNode(e, "MethodDefinition");
            };
            ae.parseClassId = function(e, t) {
                e.id = this.type === b.name ? this.parseIdent() : t === true ? this.unexpected() : null;
            };
            ae.parseClassSuper = function(e) {
                e.superClass = this.eat(b._extends) ? this.parseExprSubscripts() : null;
            };
            ae.parseExport = function(e, t) {
                var i = this;
                this.next();
                if (this.eat(b.star)) {
                    this.expectContextual("from");
                    if (this.type !== b.string) {
                        this.unexpected();
                    }
                    e.source = this.parseExprAtom();
                    this.semicolon();
                    return this.finishNode(e, "ExportAllDeclaration");
                }
                if (this.eat(b._default)) {
                    this.checkExport(t, "default", this.lastTokStart);
                    var r;
                    if (this.type === b._function || (r = this.isAsyncFunction())) {
                        var s = this.startNode();
                        this.next();
                        if (r) {
                            this.next();
                        }
                        e.declaration = this.parseFunction(s, ue | he, false, r, true);
                    } else if (this.type === b._class) {
                        var a = this.startNode();
                        e.declaration = this.parseClass(a, "nullableID");
                    } else {
                        e.declaration = this.parseMaybeAssign();
                        this.semicolon();
                    }
                    return this.finishNode(e, "ExportDefaultDeclaration");
                }
                if (this.shouldParseExportStatement()) {
                    e.declaration = this.parseStatement(null);
                    if (e.declaration.type === "VariableDeclaration") {
                        this.checkVariableExport(t, e.declaration.declarations);
                    } else {
                        this.checkExport(t, e.declaration.id.name, e.declaration.id.start);
                    }
                    e.specifiers = [];
                    e.source = null;
                } else {
                    e.declaration = null;
                    e.specifiers = this.parseExportSpecifiers(t);
                    if (this.eatContextual("from")) {
                        if (this.type !== b.string) {
                            this.unexpected();
                        }
                        e.source = this.parseExprAtom();
                    } else {
                        for (var n = 0, o = e.specifiers; n < o.length; n += 1) {
                            var l = o[n];
                            i.checkUnreserved(l.local);
                        }
                        e.source = null;
                    }
                    this.semicolon();
                }
                return this.finishNode(e, "ExportNamedDeclaration");
            };
            ae.checkExport = function(e, t, i) {
                if (!e) {
                    return;
                }
                if (D(e, t)) {
                    this.raiseRecoverable(i, "Duplicate export '" + t + "'");
                }
                e[t] = true;
            };
            ae.checkPatternExport = function(e, t) {
                var i = this;
                var r = t.type;
                if (r === "Identifier") {
                    this.checkExport(e, t.name, t.start);
                } else if (r === "ObjectPattern") {
                    for (var s = 0, a = t.properties; s < a.length; s += 1) {
                        var n = a[s];
                        i.checkPatternExport(e, n);
                    }
                } else if (r === "ArrayPattern") {
                    for (var o = 0, l = t.elements; o < l.length; o += 1) {
                        var u = l[o];
                        if (u) {
                            i.checkPatternExport(e, u);
                        }
                    }
                } else if (r === "Property") {
                    this.checkPatternExport(e, t.value);
                } else if (r === "AssignmentPattern") {
                    this.checkPatternExport(e, t.left);
                } else if (r === "RestElement") {
                    this.checkPatternExport(e, t.argument);
                } else if (r === "ParenthesizedExpression") {
                    this.checkPatternExport(e, t.expression);
                }
            };
            ae.checkVariableExport = function(e, t) {
                var i = this;
                if (!e) {
                    return;
                }
                for (var r = 0, s = t; r < s.length; r += 1) {
                    var a = s[r];
                    i.checkPatternExport(e, a.id);
                }
            };
            ae.shouldParseExportStatement = function() {
                return this.type.keyword === "var" || this.type.keyword === "const" || this.type.keyword === "class" || this.type.keyword === "function" || this.isLet() || this.isAsyncFunction();
            };
            ae.parseExportSpecifiers = function(e) {
                var t = this;
                var i = [], r = true;
                this.expect(b.braceL);
                while (!this.eat(b.braceR)) {
                    if (!r) {
                        t.expect(b.comma);
                        if (t.afterTrailingComma(b.braceR)) {
                            break;
                        }
                    } else {
                        r = false;
                    }
                    var s = t.startNode();
                    s.local = t.parseIdent(true);
                    s.exported = t.eatContextual("as") ? t.parseIdent(true) : s.local;
                    t.checkExport(e, s.exported.name, s.exported.start);
                    i.push(t.finishNode(s, "ExportSpecifier"));
                }
                return i;
            };
            ae.parseImport = function(e) {
                this.next();
                if (this.type === b.string) {
                    e.specifiers = le;
                    e.source = this.parseExprAtom();
                } else {
                    e.specifiers = this.parseImportSpecifiers();
                    this.expectContextual("from");
                    e.source = this.type === b.string ? this.parseExprAtom() : this.unexpected();
                }
                this.semicolon();
                return this.finishNode(e, "ImportDeclaration");
            };
            ae.parseImportSpecifiers = function() {
                var e = this;
                var t = [], i = true;
                if (this.type === b.name) {
                    var r = this.startNode();
                    r.local = this.parseIdent();
                    this.checkLVal(r.local, H);
                    t.push(this.finishNode(r, "ImportDefaultSpecifier"));
                    if (!this.eat(b.comma)) {
                        return t;
                    }
                }
                if (this.type === b.star) {
                    var s = this.startNode();
                    this.next();
                    this.expectContextual("as");
                    s.local = this.parseIdent();
                    this.checkLVal(s.local, H);
                    t.push(this.finishNode(s, "ImportNamespaceSpecifier"));
                    return t;
                }
                this.expect(b.braceL);
                while (!this.eat(b.braceR)) {
                    if (!i) {
                        e.expect(b.comma);
                        if (e.afterTrailingComma(b.braceR)) {
                            break;
                        }
                    } else {
                        i = false;
                    }
                    var a = e.startNode();
                    a.imported = e.parseIdent(true);
                    if (e.eatContextual("as")) {
                        a.local = e.parseIdent();
                    } else {
                        e.checkUnreserved(a.imported);
                        a.local = a.imported;
                    }
                    e.checkLVal(a.local, H);
                    t.push(e.finishNode(a, "ImportSpecifier"));
                }
                return t;
            };
            ae.adaptDirectivePrologue = function(e) {
                for (var t = 0; t < e.length && this.isDirectiveCandidate(e[t]); ++t) {
                    e[t].directive = e[t].expression.raw.slice(1, -1);
                }
            };
            ae.isDirectiveCandidate = function(e) {
                return e.type === "ExpressionStatement" && e.expression.type === "Literal" && typeof e.expression.value === "string" && (this.input[e.start] === '"' || this.input[e.start] === "'");
            };
            var pe = ee.prototype;
            pe.toAssignable = function(e, t, i) {
                var r = this;
                if (this.options.ecmaVersion >= 6 && e) {
                    switch (e.type) {
                      case "Identifier":
                        if (this.inAsync && e.name === "await") {
                            this.raise(e.start, "Can not use 'await' as identifier inside an async function");
                        }
                        break;

                      case "ObjectPattern":
                      case "ArrayPattern":
                      case "RestElement":
                        break;

                      case "ObjectExpression":
                        e.type = "ObjectPattern";
                        if (i) {
                            this.checkPatternErrors(i, true);
                        }
                        for (var s = 0, a = e.properties; s < a.length; s += 1) {
                            var n = a[s];
                            r.toAssignable(n, t);
                            if (n.type === "RestElement" && (n.argument.type === "ArrayPattern" || n.argument.type === "ObjectPattern")) {
                                r.raise(n.argument.start, "Unexpected token");
                            }
                        }
                        break;

                      case "Property":
                        if (e.kind !== "init") {
                            this.raise(e.key.start, "Object pattern can't contain getter or setter");
                        }
                        this.toAssignable(e.value, t);
                        break;

                      case "ArrayExpression":
                        e.type = "ArrayPattern";
                        if (i) {
                            this.checkPatternErrors(i, true);
                        }
                        this.toAssignableList(e.elements, t);
                        break;

                      case "SpreadElement":
                        e.type = "RestElement";
                        this.toAssignable(e.argument, t);
                        if (e.argument.type === "AssignmentPattern") {
                            this.raise(e.argument.start, "Rest elements cannot have a default value");
                        }
                        break;

                      case "AssignmentExpression":
                        if (e.operator !== "=") {
                            this.raise(e.left.end, "Only '=' operator can be used for specifying default value.");
                        }
                        e.type = "AssignmentPattern";
                        delete e.operator;
                        this.toAssignable(e.left, t);

                      case "AssignmentPattern":
                        break;

                      case "ParenthesizedExpression":
                        this.toAssignable(e.expression, t, i);
                        break;

                      case "MemberExpression":
                        if (!t) {
                            break;
                        }

                      default:
                        this.raise(e.start, "Assigning to rvalue");
                    }
                } else if (i) {
                    this.checkPatternErrors(i, true);
                }
                return e;
            };
            pe.toAssignableList = function(e, t) {
                var i = this;
                var r = e.length;
                for (var s = 0; s < r; s++) {
                    var a = e[s];
                    if (a) {
                        i.toAssignable(a, t);
                    }
                }
                if (r) {
                    var n = e[r - 1];
                    if (this.options.ecmaVersion === 6 && t && n && n.type === "RestElement" && n.argument.type !== "Identifier") {
                        this.unexpected(n.argument.start);
                    }
                }
                return e;
            };
            pe.parseSpread = function(e) {
                var t = this.startNode();
                this.next();
                t.argument = this.parseMaybeAssign(false, e);
                return this.finishNode(t, "SpreadElement");
            };
            pe.parseRestBinding = function() {
                var e = this.startNode();
                this.next();
                if (this.options.ecmaVersion === 6 && this.type !== b.name) {
                    this.unexpected();
                }
                e.argument = this.parseBindingAtom();
                return this.finishNode(e, "RestElement");
            };
            pe.parseBindingAtom = function() {
                if (this.options.ecmaVersion >= 6) {
                    switch (this.type) {
                      case b.bracketL:
                        var e = this.startNode();
                        this.next();
                        e.elements = this.parseBindingList(b.bracketR, true, true);
                        return this.finishNode(e, "ArrayPattern");

                      case b.braceL:
                        return this.parseObj(true);
                    }
                }
                return this.parseIdent();
            };
            pe.parseBindingList = function(e, t, i) {
                var r = this;
                var s = [], a = true;
                while (!this.eat(e)) {
                    if (a) {
                        a = false;
                    } else {
                        r.expect(b.comma);
                    }
                    if (t && r.type === b.comma) {
                        s.push(null);
                    } else if (i && r.afterTrailingComma(e)) {
                        break;
                    } else if (r.type === b.ellipsis) {
                        var n = r.parseRestBinding();
                        r.parseBindingListItem(n);
                        s.push(n);
                        if (r.type === b.comma) {
                            r.raise(r.start, "Comma is not permitted after the rest element");
                        }
                        r.expect(e);
                        break;
                    } else {
                        var o = r.parseMaybeDefault(r.start, r.startLoc);
                        r.parseBindingListItem(o);
                        s.push(o);
                    }
                }
                return s;
            };
            pe.parseBindingListItem = function(e) {
                return e;
            };
            pe.parseMaybeDefault = function(e, t, i) {
                i = i || this.parseBindingAtom();
                if (this.options.ecmaVersion < 6 || !this.eat(b.eq)) {
                    return i;
                }
                var r = this.startNodeAt(e, t);
                r.left = i;
                r.right = this.parseMaybeAssign();
                return this.finishNode(r, "AssignmentPattern");
            };
            pe.checkLVal = function(e, t, i) {
                var r = this;
                if (t === void 0) t = K;
                switch (e.type) {
                  case "Identifier":
                    if (this.strict && this.reservedWordsStrictBind.test(e.name)) {
                        this.raiseRecoverable(e.start, (t ? "Binding " : "Assigning to ") + e.name + " in strict mode");
                    }
                    if (i) {
                        if (D(i, e.name)) {
                            this.raiseRecoverable(e.start, "Argument name clash");
                        }
                        i[e.name] = true;
                    }
                    if (t !== K && t !== $) {
                        this.declareName(e.name, t, e.start);
                    }
                    break;

                  case "MemberExpression":
                    if (t) {
                        this.raiseRecoverable(e.start, "Binding member expression");
                    }
                    break;

                  case "ObjectPattern":
                    for (var s = 0, a = e.properties; s < a.length; s += 1) {
                        var n = a[s];
                        r.checkLVal(n, t, i);
                    }
                    break;

                  case "Property":
                    this.checkLVal(e.value, t, i);
                    break;

                  case "ArrayPattern":
                    for (var o = 0, l = e.elements; o < l.length; o += 1) {
                        var u = l[o];
                        if (u) {
                            r.checkLVal(u, t, i);
                        }
                    }
                    break;

                  case "AssignmentPattern":
                    this.checkLVal(e.left, t, i);
                    break;

                  case "RestElement":
                    this.checkLVal(e.argument, t, i);
                    break;

                  case "ParenthesizedExpression":
                    this.checkLVal(e.expression, t, i);
                    break;

                  default:
                    this.raise(e.start, (t ? "Binding" : "Assigning to") + " rvalue");
                }
            };
            var fe = ee.prototype;
            fe.checkPropClash = function(e, t, i) {
                if (this.options.ecmaVersion >= 9 && e.type === "SpreadElement") {
                    return;
                }
                if (this.options.ecmaVersion >= 6 && (e.computed || e.method || e.shorthand)) {
                    return;
                }
                var r = e.key;
                var s;
                switch (r.type) {
                  case "Identifier":
                    s = r.name;
                    break;

                  case "Literal":
                    s = String(r.value);
                    break;

                  default:
                    return;
                }
                var a = e.kind;
                if (this.options.ecmaVersion >= 6) {
                    if (s === "__proto__" && a === "init") {
                        if (t.proto) {
                            if (i && i.doubleProto < 0) {
                                i.doubleProto = r.start;
                            } else {
                                this.raiseRecoverable(r.start, "Redefinition of __proto__ property");
                            }
                        }
                        t.proto = true;
                    }
                    return;
                }
                s = "$" + s;
                var n = t[s];
                if (n) {
                    var o;
                    if (a === "init") {
                        o = this.strict && n.init || n.get || n.set;
                    } else {
                        o = n.init || n[a];
                    }
                    if (o) {
                        this.raiseRecoverable(r.start, "Redefinition of property");
                    }
                } else {
                    n = t[s] = {
                        init: false,
                        get: false,
                        set: false
                    };
                }
                n[a] = true;
            };
            fe.parseExpression = function(e, t) {
                var i = this;
                var r = this.start, s = this.startLoc;
                var a = this.parseMaybeAssign(e, t);
                if (this.type === b.comma) {
                    var n = this.startNodeAt(r, s);
                    n.expressions = [ a ];
                    while (this.eat(b.comma)) {
                        n.expressions.push(i.parseMaybeAssign(e, t));
                    }
                    return this.finishNode(n, "SequenceExpression");
                }
                return a;
            };
            fe.parseMaybeAssign = function(e, t, i) {
                if (this.isContextual("yield")) {
                    if (this.inGenerator) {
                        return this.parseYield();
                    } else {
                        this.exprAllowed = false;
                    }
                }
                var r = false, s = -1, a = -1, n = -1;
                if (t) {
                    s = t.parenthesizedAssign;
                    a = t.trailingComma;
                    n = t.shorthandAssign;
                    t.parenthesizedAssign = t.trailingComma = t.shorthandAssign = -1;
                } else {
                    t = new se();
                    r = true;
                }
                var o = this.start, l = this.startLoc;
                if (this.type === b.parenL || this.type === b.name) {
                    this.potentialArrowAt = this.start;
                }
                var u = this.parseMaybeConditional(e, t);
                if (i) {
                    u = i.call(this, u, o, l);
                }
                if (this.type.isAssign) {
                    var c = this.startNodeAt(o, l);
                    c.operator = this.value;
                    c.left = this.type === b.eq ? this.toAssignable(u, false, t) : u;
                    if (!r) {
                        se.call(t);
                    }
                    t.shorthandAssign = -1;
                    this.checkLVal(u);
                    this.next();
                    c.right = this.parseMaybeAssign(e);
                    return this.finishNode(c, "AssignmentExpression");
                } else {
                    if (r) {
                        this.checkExpressionErrors(t, true);
                    }
                }
                if (s > -1) {
                    t.parenthesizedAssign = s;
                }
                if (a > -1) {
                    t.trailingComma = a;
                }
                if (n > -1) {
                    t.shorthandAssign = n;
                }
                return u;
            };
            fe.parseMaybeConditional = function(e, t) {
                var i = this.start, r = this.startLoc;
                var s = this.parseExprOps(e, t);
                if (this.checkExpressionErrors(t)) {
                    return s;
                }
                if (this.eat(b.question)) {
                    var a = this.startNodeAt(i, r);
                    a.test = s;
                    a.consequent = this.parseMaybeAssign();
                    this.expect(b.colon);
                    a.alternate = this.parseMaybeAssign(e);
                    return this.finishNode(a, "ConditionalExpression");
                }
                return s;
            };
            fe.parseExprOps = function(e, t) {
                var i = this.start, r = this.startLoc;
                var s = this.parseMaybeUnary(t, false);
                if (this.checkExpressionErrors(t)) {
                    return s;
                }
                return s.start === i && s.type === "ArrowFunctionExpression" ? s : this.parseExprOp(s, i, r, -1, e);
            };
            fe.parseExprOp = function(e, t, i, r, s) {
                var a = this.type.binop;
                if (a != null && (!s || this.type !== b._in)) {
                    if (a > r) {
                        var n = this.type === b.logicalOR || this.type === b.logicalAND;
                        var o = this.value;
                        this.next();
                        var l = this.start, u = this.startLoc;
                        var c = this.parseExprOp(this.parseMaybeUnary(null, false), l, u, a, s);
                        var h = this.buildBinary(t, i, e, c, o, n);
                        return this.parseExprOp(h, t, i, r, s);
                    }
                }
                return e;
            };
            fe.buildBinary = function(e, t, i, r, s, a) {
                var n = this.startNodeAt(e, t);
                n.left = i;
                n.operator = s;
                n.right = r;
                return this.finishNode(n, a ? "LogicalExpression" : "BinaryExpression");
            };
            fe.parseMaybeUnary = function(e, t) {
                var i = this;
                var r = this.start, s = this.startLoc, a;
                if (this.isContextual("await") && (this.inAsync || !this.inFunction && this.options.allowAwaitOutsideFunction)) {
                    a = this.parseAwait();
                    t = true;
                } else if (this.type.prefix) {
                    var n = this.startNode(), o = this.type === b.incDec;
                    n.operator = this.value;
                    n.prefix = true;
                    this.next();
                    n.argument = this.parseMaybeUnary(null, true);
                    this.checkExpressionErrors(e, true);
                    if (o) {
                        this.checkLVal(n.argument);
                    } else if (this.strict && n.operator === "delete" && n.argument.type === "Identifier") {
                        this.raiseRecoverable(n.start, "Deleting local variable in strict mode");
                    } else {
                        t = true;
                    }
                    a = this.finishNode(n, o ? "UpdateExpression" : "UnaryExpression");
                } else {
                    a = this.parseExprSubscripts(e);
                    if (this.checkExpressionErrors(e)) {
                        return a;
                    }
                    while (this.type.postfix && !this.canInsertSemicolon()) {
                        var l = i.startNodeAt(r, s);
                        l.operator = i.value;
                        l.prefix = false;
                        l.argument = a;
                        i.checkLVal(a);
                        i.next();
                        a = i.finishNode(l, "UpdateExpression");
                    }
                }
                if (!t && this.eat(b.starstar)) {
                    return this.buildBinary(r, s, a, this.parseMaybeUnary(null, false), "**", false);
                } else {
                    return a;
                }
            };
            fe.parseExprSubscripts = function(e) {
                var t = this.start, i = this.startLoc;
                var r = this.parseExprAtom(e);
                var s = r.type === "ArrowFunctionExpression" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== ")";
                if (this.checkExpressionErrors(e) || s) {
                    return r;
                }
                var a = this.parseSubscripts(r, t, i);
                if (e && a.type === "MemberExpression") {
                    if (e.parenthesizedAssign >= a.start) {
                        e.parenthesizedAssign = -1;
                    }
                    if (e.parenthesizedBind >= a.start) {
                        e.parenthesizedBind = -1;
                    }
                }
                return a;
            };
            fe.parseSubscripts = function(e, t, i, r) {
                var s = this;
                var a = this.options.ecmaVersion >= 8 && e.type === "Identifier" && e.name === "async" && this.lastTokEnd === e.end && !this.canInsertSemicolon() && this.input.slice(e.start, e.end) === "async";
                for (var n = void 0; ;) {
                    if ((n = s.eat(b.bracketL)) || s.eat(b.dot)) {
                        var o = s.startNodeAt(t, i);
                        o.object = e;
                        o.property = n ? s.parseExpression() : s.parseIdent(true);
                        o.computed = !!n;
                        if (n) {
                            s.expect(b.bracketR);
                        }
                        e = s.finishNode(o, "MemberExpression");
                    } else if (!r && s.eat(b.parenL)) {
                        var l = new se(), u = s.yieldPos, c = s.awaitPos;
                        s.yieldPos = 0;
                        s.awaitPos = 0;
                        var h = s.parseExprList(b.parenR, s.options.ecmaVersion >= 8, false, l);
                        if (a && !s.canInsertSemicolon() && s.eat(b.arrow)) {
                            s.checkPatternErrors(l, false);
                            s.checkYieldAwaitInDefaultParams();
                            s.yieldPos = u;
                            s.awaitPos = c;
                            return s.parseArrowExpression(s.startNodeAt(t, i), h, true);
                        }
                        s.checkExpressionErrors(l, true);
                        s.yieldPos = u || s.yieldPos;
                        s.awaitPos = c || s.awaitPos;
                        var p = s.startNodeAt(t, i);
                        p.callee = e;
                        p.arguments = h;
                        e = s.finishNode(p, "CallExpression");
                    } else if (s.type === b.backQuote) {
                        var f = s.startNodeAt(t, i);
                        f.tag = e;
                        f.quasi = s.parseTemplate({
                            isTagged: true
                        });
                        e = s.finishNode(f, "TaggedTemplateExpression");
                    } else {
                        return e;
                    }
                }
            };
            fe.parseExprAtom = function(e) {
                if (this.type === b.slash) {
                    this.readRegexp();
                }
                var t, i = this.potentialArrowAt === this.start;
                switch (this.type) {
                  case b._super:
                    if (!this.allowSuper) {
                        this.raise(this.start, "'super' keyword outside a method");
                    }
                    t = this.startNode();
                    this.next();
                    if (this.type === b.parenL && !this.allowDirectSuper) {
                        this.raise(t.start, "super() call outside constructor of a subclass");
                    }
                    if (this.type !== b.dot && this.type !== b.bracketL && this.type !== b.parenL) {
                        this.unexpected();
                    }
                    return this.finishNode(t, "Super");

                  case b._this:
                    t = this.startNode();
                    this.next();
                    return this.finishNode(t, "ThisExpression");

                  case b.name:
                    var r = this.start, s = this.startLoc, a = this.containsEsc;
                    var n = this.parseIdent(this.type !== b.name);
                    if (this.options.ecmaVersion >= 8 && !a && n.name === "async" && !this.canInsertSemicolon() && this.eat(b._function)) {
                        return this.parseFunction(this.startNodeAt(r, s), 0, false, true);
                    }
                    if (i && !this.canInsertSemicolon()) {
                        if (this.eat(b.arrow)) {
                            return this.parseArrowExpression(this.startNodeAt(r, s), [ n ], false);
                        }
                        if (this.options.ecmaVersion >= 8 && n.name === "async" && this.type === b.name && !a) {
                            n = this.parseIdent();
                            if (this.canInsertSemicolon() || !this.eat(b.arrow)) {
                                this.unexpected();
                            }
                            return this.parseArrowExpression(this.startNodeAt(r, s), [ n ], true);
                        }
                    }
                    return n;

                  case b.regexp:
                    var o = this.value;
                    t = this.parseLiteral(o.value);
                    t.regex = {
                        pattern: o.pattern,
                        flags: o.flags
                    };
                    return t;

                  case b.num:
                  case b.string:
                    return this.parseLiteral(this.value);

                  case b._null:
                  case b._true:
                  case b._false:
                    t = this.startNode();
                    t.value = this.type === b._null ? null : this.type === b._true;
                    t.raw = this.type.keyword;
                    this.next();
                    return this.finishNode(t, "Literal");

                  case b.parenL:
                    var l = this.start, u = this.parseParenAndDistinguishExpression(i);
                    if (e) {
                        if (e.parenthesizedAssign < 0 && !this.isSimpleAssignTarget(u)) {
                            e.parenthesizedAssign = l;
                        }
                        if (e.parenthesizedBind < 0) {
                            e.parenthesizedBind = l;
                        }
                    }
                    return u;

                  case b.bracketL:
                    t = this.startNode();
                    this.next();
                    t.elements = this.parseExprList(b.bracketR, true, true, e);
                    return this.finishNode(t, "ArrayExpression");

                  case b.braceL:
                    return this.parseObj(false, e);

                  case b._function:
                    t = this.startNode();
                    this.next();
                    return this.parseFunction(t, 0);

                  case b._class:
                    return this.parseClass(this.startNode(), false);

                  case b._new:
                    return this.parseNew();

                  case b.backQuote:
                    return this.parseTemplate();

                  default:
                    this.unexpected();
                }
            };
            fe.parseLiteral = function(e) {
                var t = this.startNode();
                t.value = e;
                t.raw = this.input.slice(this.start, this.end);
                this.next();
                return this.finishNode(t, "Literal");
            };
            fe.parseParenExpression = function() {
                this.expect(b.parenL);
                var e = this.parseExpression();
                this.expect(b.parenR);
                return e;
            };
            fe.parseParenAndDistinguishExpression = function(e) {
                var t = this;
                var i = this.start, r = this.startLoc, s, a = this.options.ecmaVersion >= 8;
                if (this.options.ecmaVersion >= 6) {
                    this.next();
                    var n = this.start, o = this.startLoc;
                    var l = [], u = true, c = false;
                    var h = new se(), p = this.yieldPos, f = this.awaitPos, d;
                    this.yieldPos = 0;
                    this.awaitPos = 0;
                    while (this.type !== b.parenR) {
                        u ? u = false : t.expect(b.comma);
                        if (a && t.afterTrailingComma(b.parenR, true)) {
                            c = true;
                            break;
                        } else if (t.type === b.ellipsis) {
                            d = t.start;
                            l.push(t.parseParenItem(t.parseRestBinding()));
                            if (t.type === b.comma) {
                                t.raise(t.start, "Comma is not permitted after the rest element");
                            }
                            break;
                        } else {
                            l.push(t.parseMaybeAssign(false, h, t.parseParenItem));
                        }
                    }
                    var m = this.start, y = this.startLoc;
                    this.expect(b.parenR);
                    if (e && !this.canInsertSemicolon() && this.eat(b.arrow)) {
                        this.checkPatternErrors(h, false);
                        this.checkYieldAwaitInDefaultParams();
                        this.yieldPos = p;
                        this.awaitPos = f;
                        return this.parseParenArrowList(i, r, l);
                    }
                    if (!l.length || c) {
                        this.unexpected(this.lastTokStart);
                    }
                    if (d) {
                        this.unexpected(d);
                    }
                    this.checkExpressionErrors(h, true);
                    this.yieldPos = p || this.yieldPos;
                    this.awaitPos = f || this.awaitPos;
                    if (l.length > 1) {
                        s = this.startNodeAt(n, o);
                        s.expressions = l;
                        this.finishNodeAt(s, "SequenceExpression", m, y);
                    } else {
                        s = l[0];
                    }
                } else {
                    s = this.parseParenExpression();
                }
                if (this.options.preserveParens) {
                    var v = this.startNodeAt(i, r);
                    v.expression = s;
                    return this.finishNode(v, "ParenthesizedExpression");
                } else {
                    return s;
                }
            };
            fe.parseParenItem = function(e) {
                return e;
            };
            fe.parseParenArrowList = function(e, t, i) {
                return this.parseArrowExpression(this.startNodeAt(e, t), i);
            };
            var de = [];
            fe.parseNew = function() {
                var e = this.startNode();
                var t = this.parseIdent(true);
                if (this.options.ecmaVersion >= 6 && this.eat(b.dot)) {
                    e.meta = t;
                    var i = this.containsEsc;
                    e.property = this.parseIdent(true);
                    if (e.property.name !== "target" || i) {
                        this.raiseRecoverable(e.property.start, "The only valid meta property for new is new.target");
                    }
                    if (!this.inNonArrowFunction()) {
                        this.raiseRecoverable(e.start, "new.target can only be used in functions");
                    }
                    return this.finishNode(e, "MetaProperty");
                }
                var r = this.start, s = this.startLoc;
                e.callee = this.parseSubscripts(this.parseExprAtom(), r, s, true);
                if (this.eat(b.parenL)) {
                    e.arguments = this.parseExprList(b.parenR, this.options.ecmaVersion >= 8, false);
                } else {
                    e.arguments = de;
                }
                return this.finishNode(e, "NewExpression");
            };
            fe.parseTemplateElement = function(e) {
                var t = e.isTagged;
                var i = this.startNode();
                if (this.type === b.invalidTemplate) {
                    if (!t) {
                        this.raiseRecoverable(this.start, "Bad escape sequence in untagged template literal");
                    }
                    i.value = {
                        raw: this.value,
                        cooked: null
                    };
                } else {
                    i.value = {
                        raw: this.input.slice(this.start, this.end).replace(/\r\n?/g, "\n"),
                        cooked: this.value
                    };
                }
                this.next();
                i.tail = this.type === b.backQuote;
                return this.finishNode(i, "TemplateElement");
            };
            fe.parseTemplate = function(e) {
                var t = this;
                if (e === void 0) e = {};
                var i = e.isTagged;
                if (i === void 0) i = false;
                var r = this.startNode();
                this.next();
                r.expressions = [];
                var s = this.parseTemplateElement({
                    isTagged: i
                });
                r.quasis = [ s ];
                while (!s.tail) {
                    if (t.type === b.eof) {
                        t.raise(t.pos, "Unterminated template literal");
                    }
                    t.expect(b.dollarBraceL);
                    r.expressions.push(t.parseExpression());
                    t.expect(b.braceR);
                    r.quasis.push(s = t.parseTemplateElement({
                        isTagged: i
                    }));
                }
                this.next();
                return this.finishNode(r, "TemplateLiteral");
            };
            fe.isAsyncProp = function(e) {
                return !e.computed && e.key.type === "Identifier" && e.key.name === "async" && (this.type === b.name || this.type === b.num || this.type === b.string || this.type === b.bracketL || this.type.keyword || this.options.ecmaVersion >= 9 && this.type === b.star) && !E.test(this.input.slice(this.lastTokEnd, this.start));
            };
            fe.parseObj = function(e, t) {
                var i = this;
                var r = this.startNode(), s = true, a = {};
                r.properties = [];
                this.next();
                while (!this.eat(b.braceR)) {
                    if (!s) {
                        i.expect(b.comma);
                        if (i.afterTrailingComma(b.braceR)) {
                            break;
                        }
                    } else {
                        s = false;
                    }
                    var n = i.parseProperty(e, t);
                    if (!e) {
                        i.checkPropClash(n, a, t);
                    }
                    r.properties.push(n);
                }
                return this.finishNode(r, e ? "ObjectPattern" : "ObjectExpression");
            };
            fe.parseProperty = function(e, t) {
                var i = this.startNode(), r, s, a, n;
                if (this.options.ecmaVersion >= 9 && this.eat(b.ellipsis)) {
                    if (e) {
                        i.argument = this.parseIdent(false);
                        if (this.type === b.comma) {
                            this.raise(this.start, "Comma is not permitted after the rest element");
                        }
                        return this.finishNode(i, "RestElement");
                    }
                    if (this.type === b.parenL && t) {
                        if (t.parenthesizedAssign < 0) {
                            t.parenthesizedAssign = this.start;
                        }
                        if (t.parenthesizedBind < 0) {
                            t.parenthesizedBind = this.start;
                        }
                    }
                    i.argument = this.parseMaybeAssign(false, t);
                    if (this.type === b.comma && t && t.trailingComma < 0) {
                        t.trailingComma = this.start;
                    }
                    return this.finishNode(i, "SpreadElement");
                }
                if (this.options.ecmaVersion >= 6) {
                    i.method = false;
                    i.shorthand = false;
                    if (e || t) {
                        a = this.start;
                        n = this.startLoc;
                    }
                    if (!e) {
                        r = this.eat(b.star);
                    }
                }
                var o = this.containsEsc;
                this.parsePropertyName(i);
                if (!e && !o && this.options.ecmaVersion >= 8 && !r && this.isAsyncProp(i)) {
                    s = true;
                    r = this.options.ecmaVersion >= 9 && this.eat(b.star);
                    this.parsePropertyName(i, t);
                } else {
                    s = false;
                }
                this.parsePropertyValue(i, e, r, s, a, n, t, o);
                return this.finishNode(i, "Property");
            };
            fe.parsePropertyValue = function(e, t, i, r, s, a, n, o) {
                if ((i || r) && this.type === b.colon) {
                    this.unexpected();
                }
                if (this.eat(b.colon)) {
                    e.value = t ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(false, n);
                    e.kind = "init";
                } else if (this.options.ecmaVersion >= 6 && this.type === b.parenL) {
                    if (t) {
                        this.unexpected();
                    }
                    e.kind = "init";
                    e.method = true;
                    e.value = this.parseMethod(i, r);
                } else if (!t && !o && this.options.ecmaVersion >= 5 && !e.computed && e.key.type === "Identifier" && (e.key.name === "get" || e.key.name === "set") && this.type !== b.comma && this.type !== b.braceR) {
                    if (i || r) {
                        this.unexpected();
                    }
                    e.kind = e.key.name;
                    this.parsePropertyName(e);
                    e.value = this.parseMethod(false);
                    var l = e.kind === "get" ? 0 : 1;
                    if (e.value.params.length !== l) {
                        var u = e.value.start;
                        if (e.kind === "get") {
                            this.raiseRecoverable(u, "getter should have no params");
                        } else {
                            this.raiseRecoverable(u, "setter should have exactly one param");
                        }
                    } else {
                        if (e.kind === "set" && e.value.params[0].type === "RestElement") {
                            this.raiseRecoverable(e.value.params[0].start, "Setter cannot use rest params");
                        }
                    }
                } else if (this.options.ecmaVersion >= 6 && !e.computed && e.key.type === "Identifier") {
                    this.checkUnreserved(e.key);
                    e.kind = "init";
                    if (t) {
                        e.value = this.parseMaybeDefault(s, a, e.key);
                    } else if (this.type === b.eq && n) {
                        if (n.shorthandAssign < 0) {
                            n.shorthandAssign = this.start;
                        }
                        e.value = this.parseMaybeDefault(s, a, e.key);
                    } else {
                        e.value = e.key;
                    }
                    e.shorthand = true;
                } else {
                    this.unexpected();
                }
            };
            fe.parsePropertyName = function(e) {
                if (this.options.ecmaVersion >= 6) {
                    if (this.eat(b.bracketL)) {
                        e.computed = true;
                        e.key = this.parseMaybeAssign();
                        this.expect(b.bracketR);
                        return e.key;
                    } else {
                        e.computed = false;
                    }
                }
                return e.key = this.type === b.num || this.type === b.string ? this.parseExprAtom() : this.parseIdent(true);
            };
            fe.initFunction = function(e) {
                e.id = null;
                if (this.options.ecmaVersion >= 6) {
                    e.generator = e.expression = false;
                }
                if (this.options.ecmaVersion >= 8) {
                    e.async = false;
                }
            };
            fe.parseMethod = function(e, t, i) {
                var r = this.startNode(), s = this.yieldPos, a = this.awaitPos;
                this.initFunction(r);
                if (this.options.ecmaVersion >= 6) {
                    r.generator = e;
                }
                if (this.options.ecmaVersion >= 8) {
                    r.async = !!t;
                }
                this.yieldPos = 0;
                this.awaitPos = 0;
                this.enterScope(W(t, r.generator) | J | (i ? z : 0));
                this.expect(b.parenL);
                r.params = this.parseBindingList(b.parenR, false, this.options.ecmaVersion >= 8);
                this.checkYieldAwaitInDefaultParams();
                this.parseFunctionBody(r, false);
                this.yieldPos = s;
                this.awaitPos = a;
                return this.finishNode(r, "FunctionExpression");
            };
            fe.parseArrowExpression = function(e, t, i) {
                var r = this.yieldPos, s = this.awaitPos;
                this.enterScope(W(i, false) | X);
                this.initFunction(e);
                if (this.options.ecmaVersion >= 8) {
                    e.async = !!i;
                }
                this.yieldPos = 0;
                this.awaitPos = 0;
                e.params = this.toAssignableList(t, true);
                this.parseFunctionBody(e, true);
                this.yieldPos = r;
                this.awaitPos = s;
                return this.finishNode(e, "ArrowFunctionExpression");
            };
            fe.parseFunctionBody = function(e, t) {
                var i = t && this.type !== b.braceL;
                var r = this.strict, s = false;
                if (i) {
                    e.body = this.parseMaybeAssign();
                    e.expression = true;
                    this.checkParams(e, false);
                } else {
                    var a = this.options.ecmaVersion >= 7 && !this.isSimpleParamList(e.params);
                    if (!r || a) {
                        s = this.strictDirective(this.end);
                        if (s && a) {
                            this.raiseRecoverable(e.start, "Illegal 'use strict' directive in function with non-simple parameter list");
                        }
                    }
                    var n = this.labels;
                    this.labels = [];
                    if (s) {
                        this.strict = true;
                    }
                    this.checkParams(e, !r && !s && !t && this.isSimpleParamList(e.params));
                    e.body = this.parseBlock(false);
                    e.expression = false;
                    this.adaptDirectivePrologue(e.body.body);
                    this.labels = n;
                }
                this.exitScope();
                if (this.strict && e.id) {
                    this.checkLVal(e.id, $);
                }
                this.strict = r;
            };
            fe.isSimpleParamList = function(e) {
                for (var t = 0, i = e; t < i.length; t += 1) {
                    var r = i[t];
                    if (r.type !== "Identifier") {
                        return false;
                    }
                }
                return true;
            };
            fe.checkParams = function(e, t) {
                var i = this;
                var r = {};
                for (var s = 0, a = e.params; s < a.length; s += 1) {
                    var n = a[s];
                    i.checkLVal(n, G, t ? null : r);
                }
            };
            fe.parseExprList = function(e, t, i, r) {
                var s = this;
                var a = [], n = true;
                while (!this.eat(e)) {
                    if (!n) {
                        s.expect(b.comma);
                        if (t && s.afterTrailingComma(e)) {
                            break;
                        }
                    } else {
                        n = false;
                    }
                    var o = void 0;
                    if (i && s.type === b.comma) {
                        o = null;
                    } else if (s.type === b.ellipsis) {
                        o = s.parseSpread(r);
                        if (r && s.type === b.comma && r.trailingComma < 0) {
                            r.trailingComma = s.start;
                        }
                    } else {
                        o = s.parseMaybeAssign(false, r);
                    }
                    a.push(o);
                }
                return a;
            };
            fe.checkUnreserved = function(e) {
                var t = e.start;
                var i = e.end;
                var r = e.name;
                if (this.inGenerator && r === "yield") {
                    this.raiseRecoverable(t, "Can not use 'yield' as identifier inside a generator");
                }
                if (this.inAsync && r === "await") {
                    this.raiseRecoverable(t, "Can not use 'await' as identifier inside an async function");
                }
                if (this.keywords.test(r)) {
                    this.raise(t, "Unexpected keyword '" + r + "'");
                }
                if (this.options.ecmaVersion < 6 && this.input.slice(t, i).indexOf("\\") !== -1) {
                    return;
                }
                var s = this.strict ? this.reservedWordsStrict : this.reservedWords;
                if (s.test(r)) {
                    if (!this.inAsync && r === "await") {
                        this.raiseRecoverable(t, "Can not use keyword 'await' outside an async function");
                    }
                    this.raiseRecoverable(t, "The keyword '" + r + "' is reserved");
                }
            };
            fe.parseIdent = function(e, t) {
                var i = this.startNode();
                if (e && this.options.allowReserved === "never") {
                    e = false;
                }
                if (this.type === b.name) {
                    i.name = this.value;
                } else if (this.type.keyword) {
                    i.name = this.type.keyword;
                    if ((i.name === "class" || i.name === "function") && (this.lastTokEnd !== this.lastTokStart + 1 || this.input.charCodeAt(this.lastTokStart) !== 46)) {
                        this.context.pop();
                    }
                } else {
                    this.unexpected();
                }
                this.next();
                this.finishNode(i, "Identifier");
                if (!e) {
                    this.checkUnreserved(i);
                }
                return i;
            };
            fe.parseYield = function() {
                if (!this.yieldPos) {
                    this.yieldPos = this.start;
                }
                var e = this.startNode();
                this.next();
                if (this.type === b.semi || this.canInsertSemicolon() || this.type !== b.star && !this.type.startsExpr) {
                    e.delegate = false;
                    e.argument = null;
                } else {
                    e.delegate = this.eat(b.star);
                    e.argument = this.parseMaybeAssign();
                }
                return this.finishNode(e, "YieldExpression");
            };
            fe.parseAwait = function() {
                if (!this.awaitPos) {
                    this.awaitPos = this.start;
                }
                var e = this.startNode();
                this.next();
                e.argument = this.parseMaybeUnary(null, true);
                return this.finishNode(e, "AwaitExpression");
            };
            var me = ee.prototype;
            me.raise = function(e, t) {
                var i = I(this.input, e);
                t += " (" + i.line + ":" + i.column + ")";
                var r = new SyntaxError(t);
                r.pos = e;
                r.loc = i;
                r.raisedAt = this.pos;
                throw r;
            };
            me.raiseRecoverable = me.raise;
            me.curPosition = function() {
                if (this.options.locations) {
                    return new N(this.curLine, this.pos - this.lineStart);
                }
            };
            var ye = ee.prototype;
            var ve = function e(t) {
                this.flags = t;
                this.var = [];
                this.lexical = [];
            };
            ye.enterScope = function(e) {
                this.scopeStack.push(new ve(e));
            };
            ye.exitScope = function() {
                this.scopeStack.pop();
            };
            ye.declareName = function(e, t, i) {
                var r = this;
                var s = false;
                if (t === H) {
                    var a = this.currentScope();
                    s = a.lexical.indexOf(e) > -1 || a.var.indexOf(e) > -1;
                    a.lexical.push(e);
                } else if (t === Q) {
                    var n = this.currentScope();
                    n.lexical.push(e);
                } else if (t === Y) {
                    var o = this.currentScope();
                    s = o.lexical.indexOf(e) > -1;
                    o.var.push(e);
                } else {
                    for (var l = this.scopeStack.length - 1; l >= 0; --l) {
                        var u = r.scopeStack[l];
                        if (u.lexical.indexOf(e) > -1 && !(u.flags & q) && u.lexical[0] === e) {
                            s = true;
                        }
                        u.var.push(e);
                        if (u.flags & R) {
                            break;
                        }
                    }
                }
                if (s) {
                    this.raiseRecoverable(i, "Identifier '" + e + "' has already been declared");
                }
            };
            ye.currentScope = function() {
                return this.scopeStack[this.scopeStack.length - 1];
            };
            ye.currentVarScope = function() {
                var e = this;
                for (var t = this.scopeStack.length - 1; ;t--) {
                    var i = e.scopeStack[t];
                    if (i.flags & R) {
                        return i;
                    }
                }
            };
            ye.currentThisScope = function() {
                var e = this;
                for (var t = this.scopeStack.length - 1; ;t--) {
                    var i = e.scopeStack[t];
                    if (i.flags & R && !(i.flags & X)) {
                        return i;
                    }
                }
            };
            var xe = function e(t, i, r) {
                this.type = "";
                this.start = i;
                this.end = 0;
                if (t.options.locations) {
                    this.loc = new F(t, r);
                }
                if (t.options.directSourceFile) {
                    this.sourceFile = t.options.directSourceFile;
                }
                if (t.options.ranges) {
                    this.range = [ i, 0 ];
                }
            };
            var ge = ee.prototype;
            ge.startNode = function() {
                return new xe(this, this.start, this.startLoc);
            };
            ge.startNodeAt = function(e, t) {
                return new xe(this, e, t);
            };
            function be(e, t, i, r) {
                e.type = t;
                e.end = i;
                if (this.options.locations) {
                    e.loc.end = r;
                }
                if (this.options.ranges) {
                    e.range[1] = i;
                }
                return e;
            }
            ge.finishNode = function(e, t) {
                return be.call(this, e, t, this.lastTokEnd, this.lastTokEndLoc);
            };
            ge.finishNodeAt = function(e, t, i, r) {
                return be.call(this, e, t, i, r);
            };
            var Ee = function e(t, i, r, s, a) {
                this.token = t;
                this.isExpr = !!i;
                this.preserveSpace = !!r;
                this.override = s;
                this.generator = !!a;
            };
            var ke = {
                b_stat: new Ee("{", false),
                b_expr: new Ee("{", true),
                b_tmpl: new Ee("${", false),
                p_stat: new Ee("(", false),
                p_expr: new Ee("(", true),
                q_tmpl: new Ee("`", true, true, function(e) {
                    return e.tryReadTemplateToken();
                }),
                f_stat: new Ee("function", false),
                f_expr: new Ee("function", true),
                f_expr_gen: new Ee("function", true, false, null, true),
                f_gen: new Ee("function", false, false, null, true)
            };
            var Se = ee.prototype;
            Se.initialContext = function() {
                return [ ke.b_stat ];
            };
            Se.braceIsBlock = function(e) {
                var t = this.curContext();
                if (t === ke.f_expr || t === ke.f_stat) {
                    return true;
                }
                if (e === b.colon && (t === ke.b_stat || t === ke.b_expr)) {
                    return !t.isExpr;
                }
                if (e === b._return || e === b.name && this.exprAllowed) {
                    return E.test(this.input.slice(this.lastTokEnd, this.start));
                }
                if (e === b._else || e === b.semi || e === b.eof || e === b.parenR || e === b.arrow) {
                    return true;
                }
                if (e === b.braceL) {
                    return t === ke.b_stat;
                }
                if (e === b._var || e === b._const || e === b.name) {
                    return false;
                }
                return !this.exprAllowed;
            };
            Se.inGeneratorContext = function() {
                var e = this;
                for (var t = this.context.length - 1; t >= 1; t--) {
                    var i = e.context[t];
                    if (i.token === "function") {
                        return i.generator;
                    }
                }
                return false;
            };
            Se.updateContext = function(e) {
                var t, i = this.type;
                if (i.keyword && e === b.dot) {
                    this.exprAllowed = false;
                } else if (t = i.updateContext) {
                    t.call(this, e);
                } else {
                    this.exprAllowed = i.beforeExpr;
                }
            };
            b.parenR.updateContext = b.braceR.updateContext = function() {
                if (this.context.length === 1) {
                    this.exprAllowed = true;
                    return;
                }
                var e = this.context.pop();
                if (e === ke.b_stat && this.curContext().token === "function") {
                    e = this.context.pop();
                }
                this.exprAllowed = !e.isExpr;
            };
            b.braceL.updateContext = function(e) {
                this.context.push(this.braceIsBlock(e) ? ke.b_stat : ke.b_expr);
                this.exprAllowed = true;
            };
            b.dollarBraceL.updateContext = function() {
                this.context.push(ke.b_tmpl);
                this.exprAllowed = true;
            };
            b.parenL.updateContext = function(e) {
                var t = e === b._if || e === b._for || e === b._with || e === b._while;
                this.context.push(t ? ke.p_stat : ke.p_expr);
                this.exprAllowed = true;
            };
            b.incDec.updateContext = function() {};
            b._function.updateContext = b._class.updateContext = function(e) {
                if (e.beforeExpr && e !== b.semi && e !== b._else && !(e === b._return && E.test(this.input.slice(this.lastTokEnd, this.start))) && !((e === b.colon || e === b.braceL) && this.curContext() === ke.b_stat)) {
                    this.context.push(ke.f_expr);
                } else {
                    this.context.push(ke.f_stat);
                }
                this.exprAllowed = false;
            };
            b.backQuote.updateContext = function() {
                if (this.curContext() === ke.q_tmpl) {
                    this.context.pop();
                } else {
                    this.context.push(ke.q_tmpl);
                }
                this.exprAllowed = false;
            };
            b.star.updateContext = function(e) {
                if (e === b._function) {
                    var t = this.context.length - 1;
                    if (this.context[t] === ke.f_expr) {
                        this.context[t] = ke.f_expr_gen;
                    } else {
                        this.context[t] = ke.f_gen;
                    }
                }
                this.exprAllowed = true;
            };
            b.name.updateContext = function(e) {
                var t = false;
                if (this.options.ecmaVersion >= 6 && e !== b.dot) {
                    if (this.value === "of" && !this.exprAllowed || this.value === "yield" && this.inGeneratorContext()) {
                        t = true;
                    }
                }
                this.exprAllowed = t;
            };
            var we = {
                $LONE: [ "ASCII", "ASCII_Hex_Digit", "AHex", "Alphabetic", "Alpha", "Any", "Assigned", "Bidi_Control", "Bidi_C", "Bidi_Mirrored", "Bidi_M", "Case_Ignorable", "CI", "Cased", "Changes_When_Casefolded", "CWCF", "Changes_When_Casemapped", "CWCM", "Changes_When_Lowercased", "CWL", "Changes_When_NFKC_Casefolded", "CWKCF", "Changes_When_Titlecased", "CWT", "Changes_When_Uppercased", "CWU", "Dash", "Default_Ignorable_Code_Point", "DI", "Deprecated", "Dep", "Diacritic", "Dia", "Emoji", "Emoji_Component", "Emoji_Modifier", "Emoji_Modifier_Base", "Emoji_Presentation", "Extender", "Ext", "Grapheme_Base", "Gr_Base", "Grapheme_Extend", "Gr_Ext", "Hex_Digit", "Hex", "IDS_Binary_Operator", "IDSB", "IDS_Trinary_Operator", "IDST", "ID_Continue", "IDC", "ID_Start", "IDS", "Ideographic", "Ideo", "Join_Control", "Join_C", "Logical_Order_Exception", "LOE", "Lowercase", "Lower", "Math", "Noncharacter_Code_Point", "NChar", "Pattern_Syntax", "Pat_Syn", "Pattern_White_Space", "Pat_WS", "Quotation_Mark", "QMark", "Radical", "Regional_Indicator", "RI", "Sentence_Terminal", "STerm", "Soft_Dotted", "SD", "Terminal_Punctuation", "Term", "Unified_Ideograph", "UIdeo", "Uppercase", "Upper", "Variation_Selector", "VS", "White_Space", "space", "XID_Continue", "XIDC", "XID_Start", "XIDS" ],
                General_Category: [ "Cased_Letter", "LC", "Close_Punctuation", "Pe", "Connector_Punctuation", "Pc", "Control", "Cc", "cntrl", "Currency_Symbol", "Sc", "Dash_Punctuation", "Pd", "Decimal_Number", "Nd", "digit", "Enclosing_Mark", "Me", "Final_Punctuation", "Pf", "Format", "Cf", "Initial_Punctuation", "Pi", "Letter", "L", "Letter_Number", "Nl", "Line_Separator", "Zl", "Lowercase_Letter", "Ll", "Mark", "M", "Combining_Mark", "Math_Symbol", "Sm", "Modifier_Letter", "Lm", "Modifier_Symbol", "Sk", "Nonspacing_Mark", "Mn", "Number", "N", "Open_Punctuation", "Ps", "Other", "C", "Other_Letter", "Lo", "Other_Number", "No", "Other_Punctuation", "Po", "Other_Symbol", "So", "Paragraph_Separator", "Zp", "Private_Use", "Co", "Punctuation", "P", "punct", "Separator", "Z", "Space_Separator", "Zs", "Spacing_Mark", "Mc", "Surrogate", "Cs", "Symbol", "S", "Titlecase_Letter", "Lt", "Unassigned", "Cn", "Uppercase_Letter", "Lu" ],
                Script: [ "Adlam", "Adlm", "Ahom", "Anatolian_Hieroglyphs", "Hluw", "Arabic", "Arab", "Armenian", "Armn", "Avestan", "Avst", "Balinese", "Bali", "Bamum", "Bamu", "Bassa_Vah", "Bass", "Batak", "Batk", "Bengali", "Beng", "Bhaiksuki", "Bhks", "Bopomofo", "Bopo", "Brahmi", "Brah", "Braille", "Brai", "Buginese", "Bugi", "Buhid", "Buhd", "Canadian_Aboriginal", "Cans", "Carian", "Cari", "Caucasian_Albanian", "Aghb", "Chakma", "Cakm", "Cham", "Cherokee", "Cher", "Common", "Zyyy", "Coptic", "Copt", "Qaac", "Cuneiform", "Xsux", "Cypriot", "Cprt", "Cyrillic", "Cyrl", "Deseret", "Dsrt", "Devanagari", "Deva", "Duployan", "Dupl", "Egyptian_Hieroglyphs", "Egyp", "Elbasan", "Elba", "Ethiopic", "Ethi", "Georgian", "Geor", "Glagolitic", "Glag", "Gothic", "Goth", "Grantha", "Gran", "Greek", "Grek", "Gujarati", "Gujr", "Gurmukhi", "Guru", "Han", "Hani", "Hangul", "Hang", "Hanunoo", "Hano", "Hatran", "Hatr", "Hebrew", "Hebr", "Hiragana", "Hira", "Imperial_Aramaic", "Armi", "Inherited", "Zinh", "Qaai", "Inscriptional_Pahlavi", "Phli", "Inscriptional_Parthian", "Prti", "Javanese", "Java", "Kaithi", "Kthi", "Kannada", "Knda", "Katakana", "Kana", "Kayah_Li", "Kali", "Kharoshthi", "Khar", "Khmer", "Khmr", "Khojki", "Khoj", "Khudawadi", "Sind", "Lao", "Laoo", "Latin", "Latn", "Lepcha", "Lepc", "Limbu", "Limb", "Linear_A", "Lina", "Linear_B", "Linb", "Lisu", "Lycian", "Lyci", "Lydian", "Lydi", "Mahajani", "Mahj", "Malayalam", "Mlym", "Mandaic", "Mand", "Manichaean", "Mani", "Marchen", "Marc", "Masaram_Gondi", "Gonm", "Meetei_Mayek", "Mtei", "Mende_Kikakui", "Mend", "Meroitic_Cursive", "Merc", "Meroitic_Hieroglyphs", "Mero", "Miao", "Plrd", "Modi", "Mongolian", "Mong", "Mro", "Mroo", "Multani", "Mult", "Myanmar", "Mymr", "Nabataean", "Nbat", "New_Tai_Lue", "Talu", "Newa", "Nko", "Nkoo", "Nushu", "Nshu", "Ogham", "Ogam", "Ol_Chiki", "Olck", "Old_Hungarian", "Hung", "Old_Italic", "Ital", "Old_North_Arabian", "Narb", "Old_Permic", "Perm", "Old_Persian", "Xpeo", "Old_South_Arabian", "Sarb", "Old_Turkic", "Orkh", "Oriya", "Orya", "Osage", "Osge", "Osmanya", "Osma", "Pahawh_Hmong", "Hmng", "Palmyrene", "Palm", "Pau_Cin_Hau", "Pauc", "Phags_Pa", "Phag", "Phoenician", "Phnx", "Psalter_Pahlavi", "Phlp", "Rejang", "Rjng", "Runic", "Runr", "Samaritan", "Samr", "Saurashtra", "Saur", "Sharada", "Shrd", "Shavian", "Shaw", "Siddham", "Sidd", "SignWriting", "Sgnw", "Sinhala", "Sinh", "Sora_Sompeng", "Sora", "Soyombo", "Soyo", "Sundanese", "Sund", "Syloti_Nagri", "Sylo", "Syriac", "Syrc", "Tagalog", "Tglg", "Tagbanwa", "Tagb", "Tai_Le", "Tale", "Tai_Tham", "Lana", "Tai_Viet", "Tavt", "Takri", "Takr", "Tamil", "Taml", "Tangut", "Tang", "Telugu", "Telu", "Thaana", "Thaa", "Thai", "Tibetan", "Tibt", "Tifinagh", "Tfng", "Tirhuta", "Tirh", "Ugaritic", "Ugar", "Vai", "Vaii", "Warang_Citi", "Wara", "Yi", "Yiii", "Zanabazar_Square", "Zanb" ]
            };
            Array.prototype.push.apply(we.$LONE, we.General_Category);
            we.gc = we.General_Category;
            we.sc = we.Script_Extensions = we.scx = we.Script;
            var Ae = ee.prototype;
            var Ce = function e(t) {
                this.parser = t;
                this.validFlags = "gim" + (t.options.ecmaVersion >= 6 ? "uy" : "") + (t.options.ecmaVersion >= 9 ? "s" : "");
                this.source = "";
                this.flags = "";
                this.start = 0;
                this.switchU = false;
                this.switchN = false;
                this.pos = 0;
                this.lastIntValue = 0;
                this.lastStringValue = "";
                this.lastAssertionIsQuantifiable = false;
                this.numCapturingParens = 0;
                this.maxBackReference = 0;
                this.groupNames = [];
                this.backReferenceNames = [];
            };
            Ce.prototype.reset = function e(t, i, r) {
                var s = r.indexOf("u") !== -1;
                this.start = t | 0;
                this.source = i + "";
                this.flags = r;
                this.switchU = s && this.parser.options.ecmaVersion >= 6;
                this.switchN = s && this.parser.options.ecmaVersion >= 9;
            };
            Ce.prototype.raise = function e(t) {
                this.parser.raiseRecoverable(this.start, "Invalid regular expression: /" + this.source + "/: " + t);
            };
            Ce.prototype.at = function e(t) {
                var i = this.source;
                var r = i.length;
                if (t >= r) {
                    return -1;
                }
                var s = i.charCodeAt(t);
                if (!this.switchU || s <= 55295 || s >= 57344 || t + 1 >= r) {
                    return s;
                }
                return (s << 10) + i.charCodeAt(t + 1) - 56613888;
            };
            Ce.prototype.nextIndex = function e(t) {
                var i = this.source;
                var r = i.length;
                if (t >= r) {
                    return r;
                }
                var s = i.charCodeAt(t);
                if (!this.switchU || s <= 55295 || s >= 57344 || t + 1 >= r) {
                    return t + 1;
                }
                return t + 2;
            };
            Ce.prototype.current = function e() {
                return this.at(this.pos);
            };
            Ce.prototype.lookahead = function e() {
                return this.at(this.nextIndex(this.pos));
            };
            Ce.prototype.advance = function e() {
                this.pos = this.nextIndex(this.pos);
            };
            Ce.prototype.eat = function e(t) {
                if (this.current() === t) {
                    this.advance();
                    return true;
                }
                return false;
            };
            function Te(e) {
                if (e <= 65535) {
                    return String.fromCharCode(e);
                }
                e -= 65536;
                return String.fromCharCode((e >> 10) + 55296, (e & 1023) + 56320);
            }
            Ae.validateRegExpFlags = function(e) {
                var t = this;
                var i = e.validFlags;
                var r = e.flags;
                for (var s = 0; s < r.length; s++) {
                    var a = r.charAt(s);
                    if (i.indexOf(a) === -1) {
                        t.raise(e.start, "Invalid regular expression flag");
                    }
                    if (r.indexOf(a, s + 1) > -1) {
                        t.raise(e.start, "Duplicate regular expression flag");
                    }
                }
            };
            Ae.validateRegExpPattern = function(e) {
                this.regexp_pattern(e);
                if (!e.switchN && this.options.ecmaVersion >= 9 && e.groupNames.length > 0) {
                    e.switchN = true;
                    this.regexp_pattern(e);
                }
            };
            Ae.regexp_pattern = function(e) {
                e.pos = 0;
                e.lastIntValue = 0;
                e.lastStringValue = "";
                e.lastAssertionIsQuantifiable = false;
                e.numCapturingParens = 0;
                e.maxBackReference = 0;
                e.groupNames.length = 0;
                e.backReferenceNames.length = 0;
                this.regexp_disjunction(e);
                if (e.pos !== e.source.length) {
                    if (e.eat(41)) {
                        e.raise("Unmatched ')'");
                    }
                    if (e.eat(93) || e.eat(125)) {
                        e.raise("Lone quantifier brackets");
                    }
                }
                if (e.maxBackReference > e.numCapturingParens) {
                    e.raise("Invalid escape");
                }
                for (var t = 0, i = e.backReferenceNames; t < i.length; t += 1) {
                    var r = i[t];
                    if (e.groupNames.indexOf(r) === -1) {
                        e.raise("Invalid named capture referenced");
                    }
                }
            };
            Ae.regexp_disjunction = function(e) {
                var t = this;
                this.regexp_alternative(e);
                while (e.eat(124)) {
                    t.regexp_alternative(e);
                }
                if (this.regexp_eatQuantifier(e, true)) {
                    e.raise("Nothing to repeat");
                }
                if (e.eat(123)) {
                    e.raise("Lone quantifier brackets");
                }
            };
            Ae.regexp_alternative = function(e) {
                while (e.pos < e.source.length && this.regexp_eatTerm(e)) {}
            };
            Ae.regexp_eatTerm = function(e) {
                if (this.regexp_eatAssertion(e)) {
                    if (e.lastAssertionIsQuantifiable && this.regexp_eatQuantifier(e)) {
                        if (e.switchU) {
                            e.raise("Invalid quantifier");
                        }
                    }
                    return true;
                }
                if (e.switchU ? this.regexp_eatAtom(e) : this.regexp_eatExtendedAtom(e)) {
                    this.regexp_eatQuantifier(e);
                    return true;
                }
                return false;
            };
            Ae.regexp_eatAssertion = function(e) {
                var t = e.pos;
                e.lastAssertionIsQuantifiable = false;
                if (e.eat(94) || e.eat(36)) {
                    return true;
                }
                if (e.eat(92)) {
                    if (e.eat(66) || e.eat(98)) {
                        return true;
                    }
                    e.pos = t;
                }
                if (e.eat(40) && e.eat(63)) {
                    var i = false;
                    if (this.options.ecmaVersion >= 9) {
                        i = e.eat(60);
                    }
                    if (e.eat(61) || e.eat(33)) {
                        this.regexp_disjunction(e);
                        if (!e.eat(41)) {
                            e.raise("Unterminated group");
                        }
                        e.lastAssertionIsQuantifiable = !i;
                        return true;
                    }
                }
                e.pos = t;
                return false;
            };
            Ae.regexp_eatQuantifier = function(e, t) {
                if (t === void 0) t = false;
                if (this.regexp_eatQuantifierPrefix(e, t)) {
                    e.eat(63);
                    return true;
                }
                return false;
            };
            Ae.regexp_eatQuantifierPrefix = function(e, t) {
                return e.eat(42) || e.eat(43) || e.eat(63) || this.regexp_eatBracedQuantifier(e, t);
            };
            Ae.regexp_eatBracedQuantifier = function(e, t) {
                var i = e.pos;
                if (e.eat(123)) {
                    var r = 0, s = -1;
                    if (this.regexp_eatDecimalDigits(e)) {
                        r = e.lastIntValue;
                        if (e.eat(44) && this.regexp_eatDecimalDigits(e)) {
                            s = e.lastIntValue;
                        }
                        if (e.eat(125)) {
                            if (s !== -1 && s < r && !t) {
                                e.raise("numbers out of order in {} quantifier");
                            }
                            return true;
                        }
                    }
                    if (e.switchU && !t) {
                        e.raise("Incomplete quantifier");
                    }
                    e.pos = i;
                }
                return false;
            };
            Ae.regexp_eatAtom = function(e) {
                return this.regexp_eatPatternCharacters(e) || e.eat(46) || this.regexp_eatReverseSolidusAtomEscape(e) || this.regexp_eatCharacterClass(e) || this.regexp_eatUncapturingGroup(e) || this.regexp_eatCapturingGroup(e);
            };
            Ae.regexp_eatReverseSolidusAtomEscape = function(e) {
                var t = e.pos;
                if (e.eat(92)) {
                    if (this.regexp_eatAtomEscape(e)) {
                        return true;
                    }
                    e.pos = t;
                }
                return false;
            };
            Ae.regexp_eatUncapturingGroup = function(e) {
                var t = e.pos;
                if (e.eat(40)) {
                    if (e.eat(63) && e.eat(58)) {
                        this.regexp_disjunction(e);
                        if (e.eat(41)) {
                            return true;
                        }
                        e.raise("Unterminated group");
                    }
                    e.pos = t;
                }
                return false;
            };
            Ae.regexp_eatCapturingGroup = function(e) {
                if (e.eat(40)) {
                    if (this.options.ecmaVersion >= 9) {
                        this.regexp_groupSpecifier(e);
                    } else if (e.current() === 63) {
                        e.raise("Invalid group");
                    }
                    this.regexp_disjunction(e);
                    if (e.eat(41)) {
                        e.numCapturingParens += 1;
                        return true;
                    }
                    e.raise("Unterminated group");
                }
                return false;
            };
            Ae.regexp_eatExtendedAtom = function(e) {
                return e.eat(46) || this.regexp_eatReverseSolidusAtomEscape(e) || this.regexp_eatCharacterClass(e) || this.regexp_eatUncapturingGroup(e) || this.regexp_eatCapturingGroup(e) || this.regexp_eatInvalidBracedQuantifier(e) || this.regexp_eatExtendedPatternCharacter(e);
            };
            Ae.regexp_eatInvalidBracedQuantifier = function(e) {
                if (this.regexp_eatBracedQuantifier(e, true)) {
                    e.raise("Nothing to repeat");
                }
                return false;
            };
            Ae.regexp_eatSyntaxCharacter = function(e) {
                var t = e.current();
                if (Pe(t)) {
                    e.lastIntValue = t;
                    e.advance();
                    return true;
                }
                return false;
            };
            function Pe(e) {
                return e === 36 || e >= 40 && e <= 43 || e === 46 || e === 63 || e >= 91 && e <= 94 || e >= 123 && e <= 125;
            }
            Ae.regexp_eatPatternCharacters = function(e) {
                var t = e.pos;
                var i = 0;
                while ((i = e.current()) !== -1 && !Pe(i)) {
                    e.advance();
                }
                return e.pos !== t;
            };
            Ae.regexp_eatExtendedPatternCharacter = function(e) {
                var t = e.current();
                if (t !== -1 && t !== 36 && !(t >= 40 && t <= 43) && t !== 46 && t !== 63 && t !== 91 && t !== 94 && t !== 124) {
                    e.advance();
                    return true;
                }
                return false;
            };
            Ae.regexp_groupSpecifier = function(e) {
                if (e.eat(63)) {
                    if (this.regexp_eatGroupName(e)) {
                        if (e.groupNames.indexOf(e.lastStringValue) !== -1) {
                            e.raise("Duplicate capture group name");
                        }
                        e.groupNames.push(e.lastStringValue);
                        return;
                    }
                    e.raise("Invalid group");
                }
            };
            Ae.regexp_eatGroupName = function(e) {
                e.lastStringValue = "";
                if (e.eat(60)) {
                    if (this.regexp_eatRegExpIdentifierName(e) && e.eat(62)) {
                        return true;
                    }
                    e.raise("Invalid capture group name");
                }
                return false;
            };
            Ae.regexp_eatRegExpIdentifierName = function(e) {
                e.lastStringValue = "";
                if (this.regexp_eatRegExpIdentifierStart(e)) {
                    e.lastStringValue += Te(e.lastIntValue);
                    while (this.regexp_eatRegExpIdentifierPart(e)) {
                        e.lastStringValue += Te(e.lastIntValue);
                    }
                    return true;
                }
                return false;
            };
            Ae.regexp_eatRegExpIdentifierStart = function(e) {
                var t = e.pos;
                var i = e.current();
                e.advance();
                if (i === 92 && this.regexp_eatRegExpUnicodeEscapeSequence(e)) {
                    i = e.lastIntValue;
                }
                if (De(i)) {
                    e.lastIntValue = i;
                    return true;
                }
                e.pos = t;
                return false;
            };
            function De(e) {
                return p(e, true) || e === 36 || e === 95;
            }
            Ae.regexp_eatRegExpIdentifierPart = function(e) {
                var t = e.pos;
                var i = e.current();
                e.advance();
                if (i === 92 && this.regexp_eatRegExpUnicodeEscapeSequence(e)) {
                    i = e.lastIntValue;
                }
                if (_e(i)) {
                    e.lastIntValue = i;
                    return true;
                }
                e.pos = t;
                return false;
            };
            function _e(e) {
                return f(e, true) || e === 36 || e === 95 || e === 8204 || e === 8205;
            }
            Ae.regexp_eatAtomEscape = function(e) {
                if (this.regexp_eatBackReference(e) || this.regexp_eatCharacterClassEscape(e) || this.regexp_eatCharacterEscape(e) || e.switchN && this.regexp_eatKGroupName(e)) {
                    return true;
                }
                if (e.switchU) {
                    if (e.current() === 99) {
                        e.raise("Invalid unicode escape");
                    }
                    e.raise("Invalid escape");
                }
                return false;
            };
            Ae.regexp_eatBackReference = function(e) {
                var t = e.pos;
                if (this.regexp_eatDecimalEscape(e)) {
                    var i = e.lastIntValue;
                    if (e.switchU) {
                        if (i > e.maxBackReference) {
                            e.maxBackReference = i;
                        }
                        return true;
                    }
                    if (i <= e.numCapturingParens) {
                        return true;
                    }
                    e.pos = t;
                }
                return false;
            };
            Ae.regexp_eatKGroupName = function(e) {
                if (e.eat(107)) {
                    if (this.regexp_eatGroupName(e)) {
                        e.backReferenceNames.push(e.lastStringValue);
                        return true;
                    }
                    e.raise("Invalid named reference");
                }
                return false;
            };
            Ae.regexp_eatCharacterEscape = function(e) {
                return this.regexp_eatControlEscape(e) || this.regexp_eatCControlLetter(e) || this.regexp_eatZero(e) || this.regexp_eatHexEscapeSequence(e) || this.regexp_eatRegExpUnicodeEscapeSequence(e) || !e.switchU && this.regexp_eatLegacyOctalEscapeSequence(e) || this.regexp_eatIdentityEscape(e);
            };
            Ae.regexp_eatCControlLetter = function(e) {
                var t = e.pos;
                if (e.eat(99)) {
                    if (this.regexp_eatControlLetter(e)) {
                        return true;
                    }
                    e.pos = t;
                }
                return false;
            };
            Ae.regexp_eatZero = function(e) {
                if (e.current() === 48 && !Be(e.lookahead())) {
                    e.lastIntValue = 0;
                    e.advance();
                    return true;
                }
                return false;
            };
            Ae.regexp_eatControlEscape = function(e) {
                var t = e.current();
                if (t === 116) {
                    e.lastIntValue = 9;
                    e.advance();
                    return true;
                }
                if (t === 110) {
                    e.lastIntValue = 10;
                    e.advance();
                    return true;
                }
                if (t === 118) {
                    e.lastIntValue = 11;
                    e.advance();
                    return true;
                }
                if (t === 102) {
                    e.lastIntValue = 12;
                    e.advance();
                    return true;
                }
                if (t === 114) {
                    e.lastIntValue = 13;
                    e.advance();
                    return true;
                }
                return false;
            };
            Ae.regexp_eatControlLetter = function(e) {
                var t = e.current();
                if (Ne(t)) {
                    e.lastIntValue = t % 32;
                    e.advance();
                    return true;
                }
                return false;
            };
            function Ne(e) {
                return e >= 65 && e <= 90 || e >= 97 && e <= 122;
            }
            Ae.regexp_eatRegExpUnicodeEscapeSequence = function(e) {
                var t = e.pos;
                if (e.eat(117)) {
                    if (this.regexp_eatFixedHexDigits(e, 4)) {
                        var i = e.lastIntValue;
                        if (e.switchU && i >= 55296 && i <= 56319) {
                            var r = e.pos;
                            if (e.eat(92) && e.eat(117) && this.regexp_eatFixedHexDigits(e, 4)) {
                                var s = e.lastIntValue;
                                if (s >= 56320 && s <= 57343) {
                                    e.lastIntValue = (i - 55296) * 1024 + (s - 56320) + 65536;
                                    return true;
                                }
                            }
                            e.pos = r;
                            e.lastIntValue = i;
                        }
                        return true;
                    }
                    if (e.switchU && e.eat(123) && this.regexp_eatHexDigits(e) && e.eat(125) && Fe(e.lastIntValue)) {
                        return true;
                    }
                    if (e.switchU) {
                        e.raise("Invalid unicode escape");
                    }
                    e.pos = t;
                }
                return false;
            };
            function Fe(e) {
                return e >= 0 && e <= 1114111;
            }
            Ae.regexp_eatIdentityEscape = function(e) {
                if (e.switchU) {
                    if (this.regexp_eatSyntaxCharacter(e)) {
                        return true;
                    }
                    if (e.eat(47)) {
                        e.lastIntValue = 47;
                        return true;
                    }
                    return false;
                }
                var t = e.current();
                if (t !== 99 && (!e.switchN || t !== 107)) {
                    e.lastIntValue = t;
                    e.advance();
                    return true;
                }
                return false;
            };
            Ae.regexp_eatDecimalEscape = function(e) {
                e.lastIntValue = 0;
                var t = e.current();
                if (t >= 49 && t <= 57) {
                    do {
                        e.lastIntValue = 10 * e.lastIntValue + (t - 48);
                        e.advance();
                    } while ((t = e.current()) >= 48 && t <= 57);
                    return true;
                }
                return false;
            };
            Ae.regexp_eatCharacterClassEscape = function(e) {
                var t = e.current();
                if (Ie(t)) {
                    e.lastIntValue = -1;
                    e.advance();
                    return true;
                }
                if (e.switchU && this.options.ecmaVersion >= 9 && (t === 80 || t === 112)) {
                    e.lastIntValue = -1;
                    e.advance();
                    if (e.eat(123) && this.regexp_eatUnicodePropertyValueExpression(e) && e.eat(125)) {
                        return true;
                    }
                    e.raise("Invalid property name");
                }
                return false;
            };
            function Ie(e) {
                return e === 100 || e === 68 || e === 115 || e === 83 || e === 119 || e === 87;
            }
            Ae.regexp_eatUnicodePropertyValueExpression = function(e) {
                var t = e.pos;
                if (this.regexp_eatUnicodePropertyName(e) && e.eat(61)) {
                    var i = e.lastStringValue;
                    if (this.regexp_eatUnicodePropertyValue(e)) {
                        var r = e.lastStringValue;
                        this.regexp_validateUnicodePropertyNameAndValue(e, i, r);
                        return true;
                    }
                }
                e.pos = t;
                if (this.regexp_eatLoneUnicodePropertyNameOrValue(e)) {
                    var s = e.lastStringValue;
                    this.regexp_validateUnicodePropertyNameOrValue(e, s);
                    return true;
                }
                return false;
            };
            Ae.regexp_validateUnicodePropertyNameAndValue = function(e, t, i) {
                if (!we.hasOwnProperty(t) || we[t].indexOf(i) === -1) {
                    e.raise("Invalid property name");
                }
            };
            Ae.regexp_validateUnicodePropertyNameOrValue = function(e, t) {
                if (we.$LONE.indexOf(t) === -1) {
                    e.raise("Invalid property name");
                }
            };
            Ae.regexp_eatUnicodePropertyName = function(e) {
                var t = 0;
                e.lastStringValue = "";
                while (Oe(t = e.current())) {
                    e.lastStringValue += Te(t);
                    e.advance();
                }
                return e.lastStringValue !== "";
            };
            function Oe(e) {
                return Ne(e) || e === 95;
            }
            Ae.regexp_eatUnicodePropertyValue = function(e) {
                var t = 0;
                e.lastStringValue = "";
                while (Le(t = e.current())) {
                    e.lastStringValue += Te(t);
                    e.advance();
                }
                return e.lastStringValue !== "";
            };
            function Le(e) {
                return Oe(e) || Be(e);
            }
            Ae.regexp_eatLoneUnicodePropertyNameOrValue = function(e) {
                return this.regexp_eatUnicodePropertyValue(e);
            };
            Ae.regexp_eatCharacterClass = function(e) {
                if (e.eat(91)) {
                    e.eat(94);
                    this.regexp_classRanges(e);
                    if (e.eat(93)) {
                        return true;
                    }
                    e.raise("Unterminated character class");
                }
                return false;
            };
            Ae.regexp_classRanges = function(e) {
                var t = this;
                while (this.regexp_eatClassAtom(e)) {
                    var i = e.lastIntValue;
                    if (e.eat(45) && t.regexp_eatClassAtom(e)) {
                        var r = e.lastIntValue;
                        if (e.switchU && (i === -1 || r === -1)) {
                            e.raise("Invalid character class");
                        }
                        if (i !== -1 && r !== -1 && i > r) {
                            e.raise("Range out of order in character class");
                        }
                    }
                }
            };
            Ae.regexp_eatClassAtom = function(e) {
                var t = e.pos;
                if (e.eat(92)) {
                    if (this.regexp_eatClassEscape(e)) {
                        return true;
                    }
                    if (e.switchU) {
                        var i = e.current();
                        if (i === 99 || Re(i)) {
                            e.raise("Invalid class escape");
                        }
                        e.raise("Invalid escape");
                    }
                    e.pos = t;
                }
                var r = e.current();
                if (r !== 93) {
                    e.lastIntValue = r;
                    e.advance();
                    return true;
                }
                return false;
            };
            Ae.regexp_eatClassEscape = function(e) {
                var t = e.pos;
                if (e.eat(98)) {
                    e.lastIntValue = 8;
                    return true;
                }
                if (e.switchU && e.eat(45)) {
                    e.lastIntValue = 45;
                    return true;
                }
                if (!e.switchU && e.eat(99)) {
                    if (this.regexp_eatClassControlLetter(e)) {
                        return true;
                    }
                    e.pos = t;
                }
                return this.regexp_eatCharacterClassEscape(e) || this.regexp_eatCharacterEscape(e);
            };
            Ae.regexp_eatClassControlLetter = function(e) {
                var t = e.current();
                if (Be(t) || t === 95) {
                    e.lastIntValue = t % 32;
                    e.advance();
                    return true;
                }
                return false;
            };
            Ae.regexp_eatHexEscapeSequence = function(e) {
                var t = e.pos;
                if (e.eat(120)) {
                    if (this.regexp_eatFixedHexDigits(e, 2)) {
                        return true;
                    }
                    if (e.switchU) {
                        e.raise("Invalid escape");
                    }
                    e.pos = t;
                }
                return false;
            };
            Ae.regexp_eatDecimalDigits = function(e) {
                var t = e.pos;
                var i = 0;
                e.lastIntValue = 0;
                while (Be(i = e.current())) {
                    e.lastIntValue = 10 * e.lastIntValue + (i - 48);
                    e.advance();
                }
                return e.pos !== t;
            };
            function Be(e) {
                return e >= 48 && e <= 57;
            }
            Ae.regexp_eatHexDigits = function(e) {
                var t = e.pos;
                var i = 0;
                e.lastIntValue = 0;
                while (Me(i = e.current())) {
                    e.lastIntValue = 16 * e.lastIntValue + je(i);
                    e.advance();
                }
                return e.pos !== t;
            };
            function Me(e) {
                return e >= 48 && e <= 57 || e >= 65 && e <= 70 || e >= 97 && e <= 102;
            }
            function je(e) {
                if (e >= 65 && e <= 70) {
                    return 10 + (e - 65);
                }
                if (e >= 97 && e <= 102) {
                    return 10 + (e - 97);
                }
                return e - 48;
            }
            Ae.regexp_eatLegacyOctalEscapeSequence = function(e) {
                if (this.regexp_eatOctalDigit(e)) {
                    var t = e.lastIntValue;
                    if (this.regexp_eatOctalDigit(e)) {
                        var i = e.lastIntValue;
                        if (t <= 3 && this.regexp_eatOctalDigit(e)) {
                            e.lastIntValue = t * 64 + i * 8 + e.lastIntValue;
                        } else {
                            e.lastIntValue = t * 8 + i;
                        }
                    } else {
                        e.lastIntValue = t;
                    }
                    return true;
                }
                return false;
            };
            Ae.regexp_eatOctalDigit = function(e) {
                var t = e.current();
                if (Re(t)) {
                    e.lastIntValue = t - 48;
                    e.advance();
                    return true;
                }
                e.lastIntValue = 0;
                return false;
            };
            function Re(e) {
                return e >= 48 && e <= 55;
            }
            Ae.regexp_eatFixedHexDigits = function(e, t) {
                var i = e.pos;
                e.lastIntValue = 0;
                for (var r = 0; r < t; ++r) {
                    var s = e.current();
                    if (!Me(s)) {
                        e.pos = i;
                        return false;
                    }
                    e.lastIntValue = 16 * e.lastIntValue + je(s);
                    e.advance();
                }
                return true;
            };
            var Ve = function e(t) {
                this.type = t.type;
                this.value = t.value;
                this.start = t.start;
                this.end = t.end;
                if (t.options.locations) {
                    this.loc = new F(t, t.startLoc, t.endLoc);
                }
                if (t.options.ranges) {
                    this.range = [ t.start, t.end ];
                }
            };
            var Ue = ee.prototype;
            Ue.next = function() {
                if (this.options.onToken) {
                    this.options.onToken(new Ve(this));
                }
                this.lastTokEnd = this.end;
                this.lastTokStart = this.start;
                this.lastTokEndLoc = this.endLoc;
                this.lastTokStartLoc = this.startLoc;
                this.nextToken();
            };
            Ue.getToken = function() {
                this.next();
                return new Ve(this);
            };
            if (typeof Symbol !== "undefined") {
                Ue[Symbol.iterator] = function() {
                    var e = this;
                    return {
                        next: function t() {
                            var i = e.getToken();
                            return {
                                done: i.type === b.eof,
                                value: i
                            };
                        }
                    };
                };
            }
            Ue.curContext = function() {
                return this.context[this.context.length - 1];
            };
            Ue.nextToken = function() {
                var e = this.curContext();
                if (!e || !e.preserveSpace) {
                    this.skipSpace();
                }
                this.start = this.pos;
                if (this.options.locations) {
                    this.startLoc = this.curPosition();
                }
                if (this.pos >= this.input.length) {
                    return this.finishToken(b.eof);
                }
                if (e.override) {
                    return e.override(this);
                } else {
                    this.readToken(this.fullCharCodeAtPos());
                }
            };
            Ue.readToken = function(e) {
                if (p(e, this.options.ecmaVersion >= 6) || e === 92) {
                    return this.readWord();
                }
                return this.getTokenFromCode(e);
            };
            Ue.fullCharCodeAtPos = function() {
                var e = this.input.charCodeAt(this.pos);
                if (e <= 55295 || e >= 57344) {
                    return e;
                }
                var t = this.input.charCodeAt(this.pos + 1);
                return (e << 10) + t - 56613888;
            };
            Ue.skipBlockComment = function() {
                var e = this;
                var t = this.options.onComment && this.curPosition();
                var i = this.pos, r = this.input.indexOf("*/", this.pos += 2);
                if (r === -1) {
                    this.raise(this.pos - 2, "Unterminated comment");
                }
                this.pos = r + 2;
                if (this.options.locations) {
                    k.lastIndex = i;
                    var s;
                    while ((s = k.exec(this.input)) && s.index < this.pos) {
                        ++e.curLine;
                        e.lineStart = s.index + s[0].length;
                    }
                }
                if (this.options.onComment) {
                    this.options.onComment(true, this.input.slice(i + 2, r), i, this.pos, t, this.curPosition());
                }
            };
            Ue.skipLineComment = function(e) {
                var t = this;
                var i = this.pos;
                var r = this.options.onComment && this.curPosition();
                var s = this.input.charCodeAt(this.pos += e);
                while (this.pos < this.input.length && !S(s)) {
                    s = t.input.charCodeAt(++t.pos);
                }
                if (this.options.onComment) {
                    this.options.onComment(false, this.input.slice(i + e, this.pos), i, this.pos, r, this.curPosition());
                }
            };
            Ue.skipSpace = function() {
                var e = this;
                e: while (this.pos < this.input.length) {
                    var t = e.input.charCodeAt(e.pos);
                    switch (t) {
                      case 32:
                      case 160:
                        ++e.pos;
                        break;

                      case 13:
                        if (e.input.charCodeAt(e.pos + 1) === 10) {
                            ++e.pos;
                        }

                      case 10:
                      case 8232:
                      case 8233:
                        ++e.pos;
                        if (e.options.locations) {
                            ++e.curLine;
                            e.lineStart = e.pos;
                        }
                        break;

                      case 47:
                        switch (e.input.charCodeAt(e.pos + 1)) {
                          case 42:
                            e.skipBlockComment();
                            break;

                          case 47:
                            e.skipLineComment(2);
                            break;

                          default:
                            break e;
                        }
                        break;

                      default:
                        if (t > 8 && t < 14 || t >= 5760 && w.test(String.fromCharCode(t))) {
                            ++e.pos;
                        } else {
                            break e;
                        }
                    }
                }
            };
            Ue.finishToken = function(e, t) {
                this.end = this.pos;
                if (this.options.locations) {
                    this.endLoc = this.curPosition();
                }
                var i = this.type;
                this.type = e;
                this.value = t;
                this.updateContext(i);
            };
            Ue.readToken_dot = function() {
                var e = this.input.charCodeAt(this.pos + 1);
                if (e >= 48 && e <= 57) {
                    return this.readNumber(true);
                }
                var t = this.input.charCodeAt(this.pos + 2);
                if (this.options.ecmaVersion >= 6 && e === 46 && t === 46) {
                    this.pos += 3;
                    return this.finishToken(b.ellipsis);
                } else {
                    ++this.pos;
                    return this.finishToken(b.dot);
                }
            };
            Ue.readToken_slash = function() {
                var e = this.input.charCodeAt(this.pos + 1);
                if (this.exprAllowed) {
                    ++this.pos;
                    return this.readRegexp();
                }
                if (e === 61) {
                    return this.finishOp(b.assign, 2);
                }
                return this.finishOp(b.slash, 1);
            };
            Ue.readToken_mult_modulo_exp = function(e) {
                var t = this.input.charCodeAt(this.pos + 1);
                var i = 1;
                var r = e === 42 ? b.star : b.modulo;
                if (this.options.ecmaVersion >= 7 && e === 42 && t === 42) {
                    ++i;
                    r = b.starstar;
                    t = this.input.charCodeAt(this.pos + 2);
                }
                if (t === 61) {
                    return this.finishOp(b.assign, i + 1);
                }
                return this.finishOp(r, i);
            };
            Ue.readToken_pipe_amp = function(e) {
                var t = this.input.charCodeAt(this.pos + 1);
                if (t === e) {
                    return this.finishOp(e === 124 ? b.logicalOR : b.logicalAND, 2);
                }
                if (t === 61) {
                    return this.finishOp(b.assign, 2);
                }
                return this.finishOp(e === 124 ? b.bitwiseOR : b.bitwiseAND, 1);
            };
            Ue.readToken_caret = function() {
                var e = this.input.charCodeAt(this.pos + 1);
                if (e === 61) {
                    return this.finishOp(b.assign, 2);
                }
                return this.finishOp(b.bitwiseXOR, 1);
            };
            Ue.readToken_plus_min = function(e) {
                var t = this.input.charCodeAt(this.pos + 1);
                if (t === e) {
                    if (t === 45 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 62 && (this.lastTokEnd === 0 || E.test(this.input.slice(this.lastTokEnd, this.pos)))) {
                        this.skipLineComment(3);
                        this.skipSpace();
                        return this.nextToken();
                    }
                    return this.finishOp(b.incDec, 2);
                }
                if (t === 61) {
                    return this.finishOp(b.assign, 2);
                }
                return this.finishOp(b.plusMin, 1);
            };
            Ue.readToken_lt_gt = function(e) {
                var t = this.input.charCodeAt(this.pos + 1);
                var i = 1;
                if (t === e) {
                    i = e === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2;
                    if (this.input.charCodeAt(this.pos + i) === 61) {
                        return this.finishOp(b.assign, i + 1);
                    }
                    return this.finishOp(b.bitShift, i);
                }
                if (t === 33 && e === 60 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 45 && this.input.charCodeAt(this.pos + 3) === 45) {
                    this.skipLineComment(4);
                    this.skipSpace();
                    return this.nextToken();
                }
                if (t === 61) {
                    i = 2;
                }
                return this.finishOp(b.relational, i);
            };
            Ue.readToken_eq_excl = function(e) {
                var t = this.input.charCodeAt(this.pos + 1);
                if (t === 61) {
                    return this.finishOp(b.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2);
                }
                if (e === 61 && t === 62 && this.options.ecmaVersion >= 6) {
                    this.pos += 2;
                    return this.finishToken(b.arrow);
                }
                return this.finishOp(e === 61 ? b.eq : b.prefix, 1);
            };
            Ue.getTokenFromCode = function(e) {
                switch (e) {
                  case 46:
                    return this.readToken_dot();

                  case 40:
                    ++this.pos;
                    return this.finishToken(b.parenL);

                  case 41:
                    ++this.pos;
                    return this.finishToken(b.parenR);

                  case 59:
                    ++this.pos;
                    return this.finishToken(b.semi);

                  case 44:
                    ++this.pos;
                    return this.finishToken(b.comma);

                  case 91:
                    ++this.pos;
                    return this.finishToken(b.bracketL);

                  case 93:
                    ++this.pos;
                    return this.finishToken(b.bracketR);

                  case 123:
                    ++this.pos;
                    return this.finishToken(b.braceL);

                  case 125:
                    ++this.pos;
                    return this.finishToken(b.braceR);

                  case 58:
                    ++this.pos;
                    return this.finishToken(b.colon);

                  case 63:
                    ++this.pos;
                    return this.finishToken(b.question);

                  case 96:
                    if (this.options.ecmaVersion < 6) {
                        break;
                    }
                    ++this.pos;
                    return this.finishToken(b.backQuote);

                  case 48:
                    var t = this.input.charCodeAt(this.pos + 1);
                    if (t === 120 || t === 88) {
                        return this.readRadixNumber(16);
                    }
                    if (this.options.ecmaVersion >= 6) {
                        if (t === 111 || t === 79) {
                            return this.readRadixNumber(8);
                        }
                        if (t === 98 || t === 66) {
                            return this.readRadixNumber(2);
                        }
                    }

                  case 49:
                  case 50:
                  case 51:
                  case 52:
                  case 53:
                  case 54:
                  case 55:
                  case 56:
                  case 57:
                    return this.readNumber(false);

                  case 34:
                  case 39:
                    return this.readString(e);

                  case 47:
                    return this.readToken_slash();

                  case 37:
                  case 42:
                    return this.readToken_mult_modulo_exp(e);

                  case 124:
                  case 38:
                    return this.readToken_pipe_amp(e);

                  case 94:
                    return this.readToken_caret();

                  case 43:
                  case 45:
                    return this.readToken_plus_min(e);

                  case 60:
                  case 62:
                    return this.readToken_lt_gt(e);

                  case 61:
                  case 33:
                    return this.readToken_eq_excl(e);

                  case 126:
                    return this.finishOp(b.prefix, 1);
                }
                this.raise(this.pos, "Unexpected character '" + Xe(e) + "'");
            };
            Ue.finishOp = function(e, t) {
                var i = this.input.slice(this.pos, this.pos + t);
                this.pos += t;
                return this.finishToken(e, i);
            };
            Ue.readRegexp = function() {
                var e = this;
                var t, i, r = this.pos;
                for (;;) {
                    if (e.pos >= e.input.length) {
                        e.raise(r, "Unterminated regular expression");
                    }
                    var s = e.input.charAt(e.pos);
                    if (E.test(s)) {
                        e.raise(r, "Unterminated regular expression");
                    }
                    if (!t) {
                        if (s === "[") {
                            i = true;
                        } else if (s === "]" && i) {
                            i = false;
                        } else if (s === "/" && !i) {
                            break;
                        }
                        t = s === "\\";
                    } else {
                        t = false;
                    }
                    ++e.pos;
                }
                var a = this.input.slice(r, this.pos);
                ++this.pos;
                var n = this.pos;
                var o = this.readWord1();
                if (this.containsEsc) {
                    this.unexpected(n);
                }
                var l = this.regexpState || (this.regexpState = new Ce(this));
                l.reset(r, a, o);
                this.validateRegExpFlags(l);
                this.validateRegExpPattern(l);
                var u = null;
                try {
                    u = new RegExp(a, o);
                } catch (e) {}
                return this.finishToken(b.regexp, {
                    pattern: a,
                    flags: o,
                    value: u
                });
            };
            Ue.readInt = function(e, t) {
                var i = this;
                var r = this.pos, s = 0;
                for (var a = 0, n = t == null ? Infinity : t; a < n; ++a) {
                    var o = i.input.charCodeAt(i.pos), l = void 0;
                    if (o >= 97) {
                        l = o - 97 + 10;
                    } else if (o >= 65) {
                        l = o - 65 + 10;
                    } else if (o >= 48 && o <= 57) {
                        l = o - 48;
                    } else {
                        l = Infinity;
                    }
                    if (l >= e) {
                        break;
                    }
                    ++i.pos;
                    s = s * e + l;
                }
                if (this.pos === r || t != null && this.pos - r !== t) {
                    return null;
                }
                return s;
            };
            Ue.readRadixNumber = function(e) {
                this.pos += 2;
                var t = this.readInt(e);
                if (t == null) {
                    this.raise(this.start + 2, "Expected number in radix " + e);
                }
                if (p(this.fullCharCodeAtPos())) {
                    this.raise(this.pos, "Identifier directly after number");
                }
                return this.finishToken(b.num, t);
            };
            Ue.readNumber = function(e) {
                var t = this.pos;
                if (!e && this.readInt(10) === null) {
                    this.raise(t, "Invalid number");
                }
                var i = this.pos - t >= 2 && this.input.charCodeAt(t) === 48;
                if (i && this.strict) {
                    this.raise(t, "Invalid number");
                }
                if (i && /[89]/.test(this.input.slice(t, this.pos))) {
                    i = false;
                }
                var r = this.input.charCodeAt(this.pos);
                if (r === 46 && !i) {
                    ++this.pos;
                    this.readInt(10);
                    r = this.input.charCodeAt(this.pos);
                }
                if ((r === 69 || r === 101) && !i) {
                    r = this.input.charCodeAt(++this.pos);
                    if (r === 43 || r === 45) {
                        ++this.pos;
                    }
                    if (this.readInt(10) === null) {
                        this.raise(t, "Invalid number");
                    }
                }
                if (p(this.fullCharCodeAtPos())) {
                    this.raise(this.pos, "Identifier directly after number");
                }
                var s = this.input.slice(t, this.pos);
                var a = i ? parseInt(s, 8) : parseFloat(s);
                return this.finishToken(b.num, a);
            };
            Ue.readCodePoint = function() {
                var e = this.input.charCodeAt(this.pos), t;
                if (e === 123) {
                    if (this.options.ecmaVersion < 6) {
                        this.unexpected();
                    }
                    var i = ++this.pos;
                    t = this.readHexChar(this.input.indexOf("}", this.pos) - this.pos);
                    ++this.pos;
                    if (t > 1114111) {
                        this.invalidStringToken(i, "Code point out of bounds");
                    }
                } else {
                    t = this.readHexChar(4);
                }
                return t;
            };
            function Xe(e) {
                if (e <= 65535) {
                    return String.fromCharCode(e);
                }
                e -= 65536;
                return String.fromCharCode((e >> 10) + 55296, (e & 1023) + 56320);
            }
            Ue.readString = function(e) {
                var t = this;
                var i = "", r = ++this.pos;
                for (;;) {
                    if (t.pos >= t.input.length) {
                        t.raise(t.start, "Unterminated string constant");
                    }
                    var s = t.input.charCodeAt(t.pos);
                    if (s === e) {
                        break;
                    }
                    if (s === 92) {
                        i += t.input.slice(r, t.pos);
                        i += t.readEscapedChar(false);
                        r = t.pos;
                    } else {
                        if (S(s, t.options.ecmaVersion >= 10)) {
                            t.raise(t.start, "Unterminated string constant");
                        }
                        ++t.pos;
                    }
                }
                i += this.input.slice(r, this.pos++);
                return this.finishToken(b.string, i);
            };
            var qe = {};
            Ue.tryReadTemplateToken = function() {
                this.inTemplateElement = true;
                try {
                    this.readTmplToken();
                } catch (e) {
                    if (e === qe) {
                        this.readInvalidTemplateToken();
                    } else {
                        throw e;
                    }
                }
                this.inTemplateElement = false;
            };
            Ue.invalidStringToken = function(e, t) {
                if (this.inTemplateElement && this.options.ecmaVersion >= 9) {
                    throw qe;
                } else {
                    this.raise(e, t);
                }
            };
            Ue.readTmplToken = function() {
                var e = this;
                var t = "", i = this.pos;
                for (;;) {
                    if (e.pos >= e.input.length) {
                        e.raise(e.start, "Unterminated template");
                    }
                    var r = e.input.charCodeAt(e.pos);
                    if (r === 96 || r === 36 && e.input.charCodeAt(e.pos + 1) === 123) {
                        if (e.pos === e.start && (e.type === b.template || e.type === b.invalidTemplate)) {
                            if (r === 36) {
                                e.pos += 2;
                                return e.finishToken(b.dollarBraceL);
                            } else {
                                ++e.pos;
                                return e.finishToken(b.backQuote);
                            }
                        }
                        t += e.input.slice(i, e.pos);
                        return e.finishToken(b.template, t);
                    }
                    if (r === 92) {
                        t += e.input.slice(i, e.pos);
                        t += e.readEscapedChar(true);
                        i = e.pos;
                    } else if (S(r)) {
                        t += e.input.slice(i, e.pos);
                        ++e.pos;
                        switch (r) {
                          case 13:
                            if (e.input.charCodeAt(e.pos) === 10) {
                                ++e.pos;
                            }

                          case 10:
                            t += "\n";
                            break;

                          default:
                            t += String.fromCharCode(r);
                            break;
                        }
                        if (e.options.locations) {
                            ++e.curLine;
                            e.lineStart = e.pos;
                        }
                        i = e.pos;
                    } else {
                        ++e.pos;
                    }
                }
            };
            Ue.readInvalidTemplateToken = function() {
                var e = this;
                for (;this.pos < this.input.length; this.pos++) {
                    switch (e.input[e.pos]) {
                      case "\\":
                        ++e.pos;
                        break;

                      case "$":
                        if (e.input[e.pos + 1] !== "{") {
                            break;
                        }

                      case "`":
                        return e.finishToken(b.invalidTemplate, e.input.slice(e.start, e.pos));
                    }
                }
                this.raise(this.start, "Unterminated template");
            };
            Ue.readEscapedChar = function(e) {
                var t = this.input.charCodeAt(++this.pos);
                ++this.pos;
                switch (t) {
                  case 110:
                    return "\n";

                  case 114:
                    return "\r";

                  case 120:
                    return String.fromCharCode(this.readHexChar(2));

                  case 117:
                    return Xe(this.readCodePoint());

                  case 116:
                    return "\t";

                  case 98:
                    return "\b";

                  case 118:
                    return "\v";

                  case 102:
                    return "\f";

                  case 13:
                    if (this.input.charCodeAt(this.pos) === 10) {
                        ++this.pos;
                    }

                  case 10:
                    if (this.options.locations) {
                        this.lineStart = this.pos;
                        ++this.curLine;
                    }
                    return "";

                  default:
                    if (t >= 48 && t <= 55) {
                        var i = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0];
                        var r = parseInt(i, 8);
                        if (r > 255) {
                            i = i.slice(0, -1);
                            r = parseInt(i, 8);
                        }
                        this.pos += i.length - 1;
                        t = this.input.charCodeAt(this.pos);
                        if ((i !== "0" || t === 56 || t === 57) && (this.strict || e)) {
                            this.invalidStringToken(this.pos - 1 - i.length, e ? "Octal literal in template string" : "Octal literal in strict mode");
                        }
                        return String.fromCharCode(r);
                    }
                    return String.fromCharCode(t);
                }
            };
            Ue.readHexChar = function(e) {
                var t = this.pos;
                var i = this.readInt(16, e);
                if (i === null) {
                    this.invalidStringToken(t, "Bad character escape sequence");
                }
                return i;
            };
            Ue.readWord1 = function() {
                var e = this;
                this.containsEsc = false;
                var t = "", i = true, r = this.pos;
                var s = this.options.ecmaVersion >= 6;
                while (this.pos < this.input.length) {
                    var a = e.fullCharCodeAtPos();
                    if (f(a, s)) {
                        e.pos += a <= 65535 ? 1 : 2;
                    } else if (a === 92) {
                        e.containsEsc = true;
                        t += e.input.slice(r, e.pos);
                        var n = e.pos;
                        if (e.input.charCodeAt(++e.pos) !== 117) {
                            e.invalidStringToken(e.pos, "Expecting Unicode escape sequence \\uXXXX");
                        }
                        ++e.pos;
                        var o = e.readCodePoint();
                        if (!(i ? p : f)(o, s)) {
                            e.invalidStringToken(n, "Invalid Unicode escape");
                        }
                        t += Xe(o);
                        r = e.pos;
                    } else {
                        break;
                    }
                    i = false;
                }
                return t + this.input.slice(r, this.pos);
            };
            Ue.readWord = function() {
                var e = this.readWord1();
                var t = b.name;
                if (this.keywords.test(e)) {
                    if (this.containsEsc) {
                        this.raiseRecoverable(this.start, "Escape sequence in keyword " + e);
                    }
                    t = x[e];
                }
                return this.finishToken(t, e);
            };
            var Je = "6.0.5";
            function ze(e, t) {
                return ee.parse(e, t);
            }
            function We(e, t, i) {
                return ee.parseExpressionAt(e, t, i);
            }
            function Ke(e, t) {
                return ee.tokenizer(e, t);
            }
            e.version = Je;
            e.parse = ze;
            e.parseExpressionAt = We;
            e.tokenizer = Ke;
            e.Parser = ee;
            e.defaultOptions = O;
            e.Position = N;
            e.SourceLocation = F;
            e.getLineInfo = I;
            e.Node = xe;
            e.TokenType = d;
            e.tokTypes = b;
            e.keywordTypes = x;
            e.TokContext = Ee;
            e.tokContexts = ke;
            e.isIdentifierChar = f;
            e.isIdentifierStart = p;
            e.Token = Ve;
            e.isNewLine = S;
            e.lineBreak = E;
            e.lineBreakG = k;
            e.nonASCIIwhitespace = w;
            Object.defineProperty(e, "__esModule", {
                value: true
            });
        });
    }, function(e, t) {
        "use strict";
        if (typeof Object.create === "function") {
            e.exports = function e(t, i) {
                t.super_ = i;
                t.prototype = Object.create(i.prototype, {
                    constructor: {
                        value: t,
                        enumerable: false,
                        writable: true,
                        configurable: true
                    }
                });
            };
        } else {
            e.exports = function e(t, i) {
                t.super_ = i;
                var r = function e() {};
                r.prototype = i.prototype;
                t.prototype = new r();
                t.prototype.constructor = t;
            };
        }
    }, function(e, t) {
        "use strict";
        var i = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(e) {
            return typeof e;
        } : function(e) {
            return e && typeof Symbol === "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
        };
        e.exports = function e(t) {
            return t && (typeof t === "undefined" ? "undefined" : i(t)) === "object" && typeof t.copy === "function" && typeof t.fill === "function" && typeof t.readUInt8 === "function";
        };
    }, function(e, t, i) {
        (function(e) {
            "use strict";
            var r = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(e) {
                return typeof e;
            } : function(e) {
                return e && typeof Symbol === "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
            };
            var s = /%[sdj%]/g;
            t.format = function(e) {
                if (!k(e)) {
                    var t = [];
                    for (var i = 0; i < arguments.length; i++) {
                        t.push(o(arguments[i]));
                    }
                    return t.join(" ");
                }
                var i = 1;
                var r = arguments;
                var a = r.length;
                var n = String(e).replace(s, function(e) {
                    if (e === "%%") return "%";
                    if (i >= a) return e;
                    switch (e) {
                      case "%s":
                        return String(r[i++]);

                      case "%d":
                        return Number(r[i++]);

                      case "%j":
                        try {
                            return JSON.stringify(r[i++]);
                        } catch (e) {
                            return "[Circular]";
                        }

                      default:
                        return e;
                    }
                });
                for (var l = r[i]; i < a; l = r[++i]) {
                    if (g(l) || !C(l)) {
                        n += " " + l;
                    } else {
                        n += " " + o(l);
                    }
                }
                return n;
            };
            t.deprecate = function(i, r) {
                if (w(e.process)) {
                    return function() {
                        return t.deprecate(i, r).apply(this, arguments);
                    };
                }
                if (process.noDeprecation === true) {
                    return i;
                }
                var s = false;
                function a() {
                    if (!s) {
                        if (process.throwDeprecation) {
                            throw new Error(r);
                        } else if (process.traceDeprecation) {
                            console.trace(r);
                        } else {
                            console.error(r);
                        }
                        s = true;
                    }
                    return i.apply(this, arguments);
                }
                return a;
            };
            var a = {};
            var n;
            t.debuglog = function(e) {
                if (w(n)) n = process.env.NODE_DEBUG || "";
                e = e.toUpperCase();
                if (!a[e]) {
                    if (new RegExp("\\b" + e + "\\b", "i").test(n)) {
                        var i = process.pid;
                        a[e] = function() {
                            var r = t.format.apply(t, arguments);
                            console.error("%s %d: %s", e, i, r);
                        };
                    } else {
                        a[e] = function() {};
                    }
                }
                return a[e];
            };
            function o(e, i) {
                var r = {
                    seen: [],
                    stylize: u
                };
                if (arguments.length >= 3) r.depth = arguments[2];
                if (arguments.length >= 4) r.colors = arguments[3];
                if (x(i)) {
                    r.showHidden = i;
                } else if (i) {
                    t._extend(r, i);
                }
                if (w(r.showHidden)) r.showHidden = false;
                if (w(r.depth)) r.depth = 2;
                if (w(r.colors)) r.colors = false;
                if (w(r.customInspect)) r.customInspect = true;
                if (r.colors) r.stylize = l;
                return h(r, e, r.depth);
            }
            t.inspect = o;
            o.colors = {
                bold: [ 1, 22 ],
                italic: [ 3, 23 ],
                underline: [ 4, 24 ],
                inverse: [ 7, 27 ],
                white: [ 37, 39 ],
                grey: [ 90, 39 ],
                black: [ 30, 39 ],
                blue: [ 34, 39 ],
                cyan: [ 36, 39 ],
                green: [ 32, 39 ],
                magenta: [ 35, 39 ],
                red: [ 31, 39 ],
                yellow: [ 33, 39 ]
            };
            o.styles = {
                special: "cyan",
                number: "yellow",
                boolean: "yellow",
                undefined: "grey",
                null: "bold",
                string: "green",
                date: "magenta",
                regexp: "red"
            };
            function l(e, t) {
                var i = o.styles[t];
                if (i) {
                    return "[" + o.colors[i][0] + "m" + e + "[" + o.colors[i][1] + "m";
                } else {
                    return e;
                }
            }
            function u(e, t) {
                return e;
            }
            function c(e) {
                var t = {};
                e.forEach(function(e, i) {
                    t[e] = true;
                });
                return t;
            }
            function h(e, i, r) {
                if (e.customInspect && i && D(i.inspect) && i.inspect !== t.inspect && !(i.constructor && i.constructor.prototype === i)) {
                    var s = i.inspect(r, e);
                    if (!k(s)) {
                        s = h(e, s, r);
                    }
                    return s;
                }
                var a = p(e, i);
                if (a) {
                    return a;
                }
                var n = Object.keys(i);
                var o = c(n);
                if (e.showHidden) {
                    n = Object.getOwnPropertyNames(i);
                }
                if (P(i) && (n.indexOf("message") >= 0 || n.indexOf("description") >= 0)) {
                    return f(i);
                }
                if (n.length === 0) {
                    if (D(i)) {
                        var l = i.name ? ": " + i.name : "";
                        return e.stylize("[Function" + l + "]", "special");
                    }
                    if (A(i)) {
                        return e.stylize(RegExp.prototype.toString.call(i), "regexp");
                    }
                    if (T(i)) {
                        return e.stylize(Date.prototype.toString.call(i), "date");
                    }
                    if (P(i)) {
                        return f(i);
                    }
                }
                var u = "", x = false, g = [ "{", "}" ];
                if (v(i)) {
                    x = true;
                    g = [ "[", "]" ];
                }
                if (D(i)) {
                    var b = i.name ? ": " + i.name : "";
                    u = " [Function" + b + "]";
                }
                if (A(i)) {
                    u = " " + RegExp.prototype.toString.call(i);
                }
                if (T(i)) {
                    u = " " + Date.prototype.toUTCString.call(i);
                }
                if (P(i)) {
                    u = " " + f(i);
                }
                if (n.length === 0 && (!x || i.length == 0)) {
                    return g[0] + u + g[1];
                }
                if (r < 0) {
                    if (A(i)) {
                        return e.stylize(RegExp.prototype.toString.call(i), "regexp");
                    } else {
                        return e.stylize("[Object]", "special");
                    }
                }
                e.seen.push(i);
                var E;
                if (x) {
                    E = d(e, i, r, o, n);
                } else {
                    E = n.map(function(t) {
                        return m(e, i, r, o, t, x);
                    });
                }
                e.seen.pop();
                return y(E, u, g);
            }
            function p(e, t) {
                if (w(t)) return e.stylize("undefined", "undefined");
                if (k(t)) {
                    var i = "'" + JSON.stringify(t).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
                    return e.stylize(i, "string");
                }
                if (E(t)) return e.stylize("" + t, "number");
                if (x(t)) return e.stylize("" + t, "boolean");
                if (g(t)) return e.stylize("null", "null");
            }
            function f(e) {
                return "[" + Error.prototype.toString.call(e) + "]";
            }
            function d(e, t, i, r, s) {
                var a = [];
                for (var n = 0, o = t.length; n < o; ++n) {
                    if (L(t, String(n))) {
                        a.push(m(e, t, i, r, String(n), true));
                    } else {
                        a.push("");
                    }
                }
                s.forEach(function(s) {
                    if (!s.match(/^\d+$/)) {
                        a.push(m(e, t, i, r, s, true));
                    }
                });
                return a;
            }
            function m(e, t, i, r, s, a) {
                var n, o, l;
                l = Object.getOwnPropertyDescriptor(t, s) || {
                    value: t[s]
                };
                if (l.get) {
                    if (l.set) {
                        o = e.stylize("[Getter/Setter]", "special");
                    } else {
                        o = e.stylize("[Getter]", "special");
                    }
                } else {
                    if (l.set) {
                        o = e.stylize("[Setter]", "special");
                    }
                }
                if (!L(r, s)) {
                    n = "[" + s + "]";
                }
                if (!o) {
                    if (e.seen.indexOf(l.value) < 0) {
                        if (g(i)) {
                            o = h(e, l.value, null);
                        } else {
                            o = h(e, l.value, i - 1);
                        }
                        if (o.indexOf("\n") > -1) {
                            if (a) {
                                o = o.split("\n").map(function(e) {
                                    return "  " + e;
                                }).join("\n").substr(2);
                            } else {
                                o = "\n" + o.split("\n").map(function(e) {
                                    return "   " + e;
                                }).join("\n");
                            }
                        }
                    } else {
                        o = e.stylize("[Circular]", "special");
                    }
                }
                if (w(n)) {
                    if (a && s.match(/^\d+$/)) {
                        return o;
                    }
                    n = JSON.stringify("" + s);
                    if (n.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
                        n = n.substr(1, n.length - 2);
                        n = e.stylize(n, "name");
                    } else {
                        n = n.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
                        n = e.stylize(n, "string");
                    }
                }
                return n + ": " + o;
            }
            function y(e, t, i) {
                var r = 0;
                var s = e.reduce(function(e, t) {
                    r++;
                    if (t.indexOf("\n") >= 0) r++;
                    return e + t.replace(/\u001b\[\d\d?m/g, "").length + 1;
                }, 0);
                if (s > 60) {
                    return i[0] + (t === "" ? "" : t + "\n ") + " " + e.join(",\n  ") + " " + i[1];
                }
                return i[0] + t + " " + e.join(", ") + " " + i[1];
            }
            function v(e) {
                return Array.isArray(e);
            }
            t.isArray = v;
            function x(e) {
                return typeof e === "boolean";
            }
            t.isBoolean = x;
            function g(e) {
                return e === null;
            }
            t.isNull = g;
            function b(e) {
                return e == null;
            }
            t.isNullOrUndefined = b;
            function E(e) {
                return typeof e === "number";
            }
            t.isNumber = E;
            function k(e) {
                return typeof e === "string";
            }
            t.isString = k;
            function S(e) {
                return (typeof e === "undefined" ? "undefined" : r(e)) === "symbol";
            }
            t.isSymbol = S;
            function w(e) {
                return e === void 0;
            }
            t.isUndefined = w;
            function A(e) {
                return C(e) && N(e) === "[object RegExp]";
            }
            t.isRegExp = A;
            function C(e) {
                return (typeof e === "undefined" ? "undefined" : r(e)) === "object" && e !== null;
            }
            t.isObject = C;
            function T(e) {
                return C(e) && N(e) === "[object Date]";
            }
            t.isDate = T;
            function P(e) {
                return C(e) && (N(e) === "[object Error]" || e instanceof Error);
            }
            t.isError = P;
            function D(e) {
                return typeof e === "function";
            }
            t.isFunction = D;
            function _(e) {
                return e === null || typeof e === "boolean" || typeof e === "number" || typeof e === "string" || (typeof e === "undefined" ? "undefined" : r(e)) === "symbol" || typeof e === "undefined";
            }
            t.isPrimitive = _;
            t.isBuffer = i(60);
            function N(e) {
                return Object.prototype.toString.call(e);
            }
            function F(e) {
                return e < 10 ? "0" + e.toString(10) : e.toString(10);
            }
            var I = [ "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec" ];
            function O() {
                var e = new Date();
                var t = [ F(e.getHours()), F(e.getMinutes()), F(e.getSeconds()) ].join(":");
                return [ e.getDate(), I[e.getMonth()], t ].join(" ");
            }
            t.log = function() {
                console.log("%s - %s", O(), t.format.apply(t, arguments));
            };
            t.inherits = i(59);
            t._extend = function(e, t) {
                if (!t || !C(t)) return e;
                var i = Object.keys(t);
                var r = i.length;
                while (r--) {
                    e[i[r]] = t[i[r]];
                }
                return e;
            };
            function L(e, t) {
                return Object.prototype.hasOwnProperty.call(e, t);
            }
        }).call(t, function() {
            return this;
        }());
    }, function(e, t, i) {
        "use strict";
        e.exports = function(e) {
            e.use(i(34));
            e.use(i(36));
        };
    }, function(e, t, i) {
        "use strict";
        e.exports = function(e) {
            e.use(i(11));
            var t = e.use(i(2));
            var r = t.Type.def;
            var s = t.Type.or;
            r("XMLDefaultDeclaration").bases("Declaration").field("namespace", r("Expression"));
            r("XMLAnyName").bases("Expression");
            r("XMLQualifiedIdentifier").bases("Expression").field("left", s(r("Identifier"), r("XMLAnyName"))).field("right", s(r("Identifier"), r("Expression"))).field("computed", Boolean);
            r("XMLFunctionQualifiedIdentifier").bases("Expression").field("right", s(r("Identifier"), r("Expression"))).field("computed", Boolean);
            r("XMLAttributeSelector").bases("Expression").field("attribute", r("Expression"));
            r("XMLFilterExpression").bases("Expression").field("left", r("Expression")).field("right", r("Expression"));
            r("XMLElement").bases("XML", "Expression").field("contents", [ r("XML") ]);
            r("XMLList").bases("XML", "Expression").field("contents", [ r("XML") ]);
            r("XML").bases("Node");
            r("XMLEscape").bases("XML").field("expression", r("Expression"));
            r("XMLText").bases("XML").field("text", String);
            r("XMLStartTag").bases("XML").field("contents", [ r("XML") ]);
            r("XMLEndTag").bases("XML").field("contents", [ r("XML") ]);
            r("XMLPointTag").bases("XML").field("contents", [ r("XML") ]);
            r("XMLName").bases("XML").field("contents", s(String, [ r("XML") ]));
            r("XMLAttribute").bases("XML").field("value", String);
            r("XMLCdata").bases("XML").field("contents", String);
            r("XMLComment").bases("XML").field("contents", String);
            r("XMLProcessingInstruction").bases("XML").field("target", String).field("contents", s(String, null));
        };
    }, function(e, t, i) {
        "use strict";
        e.exports = function(e) {
            e.use(i(11));
            var t = e.use(i(2));
            var r = t.Type;
            var s = t.Type.def;
            var a = r.or;
            var n = e.use(i(5));
            var o = n.defaults;
            s("OptionalMemberExpression").bases("MemberExpression").build("object", "property", "computed", "optional").field("optional", Boolean, o["true"]);
            s("OptionalCallExpression").bases("CallExpression").build("callee", "arguments", "optional").field("optional", Boolean, o["true"]);
            var l = a("||", "&&", "??");
            s("LogicalExpression").field("operator", l);
        };
    }, function(e, t, i) {
        "use strict";
        e.exports = function(e) {
            e.use(i(12));
            var t = e.use(i(2));
            var r = e.use(i(5)).defaults;
            var s = t.Type.def;
            var a = t.Type.or;
            s("VariableDeclaration").field("declarations", [ a(s("VariableDeclarator"), s("Identifier")) ]);
            s("Property").field("value", a(s("Expression"), s("Pattern")));
            s("ArrayPattern").field("elements", [ a(s("Pattern"), s("SpreadElement"), null) ]);
            s("ObjectPattern").field("properties", [ a(s("Property"), s("PropertyPattern"), s("SpreadPropertyPattern"), s("SpreadProperty")) ]);
            s("ExportSpecifier").bases("ModuleSpecifier").build("id", "name");
            s("ExportBatchSpecifier").bases("Specifier").build();
            s("ExportDeclaration").bases("Declaration").build("default", "declaration", "specifiers", "source").field("default", Boolean).field("declaration", a(s("Declaration"), s("Expression"), null)).field("specifiers", [ a(s("ExportSpecifier"), s("ExportBatchSpecifier")) ], r.emptyArray).field("source", a(s("Literal"), null), r["null"]);
            s("Block").bases("Comment").build("value", "leading", "trailing");
            s("Line").bases("Comment").build("value", "leading", "trailing");
        };
    }, function(e, t, i) {
        "use strict";
        e.exports = function(e) {
            e.use(i(12));
            var t = e.use(i(2));
            var r = t.Type.def;
            var s = t.Type.or;
            var a = e.use(i(5)).defaults;
            r("JSXAttribute").bases("Node").build("name", "value").field("name", s(r("JSXIdentifier"), r("JSXNamespacedName"))).field("value", s(r("Literal"), r("JSXExpressionContainer"), null), a["null"]);
            r("JSXIdentifier").bases("Identifier").build("name").field("name", String);
            r("JSXNamespacedName").bases("Node").build("namespace", "name").field("namespace", r("JSXIdentifier")).field("name", r("JSXIdentifier"));
            r("JSXMemberExpression").bases("MemberExpression").build("object", "property").field("object", s(r("JSXIdentifier"), r("JSXMemberExpression"))).field("property", r("JSXIdentifier")).field("computed", Boolean, a.false);
            var n = s(r("JSXIdentifier"), r("JSXNamespacedName"), r("JSXMemberExpression"));
            r("JSXSpreadAttribute").bases("Node").build("argument").field("argument", r("Expression"));
            var o = [ s(r("JSXAttribute"), r("JSXSpreadAttribute")) ];
            r("JSXExpressionContainer").bases("Expression").build("expression").field("expression", r("Expression"));
            r("JSXElement").bases("Expression").build("openingElement", "closingElement", "children").field("openingElement", r("JSXOpeningElement")).field("closingElement", s(r("JSXClosingElement"), null), a["null"]).field("children", [ s(r("JSXElement"), r("JSXExpressionContainer"), r("JSXFragment"), r("JSXText"), r("Literal")) ], a.emptyArray).field("name", n, function() {
                return this.openingElement.name;
            }, true).field("selfClosing", Boolean, function() {
                return this.openingElement.selfClosing;
            }, true).field("attributes", o, function() {
                return this.openingElement.attributes;
            }, true);
            r("JSXOpeningElement").bases("Node").build("name", "attributes", "selfClosing").field("name", n).field("attributes", o, a.emptyArray).field("selfClosing", Boolean, a["false"]);
            r("JSXClosingElement").bases("Node").build("name").field("name", n);
            r("JSXFragment").bases("Expression").build("openingElement", "closingElement", "children").field("openingElement", r("JSXOpeningFragment")).field("closingElement", r("JSXClosingFragment")).field("children", [ s(r("JSXElement"), r("JSXExpressionContainer"), r("JSXFragment"), r("JSXText"), r("Literal")) ], a.emptyArray);
            r("JSXOpeningFragment").bases("Node").build();
            r("JSXClosingFragment").bases("Node").build();
            r("JSXText").bases("Literal").build("value").field("value", String);
            r("JSXEmptyExpression").bases("Expression").build();
            r("JSXSpreadChild").bases("Expression").build("expression").field("expression", r("Expression"));
        };
    }, function(e, t, i) {
        "use strict";
        e.exports = function(e) {
            e.use(i(11));
            var t = e.use(i(2));
            var r = t.Type.def;
            var s = t.Type.or;
            var a = e.use(i(5));
            var n = a.geq;
            var o = a.defaults;
            r("Function").field("body", s(r("BlockStatement"), r("Expression")));
            r("ForInStatement").build("left", "right", "body", "each").field("each", Boolean, o["false"]);
            r("LetStatement").bases("Statement").build("head", "body").field("head", [ r("VariableDeclarator") ]).field("body", r("Statement"));
            r("LetExpression").bases("Expression").build("head", "body").field("head", [ r("VariableDeclarator") ]).field("body", r("Expression"));
            r("GraphExpression").bases("Expression").build("index", "expression").field("index", n(0)).field("expression", r("Literal"));
            r("GraphIndexExpression").bases("Expression").build("index").field("index", n(0));
        };
    }, function(e, t, i) {
        "use strict";
        e.exports = function(e) {
            e.use(i(34));
            var t = e.use(i(2));
            var r = t.namedTypes;
            var s = t.Type.def;
            var a = t.Type.or;
            var n = e.use(i(5)).defaults;
            var o = new t.Type(function(e, t) {
                if (r.StringLiteral && r.StringLiteral.check(e, t)) {
                    return true;
                }
                if (r.Literal && r.Literal.check(e, t) && typeof e.value === "string") {
                    return true;
                }
                return false;
            }, "StringLiteral");
            s("TSType").bases("Node");
            var l = a(s("Identifier"), s("TSQualifiedName"));
            s("TSTypeReference").bases("TSType").build("typeName", "typeParameters").field("typeName", l).field("typeParameters", a(s("TSTypeParameterInstantiation"), null), n["null"]);
            s("TSHasOptionalTypeParameters").field("typeParameters", a(s("TSTypeParameterDeclaration"), null), n["null"]);
            s("TSHasOptionalTypeAnnotation").field("typeAnnotation", a(s("TSTypeAnnotation"), null), n["null"]);
            s("TSQualifiedName").bases("Node").build("left", "right").field("left", l).field("right", l);
            s("TSAsExpression").bases("Expression").build("expression").field("expression", s("Expression")).field("typeAnnotation", s("TSType")).field("extra", a({
                parenthesized: Boolean
            }, null), n["null"]);
            s("TSNonNullExpression").bases("Expression").build("expression").field("expression", s("Expression"));
            [ "TSAnyKeyword", "TSBooleanKeyword", "TSNeverKeyword", "TSNullKeyword", "TSNumberKeyword", "TSObjectKeyword", "TSStringKeyword", "TSSymbolKeyword", "TSUndefinedKeyword", "TSUnknownKeyword", "TSVoidKeyword", "TSThisType" ].forEach(function(e) {
                s(e).bases("TSType").build();
            });
            s("TSArrayType").bases("TSType").build("elementType").field("elementType", s("TSType"));
            s("TSLiteralType").bases("TSType").build("literal").field("literal", a(s("NumericLiteral"), s("StringLiteral"), s("BooleanLiteral")));
            [ "TSUnionType", "TSIntersectionType" ].forEach(function(e) {
                s(e).bases("TSType").build("types").field("types", [ s("TSType") ]);
            });
            s("TSConditionalType").bases("TSType").build("checkType", "extendsType", "trueType", "falseType").field("checkType", s("TSType")).field("extendsType", s("TSType")).field("trueType", s("TSType")).field("falseType", s("TSType"));
            s("TSInferType").bases("TSType").build("typeParameter").field("typeParameter", s("TSTypeParameter"));
            s("TSParenthesizedType").bases("TSType").build("typeAnnotation").field("typeAnnotation", s("TSType"));
            var u = [ a(s("Identifier"), s("RestElement")) ];
            [ "TSFunctionType", "TSConstructorType" ].forEach(function(e) {
                s(e).bases("TSType", "TSHasOptionalTypeParameters", "TSHasOptionalTypeAnnotation").build("parameters").field("parameters", u);
            });
            s("TSDeclareFunction").bases("Declaration", "TSHasOptionalTypeParameters").build("id", "params", "returnType").field("declare", Boolean, n["false"]).field("async", Boolean, n["false"]).field("generator", Boolean, n["false"]).field("id", a(s("Identifier"), null), n["null"]).field("params", [ s("Pattern") ]).field("returnType", a(s("TSTypeAnnotation"), s("Noop"), null), n["null"]);
            s("TSDeclareMethod").bases("Declaration", "TSHasOptionalTypeParameters").build("key", "params", "returnType").field("async", Boolean, n["false"]).field("generator", Boolean, n["false"]).field("params", [ s("Pattern") ]).field("abstract", Boolean, n["false"]).field("accessibility", a("public", "private", "protected", void 0), n["undefined"]).field("static", Boolean, n["false"]).field("computed", Boolean, n["false"]).field("optional", Boolean, n["false"]).field("key", a(s("Identifier"), s("StringLiteral"), s("NumericLiteral"), s("Expression"))).field("kind", a("get", "set", "method", "constructor"), function e() {
                return "method";
            }).field("access", a("public", "private", "protected", void 0), n["undefined"]).field("decorators", a([ s("Decorator") ], null), n["null"]).field("returnType", a(s("TSTypeAnnotation"), s("Noop"), null), n["null"]);
            s("TSMappedType").bases("TSType").build("typeParameter", "typeAnnotation").field("readonly", Boolean, n["false"]).field("typeParameter", s("TSTypeParameter")).field("optional", Boolean, n["false"]).field("typeAnnotation", a(s("TSType"), null), n["null"]);
            s("TSTupleType").bases("TSType").build("elementTypes").field("elementTypes", [ s("TSType") ]);
            s("TSRestType").bases("TSType").build("typeAnnotation").field("typeAnnotation", s("TSType"));
            s("TSOptionalType").bases("TSType").build("typeAnnotation").field("typeAnnotation", s("TSType"));
            s("TSIndexedAccessType").bases("TSType").build("objectType", "indexType").field("objectType", s("TSType")).field("indexType", s("TSType"));
            s("TSTypeOperator").bases("TSType").build("operator").field("operator", String).field("typeAnnotation", s("TSType"));
            s("TSTypeAnnotation").bases("Node").build("typeAnnotation").field("typeAnnotation", a(s("TSType"), s("TSTypeAnnotation")));
            s("TSIndexSignature").bases("Declaration", "TSHasOptionalTypeAnnotation").build("parameters").field("parameters", [ s("Identifier") ]).field("readonly", Boolean, n["false"]);
            s("TSPropertySignature").bases("Declaration", "TSHasOptionalTypeAnnotation").build("key").field("key", s("Expression")).field("computed", Boolean, n["false"]).field("readonly", Boolean, n["false"]).field("optional", Boolean, n["false"]).field("initializer", a(s("Expression"), null), n["null"]);
            s("TSMethodSignature").bases("Declaration", "TSHasOptionalTypeParameters", "TSHasOptionalTypeAnnotation").build("key").field("key", s("Expression")).field("computed", Boolean, n["false"]).field("optional", Boolean, n["false"]).field("parameters", u);
            s("TSTypePredicate").bases("TSTypeAnnotation").build("parameterName", "typeAnnotation").field("parameterName", a(s("Identifier"), s("TSThisType"))).field("typeAnnotation", s("TSTypeAnnotation"));
            [ "TSCallSignatureDeclaration", "TSConstructSignatureDeclaration" ].forEach(function(e) {
                s(e).bases("Declaration", "TSHasOptionalTypeParameters", "TSHasOptionalTypeAnnotation").build("parameters").field("parameters", u);
            });
            s("TSEnumMember").bases("Node").build("id", "initializer").field("id", a(s("Identifier"), o)).field("initializer", a(s("Expression"), null), n["null"]);
            s("TSTypeQuery").bases("TSType").build("exprName").field("exprName", s("Identifier"));
            var c = a(s("TSCallSignatureDeclaration"), s("TSConstructSignatureDeclaration"), s("TSIndexSignature"), s("TSMethodSignature"), s("TSPropertySignature"));
            s("TSTypeLiteral").bases("TSType").build("members").field("members", [ c ]);
            s("TSTypeParameter").bases("Identifier").field("name", String).field("constraint", a(s("TSType"), null), n["null"]).field("default", a(s("TSType"), null), n["null"]);
            s("TSTypeAssertion").bases("Expression").build("typeAnnotation", "expression").field("typeAnnotation", s("TSType")).field("expression", s("Expression")).field("extra", a({
                parenthesized: Boolean
            }, null), n["null"]);
            s("TSTypeParameterDeclaration").bases("Declaration").build("params").field("params", [ s("TSTypeParameter") ]);
            s("TSTypeParameterInstantiation").bases("Node").build("params").field("params", [ s("TSType") ]);
            s("TSEnumDeclaration").bases("Declaration").build("id", "members").field("id", s("Identifier")).field("const", Boolean, n["false"]).field("declare", Boolean, n["false"]).field("members", [ s("TSEnumMember") ]).field("initializer", a(s("Expression"), null), n["null"]);
            s("TSTypeAliasDeclaration").bases("Declaration", "TSHasOptionalTypeParameters").build("id").field("id", s("Identifier")).field("declare", Boolean, n["false"]).field("typeAnnotation", s("TSType"));
            s("TSModuleBlock").bases("Node").build("body").field("body", [ s("Statement") ]);
            s("TSModuleDeclaration").bases("Declaration").build("id", "body").field("id", a(o, l)).field("declare", Boolean, n["false"]).field("global", Boolean, n["false"]).field("body", a(s("TSModuleBlock"), s("TSModuleDeclaration"), null), n["null"]);
            s("TSImportEqualsDeclaration").bases("Declaration").build("id", "moduleReference").field("id", s("Identifier")).field("isExport", Boolean, n["false"]).field("moduleReference", a(l, s("TSExternalModuleReference")));
            s("TSExternalModuleReference").bases("Declaration").build("expression").field("expression", o);
            s("TSExportAssignment").bases("Statement").build("expression").field("expression", s("Expression"));
            s("TSNamespaceExportDeclaration").bases("Declaration").build("id").field("id", s("Identifier"));
            s("TSInterfaceBody").bases("Node").build("body").field("body", [ c ]);
            s("TSExpressionWithTypeArguments").bases("TSType").build("expression", "typeParameters").field("expression", l).field("typeParameters", a(s("TSTypeParameterInstantiation"), null), n["null"]);
            s("TSInterfaceDeclaration").bases("Declaration", "TSHasOptionalTypeParameters").build("id", "body").field("id", l).field("declare", Boolean, n["false"]).field("extends", a([ s("TSExpressionWithTypeArguments") ], null), n["null"]).field("body", s("TSInterfaceBody"));
            [ "ClassDeclaration", "ClassExpression" ].forEach(function(e) {
                s(e).field("implements", [ s("TSExpressionWithTypeArguments") ], n.emptyArray);
            });
            s("TSParameterProperty").bases("Pattern").build("parameter").field("accessibility", a("public", "private", "protected", void 0), n["undefined"]).field("readonly", Boolean, n["false"]).field("parameter", a(s("Identifier"), s("AssignmentPattern")));
            s("ClassBody").field("body", [ a(s("MethodDefinition"), s("VariableDeclarator"), s("ClassPropertyDefinition"), s("ClassProperty"), s("ClassMethod"), s("TSDeclareMethod"), c) ]);
        };
    }, function(e, t, i) {
        "use strict";
        e.exports = function(e) {
            var t = [];
            var r = [];
            var s = {};
            function a(e) {
                var i = t.indexOf(e);
                if (i === -1) {
                    i = t.length;
                    t.push(e);
                    r[i] = e(s);
                }
                return r[i];
            }
            s.use = a;
            var n = a(i(2));
            e.forEach(a);
            n.finalize();
            var o = {
                Type: n.Type,
                builtInTypes: n.builtInTypes,
                namedTypes: n.namedTypes,
                builders: n.builders,
                defineMethod: n.defineMethod,
                getFieldNames: n.getFieldNames,
                getFieldValue: n.getFieldValue,
                eachField: n.eachField,
                someField: n.someField,
                getSupertypeNames: n.getSupertypeNames,
                astNodesAreEquivalent: a(i(70)),
                finalize: n.finalize,
                Path: a(i(37)),
                NodePath: a(i(19)),
                PathVisitor: a(i(71)),
                use: a
            };
            o.visit = o.PathVisitor.visit;
            return o;
        };
    }, function(e, t, i) {
        "use strict";
        e.exports = function(e) {
            var t = e.use(i(2));
            var r = t.getFieldNames;
            var s = t.getFieldValue;
            var a = t.builtInTypes.array;
            var n = t.builtInTypes.object;
            var o = t.builtInTypes.Date;
            var l = t.builtInTypes.RegExp;
            var u = Object.prototype.hasOwnProperty;
            function c(e, t, i) {
                if (a.check(i)) {
                    i.length = 0;
                } else {
                    i = null;
                }
                return p(e, t, i);
            }
            c.assert = function(e, t) {
                var i = [];
                if (!c(e, t, i)) {
                    if (i.length === 0) {
                        if (e !== t) {
                            throw new Error("Nodes must be equal");
                        }
                    } else {
                        throw new Error("Nodes differ in the following path: " + i.map(h).join(""));
                    }
                }
            };
            function h(e) {
                if (/[_$a-z][_$a-z0-9]*/i.test(e)) {
                    return "." + e;
                }
                return "[" + JSON.stringify(e) + "]";
            }
            function p(e, t, i) {
                if (e === t) {
                    return true;
                }
                if (a.check(e)) {
                    return f(e, t, i);
                }
                if (n.check(e)) {
                    return d(e, t, i);
                }
                if (o.check(e)) {
                    return o.check(t) && +e === +t;
                }
                if (l.check(e)) {
                    return l.check(t) && e.source === t.source && e.global === t.global && e.multiline === t.multiline && e.ignoreCase === t.ignoreCase;
                }
                return e == t;
            }
            function f(e, t, i) {
                a.assert(e);
                var r = e.length;
                if (!a.check(t) || t.length !== r) {
                    if (i) {
                        i.push("length");
                    }
                    return false;
                }
                for (var s = 0; s < r; ++s) {
                    if (i) {
                        i.push(s);
                    }
                    if (s in e !== s in t) {
                        return false;
                    }
                    if (!p(e[s], t[s], i)) {
                        return false;
                    }
                    if (i) {
                        var n = i.pop();
                        if (n !== s) {
                            throw new Error("" + n);
                        }
                    }
                }
                return true;
            }
            function d(e, t, i) {
                n.assert(e);
                if (!n.check(t)) {
                    return false;
                }
                if (e.type !== t.type) {
                    if (i) {
                        i.push("type");
                    }
                    return false;
                }
                var a = r(e);
                var o = a.length;
                var l = r(t);
                var c = l.length;
                if (o === c) {
                    for (var h = 0; h < o; ++h) {
                        var f = a[h];
                        var d = s(e, f);
                        var m = s(t, f);
                        if (i) {
                            i.push(f);
                        }
                        if (!p(d, m, i)) {
                            return false;
                        }
                        if (i) {
                            var y = i.pop();
                            if (y !== f) {
                                throw new Error("" + y);
                            }
                        }
                    }
                    return true;
                }
                if (!i) {
                    return false;
                }
                var v = Object.create(null);
                for (h = 0; h < o; ++h) {
                    v[a[h]] = true;
                }
                for (h = 0; h < c; ++h) {
                    f = l[h];
                    if (!u.call(v, f)) {
                        i.push(f);
                        return false;
                    }
                    delete v[f];
                }
                for (f in v) {
                    i.push(f);
                    break;
                }
                return false;
            }
            return c;
        };
    }, function(e, t, i) {
        "use strict";
        var r = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(e) {
            return typeof e;
        } : function(e) {
            return e && typeof Symbol === "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
        };
        var s = Object.prototype.hasOwnProperty;
        e.exports = function(e) {
            var t = e.use(i(2));
            var a = e.use(i(19));
            var n = t.namedTypes.Printable;
            var o = t.builtInTypes.array;
            var l = t.builtInTypes.object;
            var u = t.builtInTypes.function;
            var c;
            function h() {
                if (!(this instanceof h)) {
                    throw new Error("PathVisitor constructor cannot be invoked without 'new'");
                }
                this._reusableContextStack = [];
                this._methodNameTable = p(this);
                this._shouldVisitComments = s.call(this._methodNameTable, "Block") || s.call(this._methodNameTable, "Line");
                this.Context = y(this);
                this._visiting = false;
                this._changeReported = false;
            }
            function p(e) {
                var i = Object.create(null);
                for (var r in e) {
                    if (/^visit[A-Z]/.test(r)) {
                        i[r.slice("visit".length)] = true;
                    }
                }
                var s = t.computeSupertypeLookupTable(i);
                var a = Object.create(null);
                var i = Object.keys(s);
                var n = i.length;
                for (var o = 0; o < n; ++o) {
                    var l = i[o];
                    r = "visit" + s[l];
                    if (u.check(e[r])) {
                        a[l] = r;
                    }
                }
                return a;
            }
            h.fromMethodsObject = function e(t) {
                if (t instanceof h) {
                    return t;
                }
                if (!l.check(t)) {
                    return new h();
                }
                function i() {
                    if (!(this instanceof i)) {
                        throw new Error("Visitor constructor cannot be invoked without 'new'");
                    }
                    h.call(this);
                }
                var r = i.prototype = Object.create(d);
                r.constructor = i;
                f(r, t);
                f(i, h);
                u.assert(i.fromMethodsObject);
                u.assert(i.visit);
                return new i();
            };
            function f(e, t) {
                for (var i in t) {
                    if (s.call(t, i)) {
                        e[i] = t[i];
                    }
                }
                return e;
            }
            h.visit = function e(t, i) {
                return h.fromMethodsObject(i).visit(t);
            };
            var d = h.prototype;
            d.visit = function() {
                if (this._visiting) {
                    throw new Error("Recursively calling visitor.visit(path) resets visitor state. " + "Try this.visit(path) or this.traverse(path) instead.");
                }
                this._visiting = true;
                this._changeReported = false;
                this._abortRequested = false;
                var e = arguments.length;
                var t = new Array(e);
                for (var i = 0; i < e; ++i) {
                    t[i] = arguments[i];
                }
                if (!(t[0] instanceof a)) {
                    t[0] = new a({
                        root: t[0]
                    }).get("root");
                }
                this.reset.apply(this, t);
                try {
                    var r = this.visitWithoutReset(t[0]);
                    var s = true;
                } finally {
                    this._visiting = false;
                    if (!s && this._abortRequested) {
                        return t[0].value;
                    }
                }
                return r;
            };
            d.AbortRequest = function e() {};
            d.abort = function() {
                var e = this;
                e._abortRequested = true;
                var t = new e.AbortRequest();
                t.cancel = function() {
                    e._abortRequested = false;
                };
                throw t;
            };
            d.reset = function(e) {};
            d.visitWithoutReset = function(e) {
                if (this instanceof this.Context) {
                    return this.visitor.visitWithoutReset(e);
                }
                if (!(e instanceof a)) {
                    throw new Error("");
                }
                var t = e.value;
                var i = t && (typeof t === "undefined" ? "undefined" : r(t)) === "object" && typeof t.type === "string" && this._methodNameTable[t.type];
                if (i) {
                    var s = this.acquireContext(e);
                    try {
                        return s.invokeVisitorMethod(i);
                    } finally {
                        this.releaseContext(s);
                    }
                } else {
                    return m(e, this);
                }
            };
            function m(e, i) {
                if (!(e instanceof a)) {
                    throw new Error("");
                }
                if (!(i instanceof h)) {
                    throw new Error("");
                }
                var r = e.value;
                if (o.check(r)) {
                    e.each(i.visitWithoutReset, i);
                } else if (!l.check(r)) {} else {
                    var n = t.getFieldNames(r);
                    if (i._shouldVisitComments && r.comments && n.indexOf("comments") < 0) {
                        n.push("comments");
                    }
                    var u = n.length;
                    var c = [];
                    for (var p = 0; p < u; ++p) {
                        var f = n[p];
                        if (!s.call(r, f)) {
                            r[f] = t.getFieldValue(r, f);
                        }
                        c.push(e.get(f));
                    }
                    for (var p = 0; p < u; ++p) {
                        i.visitWithoutReset(c[p]);
                    }
                }
                return e.value;
            }
            d.acquireContext = function(e) {
                if (this._reusableContextStack.length === 0) {
                    return new this.Context(e);
                }
                return this._reusableContextStack.pop().reset(e);
            };
            d.releaseContext = function(e) {
                if (!(e instanceof this.Context)) {
                    throw new Error("");
                }
                this._reusableContextStack.push(e);
                e.currentPath = null;
            };
            d.reportChanged = function() {
                this._changeReported = true;
            };
            d.wasChangeReported = function() {
                return this._changeReported;
            };
            function y(e) {
                function t(i) {
                    if (!(this instanceof t)) {
                        throw new Error("");
                    }
                    if (!(this instanceof h)) {
                        throw new Error("");
                    }
                    if (!(i instanceof a)) {
                        throw new Error("");
                    }
                    Object.defineProperty(this, "visitor", {
                        value: e,
                        writable: false,
                        enumerable: true,
                        configurable: false
                    });
                    this.currentPath = i;
                    this.needToCallTraverse = true;
                    Object.seal(this);
                }
                if (!(e instanceof h)) {
                    throw new Error("");
                }
                var i = t.prototype = Object.create(e);
                i.constructor = t;
                f(i, v);
                return t;
            }
            var v = Object.create(null);
            v.reset = function e(t) {
                if (!(this instanceof this.Context)) {
                    throw new Error("");
                }
                if (!(t instanceof a)) {
                    throw new Error("");
                }
                this.currentPath = t;
                this.needToCallTraverse = true;
                return this;
            };
            v.invokeVisitorMethod = function e(t) {
                if (!(this instanceof this.Context)) {
                    throw new Error("");
                }
                if (!(this.currentPath instanceof a)) {
                    throw new Error("");
                }
                var i = this.visitor[t].call(this, this.currentPath);
                if (i === false) {
                    this.needToCallTraverse = false;
                } else if (i !== c) {
                    this.currentPath = this.currentPath.replace(i)[0];
                    if (this.needToCallTraverse) {
                        this.traverse(this.currentPath);
                    }
                }
                if (this.needToCallTraverse !== false) {
                    throw new Error("Must either call this.traverse or return false in " + t);
                }
                var r = this.currentPath;
                return r && r.value;
            };
            v.traverse = function e(t, i) {
                if (!(this instanceof this.Context)) {
                    throw new Error("");
                }
                if (!(t instanceof a)) {
                    throw new Error("");
                }
                if (!(this.currentPath instanceof a)) {
                    throw new Error("");
                }
                this.needToCallTraverse = false;
                return m(t, h.fromMethodsObject(i || this.visitor));
            };
            v.visit = function e(t, i) {
                if (!(this instanceof this.Context)) {
                    throw new Error("");
                }
                if (!(t instanceof a)) {
                    throw new Error("");
                }
                if (!(this.currentPath instanceof a)) {
                    throw new Error("");
                }
                this.needToCallTraverse = false;
                return h.fromMethodsObject(i || this.visitor).visitWithoutReset(t);
            };
            v.reportChanged = function e() {
                this.visitor.reportChanged();
            };
            v.abort = function e() {
                this.needToCallTraverse = false;
                this.visitor.abort();
            };
            return h;
        };
    }, function(e, t, i) {
        "use strict";
        var r = Object.prototype.hasOwnProperty;
        e.exports = function(e) {
            var t = e.use(i(2));
            var s = t.Type;
            var a = t.namedTypes;
            var n = a.Node;
            var o = a.Expression;
            var l = t.builtInTypes.array;
            var u = t.builders;
            function c(t, r) {
                if (!(this instanceof c)) {
                    throw new Error("Scope constructor cannot be invoked without 'new'");
                }
                if (!(t instanceof e.use(i(19)))) {
                    throw new Error("");
                }
                p.assert(t.value);
                var s;
                if (r) {
                    if (!(r instanceof c)) {
                        throw new Error("");
                    }
                    s = r.depth + 1;
                } else {
                    r = null;
                    s = 0;
                }
                Object.defineProperties(this, {
                    path: {
                        value: t
                    },
                    node: {
                        value: t.value
                    },
                    isGlobal: {
                        value: !r,
                        enumerable: true
                    },
                    depth: {
                        value: s
                    },
                    parent: {
                        value: r
                    },
                    bindings: {
                        value: {}
                    },
                    types: {
                        value: {}
                    }
                });
            }
            var h = [ a.Program, a.Function, a.CatchClause ];
            var p = s.or.apply(s, h);
            c.isEstablishedBy = function(e) {
                return p.check(e);
            };
            var f = c.prototype;
            f.didScan = false;
            f.declares = function(e) {
                this.scan();
                return r.call(this.bindings, e);
            };
            f.declaresType = function(e) {
                this.scan();
                return r.call(this.types, e);
            };
            f.declareTemporary = function(e) {
                if (e) {
                    if (!/^[a-z$_]/i.test(e)) {
                        throw new Error("");
                    }
                } else {
                    e = "t$";
                }
                e += this.depth.toString(36) + "$";
                this.scan();
                var i = 0;
                while (this.declares(e + i)) {
                    ++i;
                }
                var r = e + i;
                return this.bindings[r] = t.builders.identifier(r);
            };
            f.injectTemporary = function(e, t) {
                e || (e = this.declareTemporary());
                var i = this.path.get("body");
                if (a.BlockStatement.check(i.value)) {
                    i = i.get("body");
                }
                i.unshift(u.variableDeclaration("var", [ u.variableDeclarator(e, t || null) ]));
                return e;
            };
            f.scan = function(e) {
                if (e || !this.didScan) {
                    for (var t in this.bindings) {
                        delete this.bindings[t];
                    }
                    d(this.path, this.bindings, this.types);
                    this.didScan = true;
                }
            };
            f.getBindings = function() {
                this.scan();
                return this.bindings;
            };
            f.getTypes = function() {
                this.scan();
                return this.types;
            };
            function d(e, t, i) {
                var r = e.value;
                p.assert(r);
                if (a.CatchClause.check(r)) {
                    x(e.get("param"), t);
                } else {
                    m(e, t, i);
                }
            }
            function m(e, i, r) {
                var s = e.value;
                if (e.parent && a.FunctionExpression.check(e.parent.node) && e.parent.node.id) {
                    x(e.parent.get("id"), i);
                }
                if (!s) {} else if (l.check(s)) {
                    e.each(function(e) {
                        v(e, i, r);
                    });
                } else if (a.Function.check(s)) {
                    e.get("params").each(function(e) {
                        x(e, i);
                    });
                    v(e.get("body"), i, r);
                } else if (a.TypeAlias && a.TypeAlias.check(s)) {
                    g(e.get("id"), r);
                } else if (a.VariableDeclarator.check(s)) {
                    x(e.get("id"), i);
                    v(e.get("init"), i, r);
                } else if (s.type === "ImportSpecifier" || s.type === "ImportNamespaceSpecifier" || s.type === "ImportDefaultSpecifier") {
                    x(e.get(s.local ? "local" : s.name ? "name" : "id"), i);
                } else if (n.check(s) && !o.check(s)) {
                    t.eachField(s, function(t, s) {
                        var a = e.get(t);
                        if (!y(a, s)) {
                            throw new Error("");
                        }
                        v(a, i, r);
                    });
                }
            }
            function y(e, t) {
                if (e.value === t) {
                    return true;
                }
                if (Array.isArray(e.value) && e.value.length === 0 && Array.isArray(t) && t.length === 0) {
                    return true;
                }
                return false;
            }
            function v(e, t, i) {
                var s = e.value;
                if (!s || o.check(s)) {} else if (a.FunctionDeclaration.check(s) && s.id !== null) {
                    x(e.get("id"), t);
                } else if (a.ClassDeclaration && a.ClassDeclaration.check(s)) {
                    x(e.get("id"), t);
                } else if (p.check(s)) {
                    if (a.CatchClause.check(s)) {
                        var n = s.param.name;
                        var l = r.call(t, n);
                        m(e.get("body"), t, i);
                        if (!l) {
                            delete t[n];
                        }
                    }
                } else {
                    m(e, t, i);
                }
            }
            function x(e, t) {
                var i = e.value;
                a.Pattern.assert(i);
                if (a.Identifier.check(i)) {
                    if (r.call(t, i.name)) {
                        t[i.name].push(e);
                    } else {
                        t[i.name] = [ e ];
                    }
                } else if (a.AssignmentPattern && a.AssignmentPattern.check(i)) {
                    x(e.get("left"), t);
                } else if (a.ObjectPattern && a.ObjectPattern.check(i)) {
                    e.get("properties").each(function(e) {
                        var i = e.value;
                        if (a.Pattern.check(i)) {
                            x(e, t);
                        } else if (a.Property.check(i)) {
                            x(e.get("value"), t);
                        } else if (a.SpreadProperty && a.SpreadProperty.check(i)) {
                            x(e.get("argument"), t);
                        }
                    });
                } else if (a.ArrayPattern && a.ArrayPattern.check(i)) {
                    e.get("elements").each(function(e) {
                        var i = e.value;
                        if (a.Pattern.check(i)) {
                            x(e, t);
                        } else if (a.SpreadElement && a.SpreadElement.check(i)) {
                            x(e.get("argument"), t);
                        }
                    });
                } else if (a.PropertyPattern && a.PropertyPattern.check(i)) {
                    x(e.get("pattern"), t);
                } else if (a.SpreadElementPattern && a.SpreadElementPattern.check(i) || a.SpreadPropertyPattern && a.SpreadPropertyPattern.check(i)) {
                    x(e.get("argument"), t);
                }
            }
            function g(e, t) {
                var i = e.value;
                a.Pattern.assert(i);
                if (a.Identifier.check(i)) {
                    if (r.call(t, i.name)) {
                        t[i.name].push(e);
                    } else {
                        t[i.name] = [ e ];
                    }
                }
            }
            f.lookup = function(e) {
                for (var t = this; t; t = t.parent) {
                    if (t.declares(e)) break;
                }
                return t;
            };
            f.lookupType = function(e) {
                for (var t = this; t; t = t.parent) {
                    if (t.declaresType(e)) break;
                }
                return t;
            };
            f.getGlobalScope = function() {
                var e = this;
                while (!e.isGlobal) {
                    e = e.parent;
                }
                return e;
            };
            return c;
        };
    }, function(e, t, i) {
        "use strict";
        e.exports = i(69)([ i(11), i(35), i(12), i(67), i(63), i(66), i(36), i(65), i(62), i(68), i(64) ]);
    }, , , , , function(e, t) {
        "use strict";
        t.endianness = function() {
            return "LE";
        };
        t.hostname = function() {
            if (typeof location !== "undefined") {
                return location.hostname;
            } else return "";
        };
        t.loadavg = function() {
            return [];
        };
        t.uptime = function() {
            return 0;
        };
        t.freemem = function() {
            return Number.MAX_VALUE;
        };
        t.totalmem = function() {
            return Number.MAX_VALUE;
        };
        t.cpus = function() {
            return [];
        };
        t.type = function() {
            return "Browser";
        };
        t.release = function() {
            if (typeof navigator !== "undefined") {
                return navigator.appVersion;
            }
            return "";
        };
        t.networkInterfaces = t.getNetworkInterfaces = function() {
            return {};
        };
        t.arch = function() {
            return "javascript";
        };
        t.platform = function() {
            return "browser";
        };
        t.tmpdir = t.tmpDir = function() {
            return "/tmp";
        };
        t.EOL = "\n";
    }, function(e, t, i) {
        "use strict";
        var r = i(7);
        var s = i(6);
        var a = s.builtInTypes.string;
        var n = s.builtInTypes.number;
        var o = s.namedTypes.SourceLocation;
        var l = s.namedTypes.Position;
        var u = i(13);
        var c = i(8).comparePos;
        function h(e, t, i) {
            r.ok(this instanceof h);
            r.ok(e instanceof u.Lines);
            o.assert(t);
            if (i) {
                r.ok(n.check(i.start.line) && n.check(i.start.column) && n.check(i.end.line) && n.check(i.end.column));
            } else {
                i = t;
            }
            Object.defineProperties(this, {
                sourceLines: {
                    value: e
                },
                sourceLoc: {
                    value: t
                },
                targetLoc: {
                    value: i
                }
            });
        }
        var p = h.prototype;
        e.exports = h;
        p.slice = function(e, t, i) {
            r.ok(e instanceof u.Lines);
            l.assert(t);
            if (i) {
                l.assert(i);
            } else {
                i = e.lastPos();
            }
            var s = this.sourceLines;
            var a = this.sourceLoc;
            var n = this.targetLoc;
            function o(o) {
                var l = a[o];
                var u = n[o];
                var c = t;
                if (o === "end") {
                    c = i;
                } else {
                    r.strictEqual(o, "start");
                }
                return m(s, l, e, u, c);
            }
            if (c(t, n.start) <= 0) {
                if (c(n.end, i) <= 0) {
                    n = {
                        start: d(n.start, t.line, t.column),
                        end: d(n.end, t.line, t.column)
                    };
                } else if (c(i, n.start) <= 0) {
                    return null;
                } else {
                    a = {
                        start: a.start,
                        end: o("end")
                    };
                    n = {
                        start: d(n.start, t.line, t.column),
                        end: d(i, t.line, t.column)
                    };
                }
            } else {
                if (c(n.end, t) <= 0) {
                    return null;
                }
                if (c(n.end, i) <= 0) {
                    a = {
                        start: o("start"),
                        end: a.end
                    };
                    n = {
                        start: {
                            line: 1,
                            column: 0
                        },
                        end: d(n.end, t.line, t.column)
                    };
                } else {
                    a = {
                        start: o("start"),
                        end: o("end")
                    };
                    n = {
                        start: {
                            line: 1,
                            column: 0
                        },
                        end: d(i, t.line, t.column)
                    };
                }
            }
            return new h(this.sourceLines, a, n);
        };
        p.add = function(e, t) {
            return new h(this.sourceLines, this.sourceLoc, {
                start: f(this.targetLoc.start, e, t),
                end: f(this.targetLoc.end, e, t)
            });
        };
        function f(e, t, i) {
            return {
                line: e.line + t - 1,
                column: e.line === 1 ? e.column + i : e.column
            };
        }
        p.subtract = function(e, t) {
            return new h(this.sourceLines, this.sourceLoc, {
                start: d(this.targetLoc.start, e, t),
                end: d(this.targetLoc.end, e, t)
            });
        };
        function d(e, t, i) {
            return {
                line: e.line - t + 1,
                column: e.line === t ? e.column - i : e.column
            };
        }
        p.indent = function(e, t, i) {
            if (e === 0) {
                return this;
            }
            var r = this.targetLoc;
            var s = r.start.line;
            var a = r.end.line;
            if (t && s === 1 && a === 1) {
                return this;
            }
            r = {
                start: r.start,
                end: r.end
            };
            if (!t || s > 1) {
                var n = r.start.column + e;
                r.start = {
                    line: s,
                    column: i ? Math.max(0, n) : n
                };
            }
            if (!t || a > 1) {
                var o = r.end.column + e;
                r.end = {
                    line: a,
                    column: i ? Math.max(0, o) : o
                };
            }
            return new h(this.sourceLines, this.sourceLoc, r);
        };
        function m(e, t, i, s, a) {
            r.ok(e instanceof u.Lines);
            r.ok(i instanceof u.Lines);
            l.assert(t);
            l.assert(s);
            l.assert(a);
            var n = c(s, a);
            if (n === 0) {
                return t;
            }
            if (n < 0) {
                var o = e.skipSpaces(t);
                var h = i.skipSpaces(s);
                var p = a.line - h.line;
                o.line += p;
                h.line += p;
                if (p > 0) {
                    o.column = 0;
                    h.column = 0;
                } else {
                    r.strictEqual(p, 0);
                }
                while (c(h, a) < 0 && i.nextPos(h, true)) {
                    r.ok(e.nextPos(o, true));
                    r.strictEqual(e.charAt(o), i.charAt(h));
                }
            } else {
                var o = e.skipSpaces(t, true);
                var h = i.skipSpaces(s, true);
                var p = a.line - h.line;
                o.line += p;
                h.line += p;
                if (p < 0) {
                    o.column = e.getLineLength(o.line);
                    h.column = i.getLineLength(h.line);
                } else {
                    r.strictEqual(p, 0);
                }
                while (c(a, h) < 0 && i.prevPos(h, true)) {
                    r.ok(e.prevPos(o, true));
                    r.strictEqual(e.charAt(o), i.charAt(h));
                }
            }
            return o;
        }
    }, function(e, t, i) {
        "use strict";
        var r = i(7);
        var s = i(6);
        var a = s.namedTypes;
        var n = s.builders;
        var o = s.builtInTypes.object;
        var l = s.builtInTypes.array;
        var u = s.builtInTypes.function;
        var c = i(42).Patcher;
        var h = i(20).normalize;
        var p = i(13).fromString;
        var f = i(40).attach;
        var d = i(8);
        t.parse = function e(t, r) {
            r = h(r);
            var s = p(t, r);
            var a = s.toString({
                tabWidth: r.tabWidth,
                reuseWhitespace: false,
                useTabs: false
            });
            var o = [];
            var l = r.parser.parse(a, {
                jsx: true,
                loc: true,
                locations: true,
                range: r.range,
                comment: true,
                onComment: o,
                tolerant: d.getOption(r, "tolerant", true),
                ecmaVersion: 6,
                sourceType: d.getOption(r, "sourceType", "module")
            });
            var u = Array.isArray(l.tokens) ? l.tokens : i(38).tokenize(a, {
                loc: true
            });
            delete l.tokens;
            u.forEach(function(e) {
                if (typeof e.value !== "string") {
                    e.value = s.sliceString(e.loc.start, e.loc.end);
                }
            });
            if (Array.isArray(l.comments)) {
                o = l.comments;
                delete l.comments;
            }
            if (l.loc) {
                d.fixFaultyLocations(l, s);
            } else {
                l.loc = {
                    start: s.firstPos(),
                    end: s.lastPos()
                };
            }
            l.loc.lines = s;
            l.loc.indent = 0;
            var c = void 0;
            var y = void 0;
            if (l.type === "Program") {
                y = l;
                c = n.file(l, r.sourceFileName || null);
                c.loc = {
                    start: s.firstPos(),
                    end: s.lastPos(),
                    lines: s,
                    indent: 0
                };
            } else if (l.type === "File") {
                c = l;
                y = c.program;
            }
            if (r.tokens) {
                c.tokens = u;
            }
            var v = d.getTrueLoc({
                type: y.type,
                loc: y.loc,
                body: [],
                comments: o
            }, s);
            y.loc.start = v.start;
            y.loc.end = v.end;
            f(o, y.body.length ? c.program : c, s);
            return new m(s, u).copy(c);
        };
        function m(e, t) {
            r.ok(this instanceof m);
            this.lines = e;
            this.tokens = t;
            this.startTokenIndex = 0;
            this.endTokenIndex = t.length;
            this.indent = 0;
            this.seen = new Map();
        }
        var y = m.prototype;
        y.copy = function(e) {
            if (this.seen.has(e)) {
                return this.seen.get(e);
            }
            if (l.check(e)) {
                var t = new Array(e.length);
                this.seen.set(e, t);
                e.forEach(function(e, i) {
                    t[i] = this.copy(e);
                }, this);
                return t;
            }
            if (!o.check(e)) {
                return e;
            }
            d.fixFaultyLocations(e, this.lines);
            var t = Object.create(Object.getPrototypeOf(e), {
                original: {
                    value: e,
                    configurable: false,
                    enumerable: false,
                    writable: true
                }
            });
            this.seen.set(e, t);
            var i = e.loc;
            var r = this.indent;
            var s = r;
            var a = this.startTokenIndex;
            var n = this.endTokenIndex;
            if (i) {
                if (e.type === "Block" || e.type === "Line" || e.type === "CommentBlock" || e.type === "CommentLine" || this.lines.isPrecededOnlyByWhitespace(i.start)) {
                    s = this.indent = i.start.column;
                }
                i.lines = this.lines;
                i.tokens = this.tokens;
                i.indent = s;
                this.findTokenRange(i);
            }
            var u = Object.keys(e);
            var c = u.length;
            for (var h = 0; h < c; ++h) {
                var p = u[h];
                if (p === "loc") {
                    t[p] = e[p];
                } else if (p === "tokens" && e.type === "File") {
                    t[p] = e[p];
                } else {
                    t[p] = this.copy(e[p]);
                }
            }
            this.indent = r;
            this.startTokenIndex = a;
            this.endTokenIndex = n;
            return t;
        };
        y.findTokenRange = function(e) {
            while (this.startTokenIndex > 0) {
                var t = e.tokens[this.startTokenIndex];
                if (d.comparePos(e.start, t.loc.start) < 0) {
                    --this.startTokenIndex;
                } else break;
            }
            while (this.endTokenIndex < e.tokens.length) {
                var i = e.tokens[this.endTokenIndex];
                if (d.comparePos(i.loc.end, e.end) < 0) {
                    ++this.endTokenIndex;
                } else break;
            }
            while (this.startTokenIndex < this.endTokenIndex) {
                var r = e.tokens[this.startTokenIndex];
                if (d.comparePos(r.loc.start, e.start) < 0) {
                    ++this.startTokenIndex;
                } else break;
            }
            e.start.token = this.startTokenIndex;
            while (this.endTokenIndex > this.startTokenIndex) {
                var s = e.tokens[this.endTokenIndex - 1];
                if (d.comparePos(e.end, s.loc.end) < 0) {
                    --this.endTokenIndex;
                } else break;
            }
            e.end.token = this.endTokenIndex;
        };
    }, function(e, t, i) {
        "use strict";
        var r = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(e) {
            return typeof e;
        } : function(e) {
            return e && typeof Symbol === "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
        };
        var s = Object.assign || function(e) {
            for (var t = 1; t < arguments.length; t++) {
                var i = arguments[t];
                for (var r in i) {
                    if (Object.prototype.hasOwnProperty.call(i, r)) {
                        e[r] = i[r];
                    }
                }
            }
            return e;
        };
        var a = i(7);
        var n = i(21);
        var o = i(40).printComments;
        var l = i(13);
        var u = l.fromString;
        var c = l.concat;
        var h = i(20).normalize;
        var f = i(42).getReprinter;
        var d = i(6);
        var m = d.namedTypes;
        var y = d.builtInTypes.string;
        var v = d.builtInTypes.object;
        var x = i(41);
        var g = i(8);
        function b(e, t) {
            a.ok(this instanceof b);
            y.assert(e);
            this.code = e;
            if (t) {
                v.assert(t);
                this.map = t;
            }
        }
        var E = b.prototype;
        var k = false;
        E.toString = function() {
            if (!k) {
                console.warn("Deprecation warning: recast.print now returns an object with " + "a .code property. You appear to be treating the object as a " + "string, which might still work but is strongly discouraged.");
                k = true;
            }
            return this.code;
        };
        var S = new b("");
        function w(e) {
            a.ok(this instanceof w);
            var t = e && e.tabWidth;
            e = h(e);
            e.sourceFileName = null;
            function i(e, t) {
                e = s({}, e, t);
                return function(t) {
                    return r(t, e);
                };
            }
            function r(s, n) {
                a.ok(s instanceof x);
                n = n || {};
                if (n.includeComments) {
                    return o(s, i(n, {
                        includeComments: false
                    }));
                }
                var l = e.tabWidth;
                if (!t) {
                    var u = s.getNode().loc;
                    if (u && u.lines && u.lines.guessTabWidth) {
                        e.tabWidth = u.lines.guessTabWidth();
                    }
                }
                var c = f(s);
                var h = c ? c(r) : A(s, e, n, i(n, {
                    includeComments: true,
                    avoidRootParens: false
                }));
                e.tabWidth = l;
                return h;
            }
            this.print = function(t) {
                if (!t) {
                    return S;
                }
                var i = r(x.from(t), {
                    includeComments: true,
                    avoidRootParens: false
                });
                return new b(i.toString(e), g.composeSourceMaps(e.inputSourceMap, i.getSourceMap(e.sourceMapName, e.sourceRoot)));
            };
            this.printGenerically = function(t) {
                if (!t) {
                    return S;
                }
                function i(t) {
                    return o(t, function(t) {
                        return A(t, e, {
                            includeComments: true,
                            avoidRootParens: false
                        }, i);
                    });
                }
                var r = x.from(t);
                var s = e.reuseWhitespace;
                e.reuseWhitespace = false;
                var a = new b(i(r).toString(e));
                e.reuseWhitespace = s;
                return a;
            };
        }
        t.Printer = w;
        function A(e, t, i, r) {
            a.ok(e instanceof x);
            var s = e.getValue();
            var n = [];
            var o = C(e, t, r);
            if (!s || o.isEmpty()) {
                return o;
            }
            var l = false;
            var u = T(e, r);
            if (u.isEmpty()) {
                if (!i.avoidRootParens) {
                    l = e.needsParens();
                }
            } else {
                n.push(u);
            }
            if (l) {
                n.unshift("(");
            }
            n.push(o);
            if (l) {
                n.push(")");
            }
            return c(n);
        }
        function C(e, t, i) {
            var s = e.getValue();
            if (!s) {
                return u("");
            }
            if (typeof s === "string") {
                return u(s, t);
            }
            m.Printable.assert(s);
            var n = [];
            switch (s.type) {
              case "File":
                return e.call(i, "program");

              case "Program":
                if (s.directives) {
                    e.each(function(e) {
                        n.push(i(e), ";\n");
                    }, "directives");
                }
                n.push(e.call(function(e) {
                    return P(e, t, i);
                }, "body"));
                return c(n);

              case "Noop":
              case "EmptyStatement":
                return u("");

              case "ExpressionStatement":
                return c([ e.call(i, "expression"), ";" ]);

              case "ParenthesizedExpression":
                return c([ "(", e.call(i, "expression"), ")" ]);

              case "BinaryExpression":
              case "LogicalExpression":
              case "AssignmentExpression":
                return u(" ").join([ e.call(i, "left"), s.operator, e.call(i, "right") ]);

              case "AssignmentPattern":
                return c([ e.call(i, "left"), " = ", e.call(i, "right") ]);

              case "MemberExpression":
              case "OptionalMemberExpression":
                n.push(e.call(i, "object"));
                var o = e.call(i, "property");
                var l = s.type === "OptionalMemberExpression";
                if (s.computed) {
                    n.push(l ? "?.[" : "[", o, "]");
                } else {
                    n.push(l ? "?." : ".", o);
                }
                return c(n);

              case "MetaProperty":
                return c([ e.call(i, "meta"), ".", e.call(i, "property") ]);

              case "BindExpression":
                if (s.object) {
                    n.push(e.call(i, "object"));
                }
                n.push("::", e.call(i, "callee"));
                return c(n);

              case "Path":
                return u(".").join(s.body);

              case "Identifier":
                return c([ u(s.name, t), s.optional ? "?" : "", e.call(i, "typeAnnotation") ]);

              case "SpreadElement":
              case "SpreadElementPattern":
              case "RestProperty":
              case "SpreadProperty":
              case "SpreadPropertyPattern":
              case "ObjectTypeSpreadProperty":
              case "RestElement":
                return c([ "...", e.call(i, "argument"), e.call(i, "typeAnnotation") ]);

              case "FunctionDeclaration":
              case "FunctionExpression":
              case "TSDeclareFunction":
                if (s.declare) {
                    n.push("declare ");
                }
                if (s.async) {
                    n.push("async ");
                }
                n.push("function");
                if (s.generator) n.push("*");
                if (s.id) {
                    n.push(" ", e.call(i, "id"), e.call(i, "typeParameters"));
                }
                n.push("(", F(e, t, i), ")", e.call(i, "returnType"));
                if (s.body) {
                    n.push(" ", e.call(i, "body"));
                }
                return c(n);

              case "ArrowFunctionExpression":
                if (s.async) {
                    n.push("async ");
                }
                if (s.typeParameters) {
                    n.push(e.call(i, "typeParameters"));
                }
                if (!t.arrowParensAlways && s.params.length === 1 && !s.rest && s.params[0].type === "Identifier" && !s.params[0].typeAnnotation && !s.returnType) {
                    n.push(e.call(i, "params", 0));
                } else {
                    n.push("(", F(e, t, i), ")", e.call(i, "returnType"));
                }
                n.push(" => ", e.call(i, "body"));
                return c(n);

              case "MethodDefinition":
                return _(e, t, i);

              case "YieldExpression":
                n.push("yield");
                if (s.delegate) n.push("*");
                if (s.argument) n.push(" ", e.call(i, "argument"));
                return c(n);

              case "AwaitExpression":
                n.push("await");
                if (s.all) n.push("*");
                if (s.argument) n.push(" ", e.call(i, "argument"));
                return c(n);

              case "ModuleDeclaration":
                n.push("module", e.call(i, "id"));
                if (s.source) {
                    a.ok(!s.body);
                    n.push("from", e.call(i, "source"));
                } else {
                    n.push(e.call(i, "body"));
                }
                return u(" ").join(n);

              case "ImportSpecifier":
                if (s.importKind && s.importKind !== "value") {
                    n.push(s.importKind + " ");
                }
                if (s.imported) {
                    n.push(e.call(i, "imported"));
                    if (s.local && s.local.name !== s.imported.name) {
                        n.push(" as ", e.call(i, "local"));
                    }
                } else if (s.id) {
                    n.push(e.call(i, "id"));
                    if (s.name) {
                        n.push(" as ", e.call(i, "name"));
                    }
                }
                return c(n);

              case "ExportSpecifier":
                if (s.local) {
                    n.push(e.call(i, "local"));
                    if (s.exported && s.exported.name !== s.local.name) {
                        n.push(" as ", e.call(i, "exported"));
                    }
                } else if (s.id) {
                    n.push(e.call(i, "id"));
                    if (s.name) {
                        n.push(" as ", e.call(i, "name"));
                    }
                }
                return c(n);

              case "ExportBatchSpecifier":
                return u("*");

              case "ImportNamespaceSpecifier":
                n.push("* as ");
                if (s.local) {
                    n.push(e.call(i, "local"));
                } else if (s.id) {
                    n.push(e.call(i, "id"));
                }
                return c(n);

              case "ImportDefaultSpecifier":
                if (s.local) {
                    return e.call(i, "local");
                }
                return e.call(i, "id");

              case "TSExportAssignment":
                return c([ "export = ", e.call(i, "expression") ]);

              case "ExportDeclaration":
              case "ExportDefaultDeclaration":
              case "ExportNamedDeclaration":
                return I(e, t, i);

              case "ExportAllDeclaration":
                n.push("export *");
                if (s.exported) {
                    n.push(" as ", e.call(i, "exported"));
                }
                n.push(" from ", e.call(i, "source"));
                return c(n);

              case "TSNamespaceExportDeclaration":
                n.push("export as namespace ", e.call(i, "id"));
                return U(c(n));

              case "ExportNamespaceSpecifier":
                return c([ "* as ", e.call(i, "exported") ]);

              case "ExportDefaultSpecifier":
                return e.call(i, "exported");

              case "Import":
                return u("import", t);

              case "ImportDeclaration":
                {
                    n.push("import ");
                    if (s.importKind && s.importKind !== "value") {
                        n.push(s.importKind + " ");
                    }
                    if (s.specifiers && s.specifiers.length > 0) {
                        var h = [];
                        var f = [];
                        e.each(function(e) {
                            var t = e.getValue();
                            if (t.type === "ImportSpecifier") {
                                f.push(i(e));
                            } else if (t.type === "ImportDefaultSpecifier" || t.type === "ImportNamespaceSpecifier") {
                                h.push(i(e));
                            }
                        }, "specifiers");
                        h.forEach(function(e, t) {
                            if (t > 0) {
                                n.push(", ");
                            }
                            n.push(e);
                        });
                        if (f.length > 0) {
                            var d = u(", ").join(f);
                            if (d.getLineLength(1) > t.wrapColumn) {
                                d = c([ u(",\n").join(f).indent(t.tabWidth), "," ]);
                            }
                            if (h.length > 0) {
                                n.push(", ");
                            }
                            if (d.length > 1) {
                                n.push("{\n", d, "\n}");
                            } else if (t.objectCurlySpacing) {
                                n.push("{ ", d, " }");
                            } else {
                                n.push("{", d, "}");
                            }
                        }
                        n.push(" from ");
                    }
                    n.push(e.call(i, "source"), ";");
                    return c(n);
                }

              case "BlockStatement":
                var y = e.call(function(e) {
                    return P(e, t, i);
                }, "body");
                if (y.isEmpty()) {
                    if (!s.directives || s.directives.length === 0) {
                        return u("{}");
                    }
                }
                n.push("{\n");
                if (s.directives) {
                    e.each(function(e) {
                        n.push(i(e).indent(t.tabWidth), ";", s.directives.length > 1 || !y.isEmpty() ? "\n" : "");
                    }, "directives");
                }
                n.push(y.indent(t.tabWidth));
                n.push("\n}");
                return c(n);

              case "ReturnStatement":
                n.push("return");
                if (s.argument) {
                    var v = e.call(i, "argument");
                    if (v.startsWithComment() || v.length > 1 && m.JSXElement && m.JSXElement.check(s.argument)) {
                        n.push(" (\n", v.indent(t.tabWidth), "\n)");
                    } else {
                        n.push(" ", v);
                    }
                }
                n.push(";");
                return c(n);

              case "CallExpression":
              case "OptionalCallExpression":
                var n = [ e.call(i, "callee") ];
                if (s.type === "OptionalCallExpression" && s.callee.type !== "OptionalMemberExpression") {
                    n.push("?.");
                }
                n.push(N(e, t, i));
                return c(n);

              case "ObjectExpression":
              case "ObjectPattern":
              case "ObjectTypeAnnotation":
                var x = false;
                var b = s.type === "ObjectTypeAnnotation";
                var E = t.flowObjectCommas ? "," : b ? ";" : ",";
                var k = [];
                if (b) {
                    k.push("indexers", "callProperties");
                }
                k.push("properties");
                var S = 0;
                k.forEach(function(e) {
                    S += s[e].length;
                });
                var w = b && S === 1 || S === 0;
                var A = s.exact ? "{|" : "{";
                var C = s.exact ? "|}" : "}";
                n.push(w ? A : A + "\n");
                var T = n.length - 1;
                var D = 0;
                k.forEach(function(r) {
                    e.each(function(e) {
                        var r = i(e);
                        if (!w) {
                            r = r.indent(t.tabWidth);
                        }
                        var s = !b && r.length > 1;
                        if (s && x) {
                            n.push("\n");
                        }
                        n.push(r);
                        if (D < S - 1) {
                            n.push(E + (s ? "\n\n" : "\n"));
                            x = !s;
                        } else if (S !== 1 && b) {
                            n.push(E);
                        } else if (!w && g.isTrailingCommaEnabled(t, "objects")) {
                            n.push(E);
                        }
                        D++;
                    }, r);
                });
                n.push(w ? C : "\n" + C);
                if (D !== 0 && w && t.objectCurlySpacing) {
                    n[T] = A + " ";
                    n[n.length - 1] = " " + C;
                }
                if (s.typeAnnotation) {
                    n.push(e.call(i, "typeAnnotation"));
                }
                return c(n);

              case "PropertyPattern":
                return c([ e.call(i, "key"), ": ", e.call(i, "pattern") ]);

              case "ObjectProperty":
              case "Property":
                if (s.method || s.kind === "get" || s.kind === "set") {
                    return _(e, t, i);
                }
                var M = e.call(i, "key");
                if (s.computed) {
                    n.push("[", M, "]");
                } else {
                    n.push(M);
                }
                if (!s.shorthand) {
                    n.push(": ", e.call(i, "value"));
                }
                return c(n);

              case "ClassMethod":
              case "ObjectMethod":
              case "TSDeclareMethod":
                return _(e, t, i);

              case "Decorator":
                return c([ "@", e.call(i, "expression") ]);

              case "ArrayExpression":
              case "ArrayPattern":
                var R = s.elements, S = R.length;
                var X = e.map(i, "elements");
                var q = u(", ").join(X);
                var w = q.getLineLength(1) <= t.wrapColumn;
                if (w) {
                    if (t.arrayBracketSpacing) {
                        n.push("[ ");
                    } else {
                        n.push("[");
                    }
                } else {
                    n.push("[\n");
                }
                e.each(function(e) {
                    var i = e.getName();
                    var r = e.getValue();
                    if (!r) {
                        n.push(",");
                    } else {
                        var s = X[i];
                        if (w) {
                            if (i > 0) n.push(" ");
                        } else {
                            s = s.indent(t.tabWidth);
                        }
                        n.push(s);
                        if (i < S - 1 || !w && g.isTrailingCommaEnabled(t, "arrays")) n.push(",");
                        if (!w) n.push("\n");
                    }
                }, "elements");
                if (w && t.arrayBracketSpacing) {
                    n.push(" ]");
                } else {
                    n.push("]");
                }
                return c(n);

              case "SequenceExpression":
                return u(", ").join(e.map(i, "expressions"));

              case "ThisExpression":
                return u("this");

              case "Super":
                return u("super");

              case "NullLiteral":
                return u("null");

              case "RegExpLiteral":
                return u(s.extra.raw);

              case "BigIntLiteral":
                return u(s.value + "n");

              case "NumericLiteral":
                if (s.extra && typeof s.extra.raw === "string" && Number(s.extra.raw) === s.value) {
                    return u(s.extra.raw, t);
                }
                return u(s.value, t);

              case "BooleanLiteral":
              case "StringLiteral":
              case "Literal":
                if (typeof s.value === "number" && typeof s.raw === "string" && Number(s.raw) === s.value) {
                    return u(s.raw, t);
                }
                if (typeof s.value !== "string") {
                    return u(s.value, t);
                }
                return u(V(s.value, t), t);

              case "Directive":
                return e.call(i, "value");

              case "DirectiveLiteral":
                return u(V(s.value, t));

              case "ModuleSpecifier":
                if (s.local) {
                    throw new Error("The ESTree ModuleSpecifier type should be abstract");
                }
                return u(V(s.value, t), t);

              case "UnaryExpression":
                n.push(s.operator);
                if (/[a-z]$/.test(s.operator)) n.push(" ");
                n.push(e.call(i, "argument"));
                return c(n);

              case "UpdateExpression":
                n.push(e.call(i, "argument"), s.operator);
                if (s.prefix) n.reverse();
                return c(n);

              case "ConditionalExpression":
                return c([ e.call(i, "test"), " ? ", e.call(i, "consequent"), " : ", e.call(i, "alternate") ]);

              case "NewExpression":
                n.push("new ", e.call(i, "callee"));
                var J = s.arguments;
                if (J) {
                    n.push(N(e, t, i));
                }
                return c(n);

              case "VariableDeclaration":
                if (s.declare) {
                    n.push("declare ");
                }
                n.push(s.kind, " ");
                var z = 0;
                var X = e.map(function(e) {
                    var t = i(e);
                    z = Math.max(t.length, z);
                    return t;
                }, "declarations");
                if (z === 1) {
                    n.push(u(", ").join(X));
                } else if (X.length > 1) {
                    n.push(u(",\n").join(X).indentTail(s.kind.length + 1));
                } else {
                    n.push(X[0]);
                }
                var W = e.getParentNode();
                if (!m.ForStatement.check(W) && !m.ForInStatement.check(W) && !(m.ForOfStatement && m.ForOfStatement.check(W)) && !(m.ForAwaitStatement && m.ForAwaitStatement.check(W))) {
                    n.push(";");
                }
                return c(n);

              case "VariableDeclarator":
                return s.init ? u(" = ").join([ e.call(i, "id"), e.call(i, "init") ]) : e.call(i, "id");

              case "WithStatement":
                return c([ "with (", e.call(i, "object"), ") ", e.call(i, "body") ]);

              case "IfStatement":
                var K = B(e.call(i, "consequent"), t), n = [ "if (", e.call(i, "test"), ")", K ];
                if (s.alternate) n.push(j(K) ? " else" : "\nelse", B(e.call(i, "alternate"), t));
                return c(n);

              case "ForStatement":
                var G = e.call(i, "init"), H = G.length > 1 ? ";\n" : "; ", Y = "for (", Q = u(H).join([ G, e.call(i, "test"), e.call(i, "update") ]).indentTail(Y.length), $ = c([ Y, Q, ")" ]), Z = B(e.call(i, "body"), t), n = [ $ ];
                if ($.length > 1) {
                    n.push("\n");
                    Z = Z.trimLeft();
                }
                n.push(Z);
                return c(n);

              case "WhileStatement":
                return c([ "while (", e.call(i, "test"), ")", B(e.call(i, "body"), t) ]);

              case "ForInStatement":
                return c([ s.each ? "for each (" : "for (", e.call(i, "left"), " in ", e.call(i, "right"), ")", B(e.call(i, "body"), t) ]);

              case "ForOfStatement":
              case "ForAwaitStatement":
                n.push("for ");
                if (s.await || s.type === "ForAwaitStatement") {
                    n.push("await ");
                }
                n.push("(", e.call(i, "left"), " of ", e.call(i, "right"), ")", B(e.call(i, "body"), t));
                return c(n);

              case "DoWhileStatement":
                var ee = c([ "do", B(e.call(i, "body"), t) ]), n = [ ee ];
                if (j(ee)) n.push(" while"); else n.push("\nwhile");
                n.push(" (", e.call(i, "test"), ");");
                return c(n);

              case "DoExpression":
                var te = e.call(function(e) {
                    return P(e, t, i);
                }, "body");
                return c([ "do {\n", te.indent(t.tabWidth), "\n}" ]);

              case "BreakStatement":
                n.push("break");
                if (s.label) n.push(" ", e.call(i, "label"));
                n.push(";");
                return c(n);

              case "ContinueStatement":
                n.push("continue");
                if (s.label) n.push(" ", e.call(i, "label"));
                n.push(";");
                return c(n);

              case "LabeledStatement":
                return c([ e.call(i, "label"), ":\n", e.call(i, "body") ]);

              case "TryStatement":
                n.push("try ", e.call(i, "block"));
                if (s.handler) {
                    n.push(" ", e.call(i, "handler"));
                } else if (s.handlers) {
                    e.each(function(e) {
                        n.push(" ", i(e));
                    }, "handlers");
                }
                if (s.finalizer) {
                    n.push(" finally ", e.call(i, "finalizer"));
                }
                return c(n);

              case "CatchClause":
                n.push("catch ");
                if (s.param) {
                    n.push("(", e.call(i, "param"));
                }
                if (s.guard) {
                    n.push(" if ", e.call(i, "guard"));
                }
                if (s.param) {
                    n.push(") ");
                }
                n.push(e.call(i, "body"));
                return c(n);

              case "ThrowStatement":
                return c([ "throw ", e.call(i, "argument"), ";" ]);

              case "SwitchStatement":
                return c([ "switch (", e.call(i, "discriminant"), ") {\n", u("\n").join(e.map(i, "cases")), "\n}" ]);

              case "SwitchCase":
                if (s.test) n.push("case ", e.call(i, "test"), ":"); else n.push("default:");
                if (s.consequent.length > 0) {
                    n.push("\n", e.call(function(e) {
                        return P(e, t, i);
                    }, "consequent").indent(t.tabWidth));
                }
                return c(n);

              case "DebuggerStatement":
                return u("debugger;");

              case "JSXAttribute":
                n.push(e.call(i, "name"));
                if (s.value) n.push("=", e.call(i, "value"));
                return c(n);

              case "JSXIdentifier":
                return u(s.name, t);

              case "JSXNamespacedName":
                return u(":").join([ e.call(i, "namespace"), e.call(i, "name") ]);

              case "JSXMemberExpression":
                return u(".").join([ e.call(i, "object"), e.call(i, "property") ]);

              case "JSXSpreadAttribute":
                return c([ "{...", e.call(i, "argument"), "}" ]);

              case "JSXSpreadChild":
                return c([ "{...", e.call(i, "expression"), "}" ]);

              case "JSXExpressionContainer":
                return c([ "{", e.call(i, "expression"), "}" ]);

              case "JSXElement":
              case "JSXFragment":
                var ie = "opening" + (s.type === "JSXElement" ? "Element" : "Fragment");
                var re = "closing" + (s.type === "JSXElement" ? "Element" : "Fragment");
                var se = e.call(i, ie);
                if (s[ie].selfClosing) {
                    a.ok(!s[re], "unexpected " + re + " element in self-closing " + s.type);
                    return se;
                }
                var ae = c(e.map(function(e) {
                    var t = e.getValue();
                    if (m.Literal.check(t) && typeof t.value === "string") {
                        if (/\S/.test(t.value)) {
                            return t.value.replace(/^\s+|\s+$/g, "");
                        } else if (/\n/.test(t.value)) {
                            return "\n";
                        }
                    }
                    return i(e);
                }, "children")).indentTail(t.tabWidth);
                var ne = e.call(i, re);
                return c([ se, ae, ne ]);

              case "JSXOpeningElement":
                n.push("<", e.call(i, "name"));
                var oe = [];
                e.each(function(e) {
                    oe.push(" ", i(e));
                }, "attributes");
                var le = c(oe);
                var ue = le.length > 1 || le.getLineLength(1) > t.wrapColumn;
                if (ue) {
                    oe.forEach(function(e, t) {
                        if (e === " ") {
                            a.strictEqual(t % 2, 0);
                            oe[t] = "\n";
                        }
                    });
                    le = c(oe).indentTail(t.tabWidth);
                }
                n.push(le, s.selfClosing ? " />" : ">");
                return c(n);

              case "JSXClosingElement":
                return c([ "</", e.call(i, "name"), ">" ]);

              case "JSXOpeningFragment":
                return u("<>");

              case "JSXClosingFragment":
                return u("</>");

              case "JSXText":
                return u(s.value, t);

              case "JSXEmptyExpression":
                return u("");

              case "TypeAnnotatedIdentifier":
                return c([ e.call(i, "annotation"), " ", e.call(i, "identifier") ]);

              case "ClassBody":
                if (s.body.length === 0) {
                    return u("{}");
                }
                return c([ "{\n", e.call(function(e) {
                    return P(e, t, i);
                }, "body").indent(t.tabWidth), "\n}" ]);

              case "ClassPropertyDefinition":
                n.push("static ", e.call(i, "definition"));
                if (!m.MethodDefinition.check(s.definition)) n.push(";");
                return c(n);

              case "ClassProperty":
                if (typeof s.accessibility === "string") {
                    n.push(s.accessibility, " ");
                }
                if (s.static) {
                    n.push("static ");
                }
                if (s.abstract) {
                    n.push("abstract ");
                }
                if (s.readonly) {
                    n.push("readonly ");
                }
                var M = e.call(i, "key");
                if (s.computed) {
                    M = c([ "[", M, "]" ]);
                }
                if (s.variance) {
                    M = c([ L(e, i), M ]);
                }
                n.push(M);
                if (s.optional) {
                    n.push("?");
                }
                if (s.typeAnnotation) {
                    n.push(e.call(i, "typeAnnotation"));
                }
                if (s.value) {
                    n.push(" = ", e.call(i, "value"));
                }
                n.push(";");
                return c(n);

              case "ClassDeclaration":
              case "ClassExpression":
                if (s.declare) {
                    n.push("declare ");
                }
                if (s.abstract) {
                    n.push("abstract ");
                }
                n.push("class");
                if (s.id) {
                    n.push(" ", e.call(i, "id"));
                }
                if (s.typeParameters) {
                    n.push(e.call(i, "typeParameters"));
                }
                if (s.superClass) {
                    n.push(" extends ", e.call(i, "superClass"), e.call(i, "superTypeParameters"));
                }
                if (s["implements"] && s["implements"].length > 0) {
                    n.push(" implements ", u(", ").join(e.map(i, "implements")));
                }
                n.push(" ", e.call(i, "body"));
                return c(n);

              case "TemplateElement":
                return u(s.value.raw, t).lockIndentTail();

              case "TemplateLiteral":
                var ce = e.map(i, "expressions");
                n.push("`");
                e.each(function(e) {
                    var t = e.getName();
                    n.push(i(e));
                    if (t < ce.length) {
                        n.push("${", ce[t], "}");
                    }
                }, "quasis");
                n.push("`");
                return c(n).lockIndentTail();

              case "TaggedTemplateExpression":
                return c([ e.call(i, "tag"), e.call(i, "quasi") ]);

              case "Node":
              case "Printable":
              case "SourceLocation":
              case "Position":
              case "Statement":
              case "Function":
              case "Pattern":
              case "Expression":
              case "Declaration":
              case "Specifier":
              case "NamedSpecifier":
              case "Comment":
              case "Flow":
              case "FlowType":
              case "FlowPredicate":
              case "MemberTypeAnnotation":
              case "Type":
              case "TSHasOptionalTypeParameters":
              case "TSHasOptionalTypeAnnotation":
                throw new Error("unprintable type: " + JSON.stringify(s.type));

              case "CommentBlock":
              case "Block":
                return c([ "/*", u(s.value, t), "*/" ]);

              case "CommentLine":
              case "Line":
                return c([ "//", u(s.value, t) ]);

              case "TypeAnnotation":
                if (s.typeAnnotation) {
                    if (s.typeAnnotation.type !== "FunctionTypeAnnotation") {
                        n.push(": ");
                    }
                    n.push(e.call(i, "typeAnnotation"));
                    return c(n);
                }
                return u("");

              case "ExistentialTypeParam":
              case "ExistsTypeAnnotation":
                return u("*", t);

              case "EmptyTypeAnnotation":
                return u("empty", t);

              case "AnyTypeAnnotation":
                return u("any", t);

              case "MixedTypeAnnotation":
                return u("mixed", t);

              case "ArrayTypeAnnotation":
                return c([ e.call(i, "elementType"), "[]" ]);

              case "TupleTypeAnnotation":
                var X = e.map(i, "types");
                var q = u(", ").join(X);
                var w = q.getLineLength(1) <= t.wrapColumn;
                if (w) {
                    if (t.arrayBracketSpacing) {
                        n.push("[ ");
                    } else {
                        n.push("[");
                    }
                } else {
                    n.push("[\n");
                }
                e.each(function(e) {
                    var i = e.getName();
                    var r = e.getValue();
                    if (!r) {
                        n.push(",");
                    } else {
                        var a = X[i];
                        if (w) {
                            if (i > 0) n.push(" ");
                        } else {
                            a = a.indent(t.tabWidth);
                        }
                        n.push(a);
                        if (i < s.types.length - 1 || !w && g.isTrailingCommaEnabled(t, "arrays")) n.push(",");
                        if (!w) n.push("\n");
                    }
                }, "types");
                if (w && t.arrayBracketSpacing) {
                    n.push(" ]");
                } else {
                    n.push("]");
                }
                return c(n);

              case "BooleanTypeAnnotation":
                return u("boolean", t);

              case "BooleanLiteralTypeAnnotation":
                a.strictEqual(r(s.value), "boolean");
                return u("" + s.value, t);

              case "DeclareClass":
                return O(e, [ "class ", e.call(i, "id"), " ", e.call(i, "body") ]);

              case "DeclareFunction":
                return O(e, [ "function ", e.call(i, "id"), ";" ]);

              case "DeclareModule":
                return O(e, [ "module ", e.call(i, "id"), " ", e.call(i, "body") ]);

              case "DeclareModuleExports":
                return O(e, [ "module.exports", e.call(i, "typeAnnotation") ]);

              case "DeclareVariable":
                return O(e, [ "var ", e.call(i, "id"), ";" ]);

              case "DeclareExportDeclaration":
              case "DeclareExportAllDeclaration":
                return c([ "declare ", I(e, t, i) ]);

              case "InferredPredicate":
                return u("%checks", t);

              case "DeclaredPredicate":
                return c([ "%checks(", e.call(i, "value"), ")" ]);

              case "FunctionTypeAnnotation":
                var he = e.getParentNode(0);
                var pe = !(m.ObjectTypeCallProperty.check(he) || m.DeclareFunction.check(e.getParentNode(2)));
                var fe = pe && !m.FunctionTypeParam.check(he);
                if (fe) {
                    n.push(": ");
                }
                n.push("(", u(", ").join(e.map(i, "params")), ")");
                if (s.returnType) {
                    n.push(pe ? " => " : ": ", e.call(i, "returnType"));
                }
                return c(n);

              case "FunctionTypeParam":
                return c([ e.call(i, "name"), s.optional ? "?" : "", ": ", e.call(i, "typeAnnotation") ]);

              case "GenericTypeAnnotation":
                return c([ e.call(i, "id"), e.call(i, "typeParameters") ]);

              case "DeclareInterface":
                n.push("declare ");

              case "InterfaceDeclaration":
              case "TSInterfaceDeclaration":
                if (s.declare) {
                    n.push("declare ");
                }
                n.push("interface ", e.call(i, "id"), e.call(i, "typeParameters"), " ");
                if (s["extends"] && s["extends"].length > 0) {
                    n.push("extends ", u(", ").join(e.map(i, "extends")), " ");
                }
                if (s.body) {
                    n.push(e.call(i, "body"));
                }
                return c(n);

              case "ClassImplements":
              case "InterfaceExtends":
                return c([ e.call(i, "id"), e.call(i, "typeParameters") ]);

              case "IntersectionTypeAnnotation":
                return u(" & ").join(e.map(i, "types"));

              case "NullableTypeAnnotation":
                return c([ "?", e.call(i, "typeAnnotation") ]);

              case "NullLiteralTypeAnnotation":
                return u("null", t);

              case "ThisTypeAnnotation":
                return u("this", t);

              case "NumberTypeAnnotation":
                return u("number", t);

              case "ObjectTypeCallProperty":
                return e.call(i, "value");

              case "ObjectTypeIndexer":
                return c([ L(e, i), "[", e.call(i, "id"), ": ", e.call(i, "key"), "]: ", e.call(i, "value") ]);

              case "ObjectTypeProperty":
                return c([ L(e, i), e.call(i, "key"), s.optional ? "?" : "", ": ", e.call(i, "value") ]);

              case "QualifiedTypeIdentifier":
                return c([ e.call(i, "qualification"), ".", e.call(i, "id") ]);

              case "StringLiteralTypeAnnotation":
                return u(V(s.value, t), t);

              case "NumberLiteralTypeAnnotation":
              case "NumericLiteralTypeAnnotation":
                a.strictEqual(r(s.value), "number");
                return u(JSON.stringify(s.value), t);

              case "StringTypeAnnotation":
                return u("string", t);

              case "DeclareTypeAlias":
                n.push("declare ");

              case "TypeAlias":
                return c([ "type ", e.call(i, "id"), e.call(i, "typeParameters"), " = ", e.call(i, "right"), ";" ]);

              case "DeclareOpaqueType":
                n.push("declare ");

              case "OpaqueType":
                n.push("opaque type ", e.call(i, "id"), e.call(i, "typeParameters"));
                if (s["supertype"]) {
                    n.push(": ", e.call(i, "supertype"));
                }
                if (s["impltype"]) {
                    n.push(" = ", e.call(i, "impltype"));
                }
                n.push(";");
                return c(n);

              case "TypeCastExpression":
                return c([ "(", e.call(i, "expression"), e.call(i, "typeAnnotation"), ")" ]);

              case "TypeParameterDeclaration":
              case "TypeParameterInstantiation":
                return c([ "<", u(", ").join(e.map(i, "params")), ">" ]);

              case "Variance":
                if (s.kind === "plus") {
                    return u("+");
                }
                if (s.kind === "minus") {
                    return u("-");
                }
                return u("");

              case "TypeParameter":
                if (s.variance) {
                    n.push(L(e, i));
                }
                n.push(e.call(i, "name"));
                if (s.bound) {
                    n.push(e.call(i, "bound"));
                }
                if (s["default"]) {
                    n.push("=", e.call(i, "default"));
                }
                return c(n);

              case "TypeofTypeAnnotation":
                return c([ u("typeof ", t), e.call(i, "argument") ]);

              case "UnionTypeAnnotation":
                return u(" | ").join(e.map(i, "types"));

              case "VoidTypeAnnotation":
                return u("void", t);

              case "NullTypeAnnotation":
                return u("null", t);

              case "TSType":
                throw new Error("unprintable type: " + JSON.stringify(s.type));

              case "TSNumberKeyword":
                return u("number", t);

              case "TSObjectKeyword":
                return u("object", t);

              case "TSBooleanKeyword":
                return u("boolean", t);

              case "TSStringKeyword":
                return u("string", t);

              case "TSSymbolKeyword":
                return u("symbol", t);

              case "TSAnyKeyword":
                return u("any", t);

              case "TSVoidKeyword":
                return u("void", t);

              case "TSThisType":
                return u("this", t);

              case "TSNullKeyword":
                return u("null", t);

              case "TSUndefinedKeyword":
                return u("undefined", t);

              case "TSUnknownKeyword":
                return u("unknown", t);

              case "TSNeverKeyword":
                return u("never", t);

              case "TSArrayType":
                return c([ e.call(i, "elementType"), "[]" ]);

              case "TSLiteralType":
                return e.call(i, "literal");

              case "TSUnionType":
                return u(" | ").join(e.map(i, "types"));

              case "TSIntersectionType":
                return u(" & ").join(e.map(i, "types"));

              case "TSConditionalType":
                n.push(e.call(i, "checkType"), " extends ", e.call(i, "extendsType"), " ? ", e.call(i, "trueType"), " : ", e.call(i, "falseType"));
                return c(n);

              case "TSInferType":
                n.push("infer ", e.call(i, "typeParameter"));
                return c(n);

              case "TSParenthesizedType":
                return c([ "(", e.call(i, "typeAnnotation"), ")" ]);

              case "TSFunctionType":
              case "TSConstructorType":
                return c([ e.call(i, "typeParameters"), "(", F(e, t, i), ")", e.call(i, "typeAnnotation") ]);

              case "TSMappedType":
                {
                    n.push(s.readonly ? "readonly " : "", "[", e.call(i, "typeParameter"), "]", s.optional ? "?" : "");
                    if (s.typeAnnotation) {
                        n.push(": ", e.call(i, "typeAnnotation"), ";");
                    }
                    return c([ "{\n", c(n).indent(t.tabWidth), "\n}" ]);
                }

              case "TSTupleType":
                return c([ "[", u(", ").join(e.map(i, "elementTypes")), "]" ]);

              case "TSRestType":
                return c([ "...", e.call(i, "typeAnnotation"), "[]" ]);

              case "TSOptionalType":
                return c([ e.call(i, "typeAnnotation"), "?" ]);

              case "TSIndexedAccessType":
                return c([ e.call(i, "objectType"), "[", e.call(i, "indexType"), "]" ]);

              case "TSTypeOperator":
                return c([ e.call(i, "operator"), " ", e.call(i, "typeAnnotation") ]);

              case "TSTypeLiteral":
                {
                    var de = u(",\n").join(e.map(i, "members"));
                    if (de.isEmpty()) {
                        return u("{}", t);
                    }
                    n.push("{\n", de.indent(t.tabWidth), "\n}");
                    return c(n);
                }

              case "TSEnumMember":
                n.push(e.call(i, "id"));
                if (s.initializer) {
                    n.push(" = ", e.call(i, "initializer"));
                }
                return c(n);

              case "TSTypeQuery":
                return c([ "typeof ", e.call(i, "exprName") ]);

              case "TSParameterProperty":
                if (s.accessibility) {
                    n.push(s.accessibility, " ");
                }
                if (s.export) {
                    n.push("export ");
                }
                if (s.static) {
                    n.push("static ");
                }
                if (s.readonly) {
                    n.push("readonly ");
                }
                n.push(e.call(i, "parameter"));
                return c(n);

              case "TSTypeReference":
                return c([ e.call(i, "typeName"), e.call(i, "typeParameters") ]);

              case "TSQualifiedName":
                return c([ e.call(i, "left"), ".", e.call(i, "right") ]);

              case "TSAsExpression":
                {
                    var me = s.extra && s.extra.parenthesized === true;
                    n = [];
                    if (me) n.push("(");
                    n.push(e.call(i, "expression"), u(" as "), e.call(i, "typeAnnotation"));
                    if (me) n.push(")");
                    return c(n);
                }

              case "TSNonNullExpression":
                return c([ e.call(i, "expression"), "!" ]);

              case "TSTypeAnnotation":
                {
                    var he = e.getParentNode(0);
                    var ye = ": ";
                    var ve = m.TSFunctionType.check(he);
                    if (m.TSFunctionType.check(he)) {
                        ye = " => ";
                    }
                    if (m.TSTypePredicate.check(he)) {
                        ye = " is ";
                    }
                    return c([ ye, e.call(i, "typeAnnotation") ]);
                }

              case "TSIndexSignature":
                return c([ s.readonly ? "readonly " : "", "[", e.map(i, "parameters"), "]", e.call(i, "typeAnnotation") ]);

              case "TSPropertySignature":
                n.push(L(e, i), s.readonly ? "readonly " : "");
                if (s.computed) {
                    n.push("[", e.call(i, "key"), "]");
                } else {
                    n.push(e.call(i, "key"));
                }
                n.push(s.optional ? "?" : "", e.call(i, "typeAnnotation"));
                return c(n);

              case "TSMethodSignature":
                if (s.computed) {
                    n.push("[", e.call(i, "key"), "]");
                } else {
                    n.push(e.call(i, "key"));
                }
                if (s.optional) {
                    n.push("?");
                }
                n.push(e.call(i, "typeParameters"), "(", F(e, t, i), ")", e.call(i, "typeAnnotation"));
                return c(n);

              case "TSTypePredicate":
                return c([ e.call(i, "parameterName"), e.call(i, "typeAnnotation") ]);

              case "TSCallSignatureDeclaration":
                return c([ e.call(i, "typeParameters"), "(", F(e, t, i), ")", e.call(i, "typeAnnotation") ]);

              case "TSConstructSignatureDeclaration":
                if (s.typeParameters) {
                    n.push("new", e.call(i, "typeParameters"));
                } else {
                    n.push("new ");
                }
                n.push("(", F(e, t, i), ")", e.call(i, "typeAnnotation"));
                return c(n);

              case "TSTypeAliasDeclaration":
                return c([ s.declare ? "declare " : "", "type ", e.call(i, "id"), e.call(i, "typeParameters"), " = ", e.call(i, "typeAnnotation"), ";" ]);

              case "TSTypeParameter":
                n.push(e.call(i, "name"));
                var he = e.getParentNode(0);
                var xe = m.TSMappedType.check(he);
                if (s.constraint) {
                    n.push(xe ? " in " : " extends ", e.call(i, "constraint"));
                }
                if (s["default"]) {
                    n.push(" = ", e.call(i, "default"));
                }
                return c(n);

              case "TSTypeAssertion":
                var me = s.extra && s.extra.parenthesized === true;
                if (me) {
                    n.push("(");
                }
                n.push("<", e.call(i, "typeAnnotation"), "> ", e.call(i, "expression"));
                if (me) {
                    n.push(")");
                }
                return c(n);

              case "TSTypeParameterDeclaration":
              case "TSTypeParameterInstantiation":
                return c([ "<", u(", ").join(e.map(i, "params")), ">" ]);

              case "TSEnumDeclaration":
                n.push(s.declare ? "declare " : "", s.const ? "const " : "", "enum ", e.call(i, "id"));
                var ge = u(",\n").join(e.map(i, "members"));
                if (ge.isEmpty()) {
                    n.push(" {}");
                } else {
                    n.push(" {\n", ge.indent(t.tabWidth), "\n}");
                }
                return c(n);

              case "TSExpressionWithTypeArguments":
                return c([ e.call(i, "expression"), e.call(i, "typeParameters") ]);

              case "TSInterfaceBody":
                var be = u(";\n").join(e.map(i, "body"));
                if (be.isEmpty()) {
                    return u("{}", t);
                }
                return c([ "{\n", be.indent(t.tabWidth), ";", "\n}" ]);

              case "TSImportEqualsDeclaration":
                if (s.isExport) {
                    n.push("export ");
                }
                n.push("import ", e.call(i, "id"), " = ", e.call(i, "moduleReference"));
                return U(c(n));

              case "TSExternalModuleReference":
                return c([ "require(", e.call(i, "expression"), ")" ]);

              case "TSModuleDeclaration":
                {
                    var Ee = e.getParentNode();
                    if (Ee.type === "TSModuleDeclaration") {
                        n.push(".");
                    } else {
                        if (s.declare) {
                            n.push("declare ");
                        }
                        if (!s.global) {
                            var ke = s.id.type === "StringLiteral" || s.id.type === "Literal" && typeof s.id.value === "string";
                            if (ke) {
                                n.push("module ");
                            } else if (s.loc && s.loc.lines && s.id.loc) {
                                var Se = s.loc.lines.sliceString(s.loc.start, s.id.loc.start);
                                if (Se.indexOf("module") >= 0) {
                                    n.push("module ");
                                } else {
                                    n.push("namespace ");
                                }
                            } else {
                                n.push("namespace ");
                            }
                        }
                    }
                    n.push(e.call(i, "id"));
                    if (s.body && s.body.type === "TSModuleDeclaration") {
                        n.push(e.call(i, "body"));
                    } else if (s.body) {
                        var we = e.call(i, "body");
                        if (we.isEmpty()) {
                            n.push(" {}");
                        } else {
                            n.push(" {\n", we.indent(t.tabWidth), "\n}");
                        }
                    }
                    return c(n);
                }

              case "TSModuleBlock":
                return e.call(function(e) {
                    return P(e, t, i);
                }, "body");

              case "ClassHeritage":
              case "ComprehensionBlock":
              case "ComprehensionExpression":
              case "Glob":
              case "GeneratorExpression":
              case "LetStatement":
              case "LetExpression":
              case "GraphExpression":
              case "GraphIndexExpression":
              case "XMLDefaultDeclaration":
              case "XMLAnyName":
              case "XMLQualifiedIdentifier":
              case "XMLFunctionQualifiedIdentifier":
              case "XMLAttributeSelector":
              case "XMLFilterExpression":
              case "XML":
              case "XMLElement":
              case "XMLList":
              case "XMLEscape":
              case "XMLText":
              case "XMLStartTag":
              case "XMLEndTag":
              case "XMLPointTag":
              case "XMLName":
              case "XMLAttribute":
              case "XMLCdata":
              case "XMLComment":
              case "XMLProcessingInstruction":
              default:
                debugger;
                throw new Error("unknown type: " + JSON.stringify(s.type));
            }
            return p;
        }
        function T(e, t) {
            var i = [];
            var r = e.getValue();
            if (r.decorators && r.decorators.length > 0 && !g.getParentExportDeclaration(e)) {
                e.each(function(e) {
                    i.push(t(e), "\n");
                }, "decorators");
            } else if (g.isExportDeclaration(r) && r.declaration && r.declaration.decorators) {
                e.each(function(e) {
                    i.push(t(e), "\n");
                }, "declaration", "decorators");
            }
            return c(i);
        }
        function P(e, t, i) {
            var r = m.ClassBody && m.ClassBody.check(e.getParentNode());
            var s = [];
            var n = false;
            var o = false;
            e.each(function(e) {
                var t = e.getName();
                var r = e.getValue();
                if (!r) {
                    return;
                }
                if (r.type === "EmptyStatement" && !(r.comments && r.comments.length > 0)) {
                    return;
                }
                if (m.Comment.check(r)) {
                    n = true;
                } else if (m.Statement.check(r)) {
                    o = true;
                } else {
                    y.assert(r);
                }
                s.push({
                    node: r,
                    printed: i(e)
                });
            });
            if (n) {
                a.strictEqual(o, false, "Comments may appear as statements in otherwise empty statement " + "lists, but may not coexist with non-Comment nodes.");
            }
            var l = null;
            var u = s.length;
            var h = [];
            s.forEach(function(e, i) {
                var r = e.printed;
                var s = e.node;
                var a = r.length > 1;
                var n = i > 0;
                var o = i < u - 1;
                var c;
                var p;
                var f = s && s.loc && s.loc.lines;
                var d = f && t.reuseWhitespace && g.getTrueLoc(s, f);
                if (n) {
                    if (d) {
                        var m = f.skipSpaces(d.start, true);
                        var y = m ? m.line : 1;
                        var v = d.start.line - y;
                        c = Array(v + 1).join("\n");
                    } else {
                        c = a ? "\n\n" : "\n";
                    }
                } else {
                    c = "";
                }
                if (o) {
                    if (d) {
                        var x = f.skipSpaces(d.end);
                        var b = x ? x.line : f.length;
                        var E = b - d.end.line;
                        p = Array(E + 1).join("\n");
                    } else {
                        p = a ? "\n\n" : "\n";
                    }
                } else {
                    p = "";
                }
                h.push(D(l, c), r);
                if (o) {
                    l = p;
                } else if (p) {
                    h.push(p);
                }
            });
            return c(h);
        }
        function D(e, t) {
            if (!e && !t) {
                return u("");
            }
            if (!e) {
                return u(t);
            }
            if (!t) {
                return u(e);
            }
            var i = u(e);
            var r = u(t);
            if (r.length > i.length) {
                return r;
            }
            return i;
        }
        function _(e, t, i) {
            var r = e.getNode();
            var s = r.kind;
            var a = [];
            var n = r.value;
            if (!m.FunctionExpression.check(n)) {
                n = r;
            }
            var o = r.accessibility || r.access;
            if (typeof o === "string") {
                a.push(o, " ");
            }
            if (r.static) {
                a.push("static ");
            }
            if (r.abstract) {
                a.push("abstract ");
            }
            if (r.readonly) {
                a.push("readonly ");
            }
            if (n.async) {
                a.push("async ");
            }
            if (n.generator) {
                a.push("*");
            }
            if (s === "get" || s === "set") {
                a.push(s, " ");
            }
            var l = e.call(i, "key");
            if (r.computed) {
                l = c([ "[", l, "]" ]);
            }
            a.push(l);
            if (r.optional) {
                a.push("?");
            }
            if (r === n) {
                a.push(e.call(i, "typeParameters"), "(", F(e, t, i), ")", e.call(i, "returnType"));
                if (r.body) {
                    a.push(" ", e.call(i, "body"));
                } else {
                    a.push(";");
                }
            } else {
                a.push(e.call(i, "value", "typeParameters"), "(", e.call(function(e) {
                    return F(e, t, i);
                }, "value"), ")", e.call(i, "value", "returnType"));
                if (n.body) {
                    a.push(" ", e.call(i, "value", "body"));
                } else {
                    a.push(";");
                }
            }
            return c(a);
        }
        function N(e, t, i) {
            var r = e.map(i, "arguments");
            var s = g.isTrailingCommaEnabled(t, "parameters");
            var a = u(", ").join(r);
            if (a.getLineLength(1) > t.wrapColumn) {
                a = u(",\n").join(r);
                return c([ "(\n", a.indent(t.tabWidth), s ? ",\n)" : "\n)" ]);
            }
            return c([ "(", a, ")" ]);
        }
        function F(e, t, i) {
            var r = e.getValue();
            if (r.params) {
                var s = r.params;
                var a = e.map(i, "params");
            } else if (r.parameters) {
                s = r.parameters;
                a = e.map(i, "parameters");
            }
            if (r.defaults) {
                e.each(function(e) {
                    var t = e.getName();
                    var r = a[t];
                    if (r && e.getValue()) {
                        a[t] = c([ r, " = ", i(e) ]);
                    }
                }, "defaults");
            }
            if (r.rest) {
                a.push(c([ "...", e.call(i, "rest") ]));
            }
            var n = u(", ").join(a);
            if (n.length > 1 || n.getLineLength(1) > t.wrapColumn) {
                n = u(",\n").join(a);
                if (g.isTrailingCommaEnabled(t, "parameters") && !r.rest && s[s.length - 1].type !== "RestElement") {
                    n = c([ n, ",\n" ]);
                } else {
                    n = c([ n, "\n" ]);
                }
                return c([ "\n", n.indent(t.tabWidth) ]);
            }
            return n;
        }
        function I(e, t, i) {
            var r = e.getValue();
            var s = [ "export " ];
            if (r.exportKind && r.exportKind !== "value") {
                s.push(r.exportKind + " ");
            }
            var a = t.objectCurlySpacing;
            m.Declaration.assert(r);
            if (r["default"] || r.type === "ExportDefaultDeclaration") {
                s.push("default ");
            }
            if (r.declaration) {
                s.push(e.call(i, "declaration"));
            } else if (r.specifiers) {
                if (r.specifiers.length === 1 && r.specifiers[0].type === "ExportBatchSpecifier") {
                    s.push("*");
                } else if (r.specifiers.length === 0) {
                    s.push("{}");
                } else if (r.specifiers[0].type === "ExportDefaultSpecifier") {
                    var n = [];
                    var o = [];
                    e.each(function(e) {
                        var t = e.getValue();
                        if (t.type === "ExportDefaultSpecifier") {
                            n.push(i(e));
                        } else {
                            o.push(i(e));
                        }
                    }, "specifiers");
                    n.forEach(function(e, t) {
                        if (t > 0) {
                            s.push(", ");
                        }
                        s.push(e);
                    });
                    if (o.length > 0) {
                        var l = u(", ").join(o);
                        if (l.getLineLength(1) > t.wrapColumn) {
                            l = c([ u(",\n").join(o).indent(t.tabWidth), "," ]);
                        }
                        if (n.length > 0) {
                            s.push(", ");
                        }
                        if (l.length > 1) {
                            s.push("{\n", l, "\n}");
                        } else if (t.objectCurlySpacing) {
                            s.push("{ ", l, " }");
                        } else {
                            s.push("{", l, "}");
                        }
                    }
                } else {
                    s.push(a ? "{ " : "{", u(", ").join(e.map(i, "specifiers")), a ? " }" : "}");
                }
                if (r.source) {
                    s.push(" from ", e.call(i, "source"));
                }
            }
            var h = c(s);
            if (M(h) !== ";" && !(r.declaration && (r.declaration.type === "FunctionDeclaration" || r.declaration.type === "ClassDeclaration" || r.declaration.type === "TSModuleDeclaration" || r.declaration.type === "TSInterfaceDeclaration" || r.declaration.type === "TSEnumDeclaration"))) {
                h = c([ h, ";" ]);
            }
            return h;
        }
        function O(e, t) {
            var i = g.getParentExportDeclaration(e);
            if (i) {
                a.strictEqual(i.type, "DeclareExportDeclaration");
            } else {
                t.unshift("declare ");
            }
            return c(t);
        }
        function L(e, t) {
            return e.call(function(e) {
                var i = e.getValue();
                if (i) {
                    if (i === "plus") {
                        return u("+");
                    }
                    if (i === "minus") {
                        return u("-");
                    }
                    return t(e);
                }
                return u("");
            }, "variance");
        }
        function B(e, t) {
            if (e.length > 1) return c([ " ", e ]);
            return c([ "\n", U(e).indent(t.tabWidth) ]);
        }
        function M(e) {
            var t = e.lastPos();
            do {
                var i = e.charAt(t);
                if (/\S/.test(i)) return i;
            } while (e.prevPos(t));
        }
        function j(e) {
            return M(e) === "}";
        }
        function R(e) {
            return e.replace(/['"]/g, function(e) {
                return e === '"' ? "'" : '"';
            });
        }
        function V(e, t) {
            y.assert(e);
            switch (t.quote) {
              case "auto":
                var i = JSON.stringify(e);
                var r = R(JSON.stringify(R(e)));
                return i.length > r.length ? r : i;

              case "single":
                return R(JSON.stringify(R(e)));

              case "double":
              default:
                return JSON.stringify(e);
            }
        }
        function U(e) {
            var t = M(e);
            if (!t || "\n};".indexOf(t) < 0) return c([ e, ";" ]);
            return e;
        }
    }, function(e, t, i) {
        "use strict";
        var r = i(6);
        var s = i(80).parse;
        var a = i(81).Printer;
        function n(e, t) {
            return new a(t).print(e);
        }
        function o(e, t) {
            return new a(t).printGenerically(e);
        }
        function l(e, t) {
            return u(process.argv[2], e, t);
        }
        function u(e, t, r) {
            i(164).readFile(e, "utf-8", function(e, i) {
                if (e) {
                    console.error(e);
                    return;
                }
                h(i, t, r);
            });
        }
        function c(e) {
            process.stdout.write(e);
        }
        function h(e, t, i) {
            var r = i && i.writeback || c;
            t(s(e, i), function(e) {
                r(n(e, i).code);
            });
        }
        Object.defineProperties(t, {
            parse: {
                enumerable: true,
                value: s
            },
            visit: {
                enumerable: true,
                value: r.visit
            },
            print: {
                enumerable: true,
                value: n
            },
            prettyPrint: {
                enumerable: false,
                value: o
            },
            types: {
                enumerable: false,
                value: r
            },
            run: {
                enumerable: false,
                value: l
            }
        });
    }, function(e, t) {
        "use strict";
        var i = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split("");
        t.encode = function(e) {
            if (0 <= e && e < i.length) {
                return i[e];
            }
            throw new TypeError("Must be between 0 and 63: " + e);
        };
        t.decode = function(e) {
            var t = 65;
            var i = 90;
            var r = 97;
            var s = 122;
            var a = 48;
            var n = 57;
            var o = 43;
            var l = 47;
            var u = 26;
            var c = 52;
            if (t <= e && e <= i) {
                return e - t;
            }
            if (r <= e && e <= s) {
                return e - r + u;
            }
            if (a <= e && e <= n) {
                return e - a + c;
            }
            if (e == o) {
                return 62;
            }
            if (e == l) {
                return 63;
            }
            return -1;
        };
    }, function(e, t) {
        "use strict";
        t.GREATEST_LOWER_BOUND = 1;
        t.LEAST_UPPER_BOUND = 2;
        function i(e, r, s, a, n, o) {
            var l = Math.floor((r - e) / 2) + e;
            var u = n(s, a[l], true);
            if (u === 0) {
                return l;
            } else if (u > 0) {
                if (r - l > 1) {
                    return i(l, r, s, a, n, o);
                }
                if (o == t.LEAST_UPPER_BOUND) {
                    return r < a.length ? r : -1;
                } else {
                    return l;
                }
            } else {
                if (l - e > 1) {
                    return i(e, l, s, a, n, o);
                }
                if (o == t.LEAST_UPPER_BOUND) {
                    return l;
                } else {
                    return e < 0 ? -1 : e;
                }
            }
        }
        t.search = function e(r, s, a, n) {
            if (s.length === 0) {
                return -1;
            }
            var o = i(-1, s.length, r, s, a, n || t.GREATEST_LOWER_BOUND);
            if (o < 0) {
                return -1;
            }
            while (o - 1 >= 0) {
                if (a(s[o], s[o - 1], true) !== 0) {
                    break;
                }
                --o;
            }
            return o;
        };
    }, function(e, t, i) {
        "use strict";
        var r = i(14);
        function s(e, t) {
            var i = e.generatedLine;
            var s = t.generatedLine;
            var a = e.generatedColumn;
            var n = t.generatedColumn;
            return s > i || s == i && n >= a || r.compareByGeneratedPositionsInflated(e, t) <= 0;
        }
        function a() {
            this._array = [];
            this._sorted = true;
            this._last = {
                generatedLine: -1,
                generatedColumn: 0
            };
        }
        a.prototype.unsortedForEach = function e(t, i) {
            this._array.forEach(t, i);
        };
        a.prototype.add = function e(t) {
            if (s(this._last, t)) {
                this._last = t;
                this._array.push(t);
            } else {
                this._sorted = false;
                this._array.push(t);
            }
        };
        a.prototype.toArray = function e() {
            if (!this._sorted) {
                this._array.sort(r.compareByGeneratedPositionsInflated);
                this._sorted = true;
            }
            return this._array;
        };
        t.MappingList = a;
    }, function(e, t) {
        "use strict";
        function i(e, t, i) {
            var r = e[t];
            e[t] = e[i];
            e[i] = r;
        }
        function r(e, t) {
            return Math.round(e + Math.random() * (t - e));
        }
        function s(e, t, a, n) {
            if (a < n) {
                var o = r(a, n);
                var l = a - 1;
                i(e, o, n);
                var u = e[n];
                for (var c = a; c < n; c++) {
                    if (t(e[c], u) <= 0) {
                        l += 1;
                        i(e, l, c);
                    }
                }
                i(e, l + 1, c);
                var h = l + 1;
                s(e, t, a, h - 1);
                s(e, t, h + 1, n);
            }
        }
        t.quickSort = function(e, t) {
            s(e, t, 0, e.length - 1);
        };
    }, function(e, t, i) {
        "use strict";
        var r = i(14);
        var s = i(84);
        var a = i(43).ArraySet;
        var n = i(44);
        var o = i(86).quickSort;
        function l(e, t) {
            var i = e;
            if (typeof e === "string") {
                i = r.parseSourceMapInput(e);
            }
            return i.sections != null ? new h(i, t) : new u(i, t);
        }
        l.fromSourceMap = function(e, t) {
            return u.fromSourceMap(e, t);
        };
        l.prototype._version = 3;
        l.prototype.__generatedMappings = null;
        Object.defineProperty(l.prototype, "_generatedMappings", {
            configurable: true,
            enumerable: true,
            get: function e() {
                if (!this.__generatedMappings) {
                    this._parseMappings(this._mappings, this.sourceRoot);
                }
                return this.__generatedMappings;
            }
        });
        l.prototype.__originalMappings = null;
        Object.defineProperty(l.prototype, "_originalMappings", {
            configurable: true,
            enumerable: true,
            get: function e() {
                if (!this.__originalMappings) {
                    this._parseMappings(this._mappings, this.sourceRoot);
                }
                return this.__originalMappings;
            }
        });
        l.prototype._charIsMappingSeparator = function e(t, i) {
            var r = t.charAt(i);
            return r === ";" || r === ",";
        };
        l.prototype._parseMappings = function e(t, i) {
            throw new Error("Subclasses must implement _parseMappings");
        };
        l.GENERATED_ORDER = 1;
        l.ORIGINAL_ORDER = 2;
        l.GREATEST_LOWER_BOUND = 1;
        l.LEAST_UPPER_BOUND = 2;
        l.prototype.eachMapping = function e(t, i, s) {
            var a = i || null;
            var n = s || l.GENERATED_ORDER;
            var o;
            switch (n) {
              case l.GENERATED_ORDER:
                o = this._generatedMappings;
                break;

              case l.ORIGINAL_ORDER:
                o = this._originalMappings;
                break;

              default:
                throw new Error("Unknown order of iteration.");
            }
            var u = this.sourceRoot;
            o.map(function(e) {
                var t = e.source === null ? null : this._sources.at(e.source);
                t = r.computeSourceURL(u, t, this._sourceMapURL);
                return {
                    source: t,
                    generatedLine: e.generatedLine,
                    generatedColumn: e.generatedColumn,
                    originalLine: e.originalLine,
                    originalColumn: e.originalColumn,
                    name: e.name === null ? null : this._names.at(e.name)
                };
            }, this).forEach(t, a);
        };
        l.prototype.allGeneratedPositionsFor = function e(t) {
            var i = r.getArg(t, "line");
            var a = {
                source: r.getArg(t, "source"),
                originalLine: i,
                originalColumn: r.getArg(t, "column", 0)
            };
            a.source = this._findSourceIndex(a.source);
            if (a.source < 0) {
                return [];
            }
            var n = [];
            var o = this._findMapping(a, this._originalMappings, "originalLine", "originalColumn", r.compareByOriginalPositions, s.LEAST_UPPER_BOUND);
            if (o >= 0) {
                var l = this._originalMappings[o];
                if (t.column === undefined) {
                    var u = l.originalLine;
                    while (l && l.originalLine === u) {
                        n.push({
                            line: r.getArg(l, "generatedLine", null),
                            column: r.getArg(l, "generatedColumn", null),
                            lastColumn: r.getArg(l, "lastGeneratedColumn", null)
                        });
                        l = this._originalMappings[++o];
                    }
                } else {
                    var c = l.originalColumn;
                    while (l && l.originalLine === i && l.originalColumn == c) {
                        n.push({
                            line: r.getArg(l, "generatedLine", null),
                            column: r.getArg(l, "generatedColumn", null),
                            lastColumn: r.getArg(l, "lastGeneratedColumn", null)
                        });
                        l = this._originalMappings[++o];
                    }
                }
            }
            return n;
        };
        t.SourceMapConsumer = l;
        function u(e, t) {
            var i = e;
            if (typeof e === "string") {
                i = r.parseSourceMapInput(e);
            }
            var s = r.getArg(i, "version");
            var n = r.getArg(i, "sources");
            var o = r.getArg(i, "names", []);
            var l = r.getArg(i, "sourceRoot", null);
            var u = r.getArg(i, "sourcesContent", null);
            var c = r.getArg(i, "mappings");
            var h = r.getArg(i, "file", null);
            if (s != this._version) {
                throw new Error("Unsupported version: " + s);
            }
            if (l) {
                l = r.normalize(l);
            }
            n = n.map(String).map(r.normalize).map(function(e) {
                return l && r.isAbsolute(l) && r.isAbsolute(e) ? r.relative(l, e) : e;
            });
            this._names = a.fromArray(o.map(String), true);
            this._sources = a.fromArray(n, true);
            this._absoluteSources = this._sources.toArray().map(function(e) {
                return r.computeSourceURL(l, e, t);
            });
            this.sourceRoot = l;
            this.sourcesContent = u;
            this._mappings = c;
            this._sourceMapURL = t;
            this.file = h;
        }
        u.prototype = Object.create(l.prototype);
        u.prototype.consumer = l;
        u.prototype._findSourceIndex = function(e) {
            var t = e;
            if (this.sourceRoot != null) {
                t = r.relative(this.sourceRoot, t);
            }
            if (this._sources.has(t)) {
                return this._sources.indexOf(t);
            }
            var i;
            for (i = 0; i < this._absoluteSources.length; ++i) {
                if (this._absoluteSources[i] == e) {
                    return i;
                }
            }
            return -1;
        };
        u.fromSourceMap = function e(t, i) {
            var s = Object.create(u.prototype);
            var n = s._names = a.fromArray(t._names.toArray(), true);
            var l = s._sources = a.fromArray(t._sources.toArray(), true);
            s.sourceRoot = t._sourceRoot;
            s.sourcesContent = t._generateSourcesContent(s._sources.toArray(), s.sourceRoot);
            s.file = t._file;
            s._sourceMapURL = i;
            s._absoluteSources = s._sources.toArray().map(function(e) {
                return r.computeSourceURL(s.sourceRoot, e, i);
            });
            var h = t._mappings.toArray().slice();
            var p = s.__generatedMappings = [];
            var f = s.__originalMappings = [];
            for (var d = 0, m = h.length; d < m; d++) {
                var y = h[d];
                var v = new c();
                v.generatedLine = y.generatedLine;
                v.generatedColumn = y.generatedColumn;
                if (y.source) {
                    v.source = l.indexOf(y.source);
                    v.originalLine = y.originalLine;
                    v.originalColumn = y.originalColumn;
                    if (y.name) {
                        v.name = n.indexOf(y.name);
                    }
                    f.push(v);
                }
                p.push(v);
            }
            o(s.__originalMappings, r.compareByOriginalPositions);
            return s;
        };
        u.prototype._version = 3;
        Object.defineProperty(u.prototype, "sources", {
            get: function e() {
                return this._absoluteSources.slice();
            }
        });
        function c() {
            this.generatedLine = 0;
            this.generatedColumn = 0;
            this.source = null;
            this.originalLine = null;
            this.originalColumn = null;
            this.name = null;
        }
        u.prototype._parseMappings = function e(t, i) {
            var s = 1;
            var a = 0;
            var l = 0;
            var u = 0;
            var h = 0;
            var p = 0;
            var f = t.length;
            var d = 0;
            var m = {};
            var y = {};
            var v = [];
            var x = [];
            var g, b, E, k, S;
            while (d < f) {
                if (t.charAt(d) === ";") {
                    s++;
                    d++;
                    a = 0;
                } else if (t.charAt(d) === ",") {
                    d++;
                } else {
                    g = new c();
                    g.generatedLine = s;
                    for (k = d; k < f; k++) {
                        if (this._charIsMappingSeparator(t, k)) {
                            break;
                        }
                    }
                    b = t.slice(d, k);
                    E = m[b];
                    if (E) {
                        d += b.length;
                    } else {
                        E = [];
                        while (d < k) {
                            n.decode(t, d, y);
                            S = y.value;
                            d = y.rest;
                            E.push(S);
                        }
                        if (E.length === 2) {
                            throw new Error("Found a source, but no line and column");
                        }
                        if (E.length === 3) {
                            throw new Error("Found a source and line, but no column");
                        }
                        m[b] = E;
                    }
                    g.generatedColumn = a + E[0];
                    a = g.generatedColumn;
                    if (E.length > 1) {
                        g.source = h + E[1];
                        h += E[1];
                        g.originalLine = l + E[2];
                        l = g.originalLine;
                        g.originalLine += 1;
                        g.originalColumn = u + E[3];
                        u = g.originalColumn;
                        if (E.length > 4) {
                            g.name = p + E[4];
                            p += E[4];
                        }
                    }
                    x.push(g);
                    if (typeof g.originalLine === "number") {
                        v.push(g);
                    }
                }
            }
            o(x, r.compareByGeneratedPositionsDeflated);
            this.__generatedMappings = x;
            o(v, r.compareByOriginalPositions);
            this.__originalMappings = v;
        };
        u.prototype._findMapping = function e(t, i, r, a, n, o) {
            if (t[r] <= 0) {
                throw new TypeError("Line must be greater than or equal to 1, got " + t[r]);
            }
            if (t[a] < 0) {
                throw new TypeError("Column must be greater than or equal to 0, got " + t[a]);
            }
            return s.search(t, i, n, o);
        };
        u.prototype.computeColumnSpans = function e() {
            for (var t = 0; t < this._generatedMappings.length; ++t) {
                var i = this._generatedMappings[t];
                if (t + 1 < this._generatedMappings.length) {
                    var r = this._generatedMappings[t + 1];
                    if (i.generatedLine === r.generatedLine) {
                        i.lastGeneratedColumn = r.generatedColumn - 1;
                        continue;
                    }
                }
                i.lastGeneratedColumn = Infinity;
            }
        };
        u.prototype.originalPositionFor = function e(t) {
            var i = {
                generatedLine: r.getArg(t, "line"),
                generatedColumn: r.getArg(t, "column")
            };
            var s = this._findMapping(i, this._generatedMappings, "generatedLine", "generatedColumn", r.compareByGeneratedPositionsDeflated, r.getArg(t, "bias", l.GREATEST_LOWER_BOUND));
            if (s >= 0) {
                var a = this._generatedMappings[s];
                if (a.generatedLine === i.generatedLine) {
                    var n = r.getArg(a, "source", null);
                    if (n !== null) {
                        n = this._sources.at(n);
                        n = r.computeSourceURL(this.sourceRoot, n, this._sourceMapURL);
                    }
                    var o = r.getArg(a, "name", null);
                    if (o !== null) {
                        o = this._names.at(o);
                    }
                    return {
                        source: n,
                        line: r.getArg(a, "originalLine", null),
                        column: r.getArg(a, "originalColumn", null),
                        name: o
                    };
                }
            }
            return {
                source: null,
                line: null,
                column: null,
                name: null
            };
        };
        u.prototype.hasContentsOfAllSources = function e() {
            if (!this.sourcesContent) {
                return false;
            }
            return this.sourcesContent.length >= this._sources.size() && !this.sourcesContent.some(function(e) {
                return e == null;
            });
        };
        u.prototype.sourceContentFor = function e(t, i) {
            if (!this.sourcesContent) {
                return null;
            }
            var s = this._findSourceIndex(t);
            if (s >= 0) {
                return this.sourcesContent[s];
            }
            var a = t;
            if (this.sourceRoot != null) {
                a = r.relative(this.sourceRoot, a);
            }
            var n;
            if (this.sourceRoot != null && (n = r.urlParse(this.sourceRoot))) {
                var o = a.replace(/^file:\/\//, "");
                if (n.scheme == "file" && this._sources.has(o)) {
                    return this.sourcesContent[this._sources.indexOf(o)];
                }
                if ((!n.path || n.path == "/") && this._sources.has("/" + a)) {
                    return this.sourcesContent[this._sources.indexOf("/" + a)];
                }
            }
            if (i) {
                return null;
            } else {
                throw new Error('"' + a + '" is not in the SourceMap.');
            }
        };
        u.prototype.generatedPositionFor = function e(t) {
            var i = r.getArg(t, "source");
            i = this._findSourceIndex(i);
            if (i < 0) {
                return {
                    line: null,
                    column: null,
                    lastColumn: null
                };
            }
            var s = {
                source: i,
                originalLine: r.getArg(t, "line"),
                originalColumn: r.getArg(t, "column")
            };
            var a = this._findMapping(s, this._originalMappings, "originalLine", "originalColumn", r.compareByOriginalPositions, r.getArg(t, "bias", l.GREATEST_LOWER_BOUND));
            if (a >= 0) {
                var n = this._originalMappings[a];
                if (n.source === s.source) {
                    return {
                        line: r.getArg(n, "generatedLine", null),
                        column: r.getArg(n, "generatedColumn", null),
                        lastColumn: r.getArg(n, "lastGeneratedColumn", null)
                    };
                }
            }
            return {
                line: null,
                column: null,
                lastColumn: null
            };
        };
        t.BasicSourceMapConsumer = u;
        function h(e, t) {
            var i = e;
            if (typeof e === "string") {
                i = r.parseSourceMapInput(e);
            }
            var s = r.getArg(i, "version");
            var n = r.getArg(i, "sections");
            if (s != this._version) {
                throw new Error("Unsupported version: " + s);
            }
            this._sources = new a();
            this._names = new a();
            var o = {
                line: -1,
                column: 0
            };
            this._sections = n.map(function(e) {
                if (e.url) {
                    throw new Error("Support for url field in sections not implemented.");
                }
                var i = r.getArg(e, "offset");
                var s = r.getArg(i, "line");
                var a = r.getArg(i, "column");
                if (s < o.line || s === o.line && a < o.column) {
                    throw new Error("Section offsets must be ordered and non-overlapping.");
                }
                o = i;
                return {
                    generatedOffset: {
                        generatedLine: s + 1,
                        generatedColumn: a + 1
                    },
                    consumer: new l(r.getArg(e, "map"), t)
                };
            });
        }
        h.prototype = Object.create(l.prototype);
        h.prototype.constructor = l;
        h.prototype._version = 3;
        Object.defineProperty(h.prototype, "sources", {
            get: function e() {
                var t = [];
                for (var i = 0; i < this._sections.length; i++) {
                    for (var r = 0; r < this._sections[i].consumer.sources.length; r++) {
                        t.push(this._sections[i].consumer.sources[r]);
                    }
                }
                return t;
            }
        });
        h.prototype.originalPositionFor = function e(t) {
            var i = {
                generatedLine: r.getArg(t, "line"),
                generatedColumn: r.getArg(t, "column")
            };
            var a = s.search(i, this._sections, function(e, t) {
                var i = e.generatedLine - t.generatedOffset.generatedLine;
                if (i) {
                    return i;
                }
                return e.generatedColumn - t.generatedOffset.generatedColumn;
            });
            var n = this._sections[a];
            if (!n) {
                return {
                    source: null,
                    line: null,
                    column: null,
                    name: null
                };
            }
            return n.consumer.originalPositionFor({
                line: i.generatedLine - (n.generatedOffset.generatedLine - 1),
                column: i.generatedColumn - (n.generatedOffset.generatedLine === i.generatedLine ? n.generatedOffset.generatedColumn - 1 : 0),
                bias: t.bias
            });
        };
        h.prototype.hasContentsOfAllSources = function e() {
            return this._sections.every(function(e) {
                return e.consumer.hasContentsOfAllSources();
            });
        };
        h.prototype.sourceContentFor = function e(t, i) {
            for (var r = 0; r < this._sections.length; r++) {
                var s = this._sections[r];
                var a = s.consumer.sourceContentFor(t, true);
                if (a) {
                    return a;
                }
            }
            if (i) {
                return null;
            } else {
                throw new Error('"' + t + '" is not in the SourceMap.');
            }
        };
        h.prototype.generatedPositionFor = function e(t) {
            for (var i = 0; i < this._sections.length; i++) {
                var s = this._sections[i];
                if (s.consumer._findSourceIndex(r.getArg(t, "source")) === -1) {
                    continue;
                }
                var a = s.consumer.generatedPositionFor(t);
                if (a) {
                    var n = {
                        line: a.line + (s.generatedOffset.generatedLine - 1),
                        column: a.column + (s.generatedOffset.generatedLine === a.line ? s.generatedOffset.generatedColumn - 1 : 0)
                    };
                    return n;
                }
            }
            return {
                line: null,
                column: null
            };
        };
        h.prototype._parseMappings = function e(t, i) {
            this.__generatedMappings = [];
            this.__originalMappings = [];
            for (var s = 0; s < this._sections.length; s++) {
                var a = this._sections[s];
                var n = a.consumer._generatedMappings;
                for (var l = 0; l < n.length; l++) {
                    var u = n[l];
                    var c = a.consumer._sources.at(u.source);
                    c = r.computeSourceURL(a.consumer.sourceRoot, c, this._sourceMapURL);
                    this._sources.add(c);
                    c = this._sources.indexOf(c);
                    var h = null;
                    if (u.name) {
                        h = a.consumer._names.at(u.name);
                        this._names.add(h);
                        h = this._names.indexOf(h);
                    }
                    var p = {
                        source: c,
                        generatedLine: u.generatedLine + (a.generatedOffset.generatedLine - 1),
                        generatedColumn: u.generatedColumn + (a.generatedOffset.generatedLine === u.generatedLine ? a.generatedOffset.generatedColumn - 1 : 0),
                        originalLine: u.originalLine,
                        originalColumn: u.originalColumn,
                        name: h
                    };
                    this.__generatedMappings.push(p);
                    if (typeof p.originalLine === "number") {
                        this.__originalMappings.push(p);
                    }
                }
            }
            o(this.__generatedMappings, r.compareByGeneratedPositionsDeflated);
            o(this.__originalMappings, r.compareByOriginalPositions);
        };
        t.IndexedSourceMapConsumer = h;
    }, function(e, t, i) {
        "use strict";
        var r = i(45).SourceMapGenerator;
        var s = i(14);
        var a = /(\r?\n)/;
        var n = 10;
        var o = "$$$isSourceNode$$$";
        function l(e, t, i, r, s) {
            this.children = [];
            this.sourceContents = {};
            this.line = e == null ? null : e;
            this.column = t == null ? null : t;
            this.source = i == null ? null : i;
            this.name = s == null ? null : s;
            this[o] = true;
            if (r != null) this.add(r);
        }
        l.fromStringWithSourceMap = function e(t, i, r) {
            var n = new l();
            var o = t.split(a);
            var u = 0;
            var c = function e() {
                var t = r();
                var i = r() || "";
                return t + i;
                function r() {
                    return u < o.length ? o[u++] : undefined;
                }
            };
            var h = 1, p = 0;
            var f = null;
            i.eachMapping(function(e) {
                if (f !== null) {
                    if (h < e.generatedLine) {
                        d(f, c());
                        h++;
                        p = 0;
                    } else {
                        var t = o[u] || "";
                        var i = t.substr(0, e.generatedColumn - p);
                        o[u] = t.substr(e.generatedColumn - p);
                        p = e.generatedColumn;
                        d(f, i);
                        f = e;
                        return;
                    }
                }
                while (h < e.generatedLine) {
                    n.add(c());
                    h++;
                }
                if (p < e.generatedColumn) {
                    var t = o[u] || "";
                    n.add(t.substr(0, e.generatedColumn));
                    o[u] = t.substr(e.generatedColumn);
                    p = e.generatedColumn;
                }
                f = e;
            }, this);
            if (u < o.length) {
                if (f) {
                    d(f, c());
                }
                n.add(o.splice(u).join(""));
            }
            i.sources.forEach(function(e) {
                var t = i.sourceContentFor(e);
                if (t != null) {
                    if (r != null) {
                        e = s.join(r, e);
                    }
                    n.setSourceContent(e, t);
                }
            });
            return n;
            function d(e, t) {
                if (e === null || e.source === undefined) {
                    n.add(t);
                } else {
                    var i = r ? s.join(r, e.source) : e.source;
                    n.add(new l(e.originalLine, e.originalColumn, i, t, e.name));
                }
            }
        };
        l.prototype.add = function e(t) {
            if (Array.isArray(t)) {
                t.forEach(function(e) {
                    this.add(e);
                }, this);
            } else if (t[o] || typeof t === "string") {
                if (t) {
                    this.children.push(t);
                }
            } else {
                throw new TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + t);
            }
            return this;
        };
        l.prototype.prepend = function e(t) {
            if (Array.isArray(t)) {
                for (var i = t.length - 1; i >= 0; i--) {
                    this.prepend(t[i]);
                }
            } else if (t[o] || typeof t === "string") {
                this.children.unshift(t);
            } else {
                throw new TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + t);
            }
            return this;
        };
        l.prototype.walk = function e(t) {
            var i;
            for (var r = 0, s = this.children.length; r < s; r++) {
                i = this.children[r];
                if (i[o]) {
                    i.walk(t);
                } else {
                    if (i !== "") {
                        t(i, {
                            source: this.source,
                            line: this.line,
                            column: this.column,
                            name: this.name
                        });
                    }
                }
            }
        };
        l.prototype.join = function e(t) {
            var i;
            var r;
            var s = this.children.length;
            if (s > 0) {
                i = [];
                for (r = 0; r < s - 1; r++) {
                    i.push(this.children[r]);
                    i.push(t);
                }
                i.push(this.children[r]);
                this.children = i;
            }
            return this;
        };
        l.prototype.replaceRight = function e(t, i) {
            var r = this.children[this.children.length - 1];
            if (r[o]) {
                r.replaceRight(t, i);
            } else if (typeof r === "string") {
                this.children[this.children.length - 1] = r.replace(t, i);
            } else {
                this.children.push("".replace(t, i));
            }
            return this;
        };
        l.prototype.setSourceContent = function e(t, i) {
            this.sourceContents[s.toSetString(t)] = i;
        };
        l.prototype.walkSourceContents = function e(t) {
            for (var i = 0, r = this.children.length; i < r; i++) {
                if (this.children[i][o]) {
                    this.children[i].walkSourceContents(t);
                }
            }
            var a = Object.keys(this.sourceContents);
            for (var i = 0, r = a.length; i < r; i++) {
                t(s.fromSetString(a[i]), this.sourceContents[a[i]]);
            }
        };
        l.prototype.toString = function e() {
            var t = "";
            this.walk(function(e) {
                t += e;
            });
            return t;
        };
        l.prototype.toStringWithSourceMap = function e(t) {
            var i = {
                code: "",
                line: 1,
                column: 0
            };
            var s = new r(t);
            var a = false;
            var o = null;
            var l = null;
            var u = null;
            var c = null;
            this.walk(function(e, t) {
                i.code += e;
                if (t.source !== null && t.line !== null && t.column !== null) {
                    if (o !== t.source || l !== t.line || u !== t.column || c !== t.name) {
                        s.addMapping({
                            source: t.source,
                            original: {
                                line: t.line,
                                column: t.column
                            },
                            generated: {
                                line: i.line,
                                column: i.column
                            },
                            name: t.name
                        });
                    }
                    o = t.source;
                    l = t.line;
                    u = t.column;
                    c = t.name;
                    a = true;
                } else if (a) {
                    s.addMapping({
                        generated: {
                            line: i.line,
                            column: i.column
                        }
                    });
                    o = null;
                    a = false;
                }
                for (var r = 0, h = e.length; r < h; r++) {
                    if (e.charCodeAt(r) === n) {
                        i.line++;
                        i.column = 0;
                        if (r + 1 === h) {
                            o = null;
                            a = false;
                        } else if (a) {
                            s.addMapping({
                                source: t.source,
                                original: {
                                    line: t.line,
                                    column: t.column
                                },
                                generated: {
                                    line: i.line,
                                    column: i.column
                                },
                                name: t.name
                            });
                        }
                    } else {
                        i.column++;
                    }
                }
            });
            this.walkSourceContents(function(e, t) {
                s.setSourceContent(e, t);
            });
            return {
                code: i.code,
                map: s
            };
        };
        t.SourceNode = l;
    }, function(e, t, i) {
        "use strict";
        var r = i(8).getOption;
        t.parse = function(e, t) {
            var s = [];
            var a = i(38).parse(e, {
                loc: true,
                locations: true,
                comment: true,
                onComment: s,
                range: r(t, "range", false),
                tolerant: r(t, "tolerant", true),
                tokens: true
            });
            if (!Array.isArray(a.comments)) {
                a.comments = s;
            }
            return a;
        };
    }, function(e, t) {
        "use strict";
        e.exports = function(e) {
            if (!e.webpackPolyfill) {
                e.deprecate = function() {};
                e.paths = [];
                e.children = [];
                e.webpackPolyfill = 1;
            }
            return e;
        };
    }, , , , , , , , , , , , , , , , function(e, t, i) {
        "use strict";
        var r = i(82);
        var s = i(58);
        var a = i(57);
        var n = r.types.builders;
        var o = "JSXElement";
        var l = "JSXText";
        var u = "JSXExpressionContainer";
        var c = [ "body", "expression", "right", "declarations", "init" ];
        var h = function e(t, i, r) {
            if (!t) return;
            if (i(t)) {
                return r(t);
            }
            if (Array.isArray(t)) {
                t.forEach(function(s, a) {
                    var n = e(s, i, r);
                    n && (t[a] = n);
                });
                return;
            }
            c.forEach(function(s) {
                var a = e(t[s], i, r);
                a && (t[s] = a);
            });
            e(t.arguments, i, r);
        };
        var p = function e(t) {
            var i = t.openingElement.attributes.map(function(e) {
                var t = n.property("init", e.name, e.value.type === u ? e.value.expression : e.value);
                return t;
            });
            var r = t.openingElement.name.name;
            if (t.children) {
                var s = t.children.filter(function(e) {
                    return e.type === o;
                });
                if (s.length) {
                    i.push(n.property("init", n.identifier("children"), n.arrayExpression(s.map(e))));
                }
                var a = t.children.filter(function(e) {
                    return e.type === l && e.extra.raw && String.prototype.trim.call(e.extra.raw);
                });
                if (a.length) {
                    i.push(n.property("init", n.identifier("text"), n.literal(a.map(function(e) {
                        return String.prototype.trim.call(e.extra.raw);
                    }).join("\n"))));
                }
            }
            var c = n.objectExpression(i);
            var h = n.newExpression(n.identifier(r), [ n.identifier("Easycanvas.sprite"), c ]);
            return h;
        };
        var f = function e(t) {
            var i = a.parse(t, {
                sourceType: "module",
                plugins: [ "jsx", "typescript", "dynamicImport" ]
            }).program;
            var s = false;
            h(i, function(e) {
                return e.type === o && (s = true);
            }, p);
            return s ? r.print(i).code : t;
        };
        var d = function e(t, i) {
            var r = f(t);
            this.callback(null, r, i);
        };
        var m = typeof window !== "undefined";
        if (m) {
            window.EasycanvasJSXTransformer = f;
        }
        e.exports = d;
    }, , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , function(e, t) {} ]);
});

