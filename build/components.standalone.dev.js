(function(e, a) { for(var i in a) e[i] = a[i]; }(window, /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/components.js":
/*!***************************!*\
  !*** ./src/components.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _Button = _interopRequireDefault(__webpack_require__(/*! ./components/Button.js */ \"./src/components/Button.js\"));\n\nvar _Image = _interopRequireDefault(__webpack_require__(/*! ./components/Image.js */ \"./src/components/Image.js\"));\n\nvar _Scroll = _interopRequireDefault(__webpack_require__(/*! ./components/Scroll.js */ \"./src/components/Scroll.js\"));\n\nvar _Sequence = _interopRequireDefault(__webpack_require__(/*! ./components/Sequence.js */ \"./src/components/Sequence.js\"));\n\nvar _Text = _interopRequireDefault(__webpack_require__(/*! ./components/Text.js */ \"./src/components/Text.js\"));\n\nvar _View = _interopRequireDefault(__webpack_require__(/*! ./components/View.js */ \"./src/components/View.js\"));\n\nvar _Input = _interopRequireDefault(__webpack_require__(/*! ./components/Input.js */ \"./src/components/Input.js\"));\n\nvar _RichText = _interopRequireDefault(__webpack_require__(/*! ./components/RichText */ \"./src/components/RichText.js\"));\n\nvar _Draggable = _interopRequireDefault(__webpack_require__(/*! ./components/Draggable.js */ \"./src/components/Draggable.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\n//# sourceURL=webpack:///./src/components.js?");

/***/ }),

/***/ "./src/components/Button.js":
/*!**********************************!*\
  !*** ./src/components/Button.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _text2image = _interopRequireDefault(__webpack_require__(/*! ./_text2image.js */ \"./src/components/_text2image.js\"));\n\nvar _browserRegister = _interopRequireDefault(__webpack_require__(/*! ./_browserRegister.js */ \"./src/components/_browserRegister.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\n/** ********** *\n *\n * Button\n * - TODO: Toggle state.\n *\n * ********** **/\nvar defaultStyle = {\n  padding: 0,\n  width: 300,\n  family: '\"Helvetica Neue\",Helvetica,Arial,sans-serif'\n};\n\nvar setStyle = function setStyle(buttonStyle, config) {\n  buttonStyle.buttonStyleNormal = Object.assign(defaultStyle, {\n    minWidth: config.style.width,\n    lineHeight: config.style.height,\n    padding: 0\n  }, config.props.normal);\n  buttonStyle.buttonStyleHovered = Object.assign({}, buttonStyle.buttonStyleNormal, config.props.hovered);\n  buttonStyle.buttonStylePressed = Object.assign({}, buttonStyle.buttonStyleNormal, config.props.pressed); // const buttonStyleToggled = Object.assign({}, buttonStyleNormal, opt.props.toggled);\n\n  buttonStyle.imageNormal = (0, _text2image[\"default\"])(config.props.text || '', buttonStyle.buttonStyleNormal);\n  buttonStyle.imageHovered = config.props.hovered && (0, _text2image[\"default\"])(config.props.text || '', buttonStyle.buttonStyleHovered);\n  buttonStyle.imagePressed = config.props.pressed && (0, _text2image[\"default\"])(config.props.text || '', buttonStyle.buttonStylePressed); // const imageToggled = text2image(opt.props.text || '', buttonStyleToggled);\n};\n\nvar component = function component(opt, Easycanvas) {\n  var $sprite;\n  var option = opt || {};\n  opt.props = opt.props || {};\n  var buttonStyle = {\n    buttonStyleNormal: undefined,\n    buttonStyleHovered: undefined,\n    buttonStylePressed: undefined,\n    imageNormal: undefined,\n    imageHovered: undefined,\n    imagePressed: undefined\n  };\n  setStyle(buttonStyle, opt);\n  var events = {};\n  opt.events = opt.events || {};\n\n  events.touchmove = events.mousemove = function () {\n    $sprite.content.img = buttonStyle.imageHovered || buttonStyle.imageNormal;\n  };\n\n  events.touchstart = events.mousedown = function () {\n    $sprite.content.img = buttonStyle.imagePressed || buttonStyle.imageHovered || buttonStyle.imageNormal;\n  };\n\n  events.touchend = events.touchout = events.mouseout = function () {\n    $sprite.content.img = buttonStyle.imageNormal;\n  };\n\n  events.mouseup = function () {\n    $sprite.content.img = buttonStyle.imageHovered || buttonStyle.imageNormal;\n  };\n\n  events.click = function (e) {\n    opt.events.click && opt.events.click.call($sprite, e);\n  };\n\n  $sprite = new Easycanvas.Sprite({\n    name: opt.name || 'Button_' + opt.props.text,\n    content: {\n      img: buttonStyle.imageNormal\n    },\n    style: opt.style,\n    props: opt.props,\n    events: events,\n    hooks: opt.hooks\n  }); // $sprite.on('ticked', () => {\n  //     if (ec.utils.funcOrValue($sprite.props.toggled, $sprite)) {\n  //         $sprite.content.img = imageToggled;\n  //     } else {\n  //         $sprite.content.img = imageNormal;\n  //     }\n  // });\n\n  $sprite.update = function (obj) {\n    this.__proto__.update.call(this, obj);\n\n    setStyle(buttonStyle, opt);\n    $sprite.content.img = buttonStyle.imageNormal;\n  };\n\n  return $sprite;\n};\n\n(0, _browserRegister[\"default\"])(component, 'Button');\nvar _default = component;\nexports[\"default\"] = _default;\n\n//# sourceURL=webpack:///./src/components/Button.js?");

/***/ }),

/***/ "./src/components/Draggable.js":
/*!*************************************!*\
  !*** ./src/components/Draggable.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _browserRegister = _interopRequireDefault(__webpack_require__(/*! ./_browserRegister.js */ \"./src/components/_browserRegister.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\n/** ********** *\n *\n * Draggable\n *\n * ********** **/\nvar startPos = {\n  left: 0,\n  top: 0\n};\nvar spritePos = {\n  left: 0,\n  top: 0\n};\n\nvar mousemove = function mousemove($sprite, event) {\n  if ($sprite.onDragStep) {\n    $sprite.onDragStep({\n      left: spritePos.left + event.canvasX - startPos.left,\n      top: spritePos.top + event.canvasY - startPos.top\n    });\n  } else {\n    $sprite.style.left = spritePos.left + event.canvasX - startPos.left;\n    $sprite.style.top = spritePos.top + event.canvasY - startPos.top;\n  }\n};\n\nvar component = function component(opt, Easycanvas) {\n  var $sprite;\n  opt.name = opt.name || 'Draggable';\n  $sprite = new Easycanvas.Sprite(opt);\n  $sprite.addEventListener('mousedown', function (event) {\n    startPos.left = event.canvasX;\n    startPos.top = event.canvasY;\n    spritePos.left = $sprite.getSelfStyle('left');\n    spritePos.top = $sprite.getSelfStyle('top');\n\n    var interceptor = function interceptor(e) {\n      if (e.type === 'mousemove') {\n        mousemove($sprite, e);\n      } else if (e.type === 'mouseup') {\n        $sprite.$canvas.removeEventListener('interceptor', interceptor);\n        $sprite.onDragEnd && $sprite.onDragEnd({\n          left: spritePos.left + e.canvasX - startPos.left,\n          top: spritePos.top + e.canvasY - startPos.top\n        });\n      }\n    };\n\n    $sprite.$canvas.addEventListener('interceptor', interceptor);\n  });\n  $sprite.addEventListener('touchstart', function (event) {\n    startPos.left = event.canvasX;\n    startPos.top = event.canvasY;\n    spritePos.left = $sprite.getSelfStyle('left');\n    spritePos.top = $sprite.getSelfStyle('top');\n\n    var interceptor = function interceptor(e) {\n      if (e.type === 'touchmove') {\n        mousemove($sprite, e);\n      } else if (e.type === 'touchend') {\n        $sprite.$canvas.removeEventListener('interceptor', interceptor);\n      }\n    };\n\n    $sprite.$canvas.addEventListener('interceptor', interceptor);\n  });\n  return $sprite;\n};\n\n(0, _browserRegister[\"default\"])(component, 'Draggable');\nvar _default = component;\nexports[\"default\"] = _default;\n\n//# sourceURL=webpack:///./src/components/Draggable.js?");

/***/ }),

/***/ "./src/components/Image.js":
/*!*********************************!*\
  !*** ./src/components/Image.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _browserRegister = _interopRequireDefault(__webpack_require__(/*! ./_browserRegister.js */ \"./src/components/_browserRegister.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\n/** ********** *\n *\n * Image\n *\n * ********** **/\nvar component = function component(opt, Easycanvas) {\n  var $sprite;\n  var option = opt || {};\n  option.name = option.name || 'Image';\n  $sprite = new Easycanvas.Sprite(option);\n  $sprite.content.img = option.src;\n  Object.defineProperty($sprite, 'src', {\n    get: function get() {\n      return $sprite.content.img ? $sprite.content.img.src : '';\n    },\n    set: function set(value) {\n      $sprite.content.img = value;\n    }\n  }); // $sprite.update = function (obj) {\n  //     this.__proto__.update.call(this, obj);\n  // };\n\n  return $sprite;\n};\n\n(0, _browserRegister[\"default\"])(component, 'Image');\nvar _default = component;\nexports[\"default\"] = _default;\n\n//# sourceURL=webpack:///./src/components/Image.js?");

/***/ }),

/***/ "./src/components/Input.js":
/*!*********************************!*\
  !*** ./src/components/Input.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _browserRegister = _interopRequireDefault(__webpack_require__(/*! ./_browserRegister.js */ \"./src/components/_browserRegister.js\"));\n\nvar _CanvasInput = _interopRequireDefault(__webpack_require__(/*! ./_CanvasInput.js */ \"./src/components/_CanvasInput.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n// hack掉CanvasInput的mousePos计算\n_CanvasInput[\"default\"].prototype._mousePos = function (event) {\n  return {\n    x: event.x,\n    y: event.y\n  };\n};\n\nvar component = function component(opt, Easycanvas) {\n  var $sprite;\n  var option = opt || {};\n  option.name = option.name || 'Input';\n\n  var canvasInputOption = _objectSpread({\n    canvas: document.createElement('canvas')\n  }, option, {}, option.style, {\n    fontColor: option.style.color // borderWidth: 0,\n\n  }); // CanvasInput接收的宽高只是可写区域的宽高，这里定义的宽高是整体的宽高，进行修正\n  // 减去\n\n\n  option.style.width = option.style.width - (option.style.borderWidth || 0) * 2 - (option.style.padding || 0) * 2;\n  option.style.height = option.style.height - (option.style.borderWidth || 0) * 2 - (option.style.padding || 0) * 2;\n  var $canvasInput = new _CanvasInput[\"default\"](canvasInputOption); // console.log($canvasInput._renderCanvas);\n\n  option.style.borderWidth = 0;\n  option.style.borderColor = undefined;\n  option.style.width = option.style.height = undefined;\n  $sprite = new Easycanvas.Sprite(option);\n  $sprite.$canvasInput = $canvasInput; // $sprite.content.img = $canvasInput._canvas;\n\n  $sprite.content.img = $canvasInput._renderCanvas;\n  $sprite.addEventListener('interceptor', function (e) {\n    e.stopPropagation();\n    var event = {\n      type: e.type,\n      x: e.canvasX - $sprite.getStyle('left'),\n      y: e.canvasY - $sprite.getStyle('top')\n    };\n    $canvasInput[e.type] && $canvasInput[e.type](event, $canvasInput);\n\n    if (e.type === 'click') {\n      var interceptor = function interceptor(e) {\n        if (e.type === 'click') {\n          $sprite.$canvas.removeEventListener('interceptor', interceptor);\n        }\n      };\n\n      $sprite.$canvas.addEventListener('interceptor', interceptor);\n    }\n  });\n  return $sprite;\n};\n\n(0, _browserRegister[\"default\"])(component, 'Input');\nvar _default = component;\nexports[\"default\"] = _default;\n\n//# sourceURL=webpack:///./src/components/Input.js?");

/***/ }),

/***/ "./src/components/RichText.js":
/*!************************************!*\
  !*** ./src/components/RichText.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _browserRegister = _interopRequireDefault(__webpack_require__(/*! ./_browserRegister.js */ \"./src/components/_browserRegister.js\"));\n\nvar _text2image = _interopRequireDefault(__webpack_require__(/*! ./_text2image.js */ \"./src/components/_text2image.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\n/** ********** *\n *\n * RichText\n * - Actually it is a image.\n *\n * ********** **/\nvar defaultStyle = {\n  padding: 0,\n  width: 300,\n  lineHeight: 100,\n  family: '\"Helvetica Neue\",Helvetica,Arial,sans-serif'\n};\n\nvar setImage = function setImage($sprite) {\n  $sprite.content.img = $sprite.text ? (0, _text2image[\"default\"])($sprite.text, Object.assign({}, defaultStyle, {\n    lineHeight: $sprite.style.fontSize,\n    textAlign: 'left'\n  }, $sprite.style)) : undefined;\n};\n\nvar component = function component(opt, Easycanvas) {\n  var $sprite;\n  opt.name = opt.name || 'Text';\n  $sprite = new Easycanvas.Sprite(opt); // $sprite.content.text = opt.text;\n\n  setImage($sprite);\n  Object.defineProperty($sprite, 'text', {\n    get: function get() {\n      return $sprite.content.text;\n    },\n    set: function set(value) {\n      $sprite.content.img = text;\n    }\n  });\n\n  $sprite.update = function (obj) {\n    this.__proto__.update.call(this, obj);\n\n    setImage(this);\n  };\n\n  return $sprite;\n};\n\n(0, _browserRegister[\"default\"])(component, 'RichText');\nvar _default = component;\nexports[\"default\"] = _default;\n\n//# sourceURL=webpack:///./src/components/RichText.js?");

/***/ }),

/***/ "./src/components/Scroll.js":
/*!**********************************!*\
  !*** ./src/components/Scroll.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _browserRegister = _interopRequireDefault(__webpack_require__(/*! ./_browserRegister.js */ \"./src/components/_browserRegister.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\n/** ********** *\n *\n * scroll\n * - Event listeners\n *\n * ********** **/\nvar funcOrValue;\nvar transition;\nvar mutipleScrollLock; // $sprite.$scroll.$wheeling用于在Chrome移动端下适配双指滑动的wheel事件\n\nvar absMin = function absMin(a, b) {\n  return Math.abs(a) < Math.abs(b) ? a : b;\n};\n\nvar scrollFuncs = {\n  loose: function loose($sprite) {\n    $sprite.$scroll.touching = false;\n  },\n  looper: function looper($sprite) {\n    if (!$sprite.$scroll || !$sprite.$scroll.$scrolling) return;\n\n    if (Math.abs($sprite.$scroll.speedX) > 1) {\n      $sprite.$scroll.speedX *= $sprite.scroll.smooth || 0.8;\n    } else {\n      $sprite.$scroll.speedX = 0;\n    }\n\n    if (Math.abs($sprite.$scroll.speedY) > 1) {\n      $sprite.$scroll.speedY *= $sprite.scroll.smooth || 0.8;\n    } else {\n      $sprite.$scroll.speedY = 0;\n    }\n\n    if (Math.abs($sprite.$scroll.speedX) <= 1 && Math.abs($sprite.$scroll.speedY) <= 1) {\n      $sprite.$scroll.$scrolling = false;\n      $sprite.$scroll.$wheeling = false;\n      return;\n    }\n\n    if ($sprite.$scroll.touching) {\n      // 已经有100毫秒没有touchmove事件了，认为停止移动，清空速度\n      // $sprite.$scroll.speedX *= 0.8;\n      // $sprite.$scroll.speedY *= 0.8;\n      return;\n    }\n\n    $sprite.scroll.scrollY -= $sprite.$scroll.speedY;\n    $sprite.scroll.scrollX -= $sprite.$scroll.speedX;\n\n    if (!$sprite.$scroll.touching && !$sprite.$scroll.$wheeling && Math.abs($sprite.$scroll.speedY) < 50 && $sprite.scroll.anchors && $sprite.scroll.anchors.length) {\n      var range = $sprite.scroll.anchorsRange || 400;\n\n      for (var i = 0; i < $sprite.scroll.anchors.length; i++) {\n        var m = $sprite.scroll.anchors[i];\n        var delta = $sprite.scroll.scrollY - m;\n\n        if (delta > 0 && delta < range && $sprite.$scroll.speedY > 0 || delta < 0 && delta > -range && $sprite.$scroll.speedY < 0) {\n          $sprite.trigger('scrollTo', m, 200);\n          $sprite.$scroll.speedY = 0;\n          break;\n        }\n      }\n    }\n\n    var minScrollX = funcOrValue($sprite.scroll.minScrollX, $sprite);\n    var maxScrollX = funcOrValue($sprite.scroll.maxScrollX, $sprite);\n    var minScrollY = funcOrValue($sprite.scroll.minScrollY, $sprite);\n    var maxScrollY = funcOrValue($sprite.scroll.maxScrollY, $sprite);\n\n    if (!isNaN(minScrollY) && $sprite.scroll.scrollY < minScrollY) {\n      $sprite.scroll.scrollY = minScrollY;\n    } else if (!isNaN(maxScrollY) && $sprite.scroll.scrollY > maxScrollY) {\n      $sprite.scroll.scrollY = maxScrollY;\n      $sprite.trigger('reachBottom');\n      $sprite.$scroll.speedY = 0;\n    }\n\n    if (!isNaN(minScrollX) && $sprite.scroll.scrollX < minScrollX) {\n      $sprite.scroll.scrollX = minScrollX;\n    } else if (!isNaN(maxScrollX) && $sprite.scroll.scrollX > maxScrollX) {\n      $sprite.scroll.scrollX = maxScrollX;\n    }\n  },\n  touch: function touch($sprite, $e) {\n    var now = Date.now();\n    $sprite.$scroll.$wheeling = false;\n\n    if (!$sprite.$scroll.touching) {\n      // start scroll\n      $sprite.$scroll.touching = now;\n      $sprite.$scroll.quickTouch = now;\n      $sprite.$scroll.lastTouchSpeed = 0;\n      $sprite.$scroll.startPos.x = $e.canvasX;\n      $sprite.$scroll.startPos.y = $e.canvasY;\n      $sprite.$scroll.lastScrollSpeed = $sprite.$scroll.speedX || $sprite.$scroll.speedY;\n      $sprite.$scroll.speedX = 0;\n      $sprite.$scroll.speedY = 0;\n    } else {\n      $sprite.$scroll.$scrolling = true;\n      var deltaX = $sprite.$scroll.startPos.x - $e.canvasX;\n      var deltaY = $sprite.$scroll.startPos.y - $e.canvasY;\n      var deltaTime = now - $sprite.$scroll.touching;\n      $sprite.$scroll.touching = now;\n      var minScrollX = funcOrValue($sprite.scroll.minScrollX, $sprite);\n      var maxScrollX = funcOrValue($sprite.scroll.maxScrollX, $sprite);\n      var minScrollY = funcOrValue($sprite.scroll.minScrollY, $sprite);\n      var maxScrollY = funcOrValue($sprite.scroll.maxScrollY, $sprite);\n\n      if ($sprite.scroll.scrollX + deltaX < minScrollX || $sprite.scroll.scrollX + deltaX > maxScrollX) {\n        if ($sprite.scroll.flexible || $sprite.scroll.flexibleX) deltaX >>= 3;else deltaX = 0;\n      }\n\n      if ($sprite.scroll.scrollY + deltaY < minScrollY || $sprite.scroll.scrollY + deltaY > maxScrollY) {\n        if ($sprite.scroll.flexible || $sprite.scroll.flexibleY) deltaY >>= 3;else deltaY = 0;\n      }\n\n      if (funcOrValue($sprite.scroll.scrollableX, $sprite) && Math.abs(deltaX) >= 1 && deltaTime > 1) {\n        var newSpeedX = ($e.canvasX - $sprite.$scroll.startPos.x) / deltaTime * 25;\n\n        if ($sprite.$scroll.lastScrollSpeed * newSpeedX > 0 && Math.abs(newSpeedX) > 15) {\n          // 连续同向滚动，速度增加\n          newSpeedX += absMin(newSpeedX, $sprite.$scroll.lastScrollSpeed);\n        }\n\n        $sprite.$scroll.speedX = ($sprite.$scroll.lastTouchSpeed + newSpeedX) / ($sprite.$scroll.lastTouchSpeed ? 2 : 1);\n        $sprite.$scroll.lastTouchSpeed = newSpeedX;\n        $sprite.scroll.scrollX += deltaX;\n      }\n\n      if (funcOrValue($sprite.scroll.scrollableY, $sprite) && Math.abs(deltaY) >= 1 && deltaTime > 1) {\n        var newSpeedY = ($e.canvasY - $sprite.$scroll.startPos.y) / deltaTime * 25;\n\n        if ($sprite.$scroll.lastScrollSpeed * newSpeedY > 0 && Math.abs(newSpeedY) > 15) {\n          // 连续同向滚动，速度增加\n          newSpeedY += absMin(newSpeedY, $sprite.$scroll.lastScrollSpeed);\n        }\n\n        $sprite.$scroll.speedY = ($sprite.$scroll.lastTouchSpeed + newSpeedY) / ($sprite.$scroll.lastTouchSpeed ? 2 : 1);\n        $sprite.$scroll.lastTouchSpeed = newSpeedY;\n        $sprite.scroll.scrollY += deltaY;\n      } // $sprite.$scroll.speedX = ($sprite.$scroll.speedX + ($e.canvasX - startPos.x) * 2) / 2;\n      // let curSpeed = ($e.canvasY - startPos.y) * 3;\n      // $sprite.$scroll.speedY = ($sprite.$scroll.speedY + curSpeed) / 2;\n\n\n      $sprite.$scroll.startPos.x = $e.canvasX;\n      $sprite.$scroll.startPos.y = $e.canvasY; // $e.event.preventDefault();\n\n      if (Math.abs(deltaX) > Math.abs(deltaY) + 1) return 1;else if (Math.abs(deltaX) < Math.abs(deltaY) - 1) return 2;\n    }\n  },\n  wheel: function wheel($sprite, $e) {\n    $sprite.$scroll.speedX = funcOrValue($sprite.scroll.scrollableX, $sprite) ? $e.event.wheelDeltaX : 0;\n    $sprite.$scroll.speedY = funcOrValue($sprite.scroll.scrollableY, $sprite) ? $e.event.wheelDeltaY : 0;\n    $sprite.$scroll.$scrolling = true;\n    $sprite.$scroll.$wheeling = true; // $e.event.preventDefault();\n\n    $e.stopPropagation();\n  }\n};\n\nvar component = function component(opt, Easycanvas) {\n  funcOrValue = Easycanvas.utils.funcOrValue;\n  transition = Easycanvas.Transition;\n  var autoScrollX = false;\n  var autoScrollY = false;\n  var option = opt || {};\n  option.scroll = Object.assign({\n    scrollX: 0,\n    scrollY: 0,\n    scrollableX: function scrollableX() {\n      return (this.style.overflowX || this.style.overflow) !== 'visible';\n    },\n    scrollableY: function scrollableY() {\n      return (this.style.overflowY || this.style.overflow) !== 'visible';\n    },\n    minScrollX: 0,\n    maxScrollX: function maxScrollX() {\n      var _this = this;\n\n      var max = 0;\n      this.getChildren().forEach(function (child) {\n        var currentMax = child.getSelfStyle('left') + child.getSelfStyle('width') - _this.getStyle('width');\n\n        if (currentMax > max) max = currentMax;\n      });\n      return max;\n    },\n    minScrollY: 0,\n    maxScrollY: function maxScrollY() {\n      var _this2 = this;\n\n      var max = 0;\n      this.getChildren().forEach(function (child) {\n        var currentMax = child.getSelfStyle('top') + child.getSelfStyle('height') - _this2.getStyle('height');\n\n        if (currentMax > max) max = currentMax;\n      });\n      return max;\n    },\n    propagationX: false,\n    propagationY: false\n  }, opt.scroll);\n\n  var autoScrollFunc = function autoScrollFunc() {\n    if (autoScrollX) {\n      $sprite.scroll.scrollX = autoScrollX();\n    }\n\n    if (autoScrollY) {\n      $sprite.scroll.scrollY = autoScrollY();\n    }\n\n    if (!autoScrollX && !autoScrollY) {\n      $sprite.off('ticked', autoScrollFunc);\n    }\n  }; // let handling = true;\n  // const handleToggle = () => {\n  //     handling = !handling;\n  // };\n\n\n  var started = false;\n  option.events = Object.assign({\n    touchstart: function touchstart($e) {\n      // 先结束，防止之前拖动时拖到外面，导致没触发loose\n      scrollFuncs.loose(this);\n      started = true;\n      mutipleScrollLock = false;\n      scrollFuncs.touch(this, $e); // scroll外面还有一个scroll的时候，让事件传递出去\n\n      if (!$sprite.scroll.propagationX && !$sprite.scroll.propagationY) {\n        $e.stopPropagation();\n      }\n    },\n    touchmove: function touchmove($e) {\n      if (!started) return; // console.log($e.canvasX)\n\n      if (mutipleScrollLock && this !== mutipleScrollLock) {\n        // console.log('rejected!', mutipleScrollLock);\n        return;\n      }\n\n      var moveDirect = scrollFuncs.touch(this, $e);\n\n      if (moveDirect === 1 && $sprite.scroll.propagationY) {\n        $e.stopPropagation();\n        mutipleScrollLock = this; // console.log('locked', mutipleScrollLock);\n      } else if (moveDirect === 2 && $sprite.scroll.propagationX) {\n        $e.stopPropagation();\n        mutipleScrollLock = this; // console.log('locked', mutipleScrollLock);\n      }\n    },\n    mousewheel: function mousewheel($e) {\n      started = true;\n      scrollFuncs.wheel(this, $e);\n      $e.stopPropagation();\n    },\n    touchend: function touchend() {\n      started = false;\n      scrollFuncs.loose(this);\n    },\n    mouseup: function mouseup() {\n      started = false;\n      scrollFuncs.loose(this);\n    }\n  }, option.events || {});\n\n  if (option.scroll.capture) {\n    option.events.interceptor = function ($e) {\n      if ($sprite.events[$e.type]) {\n        $sprite.events[$e.type].call($sprite, $e);\n        return false;\n      }\n\n      return $e;\n    };\n  }\n\n  var $sprite = new Easycanvas.Sprite(option);\n  $sprite.on('ticked', function () {\n    scrollFuncs.looper($sprite);\n  }); // $sprite.on('handleToggle', handleToggle);\n\n  $sprite.scrollTo = function (left, top, duration) {\n    var callback;\n    autoScrollX = transition.ease($sprite.scroll.scrollY, left, duration || 200, {\n      cycle: 0.5\n    }).then(function () {\n      autoScrollX = false;\n      callback && callback();\n      callback = false;\n    });\n    autoScrollY = transition.ease($sprite.scroll.scrollY, top, duration || 200, {\n      cycle: 0.5\n    }).then(function () {\n      autoScrollY = false;\n      callback && callback();\n      callback = false;\n    });\n    $sprite.on('ticked', autoScrollFunc);\n    return {\n      then: function then(cb) {\n        callback = cb;\n      }\n    };\n  };\n\n  $sprite.$scroll = {\n    speedX: 0,\n    speedY: 0,\n    touching: false,\n    startPos: {},\n    lastTouchSpeed: 0,\n    // 记录用户上一次touch产生的速度，用于平滑的速度计算\n    lastScrollSpeed: 0 // 记录用户上一次touch最终的速度，判断连续相同方向scroll时速度叠加\n\n  };\n  var $scrollingElement = $sprite.add({\n    name: 'scrolling-element',\n    style: {\n      left: function left() {\n        return -this.$parent.scroll.scrollX;\n      },\n      top: function top() {\n        return -this.$parent.scroll.scrollY;\n      }\n    }\n  });\n  $sprite.add = $scrollingElement.add.bind($scrollingElement);\n  $sprite.clear = $scrollingElement.clear.bind($scrollingElement);\n\n  $sprite.getChildren = function () {\n    return $scrollingElement.children;\n  };\n\n  return $sprite;\n};\n\n(0, _browserRegister[\"default\"])(component, 'Scroll');\nvar _default = component;\nexports[\"default\"] = _default;\n\n//# sourceURL=webpack:///./src/components/Scroll.js?");

/***/ }),

/***/ "./src/components/Sequence.js":
/*!************************************!*\
  !*** ./src/components/Sequence.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _browserRegister = _interopRequireDefault(__webpack_require__(/*! ./_browserRegister.js */ \"./src/components/_browserRegister.js\"));\n\nvar _Image = _interopRequireDefault(__webpack_require__(/*! ./Image.js */ \"./src/components/Image.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\n/** ********** *\n *\n * Sequence Sprite Animation\n *\n * ********** **/\nvar component = function component(opt, Easycanvas) {\n  var funcOrValue = Easycanvas.utils.funcOrValue; // let $sprite = new Easycanvas.Sprite(opt);\n\n  var $sprite = new _Image[\"default\"](opt, Easycanvas);\n  $sprite.index = opt.index || 0;\n  $sprite.on('beforeTick', function () {\n    var img = funcOrValue(this.content.img, this);\n    if (!img || !img.width) return; // 确立index\n\n    var index = this.index || 0;\n    if (index < 0) index = 0; // 计算每帧的宽高\n\n    var pw, ph;\n\n    if (this.frameWidth || this.frameHeight) {\n      if (this.frameWidth < 0) {\n        pw = img.width / -this.frameWidth;\n      } else {\n        pw = this.frameWidth;\n      }\n\n      if (this.frameHeight < 0) {\n        ph = img.height / -this.frameHeight;\n      } else {\n        ph = this.frameHeight;\n      }\n\n      var wTimes = Math.floor(img.width / pw);\n      var hTimes = Math.floor(img.height / ph);\n      this.style.cutLeft = index % wTimes * pw;\n      this.style.cutTop = Math.floor(index / wTimes) % hTimes * ph;\n    } // 不循环的精灵动画自动移除\n\n\n    if (!this.loop && index > 0 && this.style.cutLeft === 0 && this.style.cutTop === 0) {\n      this.style.img = undefined;\n      this.remove();\n      return;\n    } // 判断是否应该下一帧\n\n\n    this.$lastFrameTime = this.$lastFrameTime || 0;\n\n    if (this.$canvas.$nextTickTime - this.$lastFrameTime >= funcOrValue(this.interval, this)) {\n      this.$lastFrameTime = this.$canvas.$nextTickTime;\n      this.index++;\n    } // 默认的读取和绘制尺寸等于每帧尺寸\n\n\n    this.style.cutWidth = this.style.cutWidth || pw;\n    this.style.cutHeight = this.style.cutHeight || ph;\n    this.style.width = this.style.width || pw;\n    this.style.height = this.style.height || ph;\n  });\n  return $sprite;\n};\n\n(0, _browserRegister[\"default\"])(component, 'Sequence');\nvar _default = component;\nexports[\"default\"] = _default;\n\n//# sourceURL=webpack:///./src/components/Sequence.js?");

/***/ }),

/***/ "./src/components/Text.js":
/*!********************************!*\
  !*** ./src/components/Text.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _browserRegister = _interopRequireDefault(__webpack_require__(/*! ./_browserRegister.js */ \"./src/components/_browserRegister.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\n/** ********** *\n *\n * Text\n * - TODO.\n *\n * ********** **/\nvar component = function component(opt, Easycanvas) {\n  var $sprite;\n  var option = opt || {};\n  option.name = option.name || 'Text';\n  option.content = option.content || {};\n  option.content.text = option.text;\n  $sprite = new Easycanvas.Sprite(option);\n  Object.defineProperty($sprite, 'text', {\n    get: function get() {\n      return $sprite.content.text || '';\n    },\n    set: function set(value) {\n      $sprite.content.text = value;\n    }\n  }); // $sprite.update = function (obj) {\n  //     this.__proto__.update.call(this, obj);\n  // };\n\n  return $sprite;\n};\n\n(0, _browserRegister[\"default\"])(component, 'Text');\nvar _default = component;\nexports[\"default\"] = _default;\n\n//# sourceURL=webpack:///./src/components/Text.js?");

/***/ }),

/***/ "./src/components/View.js":
/*!********************************!*\
  !*** ./src/components/View.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _browserRegister = _interopRequireDefault(__webpack_require__(/*! ./_browserRegister.js */ \"./src/components/_browserRegister.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\n/** ********** *\n *\n * Image\n *\n * ********** **/\nvar component = function component(opt, Easycanvas) {\n  var $sprite;\n  var option = opt || {};\n  option.name = option.name || 'View';\n  $sprite = new Easycanvas.Sprite(option);\n  return $sprite;\n};\n\n(0, _browserRegister[\"default\"])(component, 'View');\nvar _default = component;\nexports[\"default\"] = _default;\n\n//# sourceURL=webpack:///./src/components/View.js?");

/***/ }),

/***/ "./src/components/_CanvasInput.js":
/*!****************************************!*\
  !*** ./src/components/_CanvasInput.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\n/*!\n *  CanvasInput v1.2.7\n *  http://goldfirestudios.com/blog/108/CanvasInput-HTML5-Canvas-Text-Input\n *\n *  (c) 2013-2017, James Simpson of GoldFire Studios\n *  goldfirestudios.com\n *\n *  MIT License\n */\n// modified to ESM by chenzhuo04\n// create a buffer that stores all inputs so that tabbing\n// between them is made possible.\nvar inputs = []; // initialize the Canvas Input\n\nvar CanvasInput = function CanvasInput(o) {\n  var self = this;\n  o = o ? o : {}; // setup the defaults\n\n  self._canvas = o.canvas || null;\n  self._ctx = self._canvas ? self._canvas.getContext('2d') : null;\n  self._x = o.x || 0;\n  self._y = o.y || 0;\n  self._extraX = o.extraX || 0;\n  self._extraY = o.extraY || 0;\n  self._fontSize = o.fontSize || 14;\n  self._fontFamily = o.fontFamily || 'Arial';\n  self._fontColor = o.fontColor || '#000';\n  self._placeHolderColor = o.placeHolderColor || '#bfbebd';\n  self._fontWeight = o.fontWeight || 'normal';\n  self._fontStyle = o.fontStyle || 'normal';\n  self._fontShadowColor = o.fontShadowColor || '';\n  self._fontShadowBlur = o.fontShadowBlur || 0;\n  self._fontShadowOffsetX = o.fontShadowOffsetX || 0;\n  self._fontShadowOffsetY = o.fontShadowOffsetY || 0;\n  self._readonly = o.readonly || false;\n  self._maxlength = o.maxlength || null;\n  self._width = o.width || 150;\n  self._height = o.height || self._fontSize;\n  self._padding = o.padding >= 0 ? o.padding : 5;\n  self._borderWidth = o.borderWidth >= 0 ? o.borderWidth : 1;\n  self._borderColor = o.borderColor || '#959595';\n  self._borderRadius = o.borderRadius >= 0 ? o.borderRadius : 3;\n  self._backgroundImage = o.backgroundImage || '';\n  self._boxShadow = o.boxShadow || '1px 1px 0px rgba(255, 255, 255, 1)';\n  self._innerShadow = o.innerShadow || '0px 0px 4px rgba(0, 0, 0, 0.4)';\n  self._selectionColor = o.selectionColor || 'rgba(179, 212, 253, 0.8)';\n  self._placeHolder = o.placeHolder || '';\n  self._value = (o.value || self._placeHolder) + '';\n\n  self._onsubmit = o.onsubmit || function () {};\n\n  self._onkeydown = o.onkeydown || function () {};\n\n  self._onkeyup = o.onkeyup || function () {};\n\n  self._onfocus = o.onfocus || function () {};\n\n  self._onblur = o.onblur || function () {};\n\n  self._cursor = false;\n  self._cursorPos = 0;\n  self._hasFocus = false;\n  self._selection = [0, 0];\n  self._wasOver = false; // parse box shadow\n\n  self.boxShadow(self._boxShadow, true); // calculate the full width and height with padding, borders and shadows\n\n  self._calcWH(); // setup the off-DOM canvas\n\n\n  self._renderCanvas = document.createElement('canvas');\n\n  self._renderCanvas.setAttribute('width', self.outerW);\n\n  self._renderCanvas.setAttribute('height', self.outerH);\n\n  self._renderCtx = self._renderCanvas.getContext('2d'); // setup another off-DOM canvas for inner-shadows\n\n  self._shadowCanvas = document.createElement('canvas');\n\n  self._shadowCanvas.setAttribute('width', self._width + self._padding * 2);\n\n  self._shadowCanvas.setAttribute('height', self._height + self._padding * 2);\n\n  self._shadowCtx = self._shadowCanvas.getContext('2d'); // setup the background color\n\n  if (typeof o.backgroundGradient !== 'undefined') {\n    self._backgroundColor = self._renderCtx.createLinearGradient(0, 0, 0, self.outerH);\n\n    self._backgroundColor.addColorStop(0, o.backgroundGradient[0]);\n\n    self._backgroundColor.addColorStop(1, o.backgroundGradient[1]);\n  } else {\n    self._backgroundColor = o.backgroundColor || '#fff';\n  } // setup main canvas events\n\n\n  if (self._canvas) {\n    self._canvas.addEventListener('mousemove', function (e) {\n      e = e || window.event;\n      self.mousemove(e, self);\n    }, false);\n\n    self._canvas.addEventListener('mousedown', function (e) {\n      e = e || window.event;\n      self.mousedown(e, self);\n    }, false);\n\n    self._canvas.addEventListener('mouseup', function (e) {\n      e = e || window.event;\n      self.mouseup(e, self);\n    }, false);\n  } // setup a global mouseup to blur the input outside of the canvas\n\n\n  var autoBlur = function autoBlur(e) {\n    e = e || window.event;\n\n    if (self._hasFocus && !self._mouseDown) {\n      self.blur();\n    }\n  };\n\n  window.addEventListener('mouseup', autoBlur, true);\n  window.addEventListener('touchend', autoBlur, true); // create the hidden input element\n\n  self._hiddenInput = document.createElement('input');\n  self._hiddenInput.type = 'text';\n  self._hiddenInput.style.position = 'absolute';\n  self._hiddenInput.style.opacity = 0;\n  self._hiddenInput.style.pointerEvents = 'none';\n  self._hiddenInput.style.zIndex = 0; // hide native blue text cursor on iOS\n\n  self._hiddenInput.style.transform = 'scale(0)';\n\n  self._updateHiddenInput();\n\n  if (self._maxlength) {\n    self._hiddenInput.maxLength = self._maxlength;\n  }\n\n  document.body.appendChild(self._hiddenInput);\n  self._hiddenInput.value = self._value; // setup the keydown listener\n\n  self._hiddenInput.addEventListener('keydown', function (e) {\n    e = e || window.event;\n\n    if (self._hasFocus) {\n      // hack to fix touch event bug in iOS Safari\n      window.focus();\n\n      self._hiddenInput.focus(); // continue with the keydown event\n\n\n      self.keydown(e, self);\n    }\n  }); // setup the keyup listener\n\n\n  self._hiddenInput.addEventListener('keyup', function (e) {\n    e = e || window.event; // update the canvas input state information from the hidden input\n\n    self._value = self._hiddenInput.value;\n    self._cursorPos = self._hiddenInput.selectionStart; // update selection to hidden input's selection in case user did keyboard-based selection\n\n    self._selection = [self._hiddenInput.selectionStart, self._hiddenInput.selectionEnd];\n    self.render();\n\n    if (self._hasFocus) {\n      self._onkeyup(e, self);\n    }\n  }); // add this to the buffer\n\n\n  inputs.push(self);\n  self._inputsIndex = inputs.length - 1; // draw the text box\n\n  self.render();\n}; // setup the prototype\n\n\nCanvasInput.prototype = {\n  /**\n   * Get/set the main canvas.\n   * @param  {Object} data Canvas reference.\n   * @return {Mixed}      CanvasInput or current canvas.\n   */\n  canvas: function canvas(data) {\n    var self = this;\n\n    if (typeof data !== 'undefined') {\n      self._canvas = data;\n      self._ctx = self._canvas.getContext('2d');\n      return self.render();\n    } else {\n      return self._canvas;\n    }\n  },\n\n  /**\n   * Get/set the x-position.\n   * @param  {Number} data The pixel position along the x-coordinate.\n   * @return {Mixed}      CanvasInput or current x-value.\n   */\n  x: function x(data) {\n    var self = this;\n\n    if (typeof data !== 'undefined') {\n      self._x = data;\n\n      self._updateHiddenInput();\n\n      return self.render();\n    } else {\n      return self._x;\n    }\n  },\n\n  /**\n   * Get/set the y-position.\n   * @param  {Number} data The pixel position along the y-coordinate.\n   * @return {Mixed}      CanvasInput or current y-value.\n   */\n  y: function y(data) {\n    var self = this;\n\n    if (typeof data !== 'undefined') {\n      self._y = data;\n\n      self._updateHiddenInput();\n\n      return self.render();\n    } else {\n      return self._y;\n    }\n  },\n\n  /**\n   * Get/set the extra x-position (generally used when no canvas is specified).\n   * @param  {Number} data The pixel position along the x-coordinate.\n   * @return {Mixed}      CanvasInput or current x-value.\n   */\n  extraX: function extraX(data) {\n    var self = this;\n\n    if (typeof data !== 'undefined') {\n      self._extraX = data;\n\n      self._updateHiddenInput();\n\n      return self.render();\n    } else {\n      return self._extraX;\n    }\n  },\n\n  /**\n   * Get/set the extra y-position (generally used when no canvas is specified).\n   * @param  {Number} data The pixel position along the y-coordinate.\n   * @return {Mixed}      CanvasInput or current y-value.\n   */\n  extraY: function extraY(data) {\n    var self = this;\n\n    if (typeof data !== 'undefined') {\n      self._extraY = data;\n\n      self._updateHiddenInput();\n\n      return self.render();\n    } else {\n      return self._extraY;\n    }\n  },\n\n  /**\n   * Get/set the font size.\n   * @param  {Number} data Font size.\n   * @return {Mixed}      CanvasInput or current font size.\n   */\n  fontSize: function fontSize(data) {\n    var self = this;\n\n    if (typeof data !== 'undefined') {\n      self._fontSize = data;\n      return self.render();\n    } else {\n      return self._fontSize;\n    }\n  },\n\n  /**\n   * Get/set the font family.\n   * @param  {String} data Font family.\n   * @return {Mixed}      CanvasInput or current font family.\n   */\n  fontFamily: function fontFamily(data) {\n    var self = this;\n\n    if (typeof data !== 'undefined') {\n      self._fontFamily = data;\n      return self.render();\n    } else {\n      return self._fontFamily;\n    }\n  },\n\n  /**\n   * Get/set the font color.\n   * @param  {String} data Font color.\n   * @return {Mixed}      CanvasInput or current font color.\n   */\n  fontColor: function fontColor(data) {\n    var self = this;\n\n    if (typeof data !== 'undefined') {\n      self._fontColor = data;\n      return self.render();\n    } else {\n      return self._fontColor;\n    }\n  },\n\n  /**\n   * Get/set the place holder font color.\n   * @param  {String} data Font color.\n   * @return {Mixed}      CanvasInput or current place holder font color.\n   */\n  placeHolderColor: function placeHolderColor(data) {\n    var self = this;\n\n    if (typeof data !== 'undefined') {\n      self._placeHolderColor = data;\n      return self.render();\n    } else {\n      return self._placeHolderColor;\n    }\n  },\n\n  /**\n   * Get/set the font weight.\n   * @param  {String} data Font weight.\n   * @return {Mixed}      CanvasInput or current font weight.\n   */\n  fontWeight: function fontWeight(data) {\n    var self = this;\n\n    if (typeof data !== 'undefined') {\n      self._fontWeight = data;\n      return self.render();\n    } else {\n      return self._fontWeight;\n    }\n  },\n\n  /**\n   * Get/set the font style.\n   * @param  {String} data Font style.\n   * @return {Mixed}      CanvasInput or current font style.\n   */\n  fontStyle: function fontStyle(data) {\n    var self = this;\n\n    if (typeof data !== 'undefined') {\n      self._fontStyle = data;\n      return self.render();\n    } else {\n      return self._fontStyle;\n    }\n  },\n\n  /**\n   * Get/set the font shadow color.\n   * @param  {String} data Font shadow color.\n   * @return {Mixed}      CanvasInput or current font shadow color.\n   */\n  fontShadowColor: function fontShadowColor(data) {\n    var self = this;\n\n    if (typeof data !== 'undefined') {\n      self._fontShadowColor = data;\n      return self.render();\n    } else {\n      return self._fontShadowColor;\n    }\n  },\n\n  /**\n   * Get/set the font shadow blur.\n   * @param  {String} data Font shadow blur.\n   * @return {Mixed}      CanvasInput or current font shadow blur.\n   */\n  fontShadowBlur: function fontShadowBlur(data) {\n    var self = this;\n\n    if (typeof data !== 'undefined') {\n      self._fontShadowBlur = data;\n      return self.render();\n    } else {\n      return self._fontShadowBlur;\n    }\n  },\n\n  /**\n   * Get/set the font shadow x-offset.\n   * @param  {String} data Font shadow x-offset.\n   * @return {Mixed}      CanvasInput or current font shadow x-offset.\n   */\n  fontShadowOffsetX: function fontShadowOffsetX(data) {\n    var self = this;\n\n    if (typeof data !== 'undefined') {\n      self._fontShadowOffsetX = data;\n      return self.render();\n    } else {\n      return self._fontShadowOffsetX;\n    }\n  },\n\n  /**\n   * Get/set the font shadow y-offset.\n   * @param  {String} data Font shadow y-offset.\n   * @return {Mixed}      CanvasInput or current font shadow y-offset.\n   */\n  fontShadowOffsetY: function fontShadowOffsetY(data) {\n    var self = this;\n\n    if (typeof data !== 'undefined') {\n      self._fontShadowOffsetY = data;\n      return self.render();\n    } else {\n      return self._fontShadowOffsetY;\n    }\n  },\n\n  /**\n   * Get/set the width of the text box.\n   * @param  {Number} data Width in pixels.\n   * @return {Mixed}      CanvasInput or current width.\n   */\n  width: function width(data) {\n    var self = this;\n\n    if (typeof data !== 'undefined') {\n      self._width = data;\n\n      self._calcWH();\n\n      self._updateCanvasWH();\n\n      self._updateHiddenInput();\n\n      return self.render();\n    } else {\n      return self._width;\n    }\n  },\n\n  /**\n   * Get/set the height of the text box.\n   * @param  {Number} data Height in pixels.\n   * @return {Mixed}      CanvasInput or current height.\n   */\n  height: function height(data) {\n    var self = this;\n\n    if (typeof data !== 'undefined') {\n      self._height = data;\n\n      self._calcWH();\n\n      self._updateCanvasWH();\n\n      self._updateHiddenInput();\n\n      return self.render();\n    } else {\n      return self._height;\n    }\n  },\n\n  /**\n   * Get/set the padding of the text box.\n   * @param  {Number} data Padding in pixels.\n   * @return {Mixed}      CanvasInput or current padding.\n   */\n  padding: function padding(data) {\n    var self = this;\n\n    if (typeof data !== 'undefined') {\n      self._padding = data;\n\n      self._calcWH();\n\n      self._updateCanvasWH();\n\n      return self.render();\n    } else {\n      return self._padding;\n    }\n  },\n\n  /**\n   * Get/set the border width.\n   * @param  {Number} data Border width.\n   * @return {Mixed}      CanvasInput or current border width.\n   */\n  borderWidth: function borderWidth(data) {\n    var self = this;\n\n    if (typeof data !== 'undefined') {\n      self._borderWidth = data;\n\n      self._calcWH();\n\n      self._updateCanvasWH();\n\n      return self.render();\n    } else {\n      return self._borderWidth;\n    }\n  },\n\n  /**\n   * Get/set the border color.\n   * @param  {String} data Border color.\n   * @return {Mixed}      CanvasInput or current border color.\n   */\n  borderColor: function borderColor(data) {\n    var self = this;\n\n    if (typeof data !== 'undefined') {\n      self._borderColor = data;\n      return self.render();\n    } else {\n      return self._borderColor;\n    }\n  },\n\n  /**\n   * Get/set the border radius.\n   * @param  {Number} data Border radius.\n   * @return {Mixed}      CanvasInput or current border radius.\n   */\n  borderRadius: function borderRadius(data) {\n    var self = this;\n\n    if (typeof data !== 'undefined') {\n      self._borderRadius = data;\n      return self.render();\n    } else {\n      return self._borderRadius;\n    }\n  },\n\n  /**\n   * Get/set the background color.\n   * @param  {Number} data Background color.\n   * @return {Mixed}      CanvasInput or current background color.\n   */\n  backgroundColor: function backgroundColor(data) {\n    var self = this;\n\n    if (typeof data !== 'undefined') {\n      self._backgroundColor = data;\n      return self.render();\n    } else {\n      return self._backgroundColor;\n    }\n  },\n\n  /**\n   * Get/set the background gradient.\n   * @param  {Number} data Background gradient.\n   * @return {Mixed}      CanvasInput or current background gradient.\n   */\n  backgroundGradient: function backgroundGradient(data) {\n    var self = this;\n\n    if (typeof data !== 'undefined') {\n      self._backgroundColor = self._renderCtx.createLinearGradient(0, 0, 0, self.outerH);\n\n      self._backgroundColor.addColorStop(0, data[0]);\n\n      self._backgroundColor.addColorStop(1, data[1]);\n\n      return self.render();\n    } else {\n      return self._backgroundColor;\n    }\n  },\n\n  /**\n   * Get/set the box shadow.\n   * @param  {String} data     Box shadow in CSS format (1px 1px 1px rgba(0, 0, 0.5)).\n   * @param  {Boolean} doReturn (optional) True to prevent a premature render.\n   * @return {Mixed}          CanvasInput or current box shadow.\n   */\n  boxShadow: function boxShadow(data, doReturn) {\n    var self = this;\n\n    if (typeof data !== 'undefined') {\n      // parse box shadow\n      var boxShadow = data.split('px ');\n      self._boxShadow = {\n        x: self._boxShadow === 'none' ? 0 : parseInt(boxShadow[0], 10),\n        y: self._boxShadow === 'none' ? 0 : parseInt(boxShadow[1], 10),\n        blur: self._boxShadow === 'none' ? 0 : parseInt(boxShadow[2], 10),\n        color: self._boxShadow === 'none' ? '' : boxShadow[3]\n      }; // take into account the shadow and its direction\n\n      if (self._boxShadow.x < 0) {\n        self.shadowL = Math.abs(self._boxShadow.x) + self._boxShadow.blur;\n        self.shadowR = self._boxShadow.blur + self._boxShadow.x;\n      } else {\n        self.shadowL = Math.abs(self._boxShadow.blur - self._boxShadow.x);\n        self.shadowR = self._boxShadow.blur + self._boxShadow.x;\n      }\n\n      if (self._boxShadow.y < 0) {\n        self.shadowT = Math.abs(self._boxShadow.y) + self._boxShadow.blur;\n        self.shadowB = self._boxShadow.blur + self._boxShadow.y;\n      } else {\n        self.shadowT = Math.abs(self._boxShadow.blur - self._boxShadow.y);\n        self.shadowB = self._boxShadow.blur + self._boxShadow.y;\n      }\n\n      self.shadowW = self.shadowL + self.shadowR;\n      self.shadowH = self.shadowT + self.shadowB;\n\n      self._calcWH();\n\n      if (!doReturn) {\n        self._updateCanvasWH();\n\n        return self.render();\n      }\n    } else {\n      return self._boxShadow;\n    }\n  },\n\n  /**\n   * Get/set the inner shadow.\n   * @param  {String} data In the format of a CSS box shadow (1px 1px 1px rgba(0, 0, 0.5)).\n   * @return {Mixed}          CanvasInput or current inner shadow.\n   */\n  innerShadow: function innerShadow(data) {\n    var self = this;\n\n    if (typeof data !== 'undefined') {\n      self._innerShadow = data;\n      return self.render();\n    } else {\n      return self._innerShadow;\n    }\n  },\n\n  /**\n   * Get/set the text selection color.\n   * @param  {String} data Color.\n   * @return {Mixed}      CanvasInput or current selection color.\n   */\n  selectionColor: function selectionColor(data) {\n    var self = this;\n\n    if (typeof data !== 'undefined') {\n      self._selectionColor = data;\n      return self.render();\n    } else {\n      return self._selectionColor;\n    }\n  },\n\n  /**\n   * Get/set the place holder text.\n   * @param  {String} data Place holder text.\n   * @return {Mixed}      CanvasInput or current place holder text.\n   */\n  placeHolder: function placeHolder(data) {\n    var self = this;\n\n    if (typeof data !== 'undefined') {\n      self._placeHolder = data;\n      return self.render();\n    } else {\n      return self._placeHolder;\n    }\n  },\n\n  /**\n   * Get/set the current text box value.\n   * @param  {String} data Text value.\n   * @return {Mixed}      CanvasInput or current text value.\n   */\n  value: function value(data) {\n    var self = this;\n\n    if (typeof data !== 'undefined') {\n      self._value = data + '';\n      self._hiddenInput.value = data + ''; // update the cursor position\n\n      self._cursorPos = self._clipText().length;\n      self.render();\n      return self;\n    } else {\n      return self._value === self._placeHolder ? '' : self._value;\n    }\n  },\n\n  /**\n   * Set or fire the onsubmit event.\n   * @param  {Function} fn Custom callback.\n   */\n  onsubmit: function onsubmit(fn) {\n    var self = this;\n\n    if (typeof fn !== 'undefined') {\n      self._onsubmit = fn;\n      return self;\n    } else {\n      self._onsubmit();\n    }\n  },\n\n  /**\n   * Set or fire the onkeydown event.\n   * @param  {Function} fn Custom callback.\n   */\n  onkeydown: function onkeydown(fn) {\n    var self = this;\n\n    if (typeof fn !== 'undefined') {\n      self._onkeydown = fn;\n      return self;\n    } else {\n      self._onkeydown();\n    }\n  },\n\n  /**\n   * Set or fire the onkeyup event.\n   * @param  {Function} fn Custom callback.\n   */\n  onkeyup: function onkeyup(fn) {\n    var self = this;\n\n    if (typeof fn !== 'undefined') {\n      self._onkeyup = fn;\n      return self;\n    } else {\n      self._onkeyup();\n    }\n  },\n\n  /**\n   * Place focus on the CanvasInput box, placing the cursor\n   * either at the end of the text or where the user clicked.\n   * @param  {Number} pos (optional) The position to place the cursor.\n   * @return {CanvasInput}\n   */\n  focus: function focus(pos) {\n    var self = this; // only fire the focus event when going from unfocussed\n\n    if (!self._hasFocus) {\n      self._onfocus(self); // remove focus from all other inputs\n\n\n      for (var i = 0; i < inputs.length; i++) {\n        if (inputs[i]._hasFocus) {\n          inputs[i].blur();\n        }\n      }\n    } // remove selection\n\n\n    if (!self._selectionUpdated) {\n      self._selection = [0, 0];\n    } else {\n      delete self._selectionUpdated;\n    } // if this is readonly, don't allow it to get focus\n\n\n    self._hasFocus = true;\n\n    if (self._readonly) {\n      self._hiddenInput.readOnly = true;\n    } else {\n      self._hiddenInput.readOnly = false; // update the cursor position\n\n      self._cursorPos = typeof pos === 'number' ? pos : self._clipText().length; // clear the place holder\n\n      if (self._placeHolder === self._value) {\n        self._value = '';\n        self._hiddenInput.value = '';\n      }\n\n      self._cursor = true; // setup cursor interval\n\n      if (self._cursorInterval) {\n        clearInterval(self._cursorInterval);\n      }\n\n      self._cursorInterval = setInterval(function () {\n        self._cursor = !self._cursor;\n        self.render();\n      }, 500);\n    } // move the real focus to the hidden input\n\n\n    var hasSelection = self._selection[0] > 0 || self._selection[1] > 0;\n\n    self._hiddenInput.focus();\n\n    self._hiddenInput.selectionStart = hasSelection ? self._selection[0] : self._cursorPos;\n    self._hiddenInput.selectionEnd = hasSelection ? self._selection[1] : self._cursorPos;\n    return self.render();\n  },\n\n  /**\n   * Removes focus from the CanvasInput box.\n   * @param  {Object} _this Reference to this.\n   * @return {CanvasInput}\n   */\n  blur: function blur(_this) {\n    var self = _this || this;\n\n    self._onblur(self);\n\n    if (self._cursorInterval) {\n      clearInterval(self._cursorInterval);\n    }\n\n    self._hasFocus = false;\n    self._cursor = false;\n    self._selection = [0, 0];\n\n    self._hiddenInput.blur(); // fill the place holder\n\n\n    if (self._value === '') {\n      self._value = self._placeHolder;\n    }\n\n    return self.render();\n  },\n\n  /**\n   * Fired with the keydown event to draw the typed characters.\n   * @param  {Event}       e    The keydown event.\n   * @param  {CanvasInput} self\n   * @return {CanvasInput}\n   */\n  keydown: function keydown(e, self) {\n    var keyCode = e.which,\n        isShift = e.shiftKey,\n        key = null,\n        startText,\n        endText; // make sure the correct text field is being updated\n\n    if (self._readonly || !self._hasFocus) {\n      return;\n    } // fire custom user event\n\n\n    self._onkeydown(e, self); // add support for Ctrl/Cmd+A selection\n\n\n    if (keyCode === 65 && (e.ctrlKey || e.metaKey)) {\n      self.selectText();\n      e.preventDefault();\n      return self.render();\n    } // block keys that shouldn't be processed\n\n\n    if (keyCode === 17 || e.metaKey || e.ctrlKey) {\n      return self;\n    }\n\n    if (keyCode === 13) {\n      // enter key\n      e.preventDefault();\n\n      self._onsubmit(e, self);\n    } else if (keyCode === 9) {\n      // tab key\n      e.preventDefault();\n\n      if (inputs.length > 1) {\n        var next = inputs[self._inputsIndex + 1] ? self._inputsIndex + 1 : 0;\n        self.blur();\n        setTimeout(function () {\n          inputs[next].focus();\n        }, 10);\n      }\n    } // update the canvas input state information from the hidden input\n\n\n    self._value = self._hiddenInput.value;\n    self._cursorPos = self._hiddenInput.selectionStart;\n    self._selection = [0, 0];\n    return self.render();\n  },\n\n  /**\n   * Fired with the click event on the canvas, and puts focus on/off\n   * based on where the user clicks.\n   * @param  {Event}       e    The click event.\n   * @param  {CanvasInput} self\n   * @return {CanvasInput}\n   */\n  click: function click(e, self) {\n    var mouse = self._mousePos(e),\n        x = mouse.x,\n        y = mouse.y;\n\n    if (self._endSelection) {\n      delete self._endSelection;\n      delete self._selectionUpdated;\n      return;\n    }\n\n    if (self._canvas && self._overInput(x, y) || !self._canvas) {\n      if (self._mouseDown) {\n        self._mouseDown = false;\n        self.click(e, self);\n        return self.focus(self._clickPos(x, y));\n      }\n    } else {\n      return self.blur();\n    }\n  },\n\n  /**\n   * Fired with the mousemove event to update the default cursor.\n   * @param  {Event}       e    The mousemove event.\n   * @param  {CanvasInput} self\n   * @return {CanvasInput}\n   */\n  mousemove: function mousemove(e, self) {\n    var mouse = self._mousePos(e),\n        x = mouse.x,\n        y = mouse.y,\n        isOver = self._overInput(x, y);\n\n    if (isOver && self._canvas) {\n      self._canvas.style.cursor = 'text';\n      self._wasOver = true;\n    } else if (self._wasOver && self._canvas) {\n      self._canvas.style.cursor = 'default';\n      self._wasOver = false;\n    }\n\n    if (self._hasFocus && self._selectionStart >= 0) {\n      var curPos = self._clickPos(x, y),\n          start = Math.min(self._selectionStart, curPos),\n          end = Math.max(self._selectionStart, curPos);\n\n      if (!isOver) {\n        self._selectionUpdated = true;\n        self._endSelection = true;\n        delete self._selectionStart;\n        self.render();\n        return;\n      }\n\n      if (self._selection[0] !== start || self._selection[1] !== end) {\n        self._selection = [start, end];\n        self.render();\n      }\n    }\n  },\n\n  /**\n   * Fired with the mousedown event to start a selection drag.\n   * @param  {Event} e    The mousedown event.\n   * @param  {CanvasInput} self\n   */\n  mousedown: function mousedown(e, self) {\n    var mouse = self._mousePos(e),\n        x = mouse.x,\n        y = mouse.y,\n        isOver = self._overInput(x, y); // setup the 'click' event\n\n\n    self._mouseDown = isOver; // start the selection drag if inside the input\n\n    if (self._hasFocus && isOver) {\n      self._selectionStart = self._clickPos(x, y);\n    }\n  },\n\n  /**\n   * Fired with the mouseup event to end a selection drag.\n   * @param  {Event} e    The mouseup event.\n   * @param  {CanvasInput} self\n   */\n  mouseup: function mouseup(e, self) {\n    var mouse = self._mousePos(e),\n        x = mouse.x,\n        y = mouse.y; // update selection if a drag has happened\n\n\n    var isSelection = self._clickPos(x, y) !== self._selectionStart;\n\n    if (self._hasFocus && self._selectionStart >= 0 && self._overInput(x, y) && isSelection) {\n      self._selectionUpdated = true;\n      delete self._selectionStart;\n      self.render();\n    } else {\n      delete self._selectionStart;\n    }\n\n    self.click(e, self);\n  },\n\n  /**\n   * Select a range of text in the input.\n   * @param  {Array} range (optional) Leave blank to select all. Format: [start, end]\n   * @return {CanvasInput}\n   */\n  selectText: function selectText(range) {\n    var self = this,\n        range = range || [0, self._value.length]; // select the range of text specified (or all if none specified)\n\n    setTimeout(function () {\n      self._selection = [range[0], range[1]];\n      self._hiddenInput.selectionStart = range[0];\n      self._hiddenInput.selectionEnd = range[1];\n      self.render();\n    }, 1);\n    return self;\n  },\n\n  /**\n   * Helper method to get the off-DOM canvas.\n   * @return {Object} Reference to the canvas.\n   */\n  renderCanvas: function renderCanvas() {\n    return this._renderCanvas;\n  },\n\n  /**\n   * Clears and redraws the CanvasInput on an off-DOM canvas,\n   * and if a main canvas is provided, draws it all onto that.\n   * @return {CanvasInput}\n   */\n  render: function render() {\n    var self = this,\n        ctx = self._renderCtx,\n        w = self.outerW,\n        h = self.outerH,\n        br = self._borderRadius,\n        bw = self._borderWidth,\n        sw = self.shadowW,\n        sh = self.shadowH;\n\n    if (!ctx) {\n      return;\n    } // clear the canvas\n\n\n    ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height); // setup the box shadow\n\n    ctx.shadowOffsetX = self._boxShadow.x;\n    ctx.shadowOffsetY = self._boxShadow.y;\n    ctx.shadowBlur = self._boxShadow.blur;\n    ctx.shadowColor = self._boxShadow.color; // draw the border\n\n    if (self._borderWidth > 0) {\n      ctx.fillStyle = self._borderColor;\n\n      self._roundedRect(ctx, self.shadowL, self.shadowT, w - sw, h - sh, br);\n\n      ctx.fill();\n      ctx.shadowOffsetX = 0;\n      ctx.shadowOffsetY = 0;\n      ctx.shadowBlur = 0;\n    } // draw the text box background\n\n\n    self._drawTextBox(function () {\n      // make sure all shadows are reset\n      ctx.shadowOffsetX = 0;\n      ctx.shadowOffsetY = 0;\n      ctx.shadowBlur = 0; // clip the text so that it fits within the box\n\n      var text = self._clipText(); // draw the selection\n\n\n      var paddingBorder = self._padding + self._borderWidth + self.shadowT;\n\n      if (self._selection[1] > 0) {\n        var selectOffset = self._textWidth(text.substring(0, self._selection[0])),\n            selectWidth = self._textWidth(text.substring(self._selection[0], self._selection[1]));\n\n        ctx.fillStyle = self._selectionColor;\n        ctx.fillRect(paddingBorder + selectOffset, paddingBorder, selectWidth, self._height);\n      } // draw the cursor\n\n\n      if (self._cursor) {\n        var cursorOffset = self._textWidth(text.substring(0, self._cursorPos));\n\n        ctx.fillStyle = self._fontColor;\n        ctx.fillRect(paddingBorder + cursorOffset, paddingBorder, 1, self._height);\n      } // draw the text\n\n\n      var textX = self._padding + self._borderWidth + self.shadowL,\n          textY = Math.round(paddingBorder + self._height / 2); // only remove the placeholder text if they have typed something\n\n      text = text === '' && self._placeHolder ? self._placeHolder : text;\n      ctx.fillStyle = self._value !== '' && self._value !== self._placeHolder ? self._fontColor : self._placeHolderColor;\n      ctx.font = self._fontStyle + ' ' + self._fontWeight + ' ' + self._fontSize + 'px ' + self._fontFamily;\n      ctx.shadowColor = self._fontShadowColor;\n      ctx.shadowBlur = self._fontShadowBlur;\n      ctx.shadowOffsetX = self._fontShadowOffsetX;\n      ctx.shadowOffsetY = self._fontShadowOffsetY;\n      ctx.textAlign = 'left';\n      ctx.textBaseline = 'middle';\n      ctx.fillText(text, textX, textY); // parse inner shadow\n\n      var innerShadow = self._innerShadow.split('px '),\n          isOffsetX = self._innerShadow === 'none' ? 0 : parseInt(innerShadow[0], 10),\n          isOffsetY = self._innerShadow === 'none' ? 0 : parseInt(innerShadow[1], 10),\n          isBlur = self._innerShadow === 'none' ? 0 : parseInt(innerShadow[2], 10),\n          isColor = self._innerShadow === 'none' ? '' : innerShadow[3]; // draw the inner-shadow (damn you canvas, this should be easier than this...)\n\n\n      if (isBlur > 0) {\n        var shadowCtx = self._shadowCtx,\n            scw = shadowCtx.canvas.width,\n            sch = shadowCtx.canvas.height;\n        shadowCtx.clearRect(0, 0, scw, sch);\n        shadowCtx.shadowBlur = isBlur;\n        shadowCtx.shadowColor = isColor; // top shadow\n\n        shadowCtx.shadowOffsetX = 0;\n        shadowCtx.shadowOffsetY = isOffsetY;\n        shadowCtx.fillRect(-1 * w, -100, 3 * w, 100); // right shadow\n\n        shadowCtx.shadowOffsetX = isOffsetX;\n        shadowCtx.shadowOffsetY = 0;\n        shadowCtx.fillRect(scw, -1 * h, 100, 3 * h); // bottom shadow\n\n        shadowCtx.shadowOffsetX = 0;\n        shadowCtx.shadowOffsetY = isOffsetY;\n        shadowCtx.fillRect(-1 * w, sch, 3 * w, 100); // left shadow\n\n        shadowCtx.shadowOffsetX = isOffsetX;\n        shadowCtx.shadowOffsetY = 0;\n        shadowCtx.fillRect(-100, -1 * h, 100, 3 * h); // create a clipping mask on the main canvas\n\n        self._roundedRect(ctx, bw + self.shadowL, bw + self.shadowT, w - bw * 2 - sw, h - bw * 2 - sh, br);\n\n        ctx.clip(); // draw the inner-shadow from the off-DOM canvas\n\n        ctx.drawImage(self._shadowCanvas, 0, 0, scw, sch, bw + self.shadowL, bw + self.shadowT, scw, sch);\n      } // draw to the visible canvas\n\n\n      if (self._ctx) {\n        self._ctx.clearRect(self._x, self._y, ctx.canvas.width, ctx.canvas.height);\n\n        self._ctx.drawImage(self._renderCanvas, self._x, self._y);\n      }\n\n      return self;\n    });\n  },\n\n  /**\n   * Destroy this input and stop rendering it.\n   */\n  destroy: function destroy() {\n    var self = this; // pull from the inputs array\n\n    var index = inputs.indexOf(self);\n\n    if (index != -1) {\n      inputs.splice(index, 1);\n    } // remove focus\n\n\n    if (self._hasFocus) {\n      self.blur();\n    } // remove the hidden input box\n\n\n    document.body.removeChild(self._hiddenInput); // remove off-DOM canvas\n\n    self._renderCanvas = null;\n    self._shadowCanvas = null;\n    self._renderCtx = null;\n  },\n\n  /**\n   * Draw the text box area with either an image or background color.\n   * @param  {Function} fn Callback.\n   */\n  _drawTextBox: function _drawTextBox(fn) {\n    var self = this,\n        ctx = self._renderCtx,\n        w = self.outerW,\n        h = self.outerH,\n        br = self._borderRadius,\n        bw = self._borderWidth,\n        sw = self.shadowW,\n        sh = self.shadowH; // only draw the background shape if no image is being used\n\n    if (self._backgroundImage === '') {\n      ctx.fillStyle = self._backgroundColor;\n\n      self._roundedRect(ctx, bw + self.shadowL, bw + self.shadowT, w - bw * 2 - sw, h - bw * 2 - sh, br);\n\n      ctx.fill();\n      fn();\n    } else {\n      var img = new Image();\n      img.src = self._backgroundImage;\n\n      img.onload = function () {\n        ctx.drawImage(img, 0, 0, img.width, img.height, bw + self.shadowL, bw + self.shadowT, w, h);\n        fn();\n      };\n    }\n  },\n\n  /**\n   * Deletes selected text in selection range and repositions cursor.\n   * @return {Boolean} true if text removed.\n   */\n  _clearSelection: function _clearSelection() {\n    var self = this;\n\n    if (self._selection[1] > 0) {\n      // clear the selected contents\n      var start = self._selection[0],\n          end = self._selection[1];\n      self._value = self._value.substr(0, start) + self._value.substr(end);\n      self._cursorPos = start;\n      self._cursorPos = self._cursorPos < 0 ? 0 : self._cursorPos;\n      self._selection = [0, 0];\n      return true;\n    }\n\n    return false;\n  },\n\n  /**\n   * Clip the text string to only return what fits in the visible text box.\n   * @param  {String} value The text to clip.\n   * @return {String} The clipped text.\n   */\n  _clipText: function _clipText(value) {\n    var self = this;\n    value = typeof value === 'undefined' ? self._value : value;\n\n    var textWidth = self._textWidth(value),\n        fillPer = textWidth / (self._width - self._padding),\n        text = fillPer > 1 ? value.substr(-1 * Math.floor(value.length / fillPer)) : value;\n\n    return text + '';\n  },\n\n  /**\n   * Gets the pixel with of passed text.\n   * @param  {String} text The text to measure.\n   * @return {Number}      The measured width.\n   */\n  _textWidth: function _textWidth(text) {\n    var self = this,\n        ctx = self._renderCtx;\n    ctx.font = self._fontStyle + ' ' + self._fontWeight + ' ' + self._fontSize + 'px ' + self._fontFamily;\n    ctx.textAlign = 'left';\n    return ctx.measureText(text).width;\n  },\n\n  /**\n   * Recalculate the outer with and height of the text box.\n   */\n  _calcWH: function _calcWH() {\n    var self = this; // calculate the full width and height with padding, borders and shadows\n\n    self.outerW = self._width + self._padding * 2 + self._borderWidth * 2 + self.shadowW;\n    self.outerH = self._height + self._padding * 2 + self._borderWidth * 2 + self.shadowH;\n  },\n\n  /**\n   * Update the width and height of the off-DOM canvas when attributes are changed.\n   */\n  _updateCanvasWH: function _updateCanvasWH() {\n    var self = this,\n        oldW = self._renderCanvas.width,\n        oldH = self._renderCanvas.height; // update off-DOM canvas\n\n    self._renderCanvas.setAttribute('width', self.outerW);\n\n    self._renderCanvas.setAttribute('height', self.outerH);\n\n    self._shadowCanvas.setAttribute('width', self._width + self._padding * 2);\n\n    self._shadowCanvas.setAttribute('height', self._height + self._padding * 2); // clear the main canvas\n\n\n    if (self._ctx) {\n      self._ctx.clearRect(self._x, self._y, oldW, oldH);\n    }\n  },\n\n  /**\n   * Update the size and position of the hidden input (better UX on mobile).\n   */\n  _updateHiddenInput: function _updateHiddenInput() {\n    var self = this;\n    self._hiddenInput.style.left = self._x + self._extraX + (self._canvas ? self._canvas.offsetLeft : 0) + 'px';\n    self._hiddenInput.style.top = self._y + self._extraY + (self._canvas ? self._canvas.offsetTop : 0) + 'px';\n    self._hiddenInput.style.width = self._width + self._padding * 2 + 'px';\n    self._hiddenInput.style.height = self._height + self._padding * 2 + 'px';\n  },\n\n  /**\n   * Creates the path for a rectangle with rounded corners.\n   * Must call ctx.fill() after calling this to draw the rectangle.\n   * @param  {Object} ctx Canvas context.\n   * @param  {Number} x   x-coordinate to draw from.\n   * @param  {Number} y   y-coordinate to draw from.\n   * @param  {Number} w   Width of rectangle.\n   * @param  {Number} h   Height of rectangle.\n   * @param  {Number} r   Border radius.\n   */\n  _roundedRect: function _roundedRect(ctx, x, y, w, h, r) {\n    if (w < 2 * r) r = w / 2;\n    if (h < 2 * r) r = h / 2;\n    ctx.beginPath();\n    ctx.moveTo(x + r, y);\n    ctx.lineTo(x + w - r, y);\n    ctx.quadraticCurveTo(x + w, y, x + w, y + r);\n    ctx.lineTo(x + w, y + h - r);\n    ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);\n    ctx.lineTo(x + r, y + h);\n    ctx.quadraticCurveTo(x, y + h, x, y + h - r);\n    ctx.lineTo(x, y + r);\n    ctx.quadraticCurveTo(x, y, x + r, y);\n    ctx.closePath();\n  },\n\n  /**\n   * Checks if a coordinate point is over the input box.\n   * @param  {Number} x x-coordinate position.\n   * @param  {Number} y y-coordinate position.\n   * @return {Boolean}   True if it is over the input box.\n   */\n  _overInput: function _overInput(x, y) {\n    var self = this,\n        xLeft = x >= self._x + self._extraX,\n        xRight = x <= self._x + self._extraX + self._width + self._padding * 2,\n        yTop = y >= self._y + self._extraY,\n        yBottom = y <= self._y + self._extraY + self._height + self._padding * 2;\n    return xLeft && xRight && yTop && yBottom;\n  },\n\n  /**\n   * Use the mouse's x & y coordinates to determine\n   * the position clicked in the text.\n   * @param  {Number} x X-coordinate.\n   * @param  {Number} y Y-coordinate.\n   * @return {Number}   Cursor position.\n   */\n  _clickPos: function _clickPos(x, y) {\n    var self = this,\n        value = self._value; // don't count placeholder text in this\n\n    if (self._value === self._placeHolder) {\n      value = '';\n    } // determine where the click was made along the string\n\n\n    var text = self._clipText(value),\n        totalW = 0,\n        pos = text.length;\n\n    if (x - (self._x + self._extraX) < self._textWidth(text)) {\n      // loop through each character to identify the position\n      for (var i = 0; i < text.length; i++) {\n        totalW += self._textWidth(text[i]);\n\n        if (totalW >= x - (self._x + self._extraX)) {\n          pos = i;\n          break;\n        }\n      }\n    }\n\n    return pos;\n  },\n\n  /**\n   * Calculate the mouse position based on the event callback and the elements on the page.\n   * @param  {Event} e\n   * @return {Object}   x & y values\n   */\n  _mousePos: function _mousePos(e) {\n    var elm = e.target,\n        x = e.pageX,\n        y = e.pageY; // support touch events in page location calculation\n\n    if (e.touches && e.touches.length) {\n      elm = e.touches[0].target;\n      x = e.touches[0].pageX;\n      y = e.touches[0].pageY;\n    } else if (e.changedTouches && e.changedTouches.length) {\n      elm = e.changedTouches[0].target;\n      x = e.changedTouches[0].pageX;\n      y = e.changedTouches[0].pageY;\n    }\n\n    var style = document.defaultView.getComputedStyle(elm, undefined),\n        paddingLeft = parseInt(style['paddingLeft'], 10) || 0,\n        paddingTop = parseInt(style['paddingLeft'], 10) || 0,\n        borderLeft = parseInt(style['borderLeftWidth'], 10) || 0,\n        borderTop = parseInt(style['borderLeftWidth'], 10) || 0,\n        htmlTop = document.body.parentNode.offsetTop || 0,\n        htmlLeft = document.body.parentNode.offsetLeft || 0,\n        offsetX = 0,\n        offsetY = 0; // calculate the total offset\n\n    if (typeof elm.offsetParent !== 'undefined') {\n      do {\n        offsetX += elm.offsetLeft;\n        offsetY += elm.offsetTop;\n      } while (elm = elm.offsetParent);\n    } // take into account borders and padding\n\n\n    offsetX += paddingLeft + borderLeft + htmlLeft;\n    offsetY += paddingTop + borderTop + htmlTop;\n    return {\n      x: x - offsetX,\n      y: y - offsetY\n    };\n  }\n};\nvar _default = CanvasInput;\nexports[\"default\"] = _default;\n\n//# sourceURL=webpack:///./src/components/_CanvasInput.js?");

/***/ }),

/***/ "./src/components/_browserRegister.js":
/*!********************************************!*\
  !*** ./src/components/_browserRegister.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\nvar inBrowser = typeof window !== 'undefined';\n\nvar _default = function _default(component, name) {\n  if (inBrowser && window.Easycanvas) {\n    Easycanvas[name] = function (opt) {\n      return component(opt, Easycanvas);\n    };\n  }\n};\n\nexports[\"default\"] = _default;\n\n//# sourceURL=webpack:///./src/components/_browserRegister.js?");

/***/ }),

/***/ "./src/components/_text2image.js":
/*!***************************************!*\
  !*** ./src/components/_text2image.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n// （多行）文本转图片\n// textRendering(String, {fontSize: 30, width: 125, color: '#333'});\n// 返回图片（实际是<canvas>对象），包含.width/.height属性\nvar cachePool = {};\nvar nextLine = '\\n'.slice(0, 1);\n\nvar textRendering = function textRendering(_text, config) {\n  var text = String(_text);\n  var cacheFlag = text + JSON.stringify(config);\n  config.fontSize = config.fontSize || 16;\n\n  if (cachePool[cacheFlag]) {\n    return cachePool[cacheFlag];\n  } // var now = Date.now();\n\n\n  var padding;\n\n  if (config.padding) {\n    padding = config.padding.split(' ');\n    padding = padding.map(function (str) {\n      return parseInt(str);\n    });\n    padding[1] = Number(padding[1] || padding[0]);\n    padding[2] = Number(padding[2] || padding[0]);\n    padding[3] = Number(padding[3] || padding[1]);\n  } else {\n    padding = [0, 0, 0, 0];\n  }\n\n  var width = config.minWidth || config.width || config.fontSize * text.length + padding[1] + padding[3] + 100;\n  var minLines = text.split('\\n').length;\n  var height = config.fontSize * (Math.round(text.length) / width + minLines - 1) * (config.lineHeight || config.fontSize) + padding[0] + padding[2] + 100; // console.warn(width, height);\n\n  var tempCanvas = document.createElement('canvas'); // document.body.appendChild(tempCanvas);\n\n  tempCanvas.width = width;\n  tempCanvas.height = height;\n  var tempCtx = tempCanvas.getContext('2d');\n  window.tempCanvas = tempCanvas;\n  window.tempCtx = tempCtx; // 确保不支持hanging的手机也能用top\n  // 部分安卓和ios的textBaseline不同，巨坑，换成middle\n  // tempCtx.textBaseline = 'top';\n  // tempCtx.textBaseline = 'hanging';\n\n  tempCtx.textBaseline = 'middle';\n  tempCtx.font = (config.fontStyle ? config.fontStyle + ' ' : '') + config.fontSize + 'px ' + (config.family || 'serif');\n  tempCtx.fillStyle = config.color || '#000';\n  tempCtx.textAlign = config.textAlign || 'left';\n\n  if (true) {\n    var context = []; // 骨架\n\n    context.push(\"var tempCanvas = document.createElement('canvas')\");\n    context.push(\"tempCanvas.width=\".concat(tempCanvas.width));\n    context.push(\"tempCanvas.height=\".concat(tempCanvas.height));\n    context.push(\"var tempCtx = tempCanvas.getContext('2d')\");\n    context.push(\"tempCtx.textBaseline='\" + tempCtx.textBaseline + \"'\");\n    context.push(\"tempCtx.font='\" + tempCtx.font + \"'\");\n    context.push(\"tempCtx.fillStyle='\" + tempCtx.fillStyle + \"'\");\n    context.push(\"tempCtx.textAlign='\" + tempCtx.textAlign + \"'\");\n  }\n\n  var drawX = 0;\n  var drawY = config.lineHeight ? (config.lineHeight - config.fontSize) / 2 : 0;\n  var startIndex = 0;\n  var endIndex = 1; // 用-来替换空格\n\n  var realWidth = 0;\n  var lastLineLeft = 0;\n  var lineCount = 1;\n\n  while (true) {\n    lastLineLeft = tempCtx.measureText(text.slice(startIndex, endIndex)).width;\n\n    if (lastLineLeft > config.width) {\n      if (config.textOverflow === 'ellipsis') {\n        // 最后一个字换成三个点\n        endIndex -= 2;\n        tempCtx.fillText(text.slice(startIndex, endIndex) + '...', drawX, drawY + config.fontSize / 2);\n\n        if (true) {\n          context.push(\"tempCtx.fillText('\".concat(text.slice(startIndex, endIndex), \"...', \").concat(drawX, \", \").concat(drawY + config.fontSize / 2, \")\"));\n        }\n\n        drawY += config.fontSize + (config.lineHeight ? (config.lineHeight - config.fontSize) / 2 : 0);\n        lineCount++;\n        realWidth = config.width - padding[1] - padding[3];\n        break;\n      } else {\n        // 换行\n        endIndex -= 1;\n        tempCtx.fillText(text.slice(startIndex, endIndex), drawX, drawY + config.fontSize / 2);\n\n        if (true) {\n          context.push(\"tempCtx.fillText('\".concat(text.slice(startIndex, endIndex), \"', \").concat(drawX, \", \").concat(drawY + config.fontSize / 2, \")\"));\n        }\n\n        startIndex = endIndex;\n        endIndex = startIndex + 1;\n        drawY += config.fontSize + (config.lineHeight ? (config.lineHeight - config.fontSize) / 2 : 10);\n        lineCount++;\n      }\n    } else {\n      if (endIndex > text.length - 1) {\n        if (lastLineLeft > realWidth) realWidth = lastLineLeft;\n        tempCtx.fillText(text.slice(startIndex, endIndex), drawX, drawY + config.fontSize / 2);\n\n        if (true) {\n          context.push(\"tempCtx.fillText('\".concat(text.slice(startIndex, endIndex), \"', \").concat(drawX, \", \").concat(drawY + config.fontSize / 2, \")\"));\n        }\n\n        drawY += config.fontSize + (config.lineHeight ? (config.lineHeight - config.fontSize) / 2 : 0);\n        break;\n      } else if (text.slice(endIndex, endIndex + 1) === nextLine) {\n        // 换行\n        tempCtx.fillText(text.slice(startIndex, endIndex), drawX, drawY + config.fontSize / 2);\n        endIndex += 1;\n        startIndex = endIndex;\n        endIndex = startIndex + 1;\n        drawY += config.fontSize + (config.lineHeight ? (config.lineHeight - config.fontSize) / 2 : 10);\n        lineCount++;\n      }\n\n      if (lastLineLeft > realWidth) realWidth = lastLineLeft;\n      endIndex++;\n    }\n  } // const firstValuable = (a, b) => {\n  //     return typeof a === 'undefined' ? b : a;\n  // },\n\n\n  var finalCanvas = document.createElement('canvas');\n  finalCanvas.lastLineLeft = lastLineLeft;\n  finalCanvas.lineCount = lineCount;\n  finalCanvas.width = Math.max(realWidth + padding[1] + padding[3], config.minWidth || 0);\n  finalCanvas.height = drawY + padding[0] + padding[2];\n  var finalCtx = finalCanvas.getContext('2d');\n\n  if (true) {\n    context.push(\"var finalCanvas=document.createElement('canvas')\");\n    context.push(\"finalCanvas.width=\".concat(finalCanvas.width));\n    context.push(\"finalCanvas.height=\".concat(finalCanvas.height));\n    context.push(\"var finalCtx = finalCanvas.getContext('2d')\");\n  }\n\n  if (config.backgroundColor) {\n    finalCtx.fillStyle = config.backgroundColor;\n    finalCtx.fillRect(0, 0, finalCanvas.width, finalCanvas.height);\n\n    if (true) {\n      context.push(\"finalCtx.fillStyle=\".concat(finalCtx.fillStyle));\n      context.push(\"finalCtx.fillRect(0, 0, \".concat(finalCanvas.width, \", \").concat(finalCanvas.height, \")\"));\n    }\n  } // finalCtx.drawImage(tempCanvas, padding[3], padding[0]);\n\n\n  finalCtx.drawImage(tempCanvas, (finalCanvas.width - realWidth) / 2, padding[0]); // document.body.prepend(finalCanvas);\n\n  if (config.border) {\n    var border = config.border.split(' ');\n    var borderStyle = border.pop(); // ctx.setLineDash([5, 3]);/*dashes are 5px and spaces are 3px*/\n\n    if (border[border.length - 1] === 'solid') border.pop();\n    var borderTop = border[0];\n    var borderRight = border[1] || borderTop;\n    var borderBottom = border[2] || borderTop;\n    var borderLeft = border[3] || borderRight || borderTop;\n    borderTop = parseInt(borderTop);\n    borderRight = parseInt(borderRight);\n    borderBottom = parseInt(borderBottom);\n    borderLeft = parseInt(borderLeft);\n    var borderRadius = config.borderRadius || 0;\n    finalCtx.beginPath();\n    finalCtx.strokeStyle = borderStyle;\n\n    if (borderTop) {\n      finalCtx.lineWidth = borderTop;\n      finalCtx.moveTo(borderLeft ? borderRadius : 0, 0);\n      finalCtx.lineTo(finalCanvas.width - (borderRight ? borderRadius : 0), 0);\n    }\n\n    if (borderRight) {\n      finalCtx.lineWidth = borderRight;\n      finalCtx.moveTo(finalCanvas.width, borderTop ? borderRadius : 0);\n      finalCtx.lineTo(finalCanvas.width, finalCanvas.height - (borderBottom ? borderRadius : 0));\n    }\n\n    if (borderBottom) {\n      finalCtx.lineWidth = borderBottom;\n      finalCtx.moveTo(borderLeft ? borderRadius : 0, finalCanvas.height);\n      finalCtx.lineTo(finalCanvas.width - (borderRight ? borderRadius : 0), finalCanvas.height);\n    }\n\n    if (borderLeft) {\n      finalCtx.lineWidth = borderLeft;\n      finalCtx.moveTo(0, borderTop ? borderRadius : 0);\n      finalCtx.lineTo(0, finalCanvas.height - (borderBottom ? borderRadius : 0));\n    }\n\n    finalCtx.stroke();\n\n    if (borderRadius) {\n      var c = document.createElement('canvas');\n      var fontSize = Math.min(finalCanvas.width, finalCanvas.height);\n      c.width = c.height = fontSize;\n      var ctx = c.getContext('2d');\n      ctx.beginPath();\n      ctx.strokeStyle = borderStyle;\n      ctx.arc(fontSize >> 1, fontSize >> 1, (fontSize >> 1) - 1, 0, 2 * Math.PI);\n      ctx.stroke();\n\n      if (borderTop && borderRight) {\n        finalCtx.drawImage(c, fontSize >> 1, 0, fontSize >> 1, fontSize >> 1, finalCanvas.width - borderRadius, 0, borderRadius, borderRadius);\n      }\n\n      if (borderBottom && borderRight) {\n        finalCtx.drawImage(c, fontSize >> 1, fontSize >> 1, fontSize >> 1, fontSize >> 1, finalCanvas.width - borderRadius, finalCanvas.height - borderRadius, borderRadius, borderRadius);\n      }\n\n      if (borderTop && borderLeft) {\n        finalCtx.drawImage(c, 0, 0, fontSize >> 1, fontSize >> 1, 0, 0, borderRadius, borderRadius);\n      }\n\n      if (borderBottom && borderLeft) {\n        finalCtx.drawImage(c, 0, fontSize >> 1, fontSize >> 1, fontSize >> 1, 0, finalCanvas.height - borderRadius, borderRadius, borderRadius);\n      }\n    } // TODO\n    // if (process.env.NODE_ENV !== 'production') {\n    //     context.push(`finalCtx.fillStyle=${finalCtx.fillStyle}`);\n    //     context.push(`finalCtx.fillRect(0, 0, ${finalCanvas.width}, ${finalCanvas.height})`);\n    // }\n\n  } // console.warn(Date.now() - now);\n\n\n  if (true) {\n    finalCanvas.$origin = context;\n  }\n\n  cachePool[cacheFlag] = finalCanvas;\n  return finalCanvas; // var image = new Image();\n  // image.src = finalCanvas.toDataURL();\n  // image.width = finalCanvas.width;\n  // image.height = finalCanvas.height;\n  // return image;\n};\n\nvar _default = textRendering;\nexports[\"default\"] = _default;\n\n//# sourceURL=webpack:///./src/components/_text2image.js?");

/***/ }),

/***/ 0:
/*!*********************************!*\
  !*** multi ./src/components.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__(/*! ./src/components.js */\"./src/components.js\");\n\n\n//# sourceURL=webpack:///multi_./src/components.js?");

/***/ })

/******/ })));