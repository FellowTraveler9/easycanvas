(function(e, a) { for(var i in a) e[i] = a[i]; }(window, /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 9);
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/lib/_glMatrix-0.9.5.min.js":
/*!****************************************!*\
  !*** ./src/lib/_glMatrix-0.9.5.min.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n// glMatrix v0.9.5\nvar vec3 = {},\n    mat3 = {},\n    mat4 = {},\n    quat4 = {};\nvar glMatrixArrayType = typeof Float32Array != \"undefined\" ? Float32Array : typeof WebGLFloatArray != \"undefined\" ? WebGLFloatArray : Array;\n\nvec3.create = function (a) {\n  var b = new glMatrixArrayType(3);\n\n  if (a) {\n    b[0] = a[0];\n    b[1] = a[1];\n    b[2] = a[2];\n  }\n\n  return b;\n};\n\nvec3.set = function (a, b) {\n  b[0] = a[0];\n  b[1] = a[1];\n  b[2] = a[2];\n  return b;\n};\n\nvec3.add = function (a, b, c) {\n  if (!c || a == c) {\n    a[0] += b[0];\n    a[1] += b[1];\n    a[2] += b[2];\n    return a;\n  }\n\n  c[0] = a[0] + b[0];\n  c[1] = a[1] + b[1];\n  c[2] = a[2] + b[2];\n  return c;\n};\n\nvec3.subtract = function (a, b, c) {\n  if (!c || a == c) {\n    a[0] -= b[0];\n    a[1] -= b[1];\n    a[2] -= b[2];\n    return a;\n  }\n\n  c[0] = a[0] - b[0];\n  c[1] = a[1] - b[1];\n  c[2] = a[2] - b[2];\n  return c;\n};\n\nvec3.negate = function (a, b) {\n  b || (b = a);\n  b[0] = -a[0];\n  b[1] = -a[1];\n  b[2] = -a[2];\n  return b;\n};\n\nvec3.scale = function (a, b, c) {\n  if (!c || a == c) {\n    a[0] *= b;\n    a[1] *= b;\n    a[2] *= b;\n    return a;\n  }\n\n  c[0] = a[0] * b;\n  c[1] = a[1] * b;\n  c[2] = a[2] * b;\n  return c;\n};\n\nvec3.normalize = function (a, b) {\n  b || (b = a);\n  var c = a[0],\n      d = a[1],\n      e = a[2],\n      g = Math.sqrt(c * c + d * d + e * e);\n\n  if (g) {\n    if (g == 1) {\n      b[0] = c;\n      b[1] = d;\n      b[2] = e;\n      return b;\n    }\n  } else {\n    b[0] = 0;\n    b[1] = 0;\n    b[2] = 0;\n    return b;\n  }\n\n  g = 1 / g;\n  b[0] = c * g;\n  b[1] = d * g;\n  b[2] = e * g;\n  return b;\n};\n\nvec3.cross = function (a, b, c) {\n  c || (c = a);\n  var d = a[0],\n      e = a[1];\n  a = a[2];\n  var g = b[0],\n      f = b[1];\n  b = b[2];\n  c[0] = e * b - a * f;\n  c[1] = a * g - d * b;\n  c[2] = d * f - e * g;\n  return c;\n};\n\nvec3.length = function (a) {\n  var b = a[0],\n      c = a[1];\n  a = a[2];\n  return Math.sqrt(b * b + c * c + a * a);\n};\n\nvec3.dot = function (a, b) {\n  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];\n};\n\nvec3.direction = function (a, b, c) {\n  c || (c = a);\n  var d = a[0] - b[0],\n      e = a[1] - b[1];\n  a = a[2] - b[2];\n  b = Math.sqrt(d * d + e * e + a * a);\n\n  if (!b) {\n    c[0] = 0;\n    c[1] = 0;\n    c[2] = 0;\n    return c;\n  }\n\n  b = 1 / b;\n  c[0] = d * b;\n  c[1] = e * b;\n  c[2] = a * b;\n  return c;\n};\n\nvec3.lerp = function (a, b, c, d) {\n  d || (d = a);\n  d[0] = a[0] + c * (b[0] - a[0]);\n  d[1] = a[1] + c * (b[1] - a[1]);\n  d[2] = a[2] + c * (b[2] - a[2]);\n  return d;\n};\n\nvec3.str = function (a) {\n  return \"[\" + a[0] + \", \" + a[1] + \", \" + a[2] + \"]\";\n};\n\nmat3.create = function (a) {\n  var b = new glMatrixArrayType(9);\n\n  if (a) {\n    b[0] = a[0];\n    b[1] = a[1];\n    b[2] = a[2];\n    b[3] = a[3];\n    b[4] = a[4];\n    b[5] = a[5];\n    b[6] = a[6];\n    b[7] = a[7];\n    b[8] = a[8];\n    b[9] = a[9];\n  }\n\n  return b;\n};\n\nmat3.set = function (a, b) {\n  b[0] = a[0];\n  b[1] = a[1];\n  b[2] = a[2];\n  b[3] = a[3];\n  b[4] = a[4];\n  b[5] = a[5];\n  b[6] = a[6];\n  b[7] = a[7];\n  b[8] = a[8];\n  return b;\n};\n\nmat3.identity = function (a) {\n  a[0] = 1;\n  a[1] = 0;\n  a[2] = 0;\n  a[3] = 0;\n  a[4] = 1;\n  a[5] = 0;\n  a[6] = 0;\n  a[7] = 0;\n  a[8] = 1;\n  return a;\n};\n\nmat3.transpose = function (a, b) {\n  if (!b || a == b) {\n    var c = a[1],\n        d = a[2],\n        e = a[5];\n    a[1] = a[3];\n    a[2] = a[6];\n    a[3] = c;\n    a[5] = a[7];\n    a[6] = d;\n    a[7] = e;\n    return a;\n  }\n\n  b[0] = a[0];\n  b[1] = a[3];\n  b[2] = a[6];\n  b[3] = a[1];\n  b[4] = a[4];\n  b[5] = a[7];\n  b[6] = a[2];\n  b[7] = a[5];\n  b[8] = a[8];\n  return b;\n};\n\nmat3.toMat4 = function (a, b) {\n  b || (b = mat4.create());\n  b[0] = a[0];\n  b[1] = a[1];\n  b[2] = a[2];\n  b[3] = 0;\n  b[4] = a[3];\n  b[5] = a[4];\n  b[6] = a[5];\n  b[7] = 0;\n  b[8] = a[6];\n  b[9] = a[7];\n  b[10] = a[8];\n  b[11] = 0;\n  b[12] = 0;\n  b[13] = 0;\n  b[14] = 0;\n  b[15] = 1;\n  return b;\n};\n\nmat3.str = function (a) {\n  return \"[\" + a[0] + \", \" + a[1] + \", \" + a[2] + \", \" + a[3] + \", \" + a[4] + \", \" + a[5] + \", \" + a[6] + \", \" + a[7] + \", \" + a[8] + \"]\";\n};\n\nvar mat4 = {};\n\nmat4.create = function (a) {\n  var b = new glMatrixArrayType(16);\n\n  if (a) {\n    b[0] = a[0];\n    b[1] = a[1];\n    b[2] = a[2];\n    b[3] = a[3];\n    b[4] = a[4];\n    b[5] = a[5];\n    b[6] = a[6];\n    b[7] = a[7];\n    b[8] = a[8];\n    b[9] = a[9];\n    b[10] = a[10];\n    b[11] = a[11];\n    b[12] = a[12];\n    b[13] = a[13];\n    b[14] = a[14];\n    b[15] = a[15];\n  }\n\n  return b;\n};\n\nmat4.set = function (a, b) {\n  b[0] = a[0];\n  b[1] = a[1];\n  b[2] = a[2];\n  b[3] = a[3];\n  b[4] = a[4];\n  b[5] = a[5];\n  b[6] = a[6];\n  b[7] = a[7];\n  b[8] = a[8];\n  b[9] = a[9];\n  b[10] = a[10];\n  b[11] = a[11];\n  b[12] = a[12];\n  b[13] = a[13];\n  b[14] = a[14];\n  b[15] = a[15];\n  return b;\n};\n\nmat4.identity = function (a) {\n  a[0] = 1;\n  a[1] = 0;\n  a[2] = 0;\n  a[3] = 0;\n  a[4] = 0;\n  a[5] = 1;\n  a[6] = 0;\n  a[7] = 0;\n  a[8] = 0;\n  a[9] = 0;\n  a[10] = 1;\n  a[11] = 0;\n  a[12] = 0;\n  a[13] = 0;\n  a[14] = 0;\n  a[15] = 1;\n  return a;\n};\n\nmat4.transpose = function (a, b) {\n  if (!b || a == b) {\n    var c = a[1],\n        d = a[2],\n        e = a[3],\n        g = a[6],\n        f = a[7],\n        h = a[11];\n    a[1] = a[4];\n    a[2] = a[8];\n    a[3] = a[12];\n    a[4] = c;\n    a[6] = a[9];\n    a[7] = a[13];\n    a[8] = d;\n    a[9] = g;\n    a[11] = a[14];\n    a[12] = e;\n    a[13] = f;\n    a[14] = h;\n    return a;\n  }\n\n  b[0] = a[0];\n  b[1] = a[4];\n  b[2] = a[8];\n  b[3] = a[12];\n  b[4] = a[1];\n  b[5] = a[5];\n  b[6] = a[9];\n  b[7] = a[13];\n  b[8] = a[2];\n  b[9] = a[6];\n  b[10] = a[10];\n  b[11] = a[14];\n  b[12] = a[3];\n  b[13] = a[7];\n  b[14] = a[11];\n  b[15] = a[15];\n  return b;\n};\n\nmat4.determinant = function (a) {\n  var b = a[0],\n      c = a[1],\n      d = a[2],\n      e = a[3],\n      g = a[4],\n      f = a[5],\n      h = a[6],\n      i = a[7],\n      j = a[8],\n      k = a[9],\n      l = a[10],\n      o = a[11],\n      m = a[12],\n      n = a[13],\n      p = a[14];\n  a = a[15];\n  return m * k * h * e - j * n * h * e - m * f * l * e + g * n * l * e + j * f * p * e - g * k * p * e - m * k * d * i + j * n * d * i + m * c * l * i - b * n * l * i - j * c * p * i + b * k * p * i + m * f * d * o - g * n * d * o - m * c * h * o + b * n * h * o + g * c * p * o - b * f * p * o - j * f * d * a + g * k * d * a + j * c * h * a - b * k * h * a - g * c * l * a + b * f * l * a;\n};\n\nmat4.inverse = function (a, b) {\n  b || (b = a);\n  var c = a[0],\n      d = a[1],\n      e = a[2],\n      g = a[3],\n      f = a[4],\n      h = a[5],\n      i = a[6],\n      j = a[7],\n      k = a[8],\n      l = a[9],\n      o = a[10],\n      m = a[11],\n      n = a[12],\n      p = a[13],\n      r = a[14],\n      s = a[15],\n      A = c * h - d * f,\n      B = c * i - e * f,\n      t = c * j - g * f,\n      u = d * i - e * h,\n      v = d * j - g * h,\n      w = e * j - g * i,\n      x = k * p - l * n,\n      y = k * r - o * n,\n      z = k * s - m * n,\n      C = l * r - o * p,\n      D = l * s - m * p,\n      E = o * s - m * r,\n      q = 1 / (A * E - B * D + t * C + u * z - v * y + w * x);\n  b[0] = (h * E - i * D + j * C) * q;\n  b[1] = (-d * E + e * D - g * C) * q;\n  b[2] = (p * w - r * v + s * u) * q;\n  b[3] = (-l * w + o * v - m * u) * q;\n  b[4] = (-f * E + i * z - j * y) * q;\n  b[5] = (c * E - e * z + g * y) * q;\n  b[6] = (-n * w + r * t - s * B) * q;\n  b[7] = (k * w - o * t + m * B) * q;\n  b[8] = (f * D - h * z + j * x) * q;\n  b[9] = (-c * D + d * z - g * x) * q;\n  b[10] = (n * v - p * t + s * A) * q;\n  b[11] = (-k * v + l * t - m * A) * q;\n  b[12] = (-f * C + h * y - i * x) * q;\n  b[13] = (c * C - d * y + e * x) * q;\n  b[14] = (-n * u + p * B - r * A) * q;\n  b[15] = (k * u - l * B + o * A) * q;\n  return b;\n};\n\nmat4.toRotationMat = function (a, b) {\n  b || (b = mat4.create());\n  b[0] = a[0];\n  b[1] = a[1];\n  b[2] = a[2];\n  b[3] = a[3];\n  b[4] = a[4];\n  b[5] = a[5];\n  b[6] = a[6];\n  b[7] = a[7];\n  b[8] = a[8];\n  b[9] = a[9];\n  b[10] = a[10];\n  b[11] = a[11];\n  b[12] = 0;\n  b[13] = 0;\n  b[14] = 0;\n  b[15] = 1;\n  return b;\n};\n\nmat4.toMat3 = function (a, b) {\n  b || (b = mat3.create());\n  b[0] = a[0];\n  b[1] = a[1];\n  b[2] = a[2];\n  b[3] = a[4];\n  b[4] = a[5];\n  b[5] = a[6];\n  b[6] = a[8];\n  b[7] = a[9];\n  b[8] = a[10];\n  return b;\n};\n\nmat4.toInverseMat3 = function (a, b) {\n  var c = a[0],\n      d = a[1],\n      e = a[2],\n      g = a[4],\n      f = a[5],\n      h = a[6],\n      i = a[8],\n      j = a[9],\n      k = a[10],\n      l = k * f - h * j,\n      o = -k * g + h * i,\n      m = j * g - f * i,\n      n = c * l + d * o + e * m;\n  if (!n) return null;\n  n = 1 / n;\n  b || (b = mat3.create());\n  b[0] = l * n;\n  b[1] = (-k * d + e * j) * n;\n  b[2] = (h * d - e * f) * n;\n  b[3] = o * n;\n  b[4] = (k * c - e * i) * n;\n  b[5] = (-h * c + e * g) * n;\n  b[6] = m * n;\n  b[7] = (-j * c + d * i) * n;\n  b[8] = (f * c - d * g) * n;\n  return b;\n};\n\nmat4.multiply = function (a, b, c) {\n  c || (c = a);\n  var d = a[0],\n      e = a[1],\n      g = a[2],\n      f = a[3],\n      h = a[4],\n      i = a[5],\n      j = a[6],\n      k = a[7],\n      l = a[8],\n      o = a[9],\n      m = a[10],\n      n = a[11],\n      p = a[12],\n      r = a[13],\n      s = a[14];\n  a = a[15];\n  var A = b[0],\n      B = b[1],\n      t = b[2],\n      u = b[3],\n      v = b[4],\n      w = b[5],\n      x = b[6],\n      y = b[7],\n      z = b[8],\n      C = b[9],\n      D = b[10],\n      E = b[11],\n      q = b[12],\n      F = b[13],\n      G = b[14];\n  b = b[15];\n  c[0] = A * d + B * h + t * l + u * p;\n  c[1] = A * e + B * i + t * o + u * r;\n  c[2] = A * g + B * j + t * m + u * s;\n  c[3] = A * f + B * k + t * n + u * a;\n  c[4] = v * d + w * h + x * l + y * p;\n  c[5] = v * e + w * i + x * o + y * r;\n  c[6] = v * g + w * j + x * m + y * s;\n  c[7] = v * f + w * k + x * n + y * a;\n  c[8] = z * d + C * h + D * l + E * p;\n  c[9] = z * e + C * i + D * o + E * r;\n  c[10] = z * g + C * j + D * m + E * s;\n  c[11] = z * f + C * k + D * n + E * a;\n  c[12] = q * d + F * h + G * l + b * p;\n  c[13] = q * e + F * i + G * o + b * r;\n  c[14] = q * g + F * j + G * m + b * s;\n  c[15] = q * f + F * k + G * n + b * a;\n  return c;\n};\n\nmat4.multiplyVec3 = function (a, b, c) {\n  c || (c = b);\n  var d = b[0],\n      e = b[1];\n  b = b[2];\n  c[0] = a[0] * d + a[4] * e + a[8] * b + a[12];\n  c[1] = a[1] * d + a[5] * e + a[9] * b + a[13];\n  c[2] = a[2] * d + a[6] * e + a[10] * b + a[14];\n  return c;\n};\n\nmat4.multiplyVec4 = function (a, b, c) {\n  c || (c = b);\n  var d = b[0],\n      e = b[1],\n      g = b[2];\n  b = b[3];\n  c[0] = a[0] * d + a[4] * e + a[8] * g + a[12] * b;\n  c[1] = a[1] * d + a[5] * e + a[9] * g + a[13] * b;\n  c[2] = a[2] * d + a[6] * e + a[10] * g + a[14] * b;\n  c[3] = a[3] * d + a[7] * e + a[11] * g + a[15] * b;\n  return c;\n};\n\nmat4.translate = function (a, b, c) {\n  var d = b[0],\n      e = b[1];\n  b = b[2];\n\n  if (!c || a == c) {\n    a[12] = a[0] * d + a[4] * e + a[8] * b + a[12];\n    a[13] = a[1] * d + a[5] * e + a[9] * b + a[13];\n    a[14] = a[2] * d + a[6] * e + a[10] * b + a[14];\n    a[15] = a[3] * d + a[7] * e + a[11] * b + a[15];\n    return a;\n  }\n\n  var g = a[0],\n      f = a[1],\n      h = a[2],\n      i = a[3],\n      j = a[4],\n      k = a[5],\n      l = a[6],\n      o = a[7],\n      m = a[8],\n      n = a[9],\n      p = a[10],\n      r = a[11];\n  c[0] = g;\n  c[1] = f;\n  c[2] = h;\n  c[3] = i;\n  c[4] = j;\n  c[5] = k;\n  c[6] = l;\n  c[7] = o;\n  c[8] = m;\n  c[9] = n;\n  c[10] = p;\n  c[11] = r;\n  c[12] = g * d + j * e + m * b + a[12];\n  c[13] = f * d + k * e + n * b + a[13];\n  c[14] = h * d + l * e + p * b + a[14];\n  c[15] = i * d + o * e + r * b + a[15];\n  return c;\n};\n\nmat4.scale = function (a, b, c) {\n  var d = b[0],\n      e = b[1];\n  b = b[2];\n\n  if (!c || a == c) {\n    a[0] *= d;\n    a[1] *= d;\n    a[2] *= d;\n    a[3] *= d;\n    a[4] *= e;\n    a[5] *= e;\n    a[6] *= e;\n    a[7] *= e;\n    a[8] *= b;\n    a[9] *= b;\n    a[10] *= b;\n    a[11] *= b;\n    return a;\n  }\n\n  c[0] = a[0] * d;\n  c[1] = a[1] * d;\n  c[2] = a[2] * d;\n  c[3] = a[3] * d;\n  c[4] = a[4] * e;\n  c[5] = a[5] * e;\n  c[6] = a[6] * e;\n  c[7] = a[7] * e;\n  c[8] = a[8] * b;\n  c[9] = a[9] * b;\n  c[10] = a[10] * b;\n  c[11] = a[11] * b;\n  c[12] = a[12];\n  c[13] = a[13];\n  c[14] = a[14];\n  c[15] = a[15];\n  return c;\n};\n\nmat4.rotate = function (a, b, c, d) {\n  var e = c[0],\n      g = c[1];\n  c = c[2];\n  var f = Math.sqrt(e * e + g * g + c * c);\n  if (!f) return null;\n\n  if (f != 1) {\n    f = 1 / f;\n    e *= f;\n    g *= f;\n    c *= f;\n  }\n\n  var h = Math.sin(b),\n      i = Math.cos(b),\n      j = 1 - i;\n  b = a[0];\n  f = a[1];\n  var k = a[2],\n      l = a[3],\n      o = a[4],\n      m = a[5],\n      n = a[6],\n      p = a[7],\n      r = a[8],\n      s = a[9],\n      A = a[10],\n      B = a[11],\n      t = e * e * j + i,\n      u = g * e * j + c * h,\n      v = c * e * j - g * h,\n      w = e * g * j - c * h,\n      x = g * g * j + i,\n      y = c * g * j + e * h,\n      z = e * c * j + g * h;\n  e = g * c * j - e * h;\n  g = c * c * j + i;\n\n  if (d) {\n    if (a != d) {\n      d[12] = a[12];\n      d[13] = a[13];\n      d[14] = a[14];\n      d[15] = a[15];\n    }\n  } else d = a;\n\n  d[0] = b * t + o * u + r * v;\n  d[1] = f * t + m * u + s * v;\n  d[2] = k * t + n * u + A * v;\n  d[3] = l * t + p * u + B * v;\n  d[4] = b * w + o * x + r * y;\n  d[5] = f * w + m * x + s * y;\n  d[6] = k * w + n * x + A * y;\n  d[7] = l * w + p * x + B * y;\n  d[8] = b * z + o * e + r * g;\n  d[9] = f * z + m * e + s * g;\n  d[10] = k * z + n * e + A * g;\n  d[11] = l * z + p * e + B * g;\n  return d;\n};\n\nmat4.rotateX = function (a, b, c) {\n  var d = Math.sin(b);\n  b = Math.cos(b);\n  var e = a[4],\n      g = a[5],\n      f = a[6],\n      h = a[7],\n      i = a[8],\n      j = a[9],\n      k = a[10],\n      l = a[11];\n\n  if (c) {\n    if (a != c) {\n      c[0] = a[0];\n      c[1] = a[1];\n      c[2] = a[2];\n      c[3] = a[3];\n      c[12] = a[12];\n      c[13] = a[13];\n      c[14] = a[14];\n      c[15] = a[15];\n    }\n  } else c = a;\n\n  c[4] = e * b + i * d;\n  c[5] = g * b + j * d;\n  c[6] = f * b + k * d;\n  c[7] = h * b + l * d;\n  c[8] = e * -d + i * b;\n  c[9] = g * -d + j * b;\n  c[10] = f * -d + k * b;\n  c[11] = h * -d + l * b;\n  return c;\n};\n\nmat4.rotateY = function (a, b, c) {\n  var d = Math.sin(b);\n  b = Math.cos(b);\n  var e = a[0],\n      g = a[1],\n      f = a[2],\n      h = a[3],\n      i = a[8],\n      j = a[9],\n      k = a[10],\n      l = a[11];\n\n  if (c) {\n    if (a != c) {\n      c[4] = a[4];\n      c[5] = a[5];\n      c[6] = a[6];\n      c[7] = a[7];\n      c[12] = a[12];\n      c[13] = a[13];\n      c[14] = a[14];\n      c[15] = a[15];\n    }\n  } else c = a;\n\n  c[0] = e * b + i * -d;\n  c[1] = g * b + j * -d;\n  c[2] = f * b + k * -d;\n  c[3] = h * b + l * -d;\n  c[8] = e * d + i * b;\n  c[9] = g * d + j * b;\n  c[10] = f * d + k * b;\n  c[11] = h * d + l * b;\n  return c;\n};\n\nmat4.rotateZ = function (a, b, c) {\n  var d = Math.sin(b);\n  b = Math.cos(b);\n  var e = a[0],\n      g = a[1],\n      f = a[2],\n      h = a[3],\n      i = a[4],\n      j = a[5],\n      k = a[6],\n      l = a[7];\n\n  if (c) {\n    if (a != c) {\n      c[8] = a[8];\n      c[9] = a[9];\n      c[10] = a[10];\n      c[11] = a[11];\n      c[12] = a[12];\n      c[13] = a[13];\n      c[14] = a[14];\n      c[15] = a[15];\n    }\n  } else c = a;\n\n  c[0] = e * b + i * d;\n  c[1] = g * b + j * d;\n  c[2] = f * b + k * d;\n  c[3] = h * b + l * d;\n  c[4] = e * -d + i * b;\n  c[5] = g * -d + j * b;\n  c[6] = f * -d + k * b;\n  c[7] = h * -d + l * b;\n  return c;\n};\n\nmat4.frustum = function (a, b, c, d, e, g, f) {\n  f || (f = mat4.create());\n  var h = b - a,\n      i = d - c,\n      j = g - e;\n  f[0] = e * 2 / h;\n  f[1] = 0;\n  f[2] = 0;\n  f[3] = 0;\n  f[4] = 0;\n  f[5] = e * 2 / i;\n  f[6] = 0;\n  f[7] = 0;\n  f[8] = (b + a) / h;\n  f[9] = (d + c) / i;\n  f[10] = -(g + e) / j;\n  f[11] = -1;\n  f[12] = 0;\n  f[13] = 0;\n  f[14] = -(g * e * 2) / j;\n  f[15] = 0;\n  return f;\n};\n\nmat4.perspective = function (a, b, c, d, e) {\n  a = c * Math.tan(a * Math.PI / 360);\n  b = a * b;\n  return mat4.frustum(-b, b, -a, a, c, d, e);\n};\n\nmat4.ortho = function (a, b, c, d, e, g, f) {\n  f || (f = mat4.create());\n  var h = b - a,\n      i = d - c,\n      j = g - e;\n  f[0] = 2 / h;\n  f[1] = 0;\n  f[2] = 0;\n  f[3] = 0;\n  f[4] = 0;\n  f[5] = 2 / i;\n  f[6] = 0;\n  f[7] = 0;\n  f[8] = 0;\n  f[9] = 0;\n  f[10] = -2 / j;\n  f[11] = 0;\n  f[12] = -(a + b) / h;\n  f[13] = -(d + c) / i;\n  f[14] = -(g + e) / j;\n  f[15] = 1;\n  return f;\n};\n\nmat4.lookAt = function (a, b, c, d) {\n  d || (d = mat4.create());\n  var e = a[0],\n      g = a[1];\n  a = a[2];\n  var f = c[0],\n      h = c[1],\n      i = c[2];\n  c = b[1];\n  var j = b[2];\n  if (e == b[0] && g == c && a == j) return mat4.identity(d);\n  var k, l, o, m;\n  c = e - b[0];\n  j = g - b[1];\n  b = a - b[2];\n  m = 1 / Math.sqrt(c * c + j * j + b * b);\n  c *= m;\n  j *= m;\n  b *= m;\n  k = h * b - i * j;\n  i = i * c - f * b;\n  f = f * j - h * c;\n\n  if (m = Math.sqrt(k * k + i * i + f * f)) {\n    m = 1 / m;\n    k *= m;\n    i *= m;\n    f *= m;\n  } else f = i = k = 0;\n\n  h = j * f - b * i;\n  l = b * k - c * f;\n  o = c * i - j * k;\n\n  if (m = Math.sqrt(h * h + l * l + o * o)) {\n    m = 1 / m;\n    h *= m;\n    l *= m;\n    o *= m;\n  } else o = l = h = 0;\n\n  d[0] = k;\n  d[1] = h;\n  d[2] = c;\n  d[3] = 0;\n  d[4] = i;\n  d[5] = l;\n  d[6] = j;\n  d[7] = 0;\n  d[8] = f;\n  d[9] = o;\n  d[10] = b;\n  d[11] = 0;\n  d[12] = -(k * e + i * g + f * a);\n  d[13] = -(h * e + l * g + o * a);\n  d[14] = -(c * e + j * g + b * a);\n  d[15] = 1;\n  return d;\n};\n\nmat4.str = function (a) {\n  return \"[\" + a[0] + \", \" + a[1] + \", \" + a[2] + \", \" + a[3] + \", \" + a[4] + \", \" + a[5] + \", \" + a[6] + \", \" + a[7] + \", \" + a[8] + \", \" + a[9] + \", \" + a[10] + \", \" + a[11] + \", \" + a[12] + \", \" + a[13] + \", \" + a[14] + \", \" + a[15] + \"]\";\n};\n\nquat4 = {};\n\nquat4.create = function (a) {\n  var b = new glMatrixArrayType(4);\n\n  if (a) {\n    b[0] = a[0];\n    b[1] = a[1];\n    b[2] = a[2];\n    b[3] = a[3];\n  }\n\n  return b;\n};\n\nquat4.set = function (a, b) {\n  b[0] = a[0];\n  b[1] = a[1];\n  b[2] = a[2];\n  b[3] = a[3];\n  return b;\n};\n\nquat4.calculateW = function (a, b) {\n  var c = a[0],\n      d = a[1],\n      e = a[2];\n\n  if (!b || a == b) {\n    a[3] = -Math.sqrt(Math.abs(1 - c * c - d * d - e * e));\n    return a;\n  }\n\n  b[0] = c;\n  b[1] = d;\n  b[2] = e;\n  b[3] = -Math.sqrt(Math.abs(1 - c * c - d * d - e * e));\n  return b;\n};\n\nquat4.inverse = function (a, b) {\n  if (!b || a == b) {\n    a[0] *= 1;\n    a[1] *= 1;\n    a[2] *= 1;\n    return a;\n  }\n\n  b[0] = -a[0];\n  b[1] = -a[1];\n  b[2] = -a[2];\n  b[3] = a[3];\n  return b;\n};\n\nquat4.length = function (a) {\n  var b = a[0],\n      c = a[1],\n      d = a[2];\n  a = a[3];\n  return Math.sqrt(b * b + c * c + d * d + a * a);\n};\n\nquat4.normalize = function (a, b) {\n  b || (b = a);\n  var c = a[0],\n      d = a[1],\n      e = a[2],\n      g = a[3],\n      f = Math.sqrt(c * c + d * d + e * e + g * g);\n\n  if (f == 0) {\n    b[0] = 0;\n    b[1] = 0;\n    b[2] = 0;\n    b[3] = 0;\n    return b;\n  }\n\n  f = 1 / f;\n  b[0] = c * f;\n  b[1] = d * f;\n  b[2] = e * f;\n  b[3] = g * f;\n  return b;\n};\n\nquat4.multiply = function (a, b, c) {\n  c || (c = a);\n  var d = a[0],\n      e = a[1],\n      g = a[2];\n  a = a[3];\n  var f = b[0],\n      h = b[1],\n      i = b[2];\n  b = b[3];\n  c[0] = d * b + a * f + e * i - g * h;\n  c[1] = e * b + a * h + g * f - d * i;\n  c[2] = g * b + a * i + d * h - e * f;\n  c[3] = a * b - d * f - e * h - g * i;\n  return c;\n};\n\nquat4.multiplyVec3 = function (a, b, c) {\n  c || (c = b);\n  var d = b[0],\n      e = b[1],\n      g = b[2];\n  b = a[0];\n  var f = a[1],\n      h = a[2];\n  a = a[3];\n  var i = a * d + f * g - h * e,\n      j = a * e + h * d - b * g,\n      k = a * g + b * e - f * d;\n  d = -b * d - f * e - h * g;\n  c[0] = i * a + d * -b + j * -h - k * -f;\n  c[1] = j * a + d * -f + k * -b - i * -h;\n  c[2] = k * a + d * -h + i * -f - j * -b;\n  return c;\n};\n\nquat4.toMat3 = function (a, b) {\n  b || (b = mat3.create());\n  var c = a[0],\n      d = a[1],\n      e = a[2],\n      g = a[3],\n      f = c + c,\n      h = d + d,\n      i = e + e,\n      j = c * f,\n      k = c * h;\n  c = c * i;\n  var l = d * h;\n  d = d * i;\n  e = e * i;\n  f = g * f;\n  h = g * h;\n  g = g * i;\n  b[0] = 1 - (l + e);\n  b[1] = k - g;\n  b[2] = c + h;\n  b[3] = k + g;\n  b[4] = 1 - (j + e);\n  b[5] = d - f;\n  b[6] = c - h;\n  b[7] = d + f;\n  b[8] = 1 - (j + l);\n  return b;\n};\n\nquat4.toMat4 = function (a, b) {\n  b || (b = mat4.create());\n  var c = a[0],\n      d = a[1],\n      e = a[2],\n      g = a[3],\n      f = c + c,\n      h = d + d,\n      i = e + e,\n      j = c * f,\n      k = c * h;\n  c = c * i;\n  var l = d * h;\n  d = d * i;\n  e = e * i;\n  f = g * f;\n  h = g * h;\n  g = g * i;\n  b[0] = 1 - (l + e);\n  b[1] = k - g;\n  b[2] = c + h;\n  b[3] = 0;\n  b[4] = k + g;\n  b[5] = 1 - (j + e);\n  b[6] = d - f;\n  b[7] = 0;\n  b[8] = c - h;\n  b[9] = d + f;\n  b[10] = 1 - (j + l);\n  b[11] = 0;\n  b[12] = 0;\n  b[13] = 0;\n  b[14] = 0;\n  b[15] = 1;\n  return b;\n};\n\nquat4.slerp = function (a, b, c, d) {\n  d || (d = a);\n  var e = c;\n  if (a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3] < 0) e = -1 * c;\n  d[0] = 1 - c * a[0] + e * b[0];\n  d[1] = 1 - c * a[1] + e * b[1];\n  d[2] = 1 - c * a[2] + e * b[2];\n  d[3] = 1 - c * a[3] + e * b[3];\n  return d;\n};\n\nquat4.str = function (a) {\n  return \"[\" + a[0] + \", \" + a[1] + \", \" + a[2] + \", \" + a[3] + \"]\";\n};\n\nmodule.exports = {\n  vec3: vec3,\n  mat3: mat3,\n  mat4: mat4,\n  quat4: quat4\n};\n\n//# sourceURL=webpack:///./src/lib/_glMatrix-0.9.5.min.js?");

/***/ }),

/***/ "./src/plugin-webgl/mmd/Physics.js":
/*!*****************************************!*\
  !*** ./src/plugin-webgl/mmd/Physics.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _Inherit = _interopRequireDefault(__webpack_require__(/*! ./_Inherit.js */ \"./src/plugin-webgl/mmd/_Inherit.js\"));\n\nvar _glMatrix095Min = __webpack_require__(/*! lib/_glMatrix-0.9.5.min.js */ \"./src/lib/_glMatrix-0.9.5.min.js\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nfunction PhysicsEntity() {\n  this.workNum = 10;\n  this.workTrs = [];\n  this.workQs = [];\n  this.workVs = [];\n\n  for (var i = 0; i < this.workNum; i++) {\n    this.workTrs[i] = new Ammo.btTransform();\n    this.workQs[i] = new Ammo.btQuaternion();\n    this.workVs[i] = new Ammo.btVector3();\n  }\n}\n\n;\n\nPhysicsEntity.prototype.allocTr = function () {\n  var tr = this.workTrs[this.workTrs.length - 1];\n  this.workTrs.length--;\n  return tr;\n};\n\nPhysicsEntity.prototype.freeTr = function (tr) {\n  this.workTrs[this.workTrs.length] = tr;\n};\n\nPhysicsEntity.prototype.allocQ = function () {\n  var q = this.workQs[this.workQs.length - 1];\n  this.workQs.length--;\n  return q;\n};\n\nPhysicsEntity.prototype.freeQ = function (q) {\n  this.workQs[this.workQs.length] = q;\n};\n\nPhysicsEntity.prototype.allocV = function () {\n  var v = this.workVs[this.workVs.length - 1];\n  this.workVs.length--;\n  return v;\n};\n\nPhysicsEntity.prototype.freeV = function (v) {\n  this.workVs[this.workVs.length] = v;\n};\n/**\n * TODO: temporal\n * @return btTransform\n */\n\n\nPhysicsEntity.prototype._newTransform = function () {\n  return new Ammo.btTransform();\n};\n/**\n * TODO: temporal\n */\n\n\nPhysicsEntity.prototype._setIdentity = function (tr) {\n  tr.setIdentity();\n};\n/**\n * TODO: temporal\n * @param tr btTransform i\n */\n\n\nPhysicsEntity.prototype._getBasis = function (tr) {\n  var q = this.allocQ();\n  tr.getBasis().getRotation(q);\n  return q;\n};\n/**\n * TODO: temporal\n * @param tr btTransform i\n */\n\n\nPhysicsEntity.prototype._getBasisMatrix3 = function (tr) {\n  var q = this._getBasis(tr);\n\n  var m = this._quaternionToMatrix3(q);\n\n  this.freeQ(q);\n  return m;\n};\n/**\n * TODO: temporal\n * @param tr btTransform i/o\n * @param q btQuaternion i\n */\n\n\nPhysicsEntity.prototype._setBasis = function (tr, q) {\n  tr.setRotation(q); //  var p = this._quaternionToEulerZYX(q);\n  //  tr.getBasis().setEulerZYX(p[0], p[1], p[2]);\n};\n/**\n * TODO: temporal\n * @param tr btTransform i/o\n * @param m array[9] i\n */\n\n\nPhysicsEntity.prototype._setBasisMatrix3 = function (tr, m) {\n  var q = this._matrix3ToQuaternion(m);\n\n  this._setBasis(tr, q);\n\n  this.freeQ(q);\n};\n/**\n * TODO: temporal\n * Note: [x, y, z, w]\n * @param tr btTransform i/o\n * @param a array[4] i\n */\n\n\nPhysicsEntity.prototype._setBasisArray4 = function (tr, a) {\n  var q = this._array4ToQuaternion(a);\n\n  this._setBasis(tr, q);\n\n  this.freeQ(q);\n};\n/**\n * TODO: temporal\n * Note: [x, y, z, w]\n * @param tr btTransform i/o\n * @param a array[4] i\n */\n\n\nPhysicsEntity.prototype._setBasisArray4Left = function (tr, a) {\n  a[0] = -a[0];\n  a[1] = -a[1];\n\n  this._setBasisArray4(tr, a);\n\n  a[0] = -a[0];\n  a[1] = -a[1];\n};\n/**\n * TODO: temporal\n * Note: [x, y, z]\n * @param tr btTransform i/o\n * @param m array[3] i\n */\n\n\nPhysicsEntity.prototype._setBasisArray3 = function (tr, a) {\n  tr.getBasis().setEulerZYX(a[0], a[1], a[2]);\n};\n/**\n * TODO: temporal\n * Note: [x, y, z]\n * @param tr btTransform i/o\n * @param m array[3] i\n */\n\n\nPhysicsEntity.prototype._setBasisArray3Left = function (tr, a) {\n  a[0] = -a[0];\n  a[1] = -a[1];\n\n  this._setBasisArray3(tr, a);\n\n  a[0] = -a[0];\n  a[1] = -a[1];\n};\n/**\n * TODO: temporal\n * @param tr btTransform i\n * @return btVector3\n */\n\n\nPhysicsEntity.prototype._getOrigin = function (tr) {\n  return tr.getOrigin();\n};\n/**\n * TODO: temporal\n * @param tr btTransform i\n * @return array[3]\n */\n\n\nPhysicsEntity.prototype._getOriginArray3 = function (tr) {\n  var o = this._getOrigin(tr);\n\n  return [o.x(), o.y(), o.z()];\n};\n/**\n * TODO: temporal\n * @param tr btTransform i/o\n * @param v btVector3 i\n */\n\n\nPhysicsEntity.prototype._setOrigin = function (tr, v) {\n  tr.getOrigin().setValue(v.x(), v.y(), v.z());\n};\n/**\n * TODO: temporal\n * @param tr btTransform i/o\n * @param a array[3] i\n */\n\n\nPhysicsEntity.prototype._setOriginArray3 = function (tr, a) {\n  tr.getOrigin().setValue(a[0], a[1], a[2]);\n};\n/**\n * TODO: temporal\n * @param tr btTransform i/o\n * @param a array[3] i\n */\n\n\nPhysicsEntity.prototype._setOriginArray3Left = function (tr, a) {\n  a[2] = -a[2];\n\n  this._setOriginArray3(tr, a);\n\n  a[2] = -a[2];\n};\n/**\n * TODO: temporal\n * @param tr btTransform i/o\n * @param x float i\n * @param y float i\n * @param z float i\n */\n\n\nPhysicsEntity.prototype._setOriginFloats = function (tr, x, y, z) {\n  tr.getOrigin().setValue(x, y, z);\n};\n/**\n * TODO: temporal\n * @param tr1 btTransform i/o\n * @param tr2 btTransform i\n */\n\n\nPhysicsEntity.prototype._copyOrigin = function (tr1, tr2) {\n  var o = tr2.getOrigin();\n\n  this._setOrigin(tr1, o);\n};\n/**\n * TODO: temporal\n * @param v1 btVector3 i\n * @param v2 btVector3 i\n * @return btVector3\n */\n\n\nPhysicsEntity.prototype._addVector3 = function (v1, v2) {\n  var v = this.allocV();\n  v.setValue(v1.x() + v2.x(), v1.y() + v2.y(), v1.z() + v2.z());\n  return v;\n};\n/**\n * TODO: temporal\n * @param v btVector3 i\n * @param a array[3]\n * @return btVector3\n */\n\n\nPhysicsEntity.prototype._addVector3ByArray3 = function (v, a) {\n  var v2 = this.allocV();\n  v2.setValue(v.x() + a[0], v.y() + a[1], v.z() + a[2]);\n  return v2;\n};\n/**\n * TODO: temporal\n * @param v1 btVector3 i\n * @param v2 btVector3 i\n * @return float\n */\n\n\nPhysicsEntity.prototype._dotVectors3 = function (v1, v2) {\n  return v1.x() * v2.x() + v1.y() * v2.y() + v1.z() * v2.z();\n};\n/**\n * TODO: temporal\n * @param m array[9] i\n * @param i int i\n * @return btVector3\n */\n\n\nPhysicsEntity.prototype._rowOfMatrix3 = function (m, i) {\n  var v = this.allocV();\n  v.setValue(m[i * 3 + 0], m[i * 3 + 1], m[i * 3 + 2]);\n  return v;\n};\n/**\n * TODO: temporal\n * @param m array[9] i\n * @param i int i\n * @return btVector3\n */\n\n\nPhysicsEntity.prototype._columnOfMatrix3 = function (m, i) {\n  var v = this.allocV();\n  v.setValue(m[i + 0], m[i + 3], m[i + 6]);\n  return v;\n};\n/**\n * TODO: temporal\n * @param v btVector3 i\n * @return btVector3\n */\n\n\nPhysicsEntity.prototype._negativeVector3 = function (v) {\n  var v2 = this.allocV();\n  v2.setValue(-v.x(), -v.y(), -v.z());\n  return v2;\n};\n/**\n * TODO: temporal\n * @param v btVector3 i\n * @return btVector3\n */\n\n\nPhysicsEntity.prototype._cloneVector3 = function (v) {\n  var v2 = this.allocV();\n  v2.setValue(v.x(), v.y(), v.z());\n  return v2;\n};\n/**\n * TODO: temporal\n * @param m array[9]\n * @return array[9]\n */\n\n\nPhysicsEntity.prototype._cloneMatrix3 = function (m) {\n  var m2 = [];\n\n  for (var i = 0; i < 9; i++) {\n    m2[i] = m[i];\n  }\n\n  return m2;\n};\n/**\n * TODO: temporal\n * @param a array[3] i\n * @return btVector3\n */\n\n\nPhysicsEntity.prototype._array3ToVector3 = function (a) {\n  var v = this.allocV();\n  v.setValue(a[0], a[1], a[2]);\n  return v;\n};\n/**\n * TODO: temporal\n * @param v btVector3 i\n * @return array[3]\n */\n\n\nPhysicsEntity.prototype._vector3ToArray3 = function (v) {\n  var a = [];\n  a[0] = v.x();\n  a[1] = v.y();\n  a[2] = v.z();\n  return a;\n};\n/**\n * Note: [x, y, z, w]\n * TODO: temporal\n * @param a array[4]\n * @return btQuaternion\n */\n\n\nPhysicsEntity.prototype._array4ToQuaternion = function (a) {\n  var q = this.allocQ();\n  q.setX(a[0]);\n  q.setY(a[1]);\n  q.setZ(a[2]);\n  q.setW(a[3]);\n  return q;\n};\n/**\n * Note: [x, y, z, w]\n * TODO: temporal\n * @param q btQuaternion\n * @return array[4]\n */\n\n\nPhysicsEntity.prototype._quaternionToArray4 = function (q) {\n  var a = [q.x(), q.y(), q.z(), q.w()];\n  return a;\n};\n/**\n * TODO: implement correctly\n * TODO: temporal\n * @param q btQuaternion i\n * @return array[3]\n */\n\n\nPhysicsEntity.prototype._quaternionToEulerZYX = function (q) {\n  var qw = q.w();\n  var qx = q.x();\n  var qy = q.y();\n  var qz = q.z();\n  var qw2 = qw * qw;\n  var qx2 = qx * qx;\n  var qy2 = qy * qy;\n  var qz2 = qz * qz;\n  var test = qx * qy + qz * qw;\n  var yaw, pitch, roll;\n\n  if (test > 0.499) {\n    roll = 360 / Math.PI * Math.atan2(qx, qw);\n    pitch = 90;\n    yaw = 0;\n  } else if (test < -0.499) {\n    roll = -360 / Math.PI * Math.atan2(qx, qw);\n    pitch = -90;\n    roll = 0;\n  } else {\n    var h = Math.atan2(2 * qy * qw - 2 * qx * qz, 1 - 2 * qy2 - 2 * qz);\n    var a = Math.asin(2 * qx * qy + 2 * qz * qw);\n    var b = Math.atan2(2 * qx * qw - 2 * qy * qz, 1 - 2 * qx2 - 2 * qz);\n    roll = Math.round(h * 180 / Math.PI);\n    pitch = Math.round(a * 180 / Math.PI);\n    yaw = Math.round(b * 180 / Math.PI);\n  }\n\n  return [yaw, roll, pitch];\n  var x2 = q.x() * q.x();\n  var y2 = q.y() * q.y();\n  var z2 = q.z() * q.z();\n  var w2 = q.w() * q.w();\n  var len = x2 + y2 + z2 + w2;\n  var abcd = q.w() * q.x() + q.y() * q.z();\n  var eps = 1e-7;\n  var yaw, pitch, roll;\n\n  if (abcd > (0.5 - eps) * len) {\n    yaw = 2 * Math.atan2(q.y(), q.w());\n    pitch = Math.PI;\n    roll = 0;\n  } else if (abcd < (-0.5 + eps) * len) {\n    yaw = -2 * Math.atan2(q.y(), q.w());\n    pitch = -Math.PI;\n    roll = 0;\n  } else {\n    var adbc = q.w() * q.z() - q.x() * q.y();\n    var acbd = q.w() * q.y() - q.x() * q.z();\n    yaw = Math.atan2(2 * adbc, 1 - 2 * (z2 + x2));\n    pitch = Math.asin(2 * abcd / len);\n    roll = Math.atan2(2 * acbd, 1 - 2 * (y2 + x2));\n  }\n\n  return [roll, pitch, yaw]; //  return [yaw, pitch, roll];\n};\n/**\n * origin = tr1.basis * tr2.origin + tr1.origin\n * basis = tr1.basis * tr2.basis\n * TODO: temporal\n * @param tr1 btTransform i\n * @param tr2 btTransform i\n * @return btTransform\n */\n\n\nPhysicsEntity.prototype._multiplyTransforms = function (tr1, tr2) {\n  var tr = this.allocTr();\n  tr.setIdentity();\n\n  var m1 = this._getBasisMatrix3(tr1);\n\n  var m2 = this._getBasisMatrix3(tr2);\n\n  var o1 = this._getOrigin(tr1);\n\n  var o2 = this._getOrigin(tr2);\n\n  var v1 = this._multiplyMatrix3ByVector3(m1, o2);\n\n  var v2 = this._addVector3(v1, o1);\n\n  this._setOrigin(tr, v2);\n\n  var m3 = this._multiplyMatrices3(m1, m2);\n\n  this._setBasisMatrix3(tr, m3);\n\n  this.freeV(v1);\n  this.freeV(v2);\n  return tr;\n};\n/**\n * origin = tr.basis.transpose * -tr.origin\n * basis = tr.basis.transpose\n * TODO: temporal\n * @param tr btTransform i\n * @return btTransform\n */\n\n\nPhysicsEntity.prototype._inverseTransform = function (tr) {\n  var tr2 = this.allocTr();\n\n  var m1 = this._getBasisMatrix3(tr);\n\n  var o = this._getOrigin(tr);\n\n  var m2 = this._transposeMatrix3(m1);\n\n  var v1 = this._negativeVector3(o);\n\n  var v2 = this._multiplyMatrix3ByVector3(m2, v1);\n\n  this._setOrigin(tr2, v2);\n\n  this._setBasisMatrix3(tr2, m2);\n\n  this.freeV(v1);\n  this.freeV(v2);\n  return tr2;\n};\n/**\n * tr.basis * v1 + tr.origin\n * TODO: temporal\n * @param tr btTransform i\n * @param v btVector3 i\n * @return btVector3\n */\n\n\nPhysicsEntity.prototype._multiplyTransformByVector3 = function (tr, v) {\n  var m = this._getBasisMatrix3(tr);\n\n  var o = this._getOrigin(tr);\n\n  var v2 = this._multiplyMatrix3ByVector3(m, v);\n\n  var v3 = this._addVector3(v2, o);\n\n  this.freeV(v2);\n  return v3;\n};\n/**\n * TODO: temporal\n * @param m array[9] i\n * @param v btVector3 i\n * @return btVector3\n */\n\n\nPhysicsEntity.prototype._multiplyMatrix3ByVector3 = function (m, v) {\n  var v4 = this.allocV();\n\n  var v0 = this._rowOfMatrix3(m, 0);\n\n  var v1 = this._rowOfMatrix3(m, 1);\n\n  var v2 = this._rowOfMatrix3(m, 2);\n\n  var x = this._dotVectors3(v0, v);\n\n  var y = this._dotVectors3(v1, v);\n\n  var z = this._dotVectors3(v2, v);\n\n  v4.setValue(x, y, z);\n  this.freeV(v0);\n  this.freeV(v1);\n  this.freeV(v2);\n  return v4;\n};\n/**\n * TODO: temporal\n * @param m1 array[9] i\n * @param m2 array[9] i\n * @return array[9]\n */\n\n\nPhysicsEntity.prototype._multiplyMatrices3 = function (m1, m2) {\n  var m3 = [];\n\n  var v10 = this._rowOfMatrix3(m1, 0);\n\n  var v11 = this._rowOfMatrix3(m1, 1);\n\n  var v12 = this._rowOfMatrix3(m1, 2);\n\n  var v20 = this._columnOfMatrix3(m2, 0);\n\n  var v21 = this._columnOfMatrix3(m2, 1);\n\n  var v22 = this._columnOfMatrix3(m2, 2);\n\n  m3[0] = this._dotVectors3(v10, v20);\n  m3[1] = this._dotVectors3(v10, v21);\n  m3[2] = this._dotVectors3(v10, v22);\n  m3[3] = this._dotVectors3(v11, v20);\n  m3[4] = this._dotVectors3(v11, v21);\n  m3[5] = this._dotVectors3(v11, v22);\n  m3[6] = this._dotVectors3(v12, v20);\n  m3[7] = this._dotVectors3(v12, v21);\n  m3[8] = this._dotVectors3(v12, v22);\n  this.freeV(v10);\n  this.freeV(v11);\n  this.freeV(v12);\n  this.freeV(v20);\n  this.freeV(v21);\n  this.freeV(v22);\n  return m3;\n};\n/**\n * TODO: temporal\n * Note: 0 1 2\n *       3 4 5\n *       6 7 8\n * @param m array[9] i\n * @return array[9]\n */\n\n\nPhysicsEntity.prototype._transposeMatrix3 = function (m) {\n  var m2 = [];\n  m2[0] = m[0];\n  m2[1] = m[3];\n  m2[2] = m[6];\n  m2[3] = m[1];\n  m2[4] = m[4];\n  m2[5] = m[7];\n  m2[6] = m[2];\n  m2[7] = m[5];\n  m2[8] = m[8];\n  return m2;\n};\n/**\n * TODO: temporal\n * Note: 0 1 2  00 01 02  a b c\n *       3 4 5  10 11 12  d e f\n *       6 7 8  20 21 22  g h i\n * @param m array[9] i\n * @return array[9]\n */\n\n\nPhysicsEntity.prototype._inverseMatrix3 = function (m) {\n  var m00 = m[0];\n  var m01 = m[1];\n  var m02 = m[2];\n  var m10 = m[3];\n  var m11 = m[4];\n  var m12 = m[5];\n  var m20 = m[6];\n  var m21 = m[7];\n  var m22 = m[8];\n  var det = m00 * m11 * m22 + m10 * m21 * m02 + m20 * m01 * m12 - m20 * m11 * m02 - m10 * m01 * m22 - m00 * m21 * m12;\n  if (det == 0) return this._cloneMatrix3(m);\n  var m2 = [];\n  m2[0] = (m11 * m22 - m12 * m21) / det;\n  m2[1] = (m02 * m21 - m01 * m22) / det;\n  m2[2] = (m01 * m12 - m02 * m11) / det;\n  m2[3] = (m12 * m20 - m10 * m22) / det;\n  m2[4] = (m00 * m22 - m02 * m20) / det;\n  m2[5] = (m02 * m10 - m00 * m12) / det;\n  m2[6] = (m10 * m21 - m11 * m20) / det;\n  m2[7] = (m01 * m20 - m00 * m21) / det;\n  m2[8] = (m00 * m11 - m01 * m10) / det;\n  return m2;\n};\n/**\n * TODO: temporal\n * Note: 0 1 2\n *       3 4 5\n *       6 7 8\n * @param q btQuaternion i\n * @return array[9]\n */\n\n\nPhysicsEntity.prototype._quaternionToMatrix3 = function (q) {\n  var q2 = _glMatrix095Min.quat4.create();\n\n  q2[0] = q.x();\n  q2[1] = q.y();\n  q2[2] = q.z();\n  q2[3] = q.w();\n  return _glMatrix095Min.quat4.toMat3(q2);\n};\n/**\n * TODO: temporal\n * Note: 0 1 2   00 01 02\n *       3 4 5   10 11 12\n *       6 7 8   20 21 22\n * @param m array[9] i\n * @return btQuaternion\n */\n\n\nPhysicsEntity.prototype._matrix3ToQuaternion = function (m) {\n  var t = m[0] + m[4] + m[8];\n  var s, x, y, z, w;\n\n  if (t > 0) {\n    s = Math.sqrt(t + 1.0) * 2;\n    w = 0.25 * s;\n    x = (m[7] - m[5]) / s;\n    y = (m[2] - m[6]) / s;\n    z = (m[3] - m[1]) / s;\n  } else if (m[0] > m[4] && m[0] > m[8]) {\n    s = Math.sqrt(1.0 + m[0] - m[4] - m[8]) * 2;\n    w = (m[7] - m[5]) / s;\n    x = 0.25 * s;\n    y = (m[1] + m[3]) / s;\n    z = (m[2] + m[6]) / s;\n  } else if (m[4] > m[8]) {\n    s = Math.sqrt(1.0 + m[4] - m[0] - m[8]) * 2;\n    w = (m[2] - m[6]) / s;\n    x = (m[1] + m[3]) / s;\n    y = 0.25 * s;\n    z = (m[5] + m[7]) / s;\n  } else {\n    s = Math.sqrt(1.0 + m[8] - m[0] - m[4]) * 2;\n    w = (m[3] - m[1]) / s;\n    x = (m[2] + m[6]) / s;\n    y = (m[5] + m[7]) / s;\n    z = 0.25 * s;\n  }\n\n  var q = this.allocQ();\n  q.setX(x);\n  q.setY(y);\n  q.setZ(z);\n  q.setW(w);\n  return q;\n};\n\nPhysicsEntity.prototype._dumpTransform = function (tr) {\n  var q = this._getBasis(tr);\n\n  var str = '';\n  str += '-- origin --\\n';\n  str += this._getOriginArray3(tr).toString() + '\\n';\n  str += '-- quaternion --\\n';\n  str += [q.x(), q.y(), q.z(), q.w()].toString() + '\\n';\n  str += '-- matrix --\\n';\n  str += this._dumpMatrix3(this._getBasisMatrix3(tr));\n  this.freeQ(q);\n  return str;\n};\n\nPhysicsEntity.prototype._dumpMatrix3 = function (m) {\n  var str = '';\n\n  for (var i = 0; i < 3; i++) {\n    str += [m[i * 3 + 0], m[i * 3 + 1], m[i * 3 + 2]].toString() + ',\\n';\n  }\n\n  return str;\n};\n\nfunction PhysicsRigidBody(pmd, world, body) {\n  this.parent = PhysicsEntity;\n  this.parent.call(this);\n  this.pmd = pmd;\n  this.world = world;\n  this.body = body;\n  this.rb = null;\n  this.bone = null;\n  this.form = null;\n  this.boneForm = null;\n  this.boneOffsetForm = null;\n  this.boneOffsetFormInverse = null;\n\n  this._init();\n}\n\n;\n(0, _Inherit[\"default\"])(PhysicsRigidBody, PhysicsEntity);\n/**\n * TODO: temporal\n */\n\nPhysicsRigidBody.prototype._init = function () {\n  var body = this.body;\n  var bone = this.pmd.bones[body.boneIndex];\n\n  var shape = this._generateShape(body);\n\n  var weight = body.type == 0 ? 0 : body.weight;\n  var localInertia = this.allocV();\n  localInertia.setValue(0, 0, 0);\n  if (weight != 0) shape.calculateLocalInertia(weight, localInertia);\n  var boneOffsetForm = this.allocTr();\n\n  this._setIdentity(boneOffsetForm);\n\n  this._setOriginArray3Left(boneOffsetForm, body.position);\n\n  this._setBasisArray3Left(boneOffsetForm, body.rotation);\n\n  var boneForm = this.allocTr();\n\n  this._setIdentity(boneForm); // TODO: temporal workaround\n\n\n  var pos = this.body.boneIndex == 0xFFFF ? [0, 0, 0] : bone.position;\n\n  this._setOriginArray3Left(boneForm, pos);\n\n  var form = this._multiplyTransforms(boneForm, boneOffsetForm);\n\n  var state = new Ammo.btDefaultMotionState(form);\n  var info = new Ammo.btRigidBodyConstructionInfo(weight, state, shape, localInertia);\n  info.set_m_friction(body.friction);\n  info.set_m_restitution(body.recoil);\n  var rb = new Ammo.btRigidBody(info);\n\n  if (body.type == 0) {\n    rb.setCollisionFlags(rb.getCollisionFlags() | 2);\n    rb.setActivationState(4);\n  }\n\n  rb.setDamping(body.positionDim, body.rotationDim);\n  rb.setSleepingThresholds(0, 0);\n  this.world.addRigidBody(rb, 1 << body.groupIndex, body.groupTarget);\n  this.rb = rb;\n  this.bone = bone;\n  this.boneOffsetForm = boneOffsetForm;\n  this.boneOffsetFormInverse = this._inverseTransform(boneOffsetForm);\n  this.freeV(localInertia);\n  this.freeTr(form);\n  this.freeTr(boneForm);\n};\n\nPhysicsRigidBody.prototype._generateShape = function (b) {\n  switch (b.shapeType) {\n    case 0:\n      return new Ammo.btSphereShape(b.width);\n\n    case 1:\n      return new Ammo.btBoxShape(new Ammo.btVector3(b.width, b.height, b.depth));\n\n    case 2:\n      return new Ammo.btCapsuleShape(b.width, b.height);\n\n    default:\n      throw 'unknown shape type.' + b;\n  }\n};\n\nPhysicsRigidBody.prototype.reset = function (motions) {\n  this._setTransformFromBone(motions);\n};\n\nPhysicsRigidBody.prototype.preSimulation = function (motions) {\n  // TODO: temporal workaround\n  if (this.body.boneIndex == 0xFFFF) return;\n  if (this.body.type == 0\n  /* && this.body.boneIndex != 0*/\n  ) this._setTransformFromBone(motions);\n  if (this.body.type == 2\n  /* && this.body.boneIndex != 0*/\n  ) this._setPositionFromBone(motions);\n};\n\nPhysicsRigidBody.prototype._setTransformFromBone = function (motions) {\n  var m = motions[this.body.boneIndex]; // TODO: temporal workaround\n\n  if (this.body.boneIndex == 0xFFFF) {\n    m = {\n      p: [0, 0, 0],\n      r: [0, 0, 0, 1]\n    };\n  }\n\n  var tr = this.allocTr();\n\n  this._setOriginArray3Left(tr, m.p);\n\n  this._setBasisArray4Left(tr, m.r);\n\n  var form = this._multiplyTransforms(tr, this.boneOffsetForm); // TODO: temporal\n  //  this.rb.setWorldTransform(form);\n\n\n  this.rb.setCenterOfMassTransform(form);\n  this.rb.getMotionState().setWorldTransform(form);\n  this.freeTr(tr);\n  this.freeTr(form);\n};\n\nPhysicsRigidBody.prototype._setPositionFromBone = function (motions) {\n  var m = motions[this.body.boneIndex];\n  var tr = this.allocTr();\n\n  this._setOriginArray3Left(tr, m.p);\n\n  this._setBasisArray4Left(tr, m.r);\n\n  var form = this._multiplyTransforms(tr, this.boneOffsetForm);\n\n  var tr2 = this.allocTr();\n  this.rb.getMotionState().getWorldTransform(tr2);\n\n  this._copyOrigin(tr2, form); // TODO: temporal\n  //  this.rb.setWorldTransform(tr2);\n\n\n  this.rb.setCenterOfMassTransform(tr2);\n  this.rb.getMotionState().setWorldTransform(tr2);\n  this.freeTr(tr);\n  this.freeTr(tr2);\n  this.freeTr(form);\n};\n\nPhysicsRigidBody.prototype.postSimulation = function (motions) {\n  // debugger;\n  // TODO: temporal workaround\n  if (this.body.type == 0 || this.body.boneIndex == 0xFFFF) return;\n  var m = motions[this.body.boneIndex];\n  var tr = this.allocTr();\n  this.rb.getMotionState().getWorldTransform(tr);\n\n  var tr2 = this._multiplyTransforms(tr, this.boneOffsetFormInverse);\n\n  var q = this._getBasis(tr2); // Right to Left\n\n\n  m.r[0] = -q.x(); // 新的速度? \n\n  m.r[1] = -q.y();\n  m.r[2] = q.z();\n  m.r[3] = q.w(); // __pmdModelView.physics.bodies.forEach((b)=>{\n  //   console.log(b.body.name === this.body.name);\n  // })\n\n  if (this.body.type == 1) {\n    var o = this._getOrigin(tr2); // Right to Left\n\n\n    m.p[0] = o.x(); // 新的速度? \n\n    m.p[1] = o.y();\n    m.p[2] = -o.z();\n  }\n\n  this.freeQ(q);\n  this.freeTr(tr);\n  this.freeTr(tr2);\n};\n\nfunction PhysicsConstraint(pmd, world, joint, bodyA, bodyB) {\n  this.parent = PhysicsEntity;\n  this.parent.call(this);\n  this.pmd = pmd;\n  this.world = world;\n  this.joint = joint;\n  this.bodyA = bodyA;\n  this.bodyB = bodyB;\n  this.constraint = null;\n  this.boneOffsetForm = null;\n  this.boneOffsetFormInverse = null;\n\n  this._init();\n}\n\n;\n(0, _Inherit[\"default\"])(PhysicsConstraint, PhysicsEntity);\n/**\n * TODO: temporal\n */\n\nPhysicsConstraint.prototype._init = function () {\n  var joint = this.joint;\n  var rb1 = this.bodyA.rb;\n  var rb2 = this.bodyB.rb;\n  var body1 = this.bodyA.body;\n  var body2 = this.bodyB.body;\n\n  if (body1.type !== 0 && body2.type == 2) {\n    if (body1.boneIndex > 0 && body2.boneIndex > 0 && body1.boneIndex != 0xFFFF && body2.boneIndex != 0xFFFF) {\n      var b1 = this.pmd.bones[body1.boneIndex];\n      var b2 = this.pmd.bones[body2.boneIndex];\n\n      if (b2.parentIndex == b1.id) {\n        body2.type = 1;\n      }\n    }\n  }\n\n  var form = this.allocTr();\n\n  this._setOriginArray3Left(form, joint.position);\n\n  this._setBasisArray3Left(form, joint.rotation);\n\n  var r1Form = rb1.getWorldTransform();\n  var r2Form = rb2.getWorldTransform();\n\n  var r1FormInverse = this._inverseTransform(r1Form);\n\n  var r2FormInverse = this._inverseTransform(r2Form);\n\n  var r1Form2 = this._multiplyTransforms(r1FormInverse, form);\n\n  var r2Form2 = this._multiplyTransforms(r2FormInverse, form);\n\n  var constraint = new Ammo.btGeneric6DofSpringConstraint(rb1, rb2, r1Form2, r2Form2, true); // Left to Right\n\n  var lll = this.allocV();\n  var lul = this.allocV();\n  var all = this.allocV();\n  var aul = this.allocV();\n  lll.setValue(joint.translationLimitation1[0], joint.translationLimitation1[1], -joint.translationLimitation2[2]);\n  lul.setValue(joint.translationLimitation2[0], joint.translationLimitation2[1], -joint.translationLimitation1[2]);\n  all.setValue(-joint.rotationLimitation2[0], -joint.rotationLimitation2[1], joint.rotationLimitation1[2]);\n  aul.setValue(-joint.rotationLimitation1[0], -joint.rotationLimitation1[1], joint.rotationLimitation2[2]);\n  constraint.setLinearLowerLimit(lll);\n  constraint.setLinearUpperLimit(lul);\n  constraint.setAngularLowerLimit(all);\n  constraint.setAngularUpperLimit(aul);\n\n  for (var i = 0; i < 3; i++) {\n    if (joint.springPosition[i] != 0) {\n      constraint.enableSpring(i, true);\n      constraint.setStiffness(i, joint.springPosition[i]);\n    }\n  }\n\n  for (var i = 0; i < 3; i++) {\n    if (joint.springRotation[i] != 0) {\n      constraint.enableSpring(i + 3, true);\n      constraint.setStiffness(i + 3, joint.springRotation[i]);\n    }\n  }\n\n  this.world.addConstraint(constraint, true);\n  this.constraint = constraint;\n  this.freeTr(form);\n  Ammo.destroy(r1Form);\n  Ammo.destroy(r2Form);\n  this.freeTr(r1FormInverse);\n  this.freeTr(r2FormInverse);\n  this.freeTr(r1Form2);\n  this.freeTr(r2Form2);\n  this.freeV(lll);\n  this.freeV(lul);\n  this.freeV(all);\n  this.freeV(aul);\n};\n\nfunction Physics(pmd) {\n  this.pmd = pmd;\n  this.world = null;\n  this.bodies = [];\n  this.constraints = [];\n  this.count = 0;\n\n  this._init();\n}\n\n;\n\nPhysics.prototype._init = function () {\n  this.world = this._generateWorld(); //  this.world.addRigidBody(this._generateGround());\n\n  this.bodies.length = 0;\n\n  for (var i = 0; i < this.pmd.rigidBodyCount; i++) {\n    this.bodies.push(new PhysicsRigidBody(this.pmd, this.world, this.pmd.rigidBodies[i]));\n  }\n\n  this.constraints.length = 0;\n\n  for (var i = 0; i < this.pmd.jointCount; i++) {\n    var joint = this.pmd.joints[i];\n    var bodyA = this.bodies[joint.rigidBody1];\n    var bodyB = this.bodies[joint.rigidBody2];\n    this.constraints.push(new PhysicsConstraint(this.pmd, this.world, joint, bodyA, bodyB));\n  }\n};\n\nPhysics.prototype._generateWorld = function () {\n  var config = new Ammo.btDefaultCollisionConfiguration();\n  var dispatcher = new Ammo.btCollisionDispatcher(config);\n  var cache = new Ammo.btDbvtBroadphase();\n  var solver = new Ammo.btSequentialImpulseConstraintSolver();\n  var world = new Ammo.btDiscreteDynamicsWorld(dispatcher, cache, solver, config);\n  world.setGravity(new Ammo.btVector3(0, -10 * 10, 0));\n  return world;\n};\n\nPhysics.prototype._generateGround = function () {\n  var form = new Ammo.btTransform();\n  form.setIdentity();\n  form.setOrigin(new Ammo.btVector3(0, -1, 0));\n  return new Ammo.btRigidBody(new Ammo.btRigidBodyConstructionInfo(0, new Ammo.btDefaultMotionState(form), new Ammo.btBoxShape(new Ammo.btVector3(5, 1, 5)), new Ammo.btVector3(0, 0, 0)));\n};\n\nPhysics.prototype.simulate = function (motions, dframe) {\n  // !!!!\n  this._preSimulation(motions); // 计算之前\n\n\n  this.world.stepSimulation(1 / 60, 0, 1 / 60);\n\n  this._postSimulation(motions); // 执行之后\n\n};\n/**\n * TODO: temporal\n */\n\n\nPhysics.prototype.simulateFrame = function (motions, dframe) {\n  var g;\n  var stepTime = 1 / 60 * dframe;\n  var maxStepNum = dframe;\n  var unitStep = 1 / 60; // Note: sacrifice some precision for the performance\n\n  if (dframe >= 3) {\n    maxStepNum = 2;\n    unitStep = 1 / 60 * 2;\n    g = this.world.getGravity();\n    g.setY(-10 * 10 / 2);\n    this.world.setGravity(g);\n  }\n\n  this._preSimulation(motions);\n\n  this.world.stepSimulation(stepTime, maxStepNum, unitStep);\n\n  this._postSimulation(motions);\n\n  if (dframe >= 3) {\n    g.setY(-10 * 10);\n    this.world.setGravity(g);\n    Ammo.destroy(g); // TODO: is this necessary?\n  }\n};\n\nPhysics.prototype._preSimulation = function (motions) {\n  for (var i = 0; i < this.bodies.length; i++) {\n    this.bodies[i].preSimulation(motions);\n  }\n};\n\nPhysics.prototype._postSimulation = function (motions) {\n  for (var i = 0; i < this.bodies.length; i++) {\n    this.bodies[i].postSimulation(motions);\n  }\n};\n\nPhysics.prototype.resetRigidBodies = function (motions) {\n  for (var i = 0; i < this.bodies.length; i++) {\n    this.bodies[i].reset(motions);\n  }\n};\n\nmodule.exports = Physics;\n\n//# sourceURL=webpack:///./src/plugin-webgl/mmd/Physics.js?");

/***/ }),

/***/ "./src/plugin-webgl/mmd/Pmd.js":
/*!*************************************!*\
  !*** ./src/plugin-webgl/mmd/Pmd.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n/**\n * instance of classes in this file should be created and\n * their fields should be set by PMDFileParser.\n * TODO: rename fields to appropriate ones.\n */\nfunction PMD() {\n  this.header = null;\n  this.englishHeader = null;\n  this.vertexCount = null;\n  this.vertexIndexCount = null;\n  this.materialCount = null;\n  this.boneCount = null;\n  this.ikCount = null;\n  this.faceCount = null;\n  this.faceDisplayCount = null;\n  this.boneFrameNameCount = null;\n  this.boneDisplayCount = null;\n  this.toonTextureCount = null;\n  this.rigidBodyCount = null;\n  this.jointCount = null;\n  this.vertices = [];\n  this.vertexIndices = [];\n  this.materials = [];\n  this.bones = [];\n  this.iks = [];\n  this.faces = [];\n  this.faceDisplays = [];\n  this.boneFrameNames = [];\n  this.boneDisplays = [];\n  this.englishBoneNames = [];\n  this.englishFaceNames = [];\n  this.englishBoneFrameNames = [];\n  this.toonTextures = [];\n  this.rigidBodies = [];\n  this.joints = [];\n  this.bonesHash = {};\n  this.facesHash = {};\n  this.images = [];\n  this.toonImages = [];\n  this.sphereImages = [];\n  this.centerBone = {};\n  this.leftFootBone = {};\n  this.rightFootBone = {};\n  this.leftEyeBone = {};\n  this.rightEyeBone = {};\n}\n\n;\n\nPMD.prototype.valid = function () {\n  return this.header.valid();\n};\n\nPMD.prototype.getParentBone = function (bone) {\n  return this.bones[bone.parentIndex];\n};\n\nPMD.prototype.loadImages = function (baseURL, callback) {\n  var loader = new PMDImageLoader(this, baseURL);\n  loader.load(callback);\n};\n\nPMD.prototype.setup = function () {\n  for (var i = 0; i < this.vertexCount; i++) {\n    this.vertices[i].setup();\n  }\n\n  for (var i = 0; i < this.boneCount; i++) {\n    this.bonesHash[this.bones[i].name] = this.bones[i];\n  }\n\n  for (var i = 0; i < this.faceCount; i++) {\n    this.facesHash[this.faces[i].name] = this.faces[i];\n  } //  this.toRight();\n\n\n  this._keepSomeBonesInfo();\n};\n\nPMD.prototype.toRight = function () {\n  for (var i = 0; i < this.vertexCount; i++) {\n    this.vertices[i].toRight();\n  }\n\n  for (var i = 0; i < this.boneCount; i++) {\n    this.bones[i].toRight();\n  }\n\n  for (var i = 0; i < this.faceCount; i++) {\n    this.faces[i].toRight();\n  }\n\n  for (var i = 0; i < this.rigidBodyCount; i++) {\n    this.rigidBodies[i].toRight();\n  }\n\n  for (var i = 0; i < this.jointCount; i++) {\n    this.joints[i].toRight();\n  }\n};\n/**\n * TODO: change strings if sjis-lib is used\n */\n\n\nPMD.prototype._keepSomeBonesInfo = function () {\n  // �Z���^�[, ������, �E����, ����, �E��\n  this._keepBoneInfo(this.centerBone, '0x830x5a0x830x930x830x5e0x810x5b');\n\n  this._keepBoneInfo(this.leftFootBone, '0x8d0xb60x910xab0x8e0xf1');\n\n  this._keepBoneInfo(this.rightFootBone, '0x890x450x910xab0x8e0xf1');\n\n  this._keepBoneInfo(this.leftEyeBone, '0x8d0xb60x960xda');\n\n  this._keepBoneInfo(this.rightEyeBone, '0x890x450x960xda');\n};\n\nPMD.prototype._keepBoneInfo = function (obj, name) {\n  var boneNum = this._findBoneNumberByName(name);\n\n  if (boneNum !== null) {\n    var bone = this.bones[boneNum];\n    obj.pos = this._getAveragePositionOfBone(bone);\n    obj.id = boneNum;\n    obj.bone = bone;\n    obj.posFromBone = [];\n    obj.posFromBone[0] = obj.pos[0] - bone.position[0];\n    obj.posFromBone[1] = obj.pos[1] - bone.position[1];\n    obj.posFromBone[2] = obj.pos[2] - bone.position[2];\n  } else {\n    obj.pos = null;\n    obj.id = null;\n    obj.bone = null;\n    obj.posFromBone = null;\n  }\n};\n\nPMD.prototype._findBoneNumberByName = function (name) {\n  for (var i = 0; i < this.boneCount; i++) {\n    if (this.bones[i].name == name) return i;\n  }\n\n  return null;\n};\n/**\n * TODO: consider the algorithm again.\n */\n\n\nPMD.prototype._getAveragePositionOfBone = function (bone) {\n  var num = 0;\n  var pos = [0, 0, 0];\n\n  for (var i = 0; i < this.vertexCount; i++) {\n    var v = this.vertices[i]; // TODO: consider boneWeight?\n\n    if (v.boneIndices[0] == bone.id || v.boneIndices[1] == bone.id) {\n      pos[0] += v.position[0];\n      pos[1] += v.position[1];\n      pos[2] += v.position[2];\n      num++;\n    }\n    /*\n        if(v.boneIndices[0] == bone.id) {\n          pos[0] += v.position[0] * (v.boneIndex / 100);\n          pos[1] += v.position[1] * (v.boneIndex / 100);\n          pos[2] += v.position[2] * (v.boneIndex / 100);\n          num++;\n        } else if(v.boneIndices[1] == bone.id) {\n          pos[0] += v.position[0] * ((100 - v.boneIndex) / 100);\n          pos[1] += v.position[1] * ((100 - v.boneIndex) / 100);\n          pos[2] += v.position[2] * ((100 - v.boneIndex) / 100);\n          num++;\n        }\n    */\n\n  }\n\n  if (num != 0) {\n    pos[0] = pos[0] / num;\n    pos[1] = pos[1] / num;\n    pos[2] = pos[2] / num;\n  }\n\n  return pos;\n};\n\nPMD.prototype.getBoneNames = function () {\n  var array = [];\n\n  for (var i = 0; i < this.boneCount; i++) {\n    array[i] = this.bones[i].name;\n  }\n\n  return array;\n};\n\nPMD.prototype.getFaceNames = function () {\n  var array = [];\n\n  for (var i = 0; i < this.faceCount; i++) {\n    array[i] = this.faces[i].name;\n  }\n\n  return array;\n};\n\nPMD.prototype.dump = function () {\n  var str = '';\n  str += 'vertexCount: ' + this.vertexCount + '\\n';\n  str += 'vertexIndexCount: ' + this.vertexIndexCount + '\\n';\n  str += 'materialCount: ' + this.materialCount + '\\n';\n  str += 'boneCount: ' + this.boneCount + '\\n';\n  str += 'ikCount: ' + this.ikCount + '\\n';\n  str += 'faceCount: ' + this.faceCount + '\\n';\n  str += 'faceDisplayCount: ' + this.faceDisplayCount + '\\n';\n  str += 'boneFrameNameCount: ' + this.boneFrameNameCount + '\\n';\n  str += 'boneDisplayCount: ' + this.boneDisplayCount + '\\n';\n  str += 'toonTextureCount: ' + this.toonTextureCount + '\\n';\n  str += 'rigidBodyCount: ' + this.rigidBodyCount + '\\n';\n  str += 'jointCount: ' + this.jointCount + '\\n';\n  str += '\\n';\n  str += this._dumpHeader();\n  str += this._dumpVertices();\n  str += this._dumpVertexIndices();\n  str += this._dumpMaterials();\n  str += this._dumpBones();\n  str += this._dumpIKs();\n  str += this._dumpFaces();\n  str += this._dumpfaceDisplays();\n  str += this._dumpBoneFrameNames();\n  str += this._dumpBoneDisplays();\n  str += this._dumpEnglishHeader();\n  str += this._dumpEnglishBoneNames();\n  str += this._dumpEnglishFaceNames();\n  str += this._dumpToonTextures();\n  str += this._dumpRigidBodies();\n  str += this._dumpJoints();\n  return str;\n};\n\nPMD.prototype.boneNumsOfMaterials = function () {\n  var offset = 0;\n  var result = [];\n\n  for (var i = 0; i < this.materialCount; i++) {\n    var array = [];\n\n    for (var j = 0; j < this.boneCount; j++) {\n      array[j] = 0;\n    }\n\n    var count = 0;\n    var num = this.materials[i].vertexCount;\n\n    for (var j = 0; j < num; j++) {\n      var v = this.vertices[this.vertexIndices[offset + j].index];\n\n      for (var k = 0; k < v.boneIndices.length; k++) {\n        var index = v.boneIndices[k];\n        if (array[index] == 0) count++;\n        array[index]++;\n      }\n    }\n\n    result.push(count);\n    offset += num;\n  }\n\n  return result;\n};\n\nPMD.prototype._dumpHeader = function () {\n  var str = '';\n  str += '-- Header --\\n';\n  str += this.header.dump();\n  str += '\\n';\n  return str;\n};\n\nPMD.prototype._dumpEnglishHeader = function () {\n  var str = '';\n  str += '-- Header(English) --\\n';\n  str += this.englishHeader.dump();\n  str += '\\n';\n  return str;\n};\n\nPMD.prototype._dumpVertices = function () {\n  var str = '';\n  str += '-- Vertices --\\n';\n\n  for (var i = 0; i < this.vertexCount; i++) {\n    str += this.vertices[i].dump();\n  }\n\n  str += '\\n';\n  return str;\n};\n\nPMD.prototype._dumpVertexIndices = function () {\n  var str = '';\n  str += '-- VertexIndices --\\n';\n\n  for (var i = 0; i < this.vertexIndexCount; i++) {\n    str += this.vertexIndices[i].dump();\n  }\n\n  str += '\\n';\n  return str;\n};\n\nPMD.prototype._dumpMaterials = function () {\n  var str = '';\n  str += '-- Materials --\\n';\n\n  for (var i = 0; i < this.materialCount; i++) {\n    str += this.materials[i].dump();\n  }\n\n  str += '\\n';\n  return str;\n};\n\nPMD.prototype._dumpBones = function () {\n  var str = '';\n  str += '-- Bones --\\n';\n\n  for (var i = 0; i < this.boneCount; i++) {\n    str += this.bones[i].dump();\n  }\n\n  str += '\\n';\n  return str;\n};\n\nPMD.prototype._dumpIKs = function () {\n  var str = '';\n  str += '-- IKs --\\n';\n\n  for (var i = 0; i < this.ikCount; i++) {\n    str += this.iks[i].dump();\n  }\n\n  str += '\\n';\n  return str;\n};\n\nPMD.prototype._dumpFaces = function () {\n  var str = '';\n  str += '-- Faces --\\n';\n\n  for (var i = 0; i < this.faceCount; i++) {\n    str += this.faces[i].dump();\n  }\n\n  str += '\\n';\n  return str;\n};\n\nPMD.prototype._dumpFaceDisplays = function () {\n  var str = '';\n  str += '-- Face Displays --\\n';\n\n  for (var i = 0; i < this.faceDisplayCount; i++) {\n    str += this.faceDisplays[i].dump();\n  }\n\n  str += '\\n';\n  return str;\n};\n\nPMD.prototype._dumpBoneFrameNames = function () {\n  var str = '';\n  str += '-- Bone Frame Names --\\n';\n\n  for (var i = 0; i < this.boneFrameNameCount; i++) {\n    str += this.boneFrameNames[i].dump();\n  }\n\n  str += '\\n';\n  return str;\n};\n\nPMD.prototype._dumpBoneDisplays = function () {\n  var str = '';\n  str += '-- Bone Displays --\\n';\n\n  for (var i = 0; i < this.boneDisplayCount; i++) {\n    str += this.boneDisplays[i].dump();\n  }\n\n  str += '\\n';\n  return str;\n};\n\nPMD.prototype._dumpEnglishBoneNames = function () {\n  var str = '';\n  str += '-- Bone Names(English) --\\n';\n\n  for (var i = 0; i < this.boneCount; i++) {\n    str += this.englishBoneNames[i].dump();\n  }\n\n  str += '\\n';\n  return str;\n};\n\nPMD.prototype._dumpEnglishFaceNames = function () {\n  var str = '';\n  str += '-- Face Names(English) --\\n';\n\n  for (var i = 0; i < this.faceCount - 1; i++) {\n    str += this.englishFaceNames[i].dump();\n  }\n\n  str += '\\n';\n  return str;\n};\n\nPMD.prototype._dumpEnglishBoneFrameNames = function () {\n  var str = '';\n  str += '-- Bone Frame Names(English) --\\n';\n\n  for (var i = 0; i < this.boneFrameNameCount; i++) {\n    str += this.englishBoneFrameNames[i].dump();\n  }\n\n  str += '\\n';\n  return str;\n};\n\nPMD.prototype._dumpToonTextures = function () {\n  var str = '';\n  str += '-- Toon Textures --\\n';\n\n  for (var i = 0; i < this.toonTextureCount; i++) {\n    str += this.toonTextures[i].dump();\n  }\n\n  str += '\\n';\n  return str;\n};\n\nPMD.prototype._dumpRigidBodies = function () {\n  var str = '';\n  str += '-- Rigid Bodies --\\n';\n\n  for (var i = 0; i < this.rigidBodyCount; i++) {\n    str += this.rigidBodies[i].dump();\n  }\n\n  str += '\\n';\n  return str;\n};\n\nPMD.prototype._dumpJoints = function () {\n  var str = '';\n  str += '-- Joints --\\n';\n\n  for (var i = 0; i < this.jointCount; i++) {\n    str += this.joints[i].dump();\n  }\n\n  str += '\\n';\n  return str;\n};\n\nfunction PMDHeader() {\n  this.magic = null;\n  this.version = null;\n  this.modelName = null;\n  this.comment = null;\n}\n\n;\n\nPMDHeader.prototype.valid = function () {\n  return this.magic == 'Pmd';\n};\n\nPMDHeader.prototype.dump = function () {\n  var str = '';\n  str += 'magic: ' + this.magic + '\\n';\n  str += 'version: ' + this.version + '\\n';\n  str += 'model_name: ' + this.modelName + '\\n';\n  str += 'comment: ' + this.comment + '\\n';\n  return str;\n};\n\nfunction PMDVertex(id) {\n  this.id = id;\n  this.position = null;\n  this.normal = null;\n  this.uv = null;\n  this.boneIndices = null;\n  this.boneWeight = null;\n  this.edgeFlag = null;\n  this.boneWeightFloat1 = null;\n  this.boneWeightFloat2 = null;\n}\n\n;\n\nPMDVertex.prototype.setup = function () {\n  this.boneWeightFloat1 = this.boneWeight / 100;\n  this.boneWeightFloat2 = (100 - this.boneWeight) / 100;\n};\n\nPMDVertex.prototype.dump = function () {\n  var str = '';\n  str += 'id: ' + this.id + '\\n';\n  str += 'position: ' + this.position + '\\n';\n  str += 'normal: ' + this.normal + '\\n';\n  str += 'uv: ' + this.uv + '\\n';\n  str += 'boneIndices: ' + this.boneIndices + '\\n';\n  str += 'boneWeight: ' + this.boneWeight + '\\n';\n  str += 'edgeFlag: ' + this.edgeFlag + '\\n';\n  return str;\n};\n\nPMDVertex.prototype.toRight = function () {\n  this.position[2] = -this.position[2];\n  this.normal[2] = -this.normal[2];\n};\n\nfunction PMDVertexIndex(id) {\n  this.id = id;\n  this.index = null;\n}\n\n;\n\nPMDVertexIndex.prototype.dump = function () {\n  var str = '';\n  str += 'id: ' + this.id + '\\n';\n  str += 'index: ' + this.index + '\\n';\n  return str;\n};\n\nfunction PMDMaterial(id) {\n  this.id = id;\n  this.color = null;\n  this.specularity = null;\n  this.specularColor = null;\n  this.mirrorColor = null;\n  this.tuneIndex = null;\n  this.edgeFlag = null;\n  this.vertexCount = null;\n  this.fileName = null;\n}\n\n;\n/**\n * TODO: temporal\n */\n\nPMDMaterial.prototype.convertedFileName = function () {\n  var filename = this.fileName.replace('.tga', '.png'); // TODO: ignore sphere map so far\n\n  var index;\n\n  if ((index = filename.lastIndexOf('*')) >= 0) {\n    filename = filename.substring(0, index);\n  }\n\n  return filename;\n};\n/**\n * TODO: temporal\n */\n\n\nPMDMaterial.prototype.hasSphereTexture = function () {\n  if (this.fileName.lastIndexOf('.sph') >= 0 || this.fileName.lastIndexOf('.spa') >= 0) return true;\n  return false;\n};\n/**\n * TODO: temporal\n */\n\n\nPMDMaterial.prototype.isSphereMapAddition = function () {\n  var filename = this.fileName;\n  if (filename.lastIndexOf('.spa') >= 0) return true;\n  return false;\n};\n/**\n * TODO: temporal\n */\n\n\nPMDMaterial.prototype.sphereMapFileName = function () {\n  var filename = this.fileName;\n  var index;\n\n  if ((index = filename.lastIndexOf('*')) >= 0) {\n    filename = filename.slice(index + 1);\n  }\n\n  if ((index = filename.lastIndexOf('+')) >= 0) {\n    filename = filename.slice(index + 1);\n  }\n\n  return filename;\n};\n\nPMDMaterial.prototype.hasToon = function () {\n  return this.tuneIndex >= 10 ? false : true;\n};\n\nPMDMaterial.prototype.dump = function () {\n  var str = '';\n  str += 'id: ' + this.id + '\\n';\n  str += 'color: ' + this.color + '\\n';\n  str += 'specularity: ' + this.specularity + '\\n';\n  str += 'specularColor: ' + this.specularColor + '\\n';\n  str += 'mirrorColor: ' + this.mirrorColor + '\\n';\n  str += 'tuneIndex: ' + this.tuneIndex + '\\n';\n  str += 'edgeFlag: ' + this.edgeFlag + '\\n';\n  str += 'vertexCount: ' + this.vertexCount + '\\n';\n  str += 'fileName: ' + this.fileName + '\\n';\n  return str;\n};\n\nfunction PMDBone(id) {\n  this.id = id;\n  this.name = null;\n  this.parentIndex = null;\n  this.tailIndex = null;\n  this.type = null;\n  this.ikIndex = null;\n  this.position = null;\n  this.motionIndex = null; // Note: be set by VMD;\n  // TODO: remove and use id in VMD\n  //       instead of motionIndex\n  //       not to have VMD related info here\n}\n\n;\n\nPMDBone.prototype.isKnee = function () {\n  // TODO: change this parameter if name type changes.\n  return this.name.indexOf('0x820xd00x820xb4') >= 0;\n};\n\nPMDBone.prototype.dump = function () {\n  var str = '';\n  str += 'id: ' + this.id + '\\n';\n  str += 'name: ' + this.name + '\\n';\n  str += 'parentIndex: ' + this.parentIndex + '\\n';\n  str += 'tailIndex: ' + this.tailIndex + '\\n';\n  str += 'type: ' + this.type + '\\n';\n  str += 'ikIndex: ' + this.ikIndex + '\\n';\n  str += 'position: ' + this.position + '\\n';\n  return str;\n};\n\nPMDBone.prototype.toRight = function () {\n  this.position[2] = -this.position[2];\n};\n\nfunction PMDIK(id) {\n  this.id = id;\n  this.index = null;\n  this.targetBoneIndex = null;\n  this.chainLength = null;\n  this.iteration = null;\n  this.limitation = null;\n  this.childBoneIndices = null;\n}\n\n;\n\nPMDIK.prototype.dump = function () {\n  var str = '';\n  str += 'id: ' + this.id + '\\n';\n  str += 'index: ' + this.index + '\\n';\n  str += 'targetBoneIndex: ' + this.targetBoneIndex + '\\n';\n  str += 'chainLength: ' + this.chainLength + '\\n';\n  str += 'iteration: ' + this.iteration + '\\n';\n  str += 'limitation: ' + this.limitation + '\\n';\n  str += 'childBoneIndices: ' + this.childBoneIndices + '\\n';\n  return str;\n};\n\nfunction PMDFace(id) {\n  this.id = id;\n  this.name = null;\n  this.vertexCount = null;\n  this.type = null;\n  this.vertices = null;\n  this.done = false;\n  this.motionIndex = null; // Note: be set by VMD;\n  // TODO: remove and use id in VMD\n  //       instead of motionIndex\n  //       not to have VMD related info here\n}\n\n;\n\nPMDFace.prototype.dump = function () {\n  var str = '';\n  str += 'id: ' + this.id + '\\n';\n  str += 'name: ' + this.name + '\\n';\n  str += 'vertexCount: ' + this.vertexCount + '\\n';\n  str += 'type: ' + this.type + '\\n';\n\n  for (var i = 0; i < this.vertices.length; i++) {\n    str += this.vertices[i].dump();\n  }\n\n  return str;\n};\n\nPMDFace.prototype.toRight = function () {\n  for (var i = 0; i < this.vertices.length; i++) {\n    this.vertices[i].toRight();\n  }\n};\n\nfunction PMDFaceVertex(id, type) {\n  this.id = id;\n  this.type = type;\n  this.index = null;\n  this.position = null;\n}\n\n;\n\nPMDFaceVertex.prototype.dump = function () {\n  var str = '';\n  str += 'id: ' + this.id + '\\n'; //  str += 'type: '     + this.type     + '\\n';\n\n  str += 'index: ' + this.index + '\\n';\n  str += 'position: ' + this.position + '\\n';\n  return str;\n};\n\nPMDFaceVertex.prototype.toRight = function () {\n  this.position[2] = -this.position[2];\n};\n\nfunction PMDFaceDisplay(id) {\n  this.id = id;\n  this.index = null;\n}\n\n;\n\nPMDFaceDisplay.prototype.dump = function () {\n  var str = '';\n  str += 'id: ' + this.id + '\\n';\n  str += 'index: ' + this.index + '\\n';\n  return str;\n};\n\nfunction PMDBoneFrameName(id) {\n  this.id = id;\n  this.name = null;\n}\n\n;\n\nPMDBoneFrameName.prototype.dump = function () {\n  var str = '';\n  str += 'id: ' + this.id + '\\n';\n  str += 'name: ' + this.name + '\\n';\n  return str;\n};\n\nfunction PMDBoneDisplay(id) {\n  this.id = id;\n  this.index = null;\n  this.frameIndex = null;\n}\n\n;\n\nPMDBoneDisplay.prototype.dump = function () {\n  var str = '';\n  str += 'id: ' + this.id + '\\n';\n  str += 'index: ' + this.index + '\\n';\n  str += 'frameIndex: ' + this.frameIndex + '\\n';\n  return str;\n};\n\nfunction PMDEnglishHeader() {\n  this.compatibility = null;\n  this.modelName = null;\n  this.comment = null;\n}\n\n;\n\nPMDEnglishHeader.prototype.dump = function () {\n  var str = '';\n  str += 'compatibility: ' + this.compatibility + '\\n';\n  str += 'modelName:     ' + this.modelName + '\\n';\n  str += 'comment: ' + this.comment + '\\n';\n  return str;\n};\n\nfunction PMDEnglishBoneName(id) {\n  this.id = id;\n  this.name = null;\n}\n\n;\n\nPMDEnglishBoneName.prototype.dump = function () {\n  var str = '';\n  str += 'id: ' + this.id + '\\n';\n  str += 'name: ' + this.name + '\\n';\n  return str;\n};\n\nfunction PMDEnglishFaceName(id) {\n  this.id = id;\n  this.name = null;\n}\n\n;\n\nPMDEnglishFaceName.prototype.dump = function () {\n  var str = '';\n  str += 'id: ' + this.id + '\\n';\n  str += 'name: ' + this.name + '\\n';\n  return str;\n};\n\nfunction PMDEnglishBoneFrameName(id) {\n  this.id = id;\n  this.name = null;\n}\n\n;\n\nPMDEnglishBoneFrameName.prototype.dump = function () {\n  var str = '';\n  str += 'id: ' + this.id + '\\n';\n  str += 'name: ' + this.name + '\\n';\n  return str;\n};\n\nfunction PMDToonTexture(id) {\n  this.id = id;\n  this.fileName = null;\n}\n\n;\n\nPMDToonTexture.prototype.dump = function () {\n  var str = '';\n  str += 'id: ' + this.id + '\\n';\n  str += 'fileName: ' + this.fileName + '\\n';\n  return str;\n};\n\nfunction PMDRigidBody(id) {\n  this.id = id;\n  this.name = null;\n  this.boneIndex = null;\n  this.groupIndex = null;\n  this.groupTarget = null;\n  this.shapeType = null;\n  this.width = null;\n  this.height = null;\n  this.depth = null;\n  this.position = null;\n  this.rotation = null;\n  this.weight = null;\n  this.positionDim = null;\n  this.rotationDim = null;\n  this.recoil = null;\n  this.friction = null;\n  this.type = null;\n}\n\n;\n\nPMDRigidBody.prototype.dump = function () {\n  var str = '';\n  str += 'id: ' + this.id + '\\n';\n  str += 'name: ' + this.name + '\\n';\n  str += 'boneIndex: ' + this.boneIndex + '\\n';\n  str += 'groupIndex: ' + this.groupIndex + '\\n';\n  str += 'groupTarget: ' + this.groupTarget + '\\n';\n  str += 'shapeType: ' + this.shapeType + '\\n';\n  str += 'width: ' + this.width + '\\n';\n  str += 'height: ' + this.height + '\\n';\n  str += 'depth: ' + this.depth + '\\n';\n  str += 'position: ' + this.position + '\\n';\n  str += 'rotation: ' + this.rotation + '\\n';\n  str += 'weight: ' + this.weight + '\\n';\n  str += 'positionDim: ' + this.positionDim + '\\n';\n  str += 'rotationDim: ' + this.rotationDim + '\\n';\n  str += 'recoil: ' + this.recoil + '\\n';\n  str += 'friction: ' + this.friction + '\\n';\n  str += 'type: ' + this.type + '\\n';\n  return str;\n};\n\nPMDRigidBody.prototype.toRight = function () {\n  this.position[2] = -this.position[2];\n  this.rotation[0] = -this.rotation[0];\n  this.rotation[1] = -this.rotation[1];\n};\n\nfunction PMDJoint(id) {\n  this.id = id;\n  this.name = null;\n  this.rigidBody1 = null;\n  this.rigidBody2 = null;\n  this.position = null;\n  this.rotation = null;\n  this.translationLimitation1 = null;\n  this.translationLimitation2 = null;\n  this.rotationLimitation1 = null;\n  this.rotationLimitation2 = null;\n  this.springPosition = null;\n  this.springRotation = null;\n}\n\n;\n\nPMDJoint.prototype.dump = function () {\n  var str = '';\n  str += 'id: ' + this.id + '\\n';\n  str += 'name: ' + this.name + '\\n';\n  str += 'rigidBody1: ' + this.rigidBody1 + '\\n';\n  str += 'rigidBody2: ' + this.rigidBody2 + '\\n';\n  str += 'position: ' + this.position + '\\n';\n  str += 'rotation: ' + this.rotation + '\\n';\n  str += 'translationLimitation1: ' + this.translationLimitation1 + '\\n';\n  str += 'translationLimitation2: ' + this.translationLimitation2 + '\\n';\n  str += 'rotationLimitation1: ' + this.rotationLimitation1 + '\\n';\n  str += 'rotationLimitation2: ' + this.rotationLimitation2 + '\\n';\n  str += 'springPosition: ' + this.springPosition + '\\n';\n  str += 'springRotation: ' + this.springRotation + '\\n';\n  return str;\n};\n\nPMDJoint.prototype.toRight = function () {\n  this.position[2] = -this.position[2];\n  this.rotation[0] = -this.rotation[0];\n  this.rotation[1] = -this.rotation[1];\n};\n\nfunction PMDImageLoader(pmd, baseURL) {\n  this.pmd = pmd;\n  this.baseURL = baseURL;\n  this.errorImageNum = 0;\n  this.loadedImageNum = 0;\n  this.noImageNum = 0;\n}\n\n;\n/**\n * TODO: temporal\n */\n\nPMDImageLoader.prototype.load = function (callback) {\n  this.pmd.images.length = 0;\n  this.pmd.toonImages.length = 0;\n  this.pmd.sphereImages.length = 0;\n  this.errorImageNum = 0;\n  this.loadedImageNum = 0;\n  this.noImageNum = 0;\n\n  for (var i = 0; i < this.pmd.materialCount; i++) {\n    var fileName = this.pmd.materials[i].convertedFileName();\n\n    if (fileName == '' || fileName.indexOf('.spa') >= 0 || fileName.indexOf('.sph') >= 0) {\n      this.pmd.images[i] = this._generatePixelImage();\n      this.noImageNum++;\n\n      this._checkDone(callback);\n\n      continue;\n    }\n\n    var self = this;\n    this.pmd.images[i] = new Image();\n\n    this.pmd.images[i].onerror = function (event) {\n      self.errorImageNum++;\n\n      self._checkDone(callback);\n    };\n\n    this.pmd.images[i].onload = function (event) {\n      self.loadedImageNum++;\n\n      self._checkDone(callback);\n    };\n\n    this.pmd.images[i].src = this.baseURL + '/' + fileName;\n  } // TODO: duplicated code\n\n\n  for (var i = 0; i < this.pmd.toonTextureCount; i++) {\n    var fileName = this.pmd.toonTextures[i].fileName;\n\n    if (fileName == '' || fileName.indexOf('.spa') >= 0 || fileName.indexOf('.sph') >= 0) {\n      this.pmd.toonImages[i] = this._generatePixelImage();\n      this.noImageNum++;\n\n      this._checkDone(callback);\n\n      continue;\n    }\n\n    var self = this;\n    this.pmd.toonImages[i] = new Image();\n\n    this.pmd.toonImages[i].onerror = function (event) {\n      self.errorImageNum++;\n\n      self._checkDone(callback);\n    };\n\n    this.pmd.toonImages[i].onload = function (event) {\n      self.loadedImageNum++;\n\n      self._checkDone(callback);\n    };\n\n    this.pmd.toonImages[i].src = this.baseURL + '/' + fileName;\n  } // TODO: duplicated code\n\n\n  for (var i = 0; i < this.pmd.materialCount; i++) {\n    if (!this.pmd.materials[i].hasSphereTexture()) {\n      this.pmd.sphereImages[i] = this._generatePixelImage();\n      this.noImageNum++;\n\n      this._checkDone(callback);\n\n      continue;\n    }\n\n    var fileName = this.pmd.materials[i].sphereMapFileName();\n    var self = this;\n    this.pmd.sphereImages[i] = new Image();\n\n    this.pmd.sphereImages[i].onerror = function (event) {\n      self.errorImageNum++;\n\n      self._checkDone(callback);\n    };\n\n    this.pmd.sphereImages[i].onload = function (event) {\n      self.loadedImageNum++;\n\n      self._checkDone(callback);\n    };\n\n    this.pmd.sphereImages[i].src = this.baseURL + '/' + fileName;\n  }\n};\n\nPMDImageLoader.prototype._generatePixelImage = function () {\n  var cvs = document.createElement('canvas');\n  cvs.width = 1;\n  cvs.height = 1;\n  var ctx = cvs.getContext('2d');\n  ctx.fillStyle = 'rgb(255, 255, 255)';\n  ctx.fillRect(0, 0, 1, 1);\n  return cvs;\n};\n\nPMDImageLoader.prototype._checkDone = function (callback) {\n  if (this.loadedImageNum + this.noImageNum + this.errorImageNum >= this.pmd.materialCount * 2 + this.pmd.toonTextureCount) {\n    callback(this.pmd);\n  }\n};\n\nmodule.exports = {\n  PMD: PMD,\n  PMDHeader: PMDHeader,\n  PMDVertex: PMDVertex,\n  PMDVertexIndex: PMDVertexIndex,\n  PMDMaterial: PMDMaterial,\n  PMDBone: PMDBone,\n  PMDIK: PMDIK,\n  PMDFace: PMDFace,\n  PMDFaceVertex: PMDFaceVertex,\n  PMDFaceDisplay: PMDFaceDisplay,\n  PMDBoneFrameName: PMDBoneFrameName,\n  PMDBoneDisplay: PMDBoneDisplay,\n  PMDEnglishHeader: PMDEnglishHeader,\n  PMDEnglishBoneName: PMDEnglishBoneName,\n  PMDEnglishFaceName: PMDEnglishFaceName,\n  PMDEnglishBoneFrameName: PMDEnglishBoneFrameName,\n  PMDToonTexture: PMDToonTexture,\n  PMDRigidBody: PMDRigidBody,\n  PMDJoint: PMDJoint\n};\n\n//# sourceURL=webpack:///./src/plugin-webgl/mmd/Pmd.js?");

/***/ }),

/***/ "./src/plugin-webgl/mmd/PmdFileParser.js":
/*!***********************************************!*\
  !*** ./src/plugin-webgl/mmd/PmdFileParser.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _Inherit = _interopRequireDefault(__webpack_require__(/*! ./_Inherit.js */ \"./src/plugin-webgl/mmd/_Inherit.js\"));\n\nvar _FileParser = _interopRequireDefault(__webpack_require__(/*! ./_FileParser.js */ \"./src/plugin-webgl/mmd/_FileParser.js\"));\n\nvar _Pmd = __webpack_require__(/*! ./Pmd.js */ \"./src/plugin-webgl/mmd/Pmd.js\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nfunction PMDFileParser(buffer) {\n  this.parent = _FileParser[\"default\"];\n  this.parent.call(this, buffer);\n  this.englishCompatibility = false;\n}\n\n;\n(0, _Inherit[\"default\"])(PMDFileParser, _FileParser[\"default\"]);\nPMDFileParser.prototype._HEADER_STRUCTURE = {\n  magic: {\n    type: 'char',\n    isArray: true,\n    size: 3\n  },\n  version: {\n    type: 'float'\n  },\n  modelName: {\n    type: 'char',\n    isArray: true,\n    size: 20\n  },\n  comment: {\n    type: 'char',\n    isArray: true,\n    size: 256\n  }\n};\nPMDFileParser.prototype._VERTICES_STRUCTURE = {\n  count: {\n    type: 'uint32'\n  },\n  vertices: {\n    type: 'object',\n    isArray: true,\n    size: 'count'\n  }\n};\nPMDFileParser.prototype._VERTEX_STRUCTURE = {\n  position: {\n    type: 'float',\n    isArray: true,\n    size: 3\n  },\n  normal: {\n    type: 'float',\n    isArray: true,\n    size: 3\n  },\n  uv: {\n    type: 'float',\n    isArray: true,\n    size: 2\n  },\n  boneIndices: {\n    type: 'uint16',\n    isArray: true,\n    size: 2\n  },\n  boneWeight: {\n    type: 'uint8'\n  },\n  edgeFlag: {\n    type: 'uint8'\n  }\n};\nPMDFileParser.prototype._VERTEX_INDICES_STRUCTURE = {\n  count: {\n    type: 'uint32'\n  },\n  // Note: type can be 'uint16'\n  indices: {\n    type: 'object',\n    isArray: true,\n    size: 'count'\n  }\n};\nPMDFileParser.prototype._VERTEX_INDEX_STRUCTURE = {\n  index: {\n    type: 'uint16'\n  }\n};\nPMDFileParser.prototype._MATERIALS_STRUCTURE = {\n  count: {\n    type: 'uint32'\n  },\n  materials: {\n    type: 'object',\n    isArray: true,\n    size: 'count'\n  }\n};\nPMDFileParser.prototype._MATERIAL_STRUCTURE = {\n  color: {\n    type: 'float',\n    isArray: true,\n    size: 4\n  },\n  specularity: {\n    type: 'float'\n  },\n  specularColor: {\n    type: 'float',\n    isArray: true,\n    size: 3\n  },\n  mirrorColor: {\n    type: 'float',\n    isArray: true,\n    size: 3\n  },\n  tuneIndex: {\n    type: 'uint8'\n  },\n  edgeFlag: {\n    type: 'uint8'\n  },\n  vertexCount: {\n    type: 'uint32'\n  },\n  fileName: {\n    type: 'char',\n    isArray: true,\n    size: 20\n  }\n};\nPMDFileParser.prototype._BONES_STRUCTURE = {\n  count: {\n    type: 'uint16'\n  },\n  bones: {\n    type: 'object',\n    isArray: true,\n    size: 'count'\n  }\n};\nPMDFileParser.prototype._BONE_STRUCTURE = {\n  name: {\n    type: 'strings',\n    isArray: true,\n    size: 20\n  },\n  parentIndex: {\n    type: 'uint16'\n  },\n  tailIndex: {\n    type: 'uint16'\n  },\n  type: {\n    type: 'uint8'\n  },\n  ikIndex: {\n    type: 'uint16'\n  },\n  position: {\n    type: 'float',\n    isArray: true,\n    size: 3\n  }\n};\nPMDFileParser.prototype._IKS_STRUCTURE = {\n  count: {\n    type: 'uint16'\n  },\n  iks: {\n    type: 'object',\n    isArray: true,\n    size: 'count'\n  }\n};\nPMDFileParser.prototype._IK_STRUCTURE = {\n  index: {\n    type: 'uint16'\n  },\n  targetBoneIndex: {\n    type: 'uint16'\n  },\n  chainLength: {\n    type: 'uint8'\n  },\n  iteration: {\n    type: 'uint16'\n  },\n  limitation: {\n    type: 'float'\n  },\n  childBoneIndices: {\n    type: 'uint16',\n    isArray: true,\n    size: 'chainLength'\n  }\n};\nPMDFileParser.prototype._FACES_STRUCTURE = {\n  count: {\n    type: 'uint16'\n  },\n  faces: {\n    type: 'object',\n    isArray: true,\n    size: 'count'\n  }\n};\nPMDFileParser.prototype._FACE_STRUCTURE = {\n  name: {\n    type: 'strings',\n    isArray: true,\n    size: 20\n  },\n  vertexCount: {\n    type: 'uint32'\n  },\n  type: {\n    type: 'uint8'\n  },\n  vertices: {\n    type: 'object',\n    isArray: true,\n    size: 'vertexCount'\n  }\n};\nPMDFileParser.prototype._FACE_VERTEX_STRUCTURE = {\n  index: {\n    type: 'uint32'\n  },\n  position: {\n    type: 'float',\n    isArray: true,\n    size: 3\n  }\n};\nPMDFileParser.prototype._FACE_DISPLAYS_STRUCTURE = {\n  count: {\n    type: 'uint8'\n  },\n  indices: {\n    type: 'object',\n    isArray: true,\n    size: 'count'\n  }\n};\nPMDFileParser.prototype._FACE_DISPLAY_STRUCTURE = {\n  index: {\n    type: 'uint16'\n  }\n};\nPMDFileParser.prototype._BONE_FRAME_NAMES_STRUCTURE = {\n  count: {\n    type: 'uint8'\n  },\n  names: {\n    type: 'object',\n    isArray: true,\n    size: 'count'\n  }\n};\nPMDFileParser.prototype._BONE_FRAME_NAME_STRUCTURE = {\n  name: {\n    type: 'strings',\n    isArray: true,\n    size: 50\n  }\n};\nPMDFileParser.prototype._BONE_DISPLAYS_STRUCTURE = {\n  count: {\n    type: 'uint32'\n  },\n  displays: {\n    type: 'object',\n    isArray: true,\n    size: 'count'\n  }\n};\nPMDFileParser.prototype._BONE_DISPLAY_STRUCTURE = {\n  index: {\n    type: 'uint16'\n  },\n  frameIndex: {\n    type: 'uint8'\n  }\n};\nPMDFileParser.prototype._ENGLISH_HEADER_STRUCTURE = {\n  compatibility: {\n    type: 'uint8'\n  },\n  modelName: {\n    type: 'char',\n    isArray: true,\n    size: 20\n  },\n  comment: {\n    type: 'char',\n    isArray: true,\n    size: 256\n  }\n};\nPMDFileParser.prototype._ENGLISH_BONE_NAME_STRUCTURE = {\n  name: {\n    type: 'char',\n    isArray: true,\n    size: 20\n  }\n};\nPMDFileParser.prototype._ENGLISH_FACE_NAME_STRUCTURE = {\n  name: {\n    type: 'char',\n    isArray: true,\n    size: 20\n  }\n};\nPMDFileParser.prototype._ENGLISH_BONE_FRAME_NAME_STRUCTURE = {\n  name: {\n    type: 'char',\n    isArray: true,\n    size: 50\n  }\n};\nPMDFileParser.prototype._TOON_TEXTURE_STRUCTURE = {\n  fileName: {\n    type: 'char',\n    isArray: true,\n    size: 100\n  }\n};\nPMDFileParser.prototype._RIGID_BODIES_STRUCTURE = {\n  count: {\n    type: 'uint32'\n  },\n  bodies: {\n    type: 'object',\n    isArray: true,\n    size: 'count'\n  }\n};\nPMDFileParser.prototype._RIGID_BODY_STRUCTURE = {\n  name: {\n    type: 'strings',\n    isArray: true,\n    size: 20\n  },\n  boneIndex: {\n    type: 'uint16'\n  },\n  groupIndex: {\n    type: 'uint8'\n  },\n  groupTarget: {\n    type: 'uint16'\n  },\n  shapeType: {\n    type: 'uint8'\n  },\n  width: {\n    type: 'float'\n  },\n  height: {\n    type: 'float'\n  },\n  depth: {\n    type: 'float'\n  },\n  position: {\n    type: 'float',\n    isArray: true,\n    size: 3\n  },\n  rotation: {\n    type: 'float',\n    isArray: true,\n    size: 3\n  },\n  weight: {\n    type: 'float'\n  },\n  positionDim: {\n    type: 'float'\n  },\n  rotationDim: {\n    type: 'float'\n  },\n  recoil: {\n    type: 'float'\n  },\n  friction: {\n    type: 'float'\n  },\n  type: {\n    type: 'uint8'\n  }\n};\nPMDFileParser.prototype._JOINTS_STRUCTURE = {\n  count: {\n    type: 'uint32'\n  },\n  joints: {\n    type: 'object',\n    isArray: true,\n    size: 'count'\n  }\n};\nPMDFileParser.prototype._JOINT_STRUCTURE = {\n  name: {\n    type: 'strings',\n    isArray: true,\n    size: 20\n  },\n  rigidBody1: {\n    type: 'uint32'\n  },\n  rigidBody2: {\n    type: 'uint32'\n  },\n  position: {\n    type: 'float',\n    isArray: true,\n    size: 3\n  },\n  rotation: {\n    type: 'float',\n    isArray: true,\n    size: 3\n  },\n  translationLimitation1: {\n    type: 'float',\n    isArray: true,\n    size: 3\n  },\n  translationLimitation2: {\n    type: 'float',\n    isArray: true,\n    size: 3\n  },\n  rotationLimitation1: {\n    type: 'float',\n    isArray: true,\n    size: 3\n  },\n  rotationLimitation2: {\n    type: 'float',\n    isArray: true,\n    size: 3\n  },\n  springPosition: {\n    type: 'float',\n    isArray: true,\n    size: 3\n  },\n  springRotation: {\n    type: 'float',\n    isArray: true,\n    size: 3\n  }\n};\n\nPMDFileParser.prototype.parse = function () {\n  this.offset = 0;\n  var p = new _Pmd.PMD();\n\n  this._parseHeader(p);\n\n  this._parseVertices(p);\n\n  this._parseVertexIndices(p);\n\n  this._parseMaterials(p);\n\n  this._parseBones(p);\n\n  this._parseIKs(p);\n\n  this._parseFaces(p);\n\n  this._parseFaceDisplays(p);\n\n  this._parseBoneFrameNames(p);\n\n  this._parseBoneDisplays(p);\n\n  this._parseEnglishHeader(p);\n\n  if (this.englishCompatibility) {\n    this._parseEnglishBoneNames(p);\n\n    this._parseEnglishFaceNames(p);\n\n    this._parseEnglishBoneFrameNames(p);\n  }\n\n  this._parseToonTextures(p);\n\n  this._parseRigidBodies(p);\n\n  this._parseJoints(p);\n\n  return p;\n};\n/**\n * TODO: be more strict.\n */\n\n\nPMDFileParser.prototype.valid = function () {\n  var tmp = this.offset;\n  this.offset = 0;\n  var p = new _Pmd.PMD();\n\n  this._parseHeader(p);\n\n  this.offset = tmp;\n  return p.valid();\n};\n\nPMDFileParser.prototype._parseHeader = function (p) {\n  var s = this._HEADER_STRUCTURE;\n  p.header = new _Pmd.PMDHeader();\n\n  this._parseObject(p.header, s);\n};\n\nPMDFileParser.prototype._parseVertices = function (p) {\n  var s = this._VERTICES_STRUCTURE;\n  p.vertexCount = this._getValue(s.count, this.offset);\n  this.offset += this._sizeof(s.count);\n  p.vertices.length = 0;\n\n  for (var i = 0; i < p.vertexCount; i++) {\n    this._parseVertex(p, i);\n  }\n};\n\nPMDFileParser.prototype._parseVertex = function (p, n) {\n  var s = this._VERTEX_STRUCTURE;\n  var v = new _Pmd.PMDVertex(n);\n\n  this._parseObject(v, s);\n\n  p.vertices[n] = v;\n};\n\nPMDFileParser.prototype._parseVertexIndices = function (p) {\n  var s = this._VERTEX_INDICES_STRUCTURE;\n  p.vertexIndexCount = this._getValue(s.count, this.offset);\n  this.offset += this._sizeof(s.count);\n  p.vertexIndices.length = 0;\n\n  for (var i = 0; i < p.vertexIndexCount; i++) {\n    this._parseVertexIndex(p, i);\n  }\n};\n\nPMDFileParser.prototype._parseVertexIndex = function (p, n) {\n  var s = this._VERTEX_INDEX_STRUCTURE;\n  var v = new _Pmd.PMDVertexIndex(n);\n\n  this._parseObject(v, s);\n\n  p.vertexIndices[n] = v;\n};\n\nPMDFileParser.prototype._parseMaterials = function (p) {\n  var s = this._MATERIALS_STRUCTURE;\n  p.materialCount = this._getValue(s.count, this.offset);\n  this.offset += this._sizeof(s.count);\n  p.materials.length = 0;\n\n  for (var i = 0; i < p.materialCount; i++) {\n    this._parseMaterial(p, i);\n  }\n};\n\nPMDFileParser.prototype._parseMaterial = function (p, n) {\n  var s = this._MATERIAL_STRUCTURE;\n  var m = new _Pmd.PMDMaterial(n);\n\n  this._parseObject(m, s);\n\n  p.materials[n] = m;\n};\n\nPMDFileParser.prototype._parseBones = function (p) {\n  var s = this._BONES_STRUCTURE;\n  p.boneCount = this._getValue(s.count, this.offset);\n  this.offset += this._sizeof(s.count);\n  p.bones.length = 0;\n\n  for (var i = 0; i < p.boneCount; i++) {\n    this._parseBone(p, i);\n  }\n};\n\nPMDFileParser.prototype._parseBone = function (p, n) {\n  var s = this._BONE_STRUCTURE;\n  var b = new _Pmd.PMDBone(n);\n\n  this._parseObject(b, s);\n\n  p.bones[n] = b;\n};\n\nPMDFileParser.prototype._parseIKs = function (p) {\n  var s = this._IKS_STRUCTURE;\n  p.ikCount = this._getValue(s.count, this.offset);\n  this.offset += this._sizeof(s.count);\n  p.iks.length = 0;\n\n  for (var i = 0; i < p.ikCount; i++) {\n    this._parseIK(p, i);\n  }\n};\n/**\n * NOTE: specialized _parseObject() because IK has a variable length array\n * TODO: be combined with general function _parseObject()\n *       to remove duplicated code.\n */\n\n\nPMDFileParser.prototype._parseIK = function (p, n) {\n  var s = this._IK_STRUCTURE;\n  var ik = new _Pmd.PMDIK(n);\n\n  for (var key in s) {\n    if (key == 'childBoneIndices') continue;\n    ik[key] = this._getValue(s[key], this.offset);\n    this.offset += this._sizeof(s[key]);\n  }\n\n  ik.childBoneIndices = [];\n\n  var size = this._sizeofScalar(s.childBoneIndices);\n\n  for (var i = 0; i < ik.chainLength; i++) {\n    ik.childBoneIndices[i] = this._getValueScalar(s.childBoneIndices, this.offset);\n    this.offset += size;\n  }\n\n  p.iks[n] = ik;\n};\n\nPMDFileParser.prototype._parseFaces = function (p) {\n  var s = this._FACES_STRUCTURE;\n  p.faceCount = this._getValue(s.count, this.offset);\n  this.offset += this._sizeof(s.count);\n  p.faces.length = 0;\n\n  for (var i = 0; i < p.faceCount; i++) {\n    this._parseFace(p, i);\n  }\n};\n/**\n * NOTE: specialized _parseObject() because Face has a variable length array\n * TODO: be combined with general function _parseObject()\n *       to remove duplicated code.\n */\n\n\nPMDFileParser.prototype._parseFace = function (p, n) {\n  var s = this._FACE_STRUCTURE;\n  var f = new _Pmd.PMDFace(n);\n\n  for (var key in s) {\n    if (key == 'vertices') continue;\n    f[key] = this._getValue(s[key], this.offset);\n    this.offset += this._sizeof(s[key]);\n  }\n\n  f.vertices = [];\n\n  for (var i = 0; i < f.vertexCount; i++) {\n    this._parseFaceVertex(f, i, f.type);\n  }\n\n  p.faces[n] = f;\n};\n\nPMDFileParser.prototype._parseFaceVertex = function (f, n, type) {\n  var s = this._FACE_VERTEX_STRUCTURE;\n  var v = new _Pmd.PMDFaceVertex(n, type);\n\n  this._parseObject(v, s);\n\n  f.vertices[n] = v;\n};\n\nPMDFileParser.prototype._parseFaceDisplays = function (p) {\n  var s = this._FACE_DISPLAYS_STRUCTURE;\n  p.faceDisplayCount = this._getValue(s.count, this.offset);\n  this.offset += this._sizeof(s.count);\n  p.faceDisplays.length = 0;\n\n  for (var i = 0; i < p.faceDisplayCount; i++) {\n    this._parseFaceDisplay(p, i);\n  }\n};\n\nPMDFileParser.prototype._parseFaceDisplay = function (p, n) {\n  var s = this._FACE_DISPLAY_STRUCTURE;\n  var d = new _Pmd.PMDFaceDisplay(n);\n\n  this._parseObject(d, s);\n\n  p.faceDisplays[n] = d;\n};\n\nPMDFileParser.prototype._parseBoneFrameNames = function (p) {\n  var s = this._BONE_FRAME_NAMES_STRUCTURE;\n  p.boneFrameNameCount = this._getValue(s.count, this.offset);\n  this.offset += this._sizeof(s.count);\n  p.boneFrameNames.length = 0;\n\n  for (var i = 0; i < p.boneFrameNameCount; i++) {\n    this._parseBoneFrameName(p, i);\n  }\n};\n\nPMDFileParser.prototype._parseBoneFrameName = function (p, n) {\n  var s = this._BONE_FRAME_NAME_STRUCTURE;\n  var d = new _Pmd.PMDBoneFrameName(n);\n\n  this._parseObject(d, s);\n\n  p.boneFrameNames[n] = d;\n};\n\nPMDFileParser.prototype._parseBoneDisplays = function (p) {\n  var s = this._BONE_DISPLAYS_STRUCTURE;\n  p.boneDisplayCount = this._getValue(s.count, this.offset);\n  this.offset += this._sizeof(s.count);\n  p.boneDisplays.length = 0;\n\n  for (var i = 0; i < p.boneDisplayCount; i++) {\n    this._parseBoneDisplay(p, i);\n  }\n};\n\nPMDFileParser.prototype._parseBoneDisplay = function (p, n) {\n  var s = this._BONE_DISPLAY_STRUCTURE;\n  var d = new _Pmd.PMDBoneDisplay(n);\n\n  this._parseObject(d, s);\n\n  p.boneDisplays[n] = d;\n};\n\nPMDFileParser.prototype._parseEnglishHeader = function (p) {\n  var s = this._ENGLISH_HEADER_STRUCTURE;\n  p.englishHeader = new _Pmd.PMDEnglishHeader();\n\n  this._parseObject(p.englishHeader, s);\n\n  if (p.englishHeader.compatibility == 0) {\n    this.offset -= this._sizeofObject(s);\n    this.offset += this._sizeof(s.compatibility);\n    this.englishCompatibility = false;\n  } else {\n    this.englishCompatibility = true;\n  }\n};\n\nPMDFileParser.prototype._parseEnglishBoneNames = function (p) {\n  var s = this._ENGLISH_BONE_NAME_STRUCTURE;\n  p.englishBoneNames.length = 0;\n\n  for (var i = 0; i < p.boneCount; i++) {\n    var b = new _Pmd.PMDEnglishBoneName(i);\n\n    this._parseObject(b, s);\n\n    p.englishBoneNames[i] = b;\n  }\n};\n\nPMDFileParser.prototype._parseEnglishFaceNames = function (p) {\n  var s = this._ENGLISH_FACE_NAME_STRUCTURE;\n  p.englishFaceNames.length = 0;\n\n  for (var i = 0; i < p.faceCount - 1; i++) {\n    var b = new _Pmd.PMDEnglishFaceName(i);\n\n    this._parseObject(b, s);\n\n    p.englishFaceNames[i] = b;\n  }\n};\n\nPMDFileParser.prototype._parseEnglishBoneFrameNames = function (p) {\n  var s = this._ENGLISH_BONE_FRAME_NAME_STRUCTURE;\n  p.englishBoneFrameNames.length = 0;\n\n  for (var i = 0; i < p.boneFrameNameCount; i++) {\n    var n = new _Pmd.PMDEnglishBoneFrameName(i);\n\n    this._parseObject(n, s);\n\n    p.englishBoneFrameNames[i] = n;\n  }\n};\n\nPMDFileParser.prototype._parseToonTextures = function (p) {\n  var s = this._TOON_TEXTURE_STRUCTURE;\n  p.toonTextureCount = 10;\n  p.toonTextures.length = 0;\n\n  for (var i = 0; i < p.toonTextureCount; i++) {\n    var t = new _Pmd.PMDToonTexture(i);\n\n    this._parseObject(t, s);\n\n    p.toonTextures[i] = t;\n  }\n};\n\nPMDFileParser.prototype._parseRigidBodies = function (p) {\n  var s = this._RIGID_BODIES_STRUCTURE;\n  p.rigidBodyCount = this._getValue(s.count, this.offset);\n  this.offset += this._sizeof(s.count);\n  p.rigidBodies.length = 0;\n\n  for (var i = 0; i < p.rigidBodyCount; i++) {\n    this._parseRigidBody(p, i);\n  }\n};\n\nPMDFileParser.prototype._parseRigidBody = function (p, n) {\n  var s = this._RIGID_BODY_STRUCTURE;\n  var b = new _Pmd.PMDRigidBody(n);\n\n  this._parseObject(b, s);\n\n  p.rigidBodies[n] = b;\n};\n\nPMDFileParser.prototype._parseJoints = function (p) {\n  var s = this._JOINTS_STRUCTURE;\n  p.jointCount = this._getValue(s.count, this.offset);\n  this.offset += this._sizeof(s.count);\n  p.joints.length = 0;\n\n  for (var i = 0; i < p.jointCount; i++) {\n    this._parseJoint(p, i);\n  }\n};\n\nPMDFileParser.prototype._parseJoint = function (p, n) {\n  var s = this._JOINT_STRUCTURE;\n  var j = new _Pmd.PMDJoint(n);\n\n  this._parseObject(j, s);\n\n  p.joints[n] = j;\n};\n\nmodule.exports = PMDFileParser;\n\n//# sourceURL=webpack:///./src/plugin-webgl/mmd/PmdFileParser.js?");

/***/ }),

/***/ "./src/plugin-webgl/mmd/PmdModelView_easycanvas.js":
/*!*********************************************************!*\
  !*** ./src/plugin-webgl/mmd/PmdModelView_easycanvas.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _glMatrix095Min = __webpack_require__(/*! lib/_glMatrix-0.9.5.min.js */ \"./src/lib/_glMatrix-0.9.5.min.js\");\n\nvar _GlslFunctions = _interopRequireDefault(__webpack_require__(/*! ./_GlslFunctions.js */ \"./src/plugin-webgl/mmd/_GlslFunctions.js\"));\n\nvar _Physics = _interopRequireDefault(__webpack_require__(/*! ./Physics.js */ \"./src/plugin-webgl/mmd/Physics.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nvar createFloatArray = function createFloatArray(num) {\n  return new Float32Array(num);\n};\n\nvar createUintArray = function createUintArray(num) {\n  return new Uint16Array(num);\n};\n/**\n * TODO: refactoring\n */\n\n\nfunction PMDModelView(layer, pmd, pmdView) {\n  this.layer = layer;\n  this.pmd = pmd;\n  this.view = pmdView;\n  this.vmd = null;\n  this.audio = null; // this.vtf = layer.generateTexture(document.createElement('img'));\n  // this.vtfWidth = layer.calculateVTFWidth(pmd.boneCount*7);\n  // var buffer = new ArrayBuffer(this.vtfWidth * this.vtfWidth * 4);\n  // this.vtfUint8Array = new Uint8Array(buffer);\n  // this.vtfFloatArray = new Float32Array(buffer);\n  // hack createFloatArray\n\n  this.vArray = createFloatArray(pmd.vertexCount * this._V_ITEM_SIZE);\n  this.vArray1 = createFloatArray(pmd.vertexCount * this._V_ITEM_SIZE);\n  this.vArray2 = createFloatArray(pmd.vertexCount * this._V_ITEM_SIZE);\n  this.vmArray = createFloatArray(pmd.vertexCount * this._V_ITEM_SIZE);\n  this.veArray = createFloatArray(pmd.vertexCount * this._VE_ITEM_SIZE);\n  this.mtArray1 = createFloatArray(pmd.vertexCount * this._MT_ITEM_SIZE);\n  this.mtArray2 = createFloatArray(pmd.vertexCount * this._MT_ITEM_SIZE);\n  this.mrArray1 = createFloatArray(pmd.vertexCount * this._MR_ITEM_SIZE);\n  this.mrArray2 = createFloatArray(pmd.vertexCount * this._MR_ITEM_SIZE);\n  this.cArray = createFloatArray(pmd.vertexCount * this._C_ITEM_SIZE);\n  this.iArray = createUintArray(pmd.vertexIndexCount);\n  this.biArray = createFloatArray(pmd.vertexCount * this._BI_ITEM_SIZE);\n  this.bwArray = createFloatArray(pmd.vertexCount * this._BW_ITEM_SIZE);\n  this.vnArray = createFloatArray(pmd.vertexCount * this._VN_ITEM_SIZE); // this.vBuffer = layer.createBuffer();\n  // this.vBuffer1 = layer.createBuffer();\n  // this.vBuffer2 = layer.createBuffer();\n  // this.vmBuffer = layer.createBuffer();\n  // this.veBuffer = layer.createBuffer();\n  // this.mtBuffer1 = layer.createBuffer();\n  // this.mtBuffer2 = layer.createBuffer();\n  // this.mrBuffer1 = layer.createBuffer();\n  // this.mrBuffer2 = layer.createBuffer();\n  // this.cBuffer = layer.createBuffer();\n  // this.iBuffer = layer.createBuffer();\n  // this.biBuffer = layer.createBuffer();\n  // this.bwBuffer = layer.createBuffer();\n  // this.vnBuffer = layer.createBuffer();\n\n  this.textures = [];\n  this.toonTextures = [];\n  this.sphereTextures = [];\n  this.basePosition = [0, 0, 0];\n  this.frame = 0;\n  this.motions = [];\n  this.originalMotions = {};\n  this.posFromBone1 = [];\n  this.posFromBone2 = [];\n  this.dancing = false;\n  this.physics = new _Physics[\"default\"](this.pmd);\n}\n\n; // Note: for reference\n\nPMDModelView.prototype.Math = Math;\nPMDModelView.prototype.vec3 = _glMatrix095Min.vec3;\nPMDModelView.prototype.quat4 = _glMatrix095Min.quat4;\nPMDModelView.prototype.mat4 = _glMatrix095Min.mat4;\nPMDModelView.prototype._V_ITEM_SIZE = 3;\nPMDModelView.prototype._C_ITEM_SIZE = 2;\nPMDModelView.prototype._I_ITEM_SIZE = 1;\nPMDModelView.prototype._BW_ITEM_SIZE = 1;\nPMDModelView.prototype._BI_ITEM_SIZE = 2;\nPMDModelView.prototype._MT_ITEM_SIZE = 3;\nPMDModelView.prototype._MR_ITEM_SIZE = 4;\nPMDModelView.prototype._VN_ITEM_SIZE = 3;\nPMDModelView.prototype._VE_ITEM_SIZE = 1;\n\nPMDModelView.prototype.setup = function () {\n  // TODO: temporal\n  for (var i = 0; i < this.pmd.vertexCount; i++) {\n    for (var j = 0; j < this._MT_ITEM_SIZE; j++) {\n      this.mtArray1[i * this._MT_ITEM_SIZE + j] = 0;\n      this.mtArray2[i * this._MT_ITEM_SIZE + j] = 0;\n    }\n\n    for (var j = 0; j < this._MR_ITEM_SIZE; j++) {\n      this.mrArray1[i * this._MR_ITEM_SIZE + j] = 0;\n      this.mrArray2[i * this._MR_ITEM_SIZE + j] = 0;\n    }\n  }\n\n  this.layer = {};\n\n  this.layer.pourArrayBuffer = function () {};\n\n  this.layer.pourElementArrayBuffer = function () {}; // var layer = this.layer;\n  // layer.pourArrayBuffer(this.mtBuffer1, this.mtArray1,\n  //                       this._MT_ITEM_SIZE, this.pmd.vertexCount);\n  // layer.pourArrayBuffer(this.mtBuffer2, this.mtArray2,\n  //                       this._MT_ITEM_SIZE, this.pmd.vertexCount);\n  // layer.pourArrayBuffer(this.mrBuffer1, this.mrArray1,\n  //                       this._MR_ITEM_SIZE, this.pmd.vertexCount);\n  // layer.pourArrayBuffer(this.mrBuffer2, this.mrArray2,\n  //                       this._MR_ITEM_SIZE, this.pmd.vertexCount);\n\n\n  this._initArrays();\n\n  this._initTextures(); // this._pourArrays();\n  // this._bindBuffers();\n\n};\n/**\n * TODO: temporal\n */\n\n\nPMDModelView.prototype.setBasePosition = function (x, y, z) {\n  this.basePosition[0] = x;\n  this.basePosition[1] = y;\n  this.basePosition[2] = z;\n\n  this._initMotions2();\n\n  for (var i = 0; i < this.pmd.boneCount; i++) {\n    this._getBoneMotion(i);\n  }\n\n  this.physics.resetRigidBodies(this.motions);\n};\n\nPMDModelView.prototype.setVMD = function (vmd) {\n  this.vmd = vmd;\n};\n\nPMDModelView.prototype.startDance = function () {\n  this.vmd.setup(this.pmd);\n  this.dancing = true;\n  this.frame = 0;\n\n  this._initMotions2();\n\n  this._moveBone(1);\n\n  this.physics.resetRigidBodies(this.motions);\n};\n\nPMDModelView.prototype._initArrays = function () {\n  this._initVertices();\n\n  this._initVerticesFromBones();\n\n  this._initVertexMorphs();\n\n  this._initVertexEdges();\n\n  this._initCoordinates();\n\n  this._initIndices();\n\n  this._initBoneWeights();\n\n  this._initBoneIndices();\n\n  this._initVertexNormals();\n\n  this._initMotions();\n\n  this._initMotionArrays();\n};\n\nPMDModelView.prototype._initVertices = function () {\n  for (var i = 0; i < this.pmd.vertexCount; i++) {\n    var pos = this.pmd.vertices[i].position;\n    var index = i * this._V_ITEM_SIZE;\n\n    for (var j = 0; j < this._V_ITEM_SIZE; j++) {\n      this.vArray[index + j] = pos[j];\n    }\n  }\n};\n\nPMDModelView.prototype._initVerticesFromBones = function () {\n  for (var i = 0; i < this.pmd.vertexCount; i++) {\n    var pos = this.pmd.vertices[i].position;\n    var bi1 = this.pmd.vertices[i].boneIndices[0];\n    var bi2 = this.pmd.vertices[i].boneIndices[1];\n    var b1 = this.pmd.bones[bi1];\n    var b2 = this.pmd.bones[bi2];\n    var v1 = this.vec3.create();\n    var v2 = this.vec3.create();\n\n    for (var j = 0; j < this._V_ITEM_SIZE; j++) {\n      v1[j] = pos[j] - b1.position[j];\n      v2[j] = pos[j] - b2.position[j];\n    }\n\n    this.posFromBone1.push(v1);\n    this.posFromBone2.push(v2);\n    var index = i * this._V_ITEM_SIZE;\n\n    for (var j = 0; j < this._V_ITEM_SIZE; j++) {\n      this.vArray1[index + j] = pos[j] - b1.position[j];\n      this.vArray2[index + j] = pos[j] - b2.position[j];\n    }\n  }\n};\n\nPMDModelView.prototype._initVertexMorphs = function () {\n  for (var i = 0; i < this.pmd.vertexCount; i++) {\n    var index = i * this._V_ITEM_SIZE;\n\n    for (var j = 0; j < this._V_ITEM_SIZE; j++) {\n      this.vmArray[index + j] = 0;\n    }\n  }\n};\n\nPMDModelView.prototype._initVertexEdges = function () {\n  for (var i = 0; i < this.pmd.vertexCount; i++) {\n    this.veArray[i] = this.pmd.vertices[i].edgeFlag ? 0.0 : 1.0;\n  }\n};\n\nPMDModelView.prototype._initCoordinates = function () {\n  for (var i = 0; i < this.pmd.vertexCount; i++) {\n    var index = i * this._C_ITEM_SIZE;\n    var uv = this.pmd.vertices[i].uv;\n\n    for (var j = 0; j < this._C_ITEM_SIZE; j++) {\n      this.cArray[index + j] = uv[j];\n    }\n  }\n};\n\nPMDModelView.prototype._initIndices = function () {\n  for (var i = 0; i < this.pmd.vertexIndexCount; i++) {\n    this.iArray[i] = this.pmd.vertexIndices[i].index;\n  }\n};\n\nPMDModelView.prototype._initBoneWeights = function () {\n  for (var i = 0; i < this.pmd.vertexCount; i++) {\n    this.bwArray[i] = this.pmd.vertices[i].boneWeight / 100;\n  }\n};\n\nPMDModelView.prototype._initBoneIndices = function () {\n  for (var i = 0; i < this.pmd.vertexCount; i++) {\n    for (var j = 0; j < this._BI_ITEM_SIZE; j++) {\n      this.biArray[i * this._BI_ITEM_SIZE + j] = this.pmd.vertices[i].boneIndices[j];\n    }\n  }\n};\n\nPMDModelView.prototype._initVertexNormals = function () {\n  for (var i = 0; i < this.pmd.vertexCount; i++) {\n    var nor = this.pmd.vertices[i].normal;\n    var index = i * this._VN_ITEM_SIZE;\n\n    for (var j = 0; j < this._VN_ITEM_SIZE; j++) {\n      this.vnArray[index + j] = nor[j];\n    }\n  }\n};\n\nPMDModelView.prototype._initMotionArrays = function () {\n  if (this.view.skinningType == this.view._SKINNING_CPU) {\n    this._skinning();\n\n    return;\n  }\n\n  if (this.view.skinningType == this.view._SKINNING_GPU) {\n    this._pourVTF();\n\n    return;\n  }\n\n  for (var i = 0; i < this.pmd.vertexCount; i++) {\n    var bn1 = this.pmd.vertices[i].boneIndices[0];\n    var bn2 = this.pmd.vertices[i].boneIndices[1];\n\n    var m1 = this._getBoneMotion(bn1);\n\n    var m2 = this._getBoneMotion(bn2);\n\n    var index = i * this._MT_ITEM_SIZE;\n\n    for (var j = 0; j < this._MT_ITEM_SIZE; j++) {\n      this.mtArray1[index + j] = m1.p[j];\n      this.mtArray2[index + j] = m2.p[j];\n    }\n\n    index = i * this._MR_ITEM_SIZE;\n\n    for (var j = 0; j < this._MR_ITEM_SIZE; j++) {\n      this.mrArray1[index + j] = m1.r[j];\n      this.mrArray2[index + j] = m2.r[j];\n    }\n  } // vec3 v1 = aVertexPosition1 + aVertexMorph;\\\n  // v1 = qtransform(v1, aMotionRotation1) + aMotionTranslation1;\\\n\n\n  PMDModelView.prototype.getVerticals = function (n) {\n    // var v1 = __GlslFunctions.arrayAdd(\n    //   [\n    //     this.vArray1[n * 3 + 0],\n    //     this.vArray1[n * 3 + 1],\n    //     this.vArray1[n * 3 + 2]\n    //   ],\n    //   // this.pmd.vertices[n].position,\n    //   [\n    //     this.vmArray[n * 3 + 0],\n    //     this.vmArray[n * 3 + 1],\n    //     this.vmArray[n * 3 + 2],\n    //   ]\n    // );\n    // v1 = __GlslFunctions.arrayAdd(\n    //   __GlslFunctions.qtransform(\n    //     v1,\n    //     [\n    //       this.mrArray1[n * 4 + 0],\n    //       this.mrArray1[n * 4 + 1],\n    //       this.mrArray1[n * 4 + 2],\n    //       this.mrArray1[n * 4 + 3],\n    //     ]\n    //   ),\n    //   [\n    //     this.mtArray1[n * 3 + 0],\n    //     this.mtArray1[n * 3 + 1],\n    //     this.mtArray1[n * 3 + 2],\n    //   ]\n    // );\n    // var v1 = __GlslFunctions.arrayAdd(\n    //   [\n    //     'this.vArray1[n * 3 + 0]',\n    //     'this.vArray1[n * 3 + 1]',\n    //     'this.vArray1[n * 3 + 2]'\n    //   ],\n    //   [\n    //     'this.vmArray[n * 3 + 0]',\n    //     'this.vmArray[n * 3 + 1]',\n    //     'this.vmArray[n * 3 + 2]',\n    //   ]\n    // );\n    // v1 = __GlslFunctions.arrayAdd(\n    //   __GlslFunctions.qtransform(\n    //     v1,\n    //     [\n    //       'this.mrArray1[n * 4 + 0]',\n    //       'this.mrArray1[n * 4 + 1]',\n    //       'this.mrArray1[n * 4 + 2]',\n    //       'this.mrArray1[n * 4 + 3]',\n    //     ]\n    //   ),\n    //   [\n    //     'this.mtArray1[n * 3 + 0]',\n    //     'this.mtArray1[n * 3 + 1]',\n    //     'this.mtArray1[n * 3 + 2]',\n    //   ]\n    // );\n    // console.warn(JSON.stringify(v1));\n    var v1 = [this.vArray1[n * 3 + 0] + this.vmArray[n * 3 + 0] + (((this.vArray1[n * 3 + 2] + this.vmArray[n * 3 + 2]) * this.mrArray1[n * 4 + 0] - (this.vArray1[n * 3 + 0] + this.vmArray[n * 3 + 0]) * this.mrArray1[n * 4 + 2] - (this.vArray1[n * 3 + 1] + this.vmArray[n * 3 + 1]) * this.mrArray1[n * 4 + 3]) * this.mrArray1[n * 4 + 2] - ((this.vArray1[n * 3 + 0] + this.vmArray[n * 3 + 0]) * this.mrArray1[n * 4 + 1] - (this.vArray1[n * 3 + 1] + this.vmArray[n * 3 + 1]) * this.mrArray1[n * 4 + 0] - (this.vArray1[n * 3 + 2] + this.vmArray[n * 3 + 2]) * this.mrArray1[n * 4 + 3]) * this.mrArray1[n * 4 + 1]) * 2 + this.mtArray1[n * 3 + 0], this.vArray1[n * 3 + 1] + this.vmArray[n * 3 + 1] + (((this.vArray1[n * 3 + 0] + this.vmArray[n * 3 + 0]) * this.mrArray1[n * 4 + 1] - (this.vArray1[n * 3 + 1] + this.vmArray[n * 3 + 1]) * this.mrArray1[n * 4 + 0] - (this.vArray1[n * 3 + 2] + this.vmArray[n * 3 + 2]) * this.mrArray1[n * 4 + 3]) * this.mrArray1[n * 4 + 0] - ((this.vArray1[n * 3 + 1] + this.vmArray[n * 3 + 1]) * this.mrArray1[n * 4 + 2] - (this.vArray1[n * 3 + 2] + this.vmArray[n * 3 + 2]) * this.mrArray1[n * 4 + 1] - (this.vArray1[n * 3 + 0] + this.vmArray[n * 3 + 0]) * this.mrArray1[n * 4 + 3]) * this.mrArray1[n * 4 + 2]) * 2 + this.mtArray1[n * 3 + 1], this.vArray1[n * 3 + 2] + this.vmArray[n * 3 + 2] + (((this.vArray1[n * 3 + 1] + this.vmArray[n * 3 + 1]) * this.mrArray1[n * 4 + 2] - (this.vArray1[n * 3 + 2] + this.vmArray[n * 3 + 2]) * this.mrArray1[n * 4 + 1] - (this.vArray1[n * 3 + 0] + this.vmArray[n * 3 + 0]) * this.mrArray1[n * 4 + 3]) * this.mrArray1[n * 4 + 1] - ((this.vArray1[n * 3 + 2] + this.vmArray[n * 3 + 2]) * this.mrArray1[n * 4 + 0] - (this.vArray1[n * 3 + 0] + this.vmArray[n * 3 + 0]) * this.mrArray1[n * 4 + 2] - (this.vArray1[n * 3 + 1] + this.vmArray[n * 3 + 1]) * this.mrArray1[n * 4 + 3]) * this.mrArray1[n * 4 + 0]) * 2 + this.mtArray1[n * 3 + 2]];\n\n    if (this.bwArray[n] < 0.99) {\n      var v2 = _GlslFunctions[\"default\"].arrayAdd([this.vArray2[n * 3 + 0], this.vArray2[n * 3 + 1], this.vArray2[n * 3 + 2]], // this.pmd.vertices[n].position,\n      [this.vmArray[n * 3 + 0], this.vmArray[n * 3 + 1], this.vmArray[n * 3 + 2]]);\n\n      v2 = _GlslFunctions[\"default\"].arrayAdd(_GlslFunctions[\"default\"].qtransform(v2, [this.mrArray2[n * 4 + 0], this.mrArray2[n * 4 + 1], this.mrArray2[n * 4 + 2], this.mrArray2[n * 4 + 3]]), [this.mtArray2[n * 3 + 0], this.mtArray2[n * 3 + 1], this.mtArray2[n * 3 + 2]]);\n      v1 = _GlslFunctions[\"default\"].mix(v2, v1, this.bwArray[n]);\n    }\n\n    return v1;\n  }.bind(this);\n};\n/**\n * TODO: consider the case if images aren't loaded yet.\n */\n\n\nPMDModelView.prototype._initTextures = function () {\n  return;\n\n  for (var i = 0; i < this.pmd.materialCount; i++) {\n    this.textures[i] = this.layer.generateTexture(this.pmd.images[i]);\n  }\n\n  for (var i = 0; i < this.pmd.toonTextureCount; i++) {\n    this.toonTextures[i] = this.layer.generateTexture(this.pmd.toonImages[i]);\n  }\n\n  for (var i = 0; i < this.pmd.materialCount; i++) {\n    this.sphereTextures[i] = this.layer.generateTexture(this.pmd.sphereImages[i]);\n  }\n};\n\nPMDModelView.prototype._initMotions = function () {\n  for (var i = 0; i < this.pmd.boneCount; i++) {\n    this.motions[i] = {\n      r: this.quat4.create(),\n      p: this.vec3.create(),\n      done: false\n    };\n    var b = this.pmd.bones[i];\n    var a = {};\n    a.location = [0, 0, 0];\n    a.rotation = [0, 0, 0, 1];\n    this.originalMotions[b.name] = a;\n  }\n};\n/**\n * TODO: temporal\n */\n\n\nPMDModelView.prototype._initMotions2 = function () {\n  for (var i = 0; i < this.pmd.boneCount; i++) {\n    if (!this.motions[i]) continue; // chenzhuo\n\n    this.quat4.clear(this.motions[i].r);\n    this.vec3.clear(this.motions[i].p);\n    this.motions[i].done = false;\n    var b = this.pmd.bones[i];\n    var a = this.originalMotions[b.name];\n    this.vec3.clear(a.location);\n    this.quat4.clear(a.rotation);\n  }\n};\n\nPMDModelView.prototype._packTo4Uint8 = function (f, uint8Array, offset) {\n  f = f * 1.0;\n  var sign = f < 0.0 ? 0x80 : 0x00;\n  f = this.Math.abs(f);\n  uint8Array[offset + 0] = sign | f & 0x7F;\n  uint8Array[offset + 1] = f * 256.0 & 0xFF;\n  uint8Array[offset + 2] = f * 256.0 * 256.0 & 0xFF;\n  uint8Array[offset + 3] = f * 256.0 * 256.0 * 256.0 & 0xFF;\n};\n\nPMDModelView.prototype._pourVTF = function () {\n  for (var i = 0; i < this.pmd.boneCount; i++) {\n    var offset = 7 * i * 4; // Motion Translation x, y, z\n\n    var m = this._getBoneMotion(i);\n\n    this._packTo4Uint8(m.p[0], this.vtfUint8Array, offset + 0);\n\n    this._packTo4Uint8(m.p[1], this.vtfUint8Array, offset + 4);\n\n    this._packTo4Uint8(m.p[2], this.vtfUint8Array, offset + 8); // Motion Rotation x, y, z, w\n\n\n    this._packTo4Uint8(m.r[0], this.vtfUint8Array, offset + 12);\n\n    this._packTo4Uint8(m.r[1], this.vtfUint8Array, offset + 16);\n\n    this._packTo4Uint8(m.r[2], this.vtfUint8Array, offset + 20);\n\n    this._packTo4Uint8(m.r[3], this.vtfUint8Array, offset + 24);\n  }\n\n  this.layer.pourVTF(this.vtf, this.vtfUint8Array, this.vtfWidth);\n};\n/**\n * TODO: rename\n */\n\n\nPMDModelView.prototype.skinningOneBone = function (b) {\n  if (b.id === null) return null;\n\n  var m = this._getBoneMotion(b.id);\n\n  var v = b.posFromBone;\n  var vd = [0, 0, 0];\n  this.quat4.multiplyVec3(m.r, v, vd);\n  this.vec3.add(vd, m.p, vd);\n  return vd;\n};\n\nPMDModelView.prototype._skinning = function () {\n  var vd1 = this.vec3.create();\n  var vd2 = this.vec3.create();\n\n  for (var i = 0; i < this.pmd.vertexCount; i++) {\n    var v = this.pmd.vertices[i];\n    var bw = v.boneWeight;\n    var b1Num = v.boneIndices[0];\n    var b1 = this.pmd.bones[b1Num];\n\n    var m1 = this._getBoneMotion(b1Num);\n\n    var v1 = this.posFromBone1[i];\n    this.quat4.multiplyVec3(m1.r, v1, vd1);\n    this.vec3.add(vd1, m1.p, vd1);\n    var index = i * this._V_ITEM_SIZE;\n\n    if (bw >= 99) {\n      this.vArray[index + 0] = vd1[0];\n      this.vArray[index + 1] = vd1[1];\n      this.vArray[index + 2] = vd1[2];\n    } else {\n      var b2Num = v.boneIndices[1];\n      var b2 = this.pmd.bones[b2Num];\n\n      var m2 = this._getBoneMotion(b2Num);\n\n      var v2 = this.posFromBone2[i];\n      this.quat4.multiplyVec3(m2.r, v2, vd2);\n      this.vec3.add(vd2, m2.p, vd2);\n      var bw1 = v.boneWeightFloat1;\n      var bw2 = v.boneWeightFloat2;\n      this.vArray[index + 0] = vd1[0] * bw1 + vd2[0] * bw2;\n      this.vArray[index + 1] = vd1[1] * bw1 + vd2[1] * bw2;\n      this.vArray[index + 2] = vd1[2] * bw1 + vd2[2] * bw2;\n    }\n  }\n\n  this.layer.pourArrayBuffer(this.vBuffer, this.vArray, this._V_ITEM_SIZE, this.pmd.vertexCount);\n};\n\nPMDModelView.prototype._pourArrays = function () {\n  var layer = this.layer;\n  layer.pourArrayBuffer(this.vBuffer, this.vArray, this._V_ITEM_SIZE, this.pmd.vertexCount);\n  layer.pourArrayBuffer(this.vBuffer1, this.vArray1, this._V_ITEM_SIZE, this.pmd.vertexCount);\n  layer.pourArrayBuffer(this.vBuffer2, this.vArray2, this._V_ITEM_SIZE, this.pmd.vertexCount);\n  layer.pourArrayBuffer(this.vmBuffer, this.vmArray, this._V_ITEM_SIZE, this.pmd.vertexCount);\n  layer.pourArrayBuffer(this.cBuffer, this.cArray, this._C_ITEM_SIZE, this.pmd.vertexCount);\n  layer.pourElementArrayBuffer(this.iBuffer, this.iArray, this._I_ITEM_SIZE, this.pmd.vertexIndexCount);\n  layer.pourArrayBuffer(this.bwBuffer, this.bwArray, this._BW_ITEM_SIZE, this.pmd.vertexCount);\n  layer.pourArrayBuffer(this.biBuffer, this.biArray, this._BI_ITEM_SIZE, this.pmd.vertexCount);\n  layer.pourArrayBuffer(this.vnBuffer, this.vnArray, this._VN_ITEM_SIZE, this.pmd.vertexCount);\n  layer.pourArrayBuffer(this.veBuffer, this.veArray, this._VE_ITEM_SIZE, this.pmd.vertexCount);\n};\n/**\n * TODO: remove shader specific attribute names from this class.\n */\n\n\nPMDModelView.prototype._bindBuffers = function () {\n  var layer = this.layer;\n  var gl = this.layer.gl;\n  var shader = this.layer.shader;\n  gl.bindBuffer(gl.ARRAY_BUFFER, this.vBuffer);\n  gl.enableVertexAttribArray(shader.vertexPositionAttribute);\n  gl.vertexAttribPointer(shader.vertexPositionAttribute, this.vBuffer.itemSize, gl.FLOAT, false, 0, 0);\n  gl.bindBuffer(gl.ARRAY_BUFFER, this.vBuffer1);\n  gl.enableVertexAttribArray(shader.vertexPositionAttribute1);\n  gl.vertexAttribPointer(shader.vertexPositionAttribute1, this.vBuffer1.itemSize, gl.FLOAT, false, 0, 0);\n  gl.bindBuffer(gl.ARRAY_BUFFER, this.vBuffer2);\n  gl.enableVertexAttribArray(shader.vertexPositionAttribute2);\n  gl.vertexAttribPointer(shader.vertexPositionAttribute2, this.vBuffer2.itemSize, gl.FLOAT, false, 0, 0);\n  gl.bindBuffer(gl.ARRAY_BUFFER, this.vmBuffer);\n  gl.enableVertexAttribArray(shader.vertexMorphAttribute);\n  gl.vertexAttribPointer(shader.vertexMorphAttribute, this.vmBuffer.itemSize, gl.FLOAT, false, 0, 0);\n  gl.bindBuffer(gl.ARRAY_BUFFER, this.cBuffer);\n  gl.enableVertexAttribArray(shader.textureCoordAttribute);\n  gl.vertexAttribPointer(shader.textureCoordAttribute, this.cBuffer.itemSize, gl.FLOAT, false, 0, 0);\n  gl.bindBuffer(gl.ARRAY_BUFFER, this.bwBuffer);\n  gl.enableVertexAttribArray(shader.boneWeightAttribute);\n  gl.vertexAttribPointer(shader.boneWeightAttribute, this.bwBuffer.itemSize, gl.FLOAT, false, 0, 0);\n  gl.bindBuffer(gl.ARRAY_BUFFER, this.biBuffer);\n  gl.enableVertexAttribArray(shader.boneIndicesAttribute);\n  gl.vertexAttribPointer(shader.boneIndicesAttribute, this.biBuffer.itemSize, gl.FLOAT, false, 0, 0);\n  gl.bindBuffer(gl.ARRAY_BUFFER, this.vnBuffer);\n  gl.enableVertexAttribArray(shader.vertexNormalAttribute);\n  gl.vertexAttribPointer(shader.vertexNormalAttribute, this.vnBuffer.itemSize, gl.FLOAT, false, 0, 0);\n  gl.bindBuffer(gl.ARRAY_BUFFER, this.veBuffer);\n  gl.enableVertexAttribArray(shader.vertexEdgeAttribute);\n  gl.vertexAttribPointer(shader.vertexEdgeAttribute, this.veBuffer.itemSize, gl.FLOAT, false, 0, 0);\n  gl.bindBuffer(gl.ARRAY_BUFFER, this.mtBuffer1);\n  gl.enableVertexAttribArray(shader.motionTranslationAttribute1);\n  gl.vertexAttribPointer(shader.motionTranslationAttribute1, this.mtBuffer1.itemSize, gl.FLOAT, false, 0, 0);\n  gl.bindBuffer(gl.ARRAY_BUFFER, this.mtBuffer2);\n  gl.enableVertexAttribArray(shader.motionTranslationAttribute2);\n  gl.vertexAttribPointer(shader.motionTranslationAttribute2, this.mtBuffer2.itemSize, gl.FLOAT, false, 0, 0);\n  gl.bindBuffer(gl.ARRAY_BUFFER, this.mrBuffer1);\n  gl.enableVertexAttribArray(shader.motionRotationAttribute1);\n  gl.vertexAttribPointer(shader.motionRotationAttribute1, this.mrBuffer1.itemSize, gl.FLOAT, false, 0, 0);\n  gl.bindBuffer(gl.ARRAY_BUFFER, this.mrBuffer2);\n  gl.enableVertexAttribArray(shader.motionRotationAttribute2);\n  gl.vertexAttribPointer(shader.motionRotationAttribute2, this.mrBuffer2.itemSize, gl.FLOAT, false, 0, 0);\n  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.iBuffer);\n};\n\nPMDModelView.prototype._draw = function (texture, pos, num) {\n  this.layer.draw(texture, this.layer._BLEND_ALPHA, num, pos);\n};\n/**\n * TODO: temporal\n */\n\n\nPMDModelView.prototype.update = function (dframe) {\n  this._initMotions2();\n\n  if (this.dancing) {\n    this._moveBone(dframe);\n\n    if (this.view.morphType == this.view._MORPH_ON) {\n      this._moveFace();\n    }\n  }\n\n  for (var i = 0; i < this.pmd.boneCount; i++) {\n    this._getBoneMotion(i);\n  }\n\n  if (this.view.physicsType == this.view._PHYSICS_ON) this._runPhysics(dframe);\n\n  this._initMotionArrays();\n};\n/**\n * TODO: temporal\n * TODO: optimize\n */\n\n\nPMDModelView.prototype.draw = function () {\n  var layer = this.layer;\n  var gl = this.layer.gl;\n  var shader = this.layer.shader;\n\n  this._bindBuffers(); // TODO: temporal\n\n\n  if (this.view.skinningType == this.view._SKINNING_GPU) {\n    gl.activeTexture(gl.TEXTURE1);\n    gl.bindTexture(gl.TEXTURE_2D, this.vtf);\n    gl.uniform1i(shader.uVTFUniform, 1);\n  } else {\n    gl.uniform1i(shader.uVTFUniform, 0);\n  }\n\n  gl.uniform1i(shader.edgeUniform, 0);\n  gl.enable(gl.BLEND);\n  gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.SRC_ALPHA, gl.DST_ALPHA);\n  var offset = 0;\n\n  for (var i = 0; i < this.pmd.materialCount; i++) {\n    var m = this.pmd.materials[i]; // TODO: temporal\n\n    if (m.edgeFlag) gl.uniform1i(shader.shadowUniform, 1);else gl.uniform1i(shader.shadowUniform, 0); // TODO: temporal\n\n    if (this.view.edgeType == this.view._EDGE_ON && m.color[3] == 1.0) {\n      gl.enable(gl.CULL_FACE);\n      gl.cullFace(gl.FRONT);\n    } else {\n      gl.disable(gl.CULL_FACE);\n      gl.cullFace(gl.FRONT);\n    }\n\n    gl.uniform4fv(shader.diffuseColorUniform, m.color);\n    gl.uniform3fv(shader.ambientColorUniform, m.mirrorColor);\n    gl.uniform3fv(shader.specularColorUniform, m.specularColor);\n    gl.uniform1f(shader.shininessUniform, m.specularity); // TODO: rename tune to toon\n\n    if (m.hasToon()) {\n      gl.activeTexture(gl.TEXTURE2);\n      gl.bindTexture(gl.TEXTURE_2D, this.toonTextures[m.tuneIndex]);\n      gl.uniform1i(shader.toonTextureUniform, 2);\n      gl.uniform1i(shader.useToonUniform, 1);\n    } else {\n      gl.uniform1i(shader.useToonUniform, 0);\n    }\n\n    if (this.view.sphereMapType == this.view._SPHERE_MAP_ON && m.hasSphereTexture()) {\n      gl.activeTexture(gl.TEXTURE3);\n      gl.bindTexture(gl.TEXTURE_2D, this.sphereTextures[i]);\n      gl.uniform1i(shader.sphereTextureUniform, 3);\n      gl.uniform1i(shader.useSphereMapUniform, 1);\n\n      if (m.isSphereMapAddition()) {\n        gl.uniform1i(shader.useSphereMapAdditionUniform, 1);\n      } else {\n        gl.uniform1i(shader.useSphereMapAdditionUniform, 0);\n      }\n    } else {\n      gl.uniform1i(shader.useSphereMapUniform, 0);\n    }\n\n    var num = this.pmd.materials[i].vertexCount;\n\n    this._draw(this.textures[i], offset, num); // textrue!!!!!  6=eye\n\n\n    offset += num;\n  }\n};\n\nPMDModelView.prototype.drawEdge = function () {\n  var layer = this.layer;\n  var gl = this.layer.gl;\n  var shader = this.layer.shader;\n  gl.uniform1i(shader.edgeUniform, 1);\n  gl.uniform1i(shader.useToonUniform, 0);\n  gl.cullFace(gl.BACK);\n  gl.disable(gl.BLEND);\n  gl.enable(gl.CULL_FACE); // Note: attempt to call _draw() as less as possible\n\n  var offset = 0;\n  var num = 0;\n  var flag = false;\n\n  for (var i = 0; i < this.pmd.materialCount; i++) {\n    num += this.pmd.materials[i].vertexCount;\n\n    if (!this.pmd.materials[i].edgeFlag) {\n      if (flag) this._draw(this.textures[0], offset, num);\n      offset += num;\n      num = 0;\n      flag = false;\n    } else {\n      flag = true;\n    }\n  }\n\n  if (flag) this._draw(this.textures[0], offset, num);\n};\n\nPMDModelView.prototype.drawShadowMap = function () {\n  var layer = this.layer;\n  var gl = this.layer.gl;\n  var shader = this.layer.shader;\n\n  this._bindBuffers(); // TODO: temporal\n\n\n  if (this.view.skinningType == this.view._SKINNING_GPU) {\n    gl.activeTexture(gl.TEXTURE1);\n    gl.bindTexture(gl.TEXTURE_2D, this.vtf);\n    gl.uniform1i(shader.uVTFUniform, 1);\n  } else {\n    gl.uniform1i(shader.uVTFUniform, 0);\n  }\n\n  gl.uniform1i(shader.edgeUniform, 0);\n  gl.disable(gl.BLEND);\n  gl.disable(gl.CULL_FACE);\n  gl.cullFace(gl.FRONT);\n\n  this._draw(this.textures[0], 0, this.pmd.vertexIndexCount);\n};\n/**\n * TODO: temporal\n */\n\n\nPMDModelView.prototype._runPhysics = function (dframe) {\n  if (dframe == 1) this.physics.simulate(this.motions);else this.physics.simulateFrame(this.motions, dframe);\n};\n/**\n * TODO: rename\n */\n\n\nPMDModelView.prototype._loadFromVMD = function (dframe) {\n  this.vmd.loadMotion();\n  if (this.view.morphType == this.view._MORPH_ON) this.vmd.loadFace();\n  this.vmd.step(dframe);\n  this.frame += dframe;\n};\n/**\n * TODO: temporal\n * TODO: any ways to avoid update all morph Buffer?\n */\n\n\nPMDModelView.prototype._moveFace = function () {\n  var done = false;\n\n  for (var i = 0; i < this.pmd.faceCount; i++) {\n    var f = this.vmd.getFace(this.pmd.faces[i]);\n\n    if (f.available) {\n      this._moveMorph(this.pmd.faces[i].id, f.weight);\n\n      done = true;\n    }\n  }\n\n  if (!done) return; // !!!!!!\n  // this.layer.pourArrayBuffer(this.vmBuffer, this.vmArray,\n  //                            this._V_ITEM_SIZE, this.pmd.vertexCount);\n\n  var base = this.pmd.faces[0];\n\n  for (var i = 0; i < base.vertexCount; i++) {\n    var v = base.vertices[i];\n    var o = v.index * this._V_ITEM_SIZE;\n    this.vmArray[o + 0] = 0;\n    this.vmArray[o + 1] = 0;\n    this.vmArray[o + 2] = 0;\n  }\n};\n/**\n * TODO: temporal\n */\n\n\nPMDModelView.prototype._moveBone = function (dframe) {\n  this._loadFromVMD(dframe);\n\n  for (var i = 0; i < this.pmd.boneCount; i++) {\n    this._getBoneMotion(i);\n  }\n\n  if (this.view.ikType == this.view._IK_ON) this._resolveIK();\n}; // TODO: move generic place\n\n\n_glMatrix095Min.vec3.clear = function (v) {\n  v[0] = 0;\n  v[1] = 0;\n  v[2] = 0;\n};\n\n_glMatrix095Min.quat4.clear = function (q) {\n  q[0] = 0;\n  q[1] = 0;\n  q[2] = 0;\n  q[3] = 1;\n};\n\nPMDModelView.prototype._getOriginalBoneMotion = function (bone) {\n  return this.dancing ? this.vmd.getBoneMotion(bone) : this.originalMotions[bone.name];\n};\n\nPMDModelView.prototype._getBoneMotion = function (index) {\n  var motion = this.motions[index];\n\n  if (!motion.done) {\n    this._resolveFK(motion, index);\n  }\n\n  return motion;\n};\n\nPMDModelView.prototype._resolveFK = function (motion, index) {\n  // TODO: temporal work around\n  var m = this._getOriginalBoneMotion(this.pmd.bones[index]);\n\n  var b = this.pmd.bones[index];\n\n  if (this.pmd.bones[index].parentIndex === 0xFFFF) {\n    this.vec3.add(b.position, m.location, motion.p);\n    this.vec3.add(motion.p, this.basePosition, motion.p);\n    this.quat4.set(m.rotation, motion.r);\n  } else {\n    var parentMotion = this._getBoneMotion(b.parentIndex);\n\n    var parentBone = this.pmd.bones[b.parentIndex];\n    this.quat4.multiply(parentMotion.r, m.rotation, motion.r);\n    this.vec3.subtract(b.position, parentBone.position, motion.p);\n    this.vec3.add(motion.p, m.location, motion.p);\n    this.quat4.multiplyVec3(parentMotion.r, motion.p, motion.p);\n    this.vec3.add(motion.p, parentMotion.p, motion.p);\n  }\n\n  motion.done = true;\n};\n/**\n * copied from MMD.js so far\n */\n\n\nPMDModelView.prototype._resolveIK = function () {\n  var axis = this.vec3.create();\n  var tbv = this.vec3.create();\n  var ikv = this.vec3.create();\n  var tmpQ = this.quat4.create();\n  var tmpR = this.quat4.create();\n\n  for (var i = 0; i < this.pmd.ikCount; i++) {\n    var ik = this.pmd.iks[i];\n    var ikb = this.pmd.bones[ik.index];\n    var tb = this.pmd.bones[ik.targetBoneIndex];\n    var tpb = this.pmd.bones[tb.parentIndex];\n\n    var ikm = this._getBoneMotion(ik.index);\n\n    var tbm = this._getBoneMotion(ik.targetBoneIndex);\n\n    var iterations = ik.iteration;\n    var chainLength = ik.chainLength;\n    this.vec3.subtract(tb.position, tpb.position, axis);\n    var minLength = 0.1 * this.vec3.length(axis);\n\n    for (var j = 0; j < iterations; j++) {\n      this.vec3.subtract(tbm.p, ikm.p, axis);\n\n      if (minLength > this.vec3.length(axis)) {\n        break;\n      }\n\n      for (var k = 0; k < chainLength; k++) {\n        var bn = ik.childBoneIndices[k];\n        var cb = this.pmd.bones[bn];\n\n        var cbm = this._getBoneMotion(bn);\n\n        tbm = this._getBoneMotion(ik.targetBoneIndex);\n        this.vec3.subtract(tbm.p, cbm.p, tbv);\n        this.vec3.subtract(ikm.p, cbm.p, ikv);\n        this.vec3.cross(tbv, ikv, axis);\n        var tbvl = this.vec3.length(tbv);\n        var ikvl = this.vec3.length(ikv);\n        var axisLen = this.vec3.length(axis);\n        var sinTheta = axisLen / ikvl / tbvl; // Note: somehow tbm.p can be NaN and make sinTheta Nan.\n        // TODO: fix this problem because isNaN not so light function.\n\n        if (isNaN(sinTheta)) {\n          continue;\n        }\n\n        if (tbvl < minLength || ikvl < minLength || sinTheta < 0.001) continue;\n        var maxangle = (k + 1) * ik.limitation * 4;\n        var theta = this.Math.asin(sinTheta);\n\n        if (this.vec3.dot(tbv, ikv) < 0) {\n          theta = 3.141592653589793 - theta;\n        }\n\n        if (theta > maxangle) theta = maxangle;\n        this.vec3.scale(axis, this.Math.sin(theta / 2) / axisLen, axis);\n        this.vec3.set(axis, tmpQ);\n        tmpQ[3] = this.Math.cos(theta / 2);\n\n        var parentRotation = this._getBoneMotion(cb.parentIndex).r;\n\n        this.quat4.inverse(parentRotation, tmpR);\n        this.quat4.multiply(tmpR, tmpQ, tmpR);\n        this.quat4.multiply(tmpR, cbm.r, tmpR);\n\n        if (this.pmd.bones[bn].isKnee()) {\n          var c = tmpR[3] > 1.0 ? 1.0 : tmpR[3]; // Note: Not to be NaN\n          // TODO: is this negative x right?\n\n          this.quat4.set([-this.Math.sqrt(1 - c * c), 0, 0, c], tmpR);\n          this.quat4.inverse(cbm.r, tmpQ);\n          this.quat4.multiply(tmpR, tmpQ, tmpQ);\n          this.quat4.multiply(parentRotation, tmpQ, tmpQ);\n        }\n\n        this.quat4.normalize(tmpR, this.vmd.getBoneMotion(cb).rotation);\n        this.quat4.multiply(tmpQ, cbm.r, cbm.r);\n        this.motions[ik.targetBoneIndex].done = false;\n\n        for (var l = 0; l <= k; l++) {\n          this.motions[ik.childBoneIndices[l]].done = false;\n        }\n      }\n    }\n  }\n};\n/**\n * TODO: temporal\n */\n\n\nPMDModelView.prototype._moveMorph = function (index, weight) {\n  //  this._initVertexMorphs();\n  // TODO: temporal\n  if (index == 0) {\n    return;\n  }\n\n  var f = this.pmd.faces[index];\n  var base = this.pmd.faces[0];\n\n  for (var i = 0; i < f.vertexCount; i++) {\n    var v = base.vertices[f.vertices[i].index];\n    var o = v.index * this._V_ITEM_SIZE;\n    this.vmArray[o + 0] += f.vertices[i].position[0] * weight;\n    this.vmArray[o + 1] += f.vertices[i].position[1] * weight;\n    this.vmArray[o + 2] += f.vertices[i].position[2] * weight;\n  }\n};\n\nmodule.exports = PMDModelView;\n\n//# sourceURL=webpack:///./src/plugin-webgl/mmd/PmdModelView_easycanvas.js?");

/***/ }),

/***/ "./src/plugin-webgl/mmd/PmdView_easycanvas.js":
/*!****************************************************!*\
  !*** ./src/plugin-webgl/mmd/PmdView_easycanvas.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _glMatrix095Min = __webpack_require__(/*! lib/_glMatrix-0.9.5.min.js */ \"./src/lib/_glMatrix-0.9.5.min.js\");\n\n/**\n * TODO: refactoring\n */\nfunction PMDView(layer) {\n  this.layer = layer;\n  this.modelViews = [];\n  this.vmd = null;\n  this.audio = null;\n  this.eye = [0, 0, 0];\n  this.center = [0, 0, 0];\n  this.up = [0, 1, 0];\n  this.cameraTranslation = [0, 0, 0];\n  this.cameraQuaternion = [0, 0, 0, 1];\n  this.cameraDistance = 0;\n  this.frame = 0;\n  this.dframe = 1;\n  this.camera = {};\n  this.camera.location = [0, 0, 0];\n  this.camera.rotation = [0, 0, 0];\n  this.length = 0;\n  this.angle = 0;\n  this.oldDate = null;\n  this.startDate = null;\n  this.audioStart = false;\n  this.dancing = false;\n  this.elapsedTime = 0.0;\n  this.skinningType = null;\n  this.lightingType = null;\n  this.ikType = null;\n  this.edgeType = null;\n  this.morphType = null;\n  this.sphereMapType = null;\n  this.shadowMappingType = null;\n  this.lightColor = [0, 0, 0];\n  this.runType = null;\n  this.stageType = null;\n  this.effectFlag = null;\n  this.audioType = null;\n  this.physicsType = null;\n  this.setLightingType(this._LIGHTING_ON);\n  this.setSkinningType(this._SKINNING_CPU_AND_GPU);\n  this.setIKType(this._IK_ON);\n  this.setMorphType(this._MORPH_ON);\n  this.setSphereMapType(this._SPHERE_MAP_ON);\n  this.setShadowMappingType(this._SHADOW_MAPPING_OFF);\n  this.setEdgeType(this._EDGE_ON);\n  this.setRunType(this._RUN_REALTIME_ORIENTED);\n  this.setStageType(this._STAGE_2);\n  this.setEffectFlag(this._EFFECT_OFF);\n  this.setAudioType(this._AUDIO_ON);\n  this.setPhysicsType(this._PHYSICS_ON);\n  this.setLightColor(1.0);\n}\n\n; // Note: for reference\n\nPMDView.prototype.Math = Math;\nPMDView.prototype.vec3 = _glMatrix095Min.vec3;\nPMDView.prototype.quat4 = _glMatrix095Min.quat4;\nPMDView.prototype.mat4 = _glMatrix095Min.mat4;\nPMDView.prototype._FRAME_S = 1 / 60;\nPMDView.prototype._FRAME_MS = 1 / 60 * 1000;\nPMDView.prototype._PHYSICS_OFF = 0;\nPMDView.prototype._PHYSICS_ON = 1;\nPMDView.prototype._PHYSICS_WORKERS_ON = 2; // Note: these skinning@parameters must correspond to vertex shader.\n\nPMDView.prototype._SKINNING_CPU = 0;\nPMDView.prototype._SKINNING_GPU = 1;\nPMDView.prototype._SKINNING_CPU_AND_GPU = 2; // Note: these lighting parameters must correspond to vertex shader.\n\nPMDView.prototype._LIGHTING_OFF = 0;\nPMDView.prototype._LIGHTING_ON = 1;\nPMDView.prototype._LIGHTING_ON_WITH_TOON = 2;\nPMDView.prototype._IK_OFF = 0;\nPMDView.prototype._IK_ON = 1;\nPMDView.prototype._MORPH_OFF = 0;\nPMDView.prototype._MORPH_ON = 1;\nPMDView.prototype._SPHERE_MAP_OFF = 0;\nPMDView.prototype._SPHERE_MAP_ON = 1;\nPMDView.prototype._SHADOW_MAPPING_OFF = 0;\nPMDView.prototype._SHADOW_MAPPING_ON = 1;\nPMDView.prototype._SHADOW_MAPPING_ONLY = 2;\nPMDView.prototype._RUN_FRAME_ORIENTED = 0;\nPMDView.prototype._RUN_REALTIME_ORIENTED = 1;\nPMDView.prototype._RUN_AUDIO_ORIENTED = 2;\nPMDView.prototype._AUDIO_OFF = 0;\nPMDView.prototype._AUDIO_ON = 1;\nPMDView.prototype._EDGE_OFF = 0;\nPMDView.prototype._EDGE_ON = 1;\nPMDView.prototype._STAGE_OFF = 0;\nPMDView.prototype._STAGE_1 = 1;\nPMDView.prototype._STAGE_2 = 2;\nPMDView.prototype._STAGE_3 = 3;\nPMDView.prototype._EFFECT_OFF = 0x0;\nPMDView.prototype._EFFECT_BLUR = 0x1;\nPMDView.prototype._EFFECT_GAUSSIAN = 0x2;\nPMDView.prototype._EFFECT_DIFFUSION = 0x4;\nPMDView.prototype._EFFECT_DIVISION = 0x8;\nPMDView.prototype._EFFECT_LOW_RESO = 0x10;\nPMDView.prototype._EFFECT_FACE_MOSAIC = 0x20;\nPMDView._PHYSICS_OFF = PMDView.prototype._PHYSICS_OFF;\nPMDView._PHYSICS_ON = PMDView.prototype._PHYSICS_ON;\nPMDView._PHYSICS_WORKERS_ON = PMDView.prototype._PHYSICS_WORKERS_ON;\nPMDView._SKINNING_CPU = PMDView.prototype._SKINNING_CPU;\nPMDView._SKINNING_GPU = PMDView.prototype._SKINNING_GPU;\nPMDView._SKINNING_CPU_AND_GPU = PMDView.prototype._SKINNING_CPU_AND_GPU;\nPMDView._LIGHTING_OFF = PMDView.prototype._LIGHTING_OFF;\nPMDView._LIGHTING_ON = PMDView.prototype._LIGHTING_ON;\nPMDView._LIGHTING_ON_WITH_TOON = PMDView.prototype._LIGHTING_ON_WITH_TOON;\nPMDView._IK_OFF = PMDView.prototype._IK_OFF;\nPMDView._IK_ON = PMDView.prototype._IK_ON;\nPMDView._MORPH_OFF = PMDView.prototype._MORPH_OFF;\nPMDView._MORPH_ON = PMDView.prototype._MORPH_ON;\nPMDView._SPHERE_MAP_OFF = PMDView.prototype._SPHERE_MAP_OFF;\nPMDView._SPHERE_MAP_ON = PMDView.prototype._SPHERE_MAP_ON;\nPMDView._SHADOW_MAPPING_OFF = PMDView.prototype._SHADOW_MAPPING_OFF;\nPMDView._SHADOW_MAPPING_ON = PMDView.prototype._SHADOW_MAPPING_ON;\nPMDView._SHADOW_MAPPING_ONLY = PMDView.prototype._SHADOW_MAPPING_ONLY;\nPMDView._RUN_FRAME_ORIENTED = PMDView.prototype._RUN_FRAME_ORIENTED;\nPMDView._RUN_REALTIME_ORIENTED = PMDView.prototype._RUN_REALTIME_ORIENTED;\nPMDView._RUN_AUDIO_ORIENTED = PMDView.prototype._RUN_AUDIO_ORIENTED;\nPMDView._AUDIO_OFF = PMDView.prototype._AUDIO_OFF = 0;\nPMDView._AUDIO_ON = PMDView.prototype._AUDIO_ON = 1;\nPMDView._EDGE_OFF = PMDView.prototype._EDGE_OFF;\nPMDView._EDGE_ON = PMDView.prototype._EDGE_ON;\nPMDView._STAGE_OFF = PMDView.prototype._STAGE_OFF;\nPMDView._STAGE_1 = PMDView.prototype._STAGE_1;\nPMDView._STAGE_2 = PMDView.prototype._STAGE_2;\nPMDView._STAGE_3 = PMDView.prototype._STAGE_3;\nPMDView._EFFECT_OFF = PMDView.prototype._EFFECT_OFF;\nPMDView._EFFECT_BLUR = PMDView.prototype._EFFECT_BLUR;\nPMDView._EFFECT_GAUSSIAN = PMDView.prototype._EFFECT_GAUSSIAN;\nPMDView._EFFECT_DIFFUSION = PMDView.prototype._EFFECT_DIFFUSION;\nPMDView._EFFECT_DIVISION = PMDView.prototype._EFFECT_DIVISION;\nPMDView._EFFECT_LOW_RESO = PMDView.prototype._EFFECT_LOW_RESO;\nPMDView._EFFECT_FACE_MOSAIC = PMDView.prototype._EFFECT_FACE_MOSAIC;\n\nPMDView.prototype.addModelView = function (view) {\n  this.modelViews.push(view);\n};\n\nPMDView.prototype.getModelView = function (index) {\n  return this.modelViews[index];\n};\n\nPMDView.prototype.getModelNum = function () {\n  return this.modelViews.length;\n};\n\nPMDView.prototype.setup = function () {\n  for (var i = 0; i < this.modelViews.length; i++) {\n    this.modelViews[i].setup();\n  }\n\n  this.elapsedTime = 0.0;\n};\n\nPMDView.prototype.setVMD = function (vmd) {\n  this.vmd = vmd;\n  this.vmd.supply();\n};\n\nPMDView.prototype.setAudio = function (audio, offset) {\n  this.audio = {};\n  this.audio.audio = audio;\n  this.audio.offset = offset;\n};\n\nPMDView.prototype.startDance = function () {\n  this.vmd.setup(this.modelViews[0].pmd);\n  this.elapsedTime = 0.0;\n  this.dancing = true;\n  this.oldDate = null;\n  this.startDate = Date.now();\n  this.frame = 0;\n  this.dframe = 0;\n\n  for (var i = 0; i < this.modelViews.length; i++) {\n    this.modelViews[i].setVMD(this.vmd.clone());\n    this.modelViews[i].startDance();\n  }\n};\n\nPMDView.prototype.setEye = function (eye) {\n  for (var i = 0; i < this.eye.length; i++) {\n    this.eye[i] = eye[i];\n  }\n\n  this.center[0] = eye[0];\n  this.center[1] = eye[1];\n  this.resetCameraMove();\n};\n\nPMDView.prototype.setPhysicsType = function (type) {\n  this.physicsType = type;\n};\n\nPMDView.prototype.setSkinningType = function (type) {\n  this.skinningType = type;\n};\n\nPMDView.prototype.setLightingType = function (type) {\n  this.lightingType = type;\n};\n\nPMDView.prototype.setLightColor = function (color) {\n  this.lightColor[0] = color;\n  this.lightColor[1] = color;\n  this.lightColor[2] = color;\n};\n\nPMDView.prototype.setIKType = function (type) {\n  this.ikType = type;\n};\n\nPMDView.prototype.setMorphType = function (type) {\n  this.morphType = type;\n};\n\nPMDView.prototype.setSphereMapType = function (type) {\n  this.sphereMapType = type;\n};\n\nPMDView.prototype.setShadowMappingType = function (type) {\n  this.shadowMappingType = type;\n};\n\nPMDView.prototype.setRunType = function (type) {\n  this.runType = type;\n};\n\nPMDView.prototype.setStageType = function (type) {\n  this.stageType = type;\n};\n/**\n * TODO: override so far\n */\n\n\nPMDView.prototype.setEffectFlag = function (flag) {\n  this.effectFlag = flag;\n};\n\nPMDView.prototype.setAudioType = function (type) {\n  this.audioType = type;\n};\n\nPMDView.prototype.setEdgeType = function (type) {\n  this.edgeType = type;\n};\n\nPMDView.prototype.moveCameraQuaternion = function (q) {\n  this.quat4.multiply(this.cameraQuaternion, q, this.cameraQuaternion);\n};\n\nPMDView.prototype.moveCameraQuaternionByXY = function (dx, dy) {\n  dx = -dx;\n  dy = -dy;\n  var length = this.Math.sqrt(dx * dx + dy * dy);\n\n  if (length != 0.0) {\n    var radian = length * this.Math.PI;\n    var theta = this.Math.sin(radian) / length;\n    var q = this.quat4.create([dy * theta, dx * theta, 0.0, this.Math.cos(radian)]);\n    this.moveCameraQuaternion(q);\n    return true;\n  }\n\n  return false;\n};\n\nPMDView.prototype.moveCameraTranslation = function (dx, dy) {\n  dy = -dy;\n  this.cameraTranslation[0] += dx * 50;\n  this.cameraTranslation[1] += dy * 50;\n};\n\nPMDView.prototype.resetCameraMove = function () {\n  this.cameraDistance = 0;\n  this.cameraTranslation[0] = 0;\n  this.cameraTranslation[1] = 0;\n  this.cameraTranslation[2] = 0;\n  this.cameraQuaternion[0] = 0;\n  this.cameraQuaternion[1] = 0;\n  this.cameraQuaternion[2] = 0;\n  this.cameraQuaternion[3] = 1;\n};\n\nPMDView.prototype.moveCameraForward = function (d) {\n  if (d > 0) this.cameraDistance -= 25;\n  if (d < 0) this.cameraDistance += 25;\n  if (this.cameraDistance <= -100) this.cameraDistance = -99;\n};\n\nPMDView.prototype._getCalculatedCameraParams = function (eye, center, up) {\n  this.vec3.set(this.eye, eye);\n  this.vec3.set(this.center, center);\n  this.vec3.set(this.up, up);\n  this.quat4.multiplyVec3(this.cameraQuaternion, eye, eye);\n  this.quat4.multiplyVec3(this.cameraQuaternion, up, up);\n  var t = [0, 0, 0];\n  this.vec3.set(this.cameraTranslation, t);\n  this.quat4.multiplyVec3(this.cameraQuaternion, t, t);\n  this.vec3.add(eye, t, eye);\n  this.vec3.add(center, t, center);\n  var d = [0, 0, 0];\n  this.vec3.subtract(eye, center, d);\n  eye[0] += d[0] * this.cameraDistance * 0.01;\n  eye[1] += d[1] * this.cameraDistance * 0.01;\n  eye[2] += d[2] * this.cameraDistance * 0.01;\n};\n/**\n * TODO: temporal\n * TODO: optimize\n */\n\n\nPMDView.prototype._calculateDframe = function () {\n  var newDate = Date.now();\n\n  if (this.runType == this._RUN_FRAME_ORIENTED) {\n    this.dframe = 1;\n    this.elapsedTime += this._FRAME_MS;\n  } else if (this.runType == this._RUN_REALTIME_ORIENTED || !this.dancing || this.audio === null) {\n    if (this.oldDate) {\n      var prevElapsedTime = this.elapsedTime;\n      var oldFrame = this.elapsedTime / this._FRAME_MS | 0;\n      this.elapsedTime += newDate - this.oldDate;\n      var newFrame = this.elapsedTime / this._FRAME_MS | 0;\n      var dframe = newFrame - oldFrame;\n\n      if (dframe <= 0) {\n        newDate = this.oldDate;\n        dframe = 0;\n        this.elapsedTime = prevElapsedTime;\n      }\n\n      this.dframe = dframe;\n    } else {\n      this.dframe = 0;\n    }\n  } else {\n    // TODO: temporal logic\n    if (this.audioStart) {\n      newDate = this.audio.audio.currentTime * 1000 + this.startDate + this.audio.offset * this._FRAME_MS;\n    }\n\n    if (this.oldDate) {\n      var prevElapsedTime = this.elapsedTime;\n      var oldFrame = this.elapsedTime / this._FRAME_MS | 0;\n      this.elapsedTime += newDate - this.oldDate;\n      var newFrame = this.elapsedTime / this._FRAME_MS | 0;\n      var dframe = newFrame - oldFrame;\n\n      if (dframe <= 0) {\n        newDate = this.oldDate;\n        dframe = 0;\n        this.elapsedTime = prevElapsedTime;\n      }\n\n      this.dframe = dframe;\n    } else {\n      this.dframe = 0;\n    }\n  }\n\n  this.oldDate = newDate;\n};\n/**\n * TODO: temporal\n * TODO: maybe better to avoid dom operation to improve the performance\n */\n\n\nPMDView.prototype._controlAudio = function () {\n  if (!this.audio || this.audioStart || this.audioType == this._AUDIO_OFF) return;\n\n  if (!this.audio.offset || this.frame >= this.audio.offset) {\n    this.audio.audio.play();\n\n    if (this.audio.offset < 0) {\n      this.audio.audio.currentTime = -this.audio.offset * this._FRAME_S;\n    }\n\n    this.audioStart = true;\n  }\n};\n/**\n * TODO: temporal\n */\n\n\nPMDView.prototype.update = function () {\n  // 每个step !!!!\n  this._controlAudio();\n\n  this._calculateDframe(); // 物理?\n\n\n  if (this.dframe == 0) return;\n\n  if (this.dancing) {\n    this._loadFromVMD(this.dframe); // 物理?\n\n  }\n\n  for (var i = 0; i < this.modelViews.length; i++) {\n    this.modelViews[i].update(this.dframe); // 物理?\n  }\n};\n/**\n * TODO: multiple post effect support.\n * TODO: optimize\n */\n\n\nPMDView.prototype.draw = function () {\n  if (this.dframe == 0) return;\n  var layer = this.layer;\n  var gl = layer.gl;\n  var shader = layer.shader; // TODO: temmporal\n\n  var postEffect = this.effectFlag & this._EFFECT_BLUR ? layer.postEffects['blur'] : this.effectFlag & this._EFFECT_GAUSSIAN ? layer.postEffects['gaussian'] : this.effectFlag & this._EFFECT_DIFFUSION ? layer.postEffects['diffusion'] : this.effectFlag & this._EFFECT_DIVISION ? layer.postEffects['division'] : this.effectFlag & this._EFFECT_LOW_RESO ? layer.postEffects['low_reso'] : this.effectFlag & this._EFFECT_FACE_MOSAIC ? layer.postEffects['face_mosaic'] : null;\n\n  if (this.shadowMappingType != this._SHADOW_MAPPING_OFF) {\n    if (this.shadowMappingType == this._SHADOW_MAPPING_ONLY) {\n      gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n      layer.viewport();\n      layer.perspective(layer.viewAngle);\n    } else {\n      gl.bindFramebuffer(gl.FRAMEBUFFER, layer.shadowFrameBuffer.f);\n      gl.viewport(0, 0, layer.shadowFrameBufferSize, layer.shadowFrameBufferSize);\n      this.mat4.perspective(layer.viewAngle, 1, layer.viewNear, layer.viewFar, layer.pMatrix);\n    }\n\n    layer.identity();\n    layer.lookAt(layer.lightPosition, layer.lightCenter, layer.lightUpDirection);\n    layer.registerLightMatrix();\n    gl.uniform1i(shader.shadowGenerationUniform, 1);\n    gl.uniform1i(shader.shadowTextureUniform, 0);\n    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\n\n    for (var i = 0; i < this.modelViews.length; i++) {\n      this.modelViews[i].drawShadowMap();\n    }\n\n    gl.flush();\n    gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n    gl.uniform1i(shader.shadowMappingUniform, 1);\n    gl.activeTexture(gl.TEXTURE4);\n    gl.bindTexture(gl.TEXTURE_2D, this.layer.shadowFrameBuffer.t);\n    gl.uniform1i(shader.shadowTextureUniform, 4);\n    gl.uniformMatrix4fv(shader.lightMatrixUniform, false, layer.lightMatrix);\n    if (this.shadowMappingType == this._SHADOW_MAPPING_ONLY) return;\n  } else {\n    gl.uniform1i(shader.shadowMappingUniform, 0);\n  }\n\n  this._setCamera();\n\n  this._setDrawParameters();\n\n  gl.uniform1i(shader.shadowGenerationUniform, 0);\n  var postShader = postEffect === null ? null : postEffect.shader;\n\n  if (this.effectFlag != this._EFFECT_OFF) {\n    postEffect.bindFrameBufferForScene();\n  } else {\n    gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n  }\n\n  gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\n\n  for (var i = 0; i < this.modelViews.length; i++) {\n    this.modelViews[i].draw();\n\n    if (this.edgeType == this._EDGE_ON) {\n      this.modelViews[i].drawEdge();\n    }\n  }\n\n  if (this.stageType != this._STAGE_OFF) {\n    this._drawStage();\n\n    if (this.effectFlag == this._EFFECT_OFF) gl.useProgram(shader);\n  }\n\n  gl.flush();\n\n  if (this.effectFlag != this._EFFECT_OFF) {\n    gl.useProgram(postShader);\n    postShader.frame = this.frame;\n    postEffect.draw(this);\n    gl.useProgram(shader);\n  }\n};\n\nPMDView.prototype._setCamera = function () {\n  var layer = this.layer;\n  var gl = layer.gl;\n  var shader = layer.shader;\n  layer.viewport();\n  var angle = 60;\n\n  if (this.dancing && this.vmd.getCamera().available) {\n    angle = this.vmd.getCamera().angle;\n    this.vmd.getCalculatedCameraParams(this.eye, this.center, this.up);\n  }\n\n  layer.perspective(angle);\n  layer.identity();\n  var eye = [0, 0, 0];\n  var center = [0, 0, 0];\n  var up = [0, 0, 0];\n\n  this._getCalculatedCameraParams(eye, center, up);\n\n  layer.lookAt(eye, center, up); //  layer.lookAt(this.eye, this.center, this.up);\n};\n\nPMDView.prototype._setDrawParameters = function () {\n  var layer = this.layer;\n  var gl = layer.gl;\n  var shader = layer.shader;\n  gl.uniform1i(shader.uSkinningTypeUniform, this.skinningType);\n  gl.uniform1i(shader.uLightingTypeUniform, this.lightingType);\n  gl.uniform3fv(shader.lightColorUniform, this.lightColor);\n  gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\n};\n/**\n * TODO: temporal\n * TODO: optimize\n */\n\n\nPMDView.prototype._drawStage = function () {\n  var layer = this.layer;\n  var gl = this.layer.gl;\n  var stage = this.layer.stageShaders[this.stageType - 1];\n  var shader = stage.shader;\n  var cPos = [];\n  var lfPos = [];\n  var rfPos = [];\n\n  for (var i = 0; i < this.modelViews.length; i++) {\n    var v = this.modelViews[i];\n    cPos.push(v.skinningOneBone(v.pmd.centerBone));\n    lfPos.push(v.skinningOneBone(v.pmd.leftFootBone));\n    rfPos.push(v.skinningOneBone(v.pmd.rightFootBone));\n  }\n\n  cPos = [].concat.apply([], cPos);\n  lfPos = [].concat.apply([], lfPos);\n  rfPos = [].concat.apply([], rfPos);\n  var sFlag = false;\n\n  if (this.shadowMappingType == this._SHADOW_MAPPING_ON) {\n    sFlag = true;\n  }\n\n  stage.draw(this.frame, this.modelViews.length, cPos, lfPos, rfPos, sFlag, layer.lightMatrix);\n};\n/**\n * TODO: rename\n */\n\n\nPMDView.prototype._loadFromVMD = function (dframe) {\n  this.vmd.loadCamera();\n  this.vmd.loadLight();\n  this.vmd.step(dframe);\n  this.frame += dframe;\n};\n/**\n * TODO: implement correctly\n */\n\n\nPMDView.prototype._moveLight = function () {\n  var light = this.vmd.getLight();\n  if (!light.available) return;\n  this.layer.gl.uniform3fv(this.layer.shader.lightColorUniform, light.color);\n  this.layer.lightPosition = light.location;\n};\n\nmodule.exports = PMDView;\n\n//# sourceURL=webpack:///./src/plugin-webgl/mmd/PmdView_easycanvas.js?");

/***/ }),

/***/ "./src/plugin-webgl/mmd/Vmd.js":
/*!*************************************!*\
  !*** ./src/plugin-webgl/mmd/Vmd.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _glMatrix095Min = __webpack_require__(/*! lib/_glMatrix-0.9.5.min.js */ \"./src/lib/_glMatrix-0.9.5.min.js\");\n\n/**\n * instance of classes in this file should be created and\n * their fields should be set by VMDFileParser.\n */\nfunction VMD() {\n  this.header = null;\n  this.motionCount = null;\n  this.faceCount = null;\n  this.cameraCount = null;\n  this.lightCount = null;\n  this.motions = [];\n  this.faces = [];\n  this.cameras = [];\n  this.lights = [];\n  this.frame = 0;\n  this.orderedMotions = [];\n  this.orderedFaces = [];\n  this.orderedCameras = [];\n  this.orderedLights = [];\n  this.cameraIndex = -1;\n  this.lightIndex = -1; // TODO: rename\n\n  this.stepMotions = [];\n  this.stepFaces = [];\n  this.stepCamera = {\n    location: [0, 0, 0],\n    rotation: [0, 0, 0],\n    length: 0,\n    angle: 0,\n    available: true\n  };\n  this.stepLight = {\n    color: [0, 0, 0],\n    location: [0, 0, 0],\n    available: true\n  };\n}\n\n; // for reference\n\nVMD.prototype.Object = Object;\nVMD.prototype.Math = Math;\nVMD.prototype.vec3 = _glMatrix095Min.vec3;\nVMD.prototype.quat4 = _glMatrix095Min.quat4;\n\nVMD.prototype.valid = function () {\n  return this.header.valid();\n};\n\nVMD.prototype.supply = function () {\n  for (var i = 0; i < this.motionCount; i++) {\n    this.motions[i].supply();\n  }\n\n  for (var i = 0; i < this.faceCount; i++) {\n    this.faces[i].supply();\n  }\n\n  for (var i = 0; i < this.cameraCount; i++) {\n    this.cameras[i].supply();\n  }\n\n  for (var i = 0; i < this.lightCount; i++) {\n    this.lights[i].supply();\n  }\n};\n/**\n * TODO: temporal\n */\n\n\nVMD.prototype.clone = function () {\n  var v = new VMD();\n  v.motionCount = this.motionCount;\n  v.faceCount = this.faceCount;\n  v.cameraCount = this.cameraCount;\n  v.lightCount = this.lightCount;\n\n  for (var i = 0; i < this.motionCount; i++) {\n    v.motions[i] = this.motions[i];\n  }\n\n  for (var i = 0; i < this.faceCount; i++) {\n    v.faces[i] = this.faces[i];\n  }\n\n  for (var i = 0; i < this.cameraCount; i++) {\n    v.cameras[i] = this.cameras[i];\n  }\n\n  for (var i = 0; i < this.lightCount; i++) {\n    v.lights[i] = this.lights[i];\n  }\n\n  return v;\n};\n\nVMD.prototype.setup = function (pmd) {\n  this.frame = 0;\n  this.cameraIndex = -1;\n  this.lightIndex = -1;\n\n  if (pmd) {\n    this._setupMotions(pmd);\n\n    this._setupFaces(pmd);\n  }\n\n  this._setupCameras();\n\n  this._setupLights(); // TODO: temporal\n\n\n  this.step(1);\n};\n/**\n * TODO: optimize\n */\n\n\nVMD.prototype._setupMotions = function (pmd) {\n  var arrays = {};\n\n  for (var i = 0; i < this.motionCount; i++) {\n    var m = this.motions[i]; // Note: remove unnecessary element for PMD\n\n    if (pmd.bonesHash[m.boneName] === undefined) continue;\n\n    if (arrays[m.boneName] === undefined) {\n      arrays[m.boneName] = {};\n      arrays[m.boneName].motions = [];\n      arrays[m.boneName].index = -1;\n    }\n\n    arrays[m.boneName].motions.push(m);\n  }\n\n  for (var key in arrays) {\n    arrays[key].motions.sort(function (a, b) {\n      return a.frameNum - b.frameNum;\n    });\n  }\n\n  this.orderedMotions.length = 0;\n  var motionKeys = this.Object.keys(arrays);\n\n  for (var i = 0; i < motionKeys.length; i++) {\n    this.orderedMotions[i] = arrays[motionKeys[i]];\n  }\n\n  this.stepMotions.length = 0;\n\n  for (var i = 0; i < pmd.boneCount; i++) {\n    var a = {};\n    a.location = [0, 0, 0];\n    a.rotation = [0, 0, 0, 1];\n\n    this._clearVec3(a.location); // just in case\n\n\n    this._clearQuat4(a.rotation); // just in case\n\n\n    this.stepMotions[i] = a;\n  }\n\n  var boneNames = pmd.getBoneNames();\n  var tmp = 0;\n\n  for (var i = 0; i < pmd.bones.length; i++) {\n    var p = pmd.bones[i];\n    p.motionIndex = motionKeys.indexOf(p.name);\n\n    if (p.motionIndex == -1) {\n      p.motionIndex = motionKeys.length + tmp;\n      tmp++;\n    }\n  }\n};\n\nVMD.prototype._setupFaces = function (pmd) {\n  var arrays = {};\n\n  for (var i = 0; i < this.faceCount; i++) {\n    var f = this.faces[i];\n    if (pmd.facesHash[f.name] === undefined) continue;\n\n    if (arrays[f.name] === undefined) {\n      arrays[f.name] = {};\n      arrays[f.name].faces = [];\n      arrays[f.name].index = -1;\n    }\n\n    arrays[f.name].faces.push(f);\n  }\n\n  for (var key in arrays) {\n    arrays[key].faces.sort(function (a, b) {\n      return a.frameNum - b.frameNum;\n    });\n  }\n\n  this.orderedFaces.length = 0;\n  var faceKeys = this.Object.keys(arrays);\n\n  for (var i = 0; i < faceKeys.length; i++) {\n    this.orderedFaces[i] = arrays[faceKeys[i]];\n  }\n\n  this.stepFaces.length = 0;\n\n  for (var i = 0; i < pmd.faceCount; i++) {\n    var a = {};\n    a.weight = 0;\n    a.available = true;\n    this.stepFaces[i] = a;\n  }\n\n  var faceNames = pmd.getFaceNames();\n  var tmp = 0;\n\n  for (var i = 0; i < pmd.faces.length; i++) {\n    var p = pmd.faces[i];\n    p.motionIndex = faceKeys.indexOf(p.name);\n\n    if (p.motionIndex == -1) {\n      p.motionIndex = faceKeys.length + tmp;\n      this.stepFaces[p.motionIndex].available = false;\n      tmp++;\n    }\n  }\n};\n\nVMD.prototype._setupCameras = function () {\n  this.orderedCameras.length = 0;\n\n  for (var i = 0; i < this.cameraCount; i++) {\n    this.orderedCameras[i] = this.cameras[i];\n  }\n\n  this.orderedCameras.sort(function (a, b) {\n    return a.frameNum - b.frameNum;\n  });\n};\n\nVMD.prototype._setupLights = function () {\n  this.orderedLights.length = 0;\n\n  for (var i = 0; i < this.lightCount; i++) {\n    this.orderedLights[i] = {};\n    this.orderedLights[i].light = this.lights[i];\n  }\n\n  this.orderedLights.sort(function (a, b) {\n    return a.light.frameNum - b.light.frameNum;\n  });\n};\n\nVMD.prototype.step = function (dframe) {\n  this._stepMotion();\n\n  this._stepFace();\n\n  this._stepCamera();\n\n  this._stepLight(); //  this.frame++;\n\n\n  this.frame += dframe;\n};\n/**\n * TODO: check the logic.\n */\n\n\nVMD.prototype._stepMotion = function () {\n  for (var i = 0; i < this.orderedMotions.length; i++) {\n    var m = this.orderedMotions[i];\n\n    while (m.index + 1 < m.motions.length && m.motions[m.index + 1].frameNum <= this.frame) {\n      m.index++;\n    }\n  }\n};\n/**\n * TODO: check the logic.\n */\n\n\nVMD.prototype._stepFace = function () {\n  for (var i = 0; i < this.orderedFaces.length; i++) {\n    var f = this.orderedFaces[i];\n\n    while (f.index + 1 < f.faces.length && f.faces[f.index + 1].frameNum <= this.frame) {\n      f.index++;\n    }\n  }\n};\n/**\n * TODO: check the logic.\n */\n\n\nVMD.prototype._stepCamera = function () {\n  while (this.cameraIndex + 1 < this.cameras.length && this.orderedCameras[this.cameraIndex + 1].frameNum <= this.frame) {\n    this.cameraIndex++;\n  }\n};\n/**\n * TODO: check the logic.\n */\n\n\nVMD.prototype._stepLight = function () {\n  while (this.lightIndex + 1 < this.lights.length && this.orderedLights[this.lightIndex + 1].light.frameNum <= this.frame) {\n    this.lightIndex++;\n  }\n};\n\nVMD.prototype.merge = function (v) {\n  this.motionCount += v.motionCount;\n  this.faceCount += v.faceCount;\n  this.cameraCount += v.cameraCount;\n  this.lightCount += v.lightCount;\n\n  for (var i = 0; i < v.motionCount; i++) {\n    this.motions.push(v.motions[i]);\n  }\n\n  for (var i = 0; i < v.faceCount; i++) {\n    this.faces.push(v.faces[i]);\n  }\n\n  for (var i = 0; i < v.cameraCount; i++) {\n    this.cameras.push(v.cameras[i]);\n  }\n\n  for (var i = 0; i < v.lightCount; i++) {\n    this.lights.push(v.lights[i]);\n  }\n};\n\nVMD.prototype.addOffset = function (o) {\n  for (var i = 0; i < this.motionCount; i++) {\n    this.motions[i].frameNum += o;\n  }\n\n  for (var i = 0; i < this.faceCount; i++) {\n    this.faces[i].frameNum += o;\n  }\n\n  for (var i = 0; i < this.cameraCount; i++) {\n    this.cameras[i].frameNum += o;\n  }\n\n  for (var i = 0; i < this.lightCount; i++) {\n    this.lights[i].frameNum += o;\n  }\n};\n/**\n * TODO: temporal\n * TODO: calculate next frameNum at setup phase?\n * TODO: check the logic\n */\n\n\nVMD.prototype.loadMotion = function () {\n  for (var i = 0; i < this.orderedMotions.length; i++) {\n    var m = this.orderedMotions[i];\n    if (m.index == -1) continue;\n    var m1 = m.motions[m.index];\n    var m2 = m.motions[m.index + 1];\n    var m3 = this.stepMotions[i];\n\n    if (m1.frameNum == this.frame || m2 === undefined || m2.frameNum - m1.frameNum <= 2) {\n      this._setVec3(m1.location, m3.location);\n\n      this._setQuat4(m1.rotation, m3.rotation);\n    } else {\n      // Note: linear interpolation so far\n      var d = m2.frameNum - m1.frameNum;\n      var d2 = this.frame - m1.frameNum;\n      var r = d2 / d;\n\n      this._slerpQuat4(m1.rotation, m2.rotation, r, m3.rotation);\n\n      this._lerpVec3(m1.location, m2.location, r, m3.location);\n    }\n  }\n\n  for (var i = this.orderedMotions.length; i < this.stepMotions.length; i++) {\n    var s = this.stepMotions[i];\n\n    this._clearVec3(s.location);\n\n    this._clearQuat4(s.rotation);\n  }\n};\n/**\n * TODO: temporal\n * TODO: any ways to avoid update all morph Buffer?\n * TODO: check the logic.\n */\n\n\nVMD.prototype.loadFace = function () {\n  for (var i = 0; i < this.orderedFaces.length; i++) {\n    var f = this.orderedFaces[i];\n    if (f.index == -1) continue;\n    var f1 = f.faces[f.index];\n    var f2 = f.faces[f.index + 1];\n    var f3 = this.stepFaces[i];\n\n    if (f1.frameNum == this.frameNum || f2 === undefined || f2.frameNum - f1.frameNum <= 2) {\n      f3.weight = f1.weight;\n    } else {\n      var d = f2.frameNum - f1.frameNum;\n      var d2 = this.frame - f1.frameNum;\n      var r = d2 / d;\n      f3.weight = this._lerp(f1.weight, f2.weight, r);\n    }\n  }\n};\n/**\n * TODO: check the logic\n */\n\n\nVMD.prototype.loadCamera = function () {\n  var ocs = this.orderedCameras;\n  var index = this.cameraIndex;\n  this.stepCamera.available = false;\n  if (index == -1) return;\n  this.stepCamera.available = true;\n  var c1 = ocs[index];\n  var c2 = ocs[index + 1];\n\n  if (c1.frameNum == this.frame || c2 === undefined || c2.frameNum - c1.frameNum <= 2) {\n    this._setVec3(c1.location, this.stepCamera.location);\n\n    this._setVec3(c1.rotation, this.stepCamera.rotation);\n\n    this.stepCamera.length = c1.length;\n    this.stepCamera.angle = c1.angle;\n  } else {\n    // Note: linear interpolation so far\n    var d = c2.frameNum - c1.frameNum;\n    var d2 = this.frame - c1.frameNum;\n    var r = d2 / d;\n\n    this._lerpVec3(c1.location, c2.location, r, this.stepCamera.location);\n\n    this._lerpVec3(c1.rotation, c2.rotation, r, this.stepCamera.rotation);\n\n    this.stepCamera.length = this._lerp(c1.length, c2.length, r);\n    this.stepCamera.angle = this._lerp(c1.angle, c2.angle, r);\n  }\n};\n/**\n * TODO: check the logic.\n * TODO: implement correctly\n */\n\n\nVMD.prototype.loadLight = function () {\n  var ols = this.orderedLights;\n  var index = this.lightIndex;\n  this.stepLight.available = false;\n  if (index == -1) return;\n  var light = ols[index].light;\n  this.stepLight.available = true;\n\n  this._setVec3(light.color, this.stepLight.color);\n\n  this._setVec3(light.location, this.stepLight.location);\n};\n\nVMD.prototype._setVec3 = function (a, b) {\n  b[0] = a[0];\n  b[1] = a[1];\n  b[2] = a[2];\n};\n\nVMD.prototype._setQuat4 = function (a, b) {\n  b[0] = a[0];\n  b[1] = a[1];\n  b[2] = a[2];\n  b[3] = a[3];\n};\n\nVMD.prototype._clearVec3 = function (a) {\n  a[0] = 0;\n  a[1] = 0;\n  a[2] = 0;\n};\n\nVMD.prototype._clearQuat4 = function (a) {\n  a[0] = 0;\n  a[1] = 0;\n  a[2] = 0;\n  a[3] = 1;\n};\n\nVMD.prototype._lerp = function (a, b, c) {\n  return a * (1 - c) + b * c;\n};\n\nVMD.prototype._lerpVec3 = function (a, b, c, d) {\n  d[0] = this._lerp(a[0], b[0], c);\n  d[1] = this._lerp(a[1], b[1], c);\n  d[2] = this._lerp(a[2], b[2], c);\n};\n/**\n * copied from somewhere so far\n * TODO: move this logic to general matrix class or somewhere\n */\n\n\nVMD.prototype._slerpQuat4 = function (q, r, t, p) {\n  var cosHalfTheta = q[0] * r[0] + q[1] * r[1] + q[2] * r[2] + q[3] * r[3];\n\n  if (cosHalfTheta < 0) {\n    p[0] = -r[0];\n    p[1] = -r[1];\n    p[2] = -r[2];\n    p[3] = -r[3];\n    cosHalfTheta = -cosHalfTheta;\n  } else {\n    p[0] = r[0];\n    p[1] = r[1];\n    p[2] = r[2];\n    p[3] = r[3];\n  }\n\n  if (this.Math.abs(cosHalfTheta) >= 1.0) {\n    p[0] = q[0];\n    p[1] = q[1];\n    p[2] = q[2];\n    p[3] = q[3];\n    return p;\n  }\n\n  var halfTheta = this.Math.acos(cosHalfTheta);\n  var sinHalfTheta = this.Math.sqrt(1.0 - cosHalfTheta * cosHalfTheta);\n\n  if (this.Math.abs(sinHalfTheta) < 0.001) {\n    p[0] = 0.5 * (q[0] + r[0]);\n    p[1] = 0.5 * (q[1] + r[1]);\n    p[2] = 0.5 * (q[2] + r[2]);\n    p[3] = 0.5 * (q[3] + r[3]);\n    return p;\n  }\n\n  var ratioA = this.Math.sin((1 - t) * halfTheta) / sinHalfTheta;\n  var ratioB = this.Math.sin(t * halfTheta) / sinHalfTheta;\n  p[0] = q[0] * ratioA + p[0] * ratioB;\n  p[1] = q[1] * ratioA + p[1] * ratioB;\n  p[2] = q[2] * ratioA + p[2] * ratioB;\n  p[3] = q[3] * ratioA + p[3] * ratioB;\n  return p;\n};\n/**\n * just copied from MMD.js so far\n */\n\n\n_glMatrix095Min.vec3.rotateX = function (vec, angle, dest) {\n  var rotation = _glMatrix095Min.mat4.rotateX(_glMatrix095Min.mat4.identity(_glMatrix095Min.mat4.create()), angle);\n\n  return _glMatrix095Min.mat4.multiplyVec3(rotation, vec, dest);\n};\n\n_glMatrix095Min.vec3.rotateY = function (vec, angle, dest) {\n  var rotation = _glMatrix095Min.mat4.rotateY(_glMatrix095Min.mat4.identity(_glMatrix095Min.mat4.create()), angle);\n\n  return _glMatrix095Min.mat4.multiplyVec3(rotation, vec, dest);\n};\n\n_glMatrix095Min.vec3.rotateZ = function (vec, angle, dest) {\n  var rotation = _glMatrix095Min.mat4.rotateZ(_glMatrix095Min.mat4.identity(_glMatrix095Min.mat4.create()), angle);\n\n  return _glMatrix095Min.mat4.multiplyVec3(rotation, vec, dest);\n};\n\nVMD.prototype.getBoneMotion = function (bone) {\n  return this.stepMotions[bone.motionIndex];\n};\n\nVMD.prototype.getFace = function (face) {\n  return this.stepFaces[face.motionIndex];\n};\n\nVMD.prototype.getCamera = function () {\n  return this.stepCamera;\n};\n\nVMD.prototype.getLight = function () {\n  return this.stepLight;\n};\n/**\n * TODO: rename\n */\n\n\nVMD.prototype.getCalculatedCameraParams = function (eye, center, up) {\n  var yOffset = 0.0;\n  var camera = this.getCamera();\n  center[0] = camera.location[0];\n  center[1] = camera.location[1] + yOffset;\n  center[2] = camera.location[2];\n  eye[0] = 0;\n  eye[1] = 0 + yOffset;\n  eye[2] = camera.length;\n  up[0] = 0;\n  up[1] = 1;\n  up[2] = 0;\n  this.vec3.rotateX(eye, camera.rotation[0], eye);\n  this.vec3.rotateY(eye, camera.rotation[1], eye);\n  this.vec3.rotateZ(eye, camera.rotation[2], eye);\n  this.vec3.add(eye, camera.location, eye);\n  this.vec3.rotateX(up, camera.rotation[0], up);\n  this.vec3.rotateY(up, camera.rotation[1], up);\n  this.vec3.rotateZ(up, camera.rotation[2], up);\n};\n\nVMD.prototype.dump = function () {\n  var str = '';\n  str += 'motionCount: ' + this.motionCount + '\\n';\n  str += 'faceCount: ' + this.faceCount + '\\n';\n  str += 'cameraCount: ' + this.cameraCount + '\\n';\n  str += 'lightCount: ' + this.lightCount + '\\n';\n  str += this._dumpMotions();\n  str += this._dumpFaces();\n  str += this._dumpCameras();\n  str += this._dumpLights();\n  return str;\n};\n\nVMD.prototype._dumpMotions = function () {\n  var str = '';\n  str += '-- Motions --\\n';\n\n  for (var i = 0; i < this.motionCount; i++) {\n    str += this.motions[i].dump();\n  }\n\n  str += '\\n';\n  return str;\n};\n\nVMD.prototype._dumpFaces = function () {\n  var str = '';\n  str += '-- Faces --\\n';\n\n  for (var i = 0; i < this.faceCount; i++) {\n    str += this.faces[i].dump();\n  }\n\n  str += '\\n';\n  return str;\n};\n\nVMD.prototype._dumpCameras = function () {\n  var str = '';\n  str += '-- Cameras --\\n';\n\n  for (var i = 0; i < this.cameraCount; i++) {\n    str += this.cameras[i].dump();\n  }\n\n  str += '\\n';\n  return str;\n};\n\nVMD.prototype._dumpLights = function () {\n  var str = '';\n  str += '-- Lights --\\n';\n\n  for (var i = 0; i < this.lightCount; i++) {\n    str += this.lights[i].dump();\n  }\n\n  str += '\\n';\n  return str;\n};\n\nfunction VMDHeader() {\n  this.magic = null;\n  this.modelName = null;\n}\n\n;\n\nVMDHeader.prototype.valid = function () {\n  return this.magic == 'Vocaloid Motion Data 0002';\n};\n\nVMDHeader.prototype.dump = function () {\n  var str = '';\n  str += 'magic: ' + this.magic + '\\n';\n  str += 'modelName: ' + this.modelName + '\\n';\n  return str;\n};\n\nfunction VMDMotion(id) {\n  this.id = id;\n  this.boneName = null;\n  this.frameNum = null;\n  this.location = null;\n  this.rotation = null;\n  this.interpolation = null;\n}\n\n;\n\nVMDMotion.prototype.supply = function () {\n  this.frameNum *= 2;\n};\n\nVMDMotion.prototype.dump = function () {\n  var str = '';\n  str += 'id: ' + this.id + '\\n';\n  str += 'boneName: ' + this.boneName + '\\n';\n  str += 'frameNum: ' + this.frameNum + '\\n';\n  str += 'location: ' + this.location + '\\n';\n  str += 'rotation: ' + this.rotation + '\\n';\n  str += 'interpolation: ' + this.interpolation + '\\n';\n  return str;\n};\n\nfunction VMDFace(id) {\n  this.id = id;\n  this.name = null;\n  this.frameNum = null;\n  this.weight = null;\n}\n\n;\n\nVMDFace.prototype.supply = function () {\n  this.frameNum *= 2;\n};\n\nVMDFace.prototype.dump = function () {\n  var str = '';\n  str += 'id: ' + this.id + '\\n';\n  str += 'name: ' + this.name + '\\n';\n  str += 'frameNum: ' + this.frameNum + '\\n';\n  str += 'weight: ' + this.weight + '\\n';\n  return str;\n};\n\nfunction VMDCamera(id) {\n  this.id = id;\n  this.frameNum = null;\n  this.length = null;\n  this.location = null;\n  this.rotation = null;\n  this.interpolation = null;\n  this.angle = null;\n  this.perspective = null;\n}\n\n;\n\nVMDCamera.prototype.supply = function () {\n  this.frameNum *= 2;\n};\n\nVMDCamera.prototype.dump = function () {\n  var str = '';\n  str += 'id: ' + this.id + '\\n';\n  str += 'frameNum: ' + this.frameNum + '\\n';\n  str += 'length: ' + this.length + '\\n';\n  str += 'location: ' + this.location + '\\n';\n  str += 'rotation: ' + this.rotation + '\\n';\n  str += 'interpolation: ' + this.interpolation + '\\n';\n  str += 'angle: ' + this.angle + '\\n';\n  str += 'perspective: ' + this.perspective + '\\n';\n  return str;\n};\n\nfunction VMDLight(id) {\n  this.id = id;\n  this.frameNum = null;\n  this.color = null;\n  this.location = null;\n}\n\n;\n\nVMDLight.prototype.supply = function () {\n  this.frameNum *= 2;\n};\n\nVMDLight.prototype.dump = function () {\n  var str = '';\n  str += 'id: ' + this.id + '\\n';\n  str += 'frameNum: ' + this.frameNum + '\\n';\n  str += 'color: ' + this.color + '\\n';\n  str += 'location: ' + this.location + '\\n';\n  return str;\n};\n\nmodule.exports = {\n  VMD: VMD,\n  VMDLight: VMDLight,\n  VMDHeader: VMDHeader,\n  VMDMotion: VMDMotion,\n  VMDFace: VMDFace,\n  VMDCamera: VMDCamera\n};\n\n//# sourceURL=webpack:///./src/plugin-webgl/mmd/Vmd.js?");

/***/ }),

/***/ "./src/plugin-webgl/mmd/VmdFileParser.js":
/*!***********************************************!*\
  !*** ./src/plugin-webgl/mmd/VmdFileParser.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _Inherit = _interopRequireDefault(__webpack_require__(/*! ./_Inherit.js */ \"./src/plugin-webgl/mmd/_Inherit.js\"));\n\nvar _Vmd = __webpack_require__(/*! ./Vmd.js */ \"./src/plugin-webgl/mmd/Vmd.js\");\n\nvar _FileParser = _interopRequireDefault(__webpack_require__(/*! ./_FileParser.js */ \"./src/plugin-webgl/mmd/_FileParser.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nfunction VMDFileParser(buffer) {\n  this.parent = _FileParser[\"default\"];\n  this.parent.call(this, buffer);\n}\n\n;\n(0, _Inherit[\"default\"])(VMDFileParser, _FileParser[\"default\"]);\nVMDFileParser.prototype._HEADER_STRUCTURE = {\n  magic: {\n    type: 'char',\n    isArray: true,\n    size: 30\n  },\n  modelName: {\n    type: 'char',\n    isArray: true,\n    size: 20\n  }\n};\nVMDFileParser.prototype._MOTIONS_STRUCTURE = {\n  count: {\n    type: 'uint32'\n  },\n  motions: {\n    type: 'object',\n    isArray: true,\n    size: 'count'\n  }\n};\nVMDFileParser.prototype._MOTION_STRUCTURE = {\n  boneName: {\n    type: 'strings',\n    isArray: true,\n    size: 15\n  },\n  frameNum: {\n    type: 'uint32'\n  },\n  location: {\n    type: 'float',\n    isArray: true,\n    size: 3\n  },\n  rotation: {\n    type: 'float',\n    isArray: true,\n    size: 4\n  },\n  interpolation: {\n    type: 'uint8',\n    isArray: true,\n    size: 64\n  }\n};\nVMDFileParser.prototype._FACES_STRUCTURE = {\n  count: {\n    type: 'uint32'\n  },\n  faces: {\n    type: 'object',\n    isArray: true,\n    size: 'count'\n  }\n};\nVMDFileParser.prototype._FACE_STRUCTURE = {\n  name: {\n    type: 'strings',\n    isArray: true,\n    size: 15\n  },\n  frameNum: {\n    type: 'uint32'\n  },\n  weight: {\n    type: 'float'\n  }\n};\nVMDFileParser.prototype._CAMERAS_STRUCTURE = {\n  count: {\n    type: 'uint32'\n  },\n  cameras: {\n    type: 'object',\n    isArray: true,\n    size: 'count'\n  }\n};\nVMDFileParser.prototype._CAMERA_STRUCTURE = {\n  frameNum: {\n    type: 'uint32'\n  },\n  length: {\n    type: 'float'\n  },\n  location: {\n    type: 'float',\n    isArray: true,\n    size: 3\n  },\n  rotation: {\n    type: 'float',\n    isArray: true,\n    size: 3\n  },\n  interpolation: {\n    type: 'uint8',\n    isArray: true,\n    size: 24\n  },\n  angle: {\n    type: 'uint32'\n  },\n  perspective: {\n    type: 'uint8'\n  }\n};\nVMDFileParser.prototype._LIGHTS_STRUCTURE = {\n  count: {\n    type: 'uint32'\n  },\n  lights: {\n    type: 'object',\n    isArray: true,\n    size: 'count'\n  }\n};\nVMDFileParser.prototype._LIGHT_STRUCTURE = {\n  frameNum: {\n    type: 'uint32'\n  },\n  color: {\n    type: 'float',\n    isArray: true,\n    size: 3\n  },\n  location: {\n    type: 'float',\n    isArray: true,\n    size: 3\n  }\n};\n\nVMDFileParser.prototype.parse = function () {\n  this.offset = 0;\n  var v = new _Vmd.VMD();\n\n  this._parseHeader(v);\n\n  this._parseMotions(v);\n\n  this._parseFaces(v);\n\n  this._parseCameras(v);\n\n  this._parseLights(v);\n\n  return v;\n};\n/**\n * TODO: be more strict.\n */\n\n\nVMDFileParser.prototype.valid = function () {\n  var tmp = this.offset;\n  this.offset = 0;\n  var v = new _Vmd.VMD();\n\n  this._parseHeader(v);\n\n  this.offset = tmp;\n  return v.valid();\n};\n\nVMDFileParser.prototype._parseHeader = function (v) {\n  var s = this._HEADER_STRUCTURE;\n  v.header = new _Vmd.VMDHeader();\n\n  this._parseObject(v.header, s);\n};\n\nVMDFileParser.prototype._parseMotions = function (v) {\n  var s = this._MOTIONS_STRUCTURE;\n  v.motionCount = this._getValue(s.count, this.offset);\n  this.offset += this._sizeof(s.count);\n  v.motions.length = 0;\n\n  for (var i = 0; i < v.motionCount; i++) {\n    this._parseMotion(v, i);\n  }\n};\n\nVMDFileParser.prototype._parseMotion = function (v, n) {\n  var s = this._MOTION_STRUCTURE;\n  var m = new _Vmd.VMDMotion(n);\n\n  this._parseObject(m, s);\n\n  v.motions[n] = m;\n};\n\nVMDFileParser.prototype._parseFaces = function (v) {\n  var s = this._FACES_STRUCTURE;\n  v.faceCount = this._getValue(s.count, this.offset);\n  this.offset += this._sizeof(s.count);\n  v.faces.length = 0;\n\n  for (var i = 0; i < v.faceCount; i++) {\n    this._parseFace(v, i);\n  }\n};\n\nVMDFileParser.prototype._parseFace = function (v, n) {\n  var s = this._FACE_STRUCTURE;\n  var f = new _Vmd.VMDFace(n);\n\n  this._parseObject(f, s);\n\n  v.faces[n] = f;\n};\n\nVMDFileParser.prototype._parseCameras = function (v) {\n  var s = this._CAMERAS_STRUCTURE;\n  v.cameraCount = this._getValue(s.count, this.offset);\n  this.offset += this._sizeof(s.count);\n  v.cameras.length = 0;\n\n  for (var i = 0; i < v.cameraCount; i++) {\n    this._parseCamera(v, i);\n  }\n};\n\nVMDFileParser.prototype._parseCamera = function (v, n) {\n  var s = this._CAMERA_STRUCTURE;\n  var c = new _Vmd.VMDCamera(n);\n\n  this._parseObject(c, s);\n\n  v.cameras[n] = c;\n};\n\nVMDFileParser.prototype._parseLights = function (v) {\n  var s = this._LIGHTS_STRUCTURE;\n  v.lightCount = this._getValue(s.count, this.offset);\n  this.offset += this._sizeof(s.count);\n  v.lights.length = 0;\n\n  for (var i = 0; i < v.lightCount; i++) {\n    this._parseLight(v, i);\n  }\n};\n\nVMDFileParser.prototype._parseLight = function (v, n) {\n  var s = this._LIGHT_STRUCTURE;\n  var l = new _Vmd.VMDLight(n);\n\n  this._parseObject(l, s);\n\n  v.lights[n] = l;\n};\n\nmodule.exports = VMDFileParser;\n\n//# sourceURL=webpack:///./src/plugin-webgl/mmd/VmdFileParser.js?");

/***/ }),

/***/ "./src/plugin-webgl/mmd/_FileParser.js":
/*!*********************************************!*\
  !*** ./src/plugin-webgl/mmd/_FileParser.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _Utility = _interopRequireDefault(__webpack_require__(/*! ./_Utility.js */ \"./src/plugin-webgl/mmd/_Utility.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nfunction FileParser(buffer) {\n  this.uint8 = new Uint8Array(buffer);\n  this.offset = 0;\n}\n\n;\nFileParser.prototype.Math = Math;\n/**\n * -- sample --\n * FileParser.prototype._VERTEX_STRUCTURE = {\n *   position: {type: 'float', isArray: true, size: 3},\n *   normal: {type: 'float', isArray: true, size: 3},\n *   uv: {type: 'float', isArray: true, size: 2},\n *   boneIndices: {type: 'uint16', isArray: true, size: 2},\n *   boneWeight: {type: 'uint8'},\n *   edgeFlag: {type: 'uint8'}\n * };\n */\n\n/**\n * Note: override this method in a child class\n */\n\nFileParser.prototype.parse = function () {\n  return {};\n};\n\nFileParser.prototype._parseObject = function (obj, s) {\n  var o = this.offset;\n\n  for (var key in s) {\n    obj[key] = this._getValue(s[key], this.offset); // TODO: this can waste time when this function is called in loop\n\n    this.offset += this._sizeof(s[key]);\n  }\n};\n\nFileParser.prototype._getValue = function (param, offset) {\n  return param.isArray === undefined ? this._getValueScalar(param, offset) : this._getValueArray(param, offset);\n};\n/**\n * TODO: you may use DataView.\n */\n\n\nFileParser.prototype._getValueScalar = function (param, offset) {\n  switch (param.type) {\n    case 'char':\n      return this._getChars(offset, 1);\n\n    case 'strings':\n      return this._getStrings(offset, 1);\n\n    case 'uint8':\n      return this._getUint8(offset);\n\n    case 'uint16':\n      return this._getUint16(offset);\n\n    case 'uint32':\n      return this._getUint32(offset);\n\n    case 'float':\n      return this._getFloat(offset);\n\n    default:\n      // TODO: to be specific\n      throw 'error: undefined type' + param;\n  }\n};\n\nFileParser.prototype._getValueArray = function (param, offset) {\n  if (param.type == 'char') {\n    return this._getChars(offset, param.size);\n  }\n\n  if (param.type == 'strings') {\n    return this._getStrings(offset, param.size);\n  }\n\n  var array = [];\n\n  var size = this._sizeofScalar(param);\n\n  for (var i = 0; i < param.size; i++) {\n    array[i] = this._getValueScalar(param, offset);\n    offset += size;\n  }\n\n  return array;\n};\n\nFileParser.prototype._sizeof = function (param) {\n  return param.isArray === undefined ? this._sizeofScalar(param) : this._sizeofArray(param);\n};\n\nFileParser.prototype._sizeofScalar = function (param) {\n  switch (param.type) {\n    case 'char':\n      return 1;\n\n    case 'strings':\n      return 1;\n\n    case 'uint8':\n      return 1;\n\n    case 'uint16':\n      return 2;\n\n    case 'uint32':\n      return 4;\n\n    case 'float':\n      return 4;\n\n    default:\n      // TODO: to be specific\n      throw 'error: undefined type ' + param + ' ' + param.type;\n  }\n};\n\nFileParser.prototype._sizeofArray = function (param) {\n  return this._sizeofScalar(param) * param.size;\n};\n\nFileParser.prototype._sizeofObject = function (o) {\n  var size = 0;\n\n  for (var key in o) {\n    size += this._sizeof(o[key]);\n  }\n\n  return size;\n};\n\nFileParser.prototype._getUint8 = function (pos) {\n  return this.uint8[pos];\n};\n\nFileParser.prototype._getUint16 = function (pos) {\n  return this._getValueWithReverseByteOrder(pos, 2);\n};\n\nFileParser.prototype._getUint32 = function (pos) {\n  return this._getValueWithReverseByteOrder(pos, 4);\n};\n\nFileParser.prototype._getFloat = function (pos) {\n  return this._toBinary32(this._getValueWithReverseByteOrder(pos, 4));\n};\n\nFileParser.prototype._getValueWithReverseByteOrder = function (pos, size) {\n  var value = 0;\n\n  for (var i = 0; i < size; i++) {\n    value = value << 8 | this.uint8[pos + size - i - 1];\n  }\n\n  return value;\n};\n\nFileParser.prototype._toBinary32 = function (uint32) {\n  var sign = uint32 >> 31 & 1;\n  var exponent = uint32 >> 23 & 0xFF;\n  var fraction = uint32 & 0x7FFFFF;\n  if (exponent == 0 && fraction == 0) return 0.0;\n  if (exponent == 255 && fraction == 0) return Infinity;\n  if (exponent == 255 && fraction != 0) return NaN;\n  var tmp = 1;\n\n  if (exponent == 0 && fraction != 0) {\n    exponent = 1;\n    tmp = 0;\n  }\n\n  for (var i = 0; i < 23; i++) {\n    if (fraction >> 22 - i & 1) {\n      tmp += this.Math.pow(2, -(i + 1));\n    }\n  }\n\n  tmp = tmp * this.Math.pow(2, exponent - 127);\n  if (sign) tmp = -tmp;\n  return tmp;\n};\n\nFileParser.prototype._getChars = function (pos, size) {\n  var str = '';\n\n  for (var i = 0; i < size; i++) {\n    var index = pos + i;\n    if (this.uint8[index] == 0) break; // TODO: temporal\n\n    str += String.fromCharCode(this.uint8[index]);\n  }\n\n  return str;\n};\n\nFileParser.prototype._getStrings = function (pos, size) {\n  var str = '';\n\n  for (var i = 0; i < size; i++) {\n    var index = pos + i;\n    if (this.uint8[index] == 0) break; // TODO: temporal\n\n    str += (0, _Utility[\"default\"])(16, this.uint8[index], 2);\n  }\n\n  return str;\n};\n\nFileParser.prototype.dump = function () {\n  var array = this.uint8;\n  var figure = 0;\n  var tmp = array.length;\n\n  while (tmp > 0) {\n    figure++;\n    tmp = tmp / 16 | 0;\n  }\n\n  var dump = '';\n  var charDump = '';\n\n  for (var i = 0; i < array.length; i++) {\n    if (i % 16 == 0) {\n      dump += (0, _Utility[\"default\"])(16, i, figure);\n      dump += ' ';\n    }\n\n    dump += (0, _Utility[\"default\"])(16, array[i], 2);\n    dump += ' ';\n    if (array[i] >= 0x20 && array[i] <= 0x7E) charDump += String.fromCharCode(array[i]);else charDump += '.';\n\n    if (i % 16 == 15) {\n      dump += '  ';\n      dump += charDump;\n      dump += '\\n';\n      charDump = '';\n    }\n  }\n\n  return dump;\n};\n\nmodule.exports = FileParser;\n\n//# sourceURL=webpack:///./src/plugin-webgl/mmd/_FileParser.js?");

/***/ }),

/***/ "./src/plugin-webgl/mmd/_GlslFunctions.js":
/*!************************************************!*\
  !*** ./src/plugin-webgl/mmd/_GlslFunctions.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar cross = function cross(a, b) {\n  // return [\n  //   '(' + String(a[1]) + '*' + String(b[2]) + '-' + String(a[2]) + '*' + String(b[1]) + ')',\n  //   '(' + String(a[2]) + '*' + String(b[0]) + '-' + String(a[0]) + '*' + String(b[2]) + ')',\n  //   '(' + String(a[0]) + '*' + String(b[1]) + '-' + String(a[1]) + '*' + String(b[0]) + ')',\n  // ];\n  return [a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0]];\n}; // var mat = [1.299038052558899, 0, 0, 0, 0, 1.7320507764816284, 0, 0, 0, 0, 1.000100016593933, 1, 0, -17.320507049560547, 21.80219078063965, 22];\n\n\nvar qtransform = function qtransform(v, q) {\n  // v + 2.0 * cross(cross(v, q.xyz) - q.w*v, q.xyz);\n  var res = arrayAdd(v, arrayMuti(cross(arrayMns(cross(v, [q[0], q[1], q[2]]), arrayMuti(v, q[3])), [q[0], q[1], q[2]]), 2));\n  return res;\n};\n\nvar arrayAdd = function arrayAdd(a, b) {\n  // return ['(' + String(a[0]) + '+' + String(b[0]) + ')', '(' + String(a[1]) + '+' + String(b[1]) + ')', '(' + String(a[2] + '+' + b[2]) + ')'];\n  return [a[0] + b[0], a[1] + b[1], a[2] + b[2]]; // return a.map((v, index) => {\n  //   return v + b[index];\n  // });\n};\n\nvar arrayMns = function arrayMns(a, b) {\n  // return ['(' + String(a[0]) + '-' + String(b[0]) + ')', '(' + String(a[1]) + '-' + String(b[1]) + ')', '(' + String(a[2] + '-' + b[2]) + ')'];\n  return [a[0] - b[0], a[1] - b[1], a[2] - b[2]]; // return a.map((v, index) => {\n  //   return v - b[index];\n  // });\n};\n\nvar arrayMuti = function arrayMuti(a, b) {\n  // if (b.push) {\n  //     return ['(' + String(a[0]) + '*' + String(b[0]) + ')', '(' + String(a[1]) + '*' + String(b[1]) + ')', '(' + String(a[2] + '*' + b[2]) + ')'];\n  // }\n  // return ['(' + String(a[0]) + '*' + String(b) + ')', '(' + String(a[1]) + '*' + String(b) + ')', '(' + String(a[2] + '*' + b) + ')'];\n  if (b.length) {\n    return [a[0] * b[0], a[1] * b[1], a[2] * b[2]];\n  }\n\n  return [a[0] * b, a[1] * b, a[2] * b]; // return a.map((v, index) => {\n  //   return v * (b.length ? b[index] : b);\n  // });\n}; // mix only https://en.wikibooks.org/wiki/GLSL_Programming/Vector_and_Matrix_Operations\n\n\nvar mix = function mix(a, b, wb) {\n  // a * (TYPE(1.0) - wb) + b * wb\n  return arrayAdd(arrayMuti(a, arrayMns([1, 1, 1], [wb, wb, wb])), arrayMuti(b, [wb, wb, wb]));\n};\n\nmodule.exports = {\n  cross: cross,\n  qtransform: qtransform,\n  arrayAdd: arrayAdd,\n  arrayMns: arrayMns,\n  arrayMuti: arrayMuti,\n  mix: mix\n};\n\n//# sourceURL=webpack:///./src/plugin-webgl/mmd/_GlslFunctions.js?");

/***/ }),

/***/ "./src/plugin-webgl/mmd/_Inherit.js":
/*!******************************************!*\
  !*** ./src/plugin-webgl/mmd/_Inherit.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n/**\n *\n */\nfunction __inherit(child, parent) {\n  var getPrototype = function getPrototype(p) {\n    if (Object.create) {\n      return Object.create(p);\n    }\n\n    function f() {}\n\n    ;\n    f.prototype = p;\n    return new f();\n  };\n\n  child.prototype = getPrototype(parent.prototype);\n  child.prototype.constructor = child;\n} // function __copyParentMethod(child, parent, methodName) {\n//   var parentName = parent.name;\n//   var name = parentName + '_' + \n//                ((methodName[0] == '_') ? methodName.slice(1) : methodName);\n//   child.prototype[name] = parent.prototype[methodName];\n// }\n\n\nmodule.exports = __inherit;\n\n//# sourceURL=webpack:///./src/plugin-webgl/mmd/_Inherit.js?");

/***/ }),

/***/ "./src/plugin-webgl/mmd/_Utility.js":
/*!******************************************!*\
  !*** ./src/plugin-webgl/mmd/_Utility.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n/**\n * @param {Integer} type bin->2, oct->8, degit->10, hex->16\n * @param {Integer} num\n * @param {Integer} figures\n */\nfunction __toString(type, num, figure) {\n  var base = '';\n  var prefix = '';\n  var minus = '';\n  if (type == 8) prefix = '0';else if (type == 16) prefix = '0x';\n\n  for (var i = 0; i < figure; i++) {\n    base += '0';\n  }\n\n  return prefix + (base + num.toString(type)).substr(-1 * figure);\n}\n\n;\nmodule.exports = __toString;\n\n//# sourceURL=webpack:///./src/plugin-webgl/mmd/_Utility.js?");

/***/ }),

/***/ "./src/plugin.webgl.mmd.js":
/*!*********************************!*\
  !*** ./src/plugin.webgl.mmd.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _Pmd = _interopRequireDefault(__webpack_require__(/*! ./plugin-webgl/mmd/Pmd.js */ \"./src/plugin-webgl/mmd/Pmd.js\"));\n\nvar _PmdFileParser = _interopRequireDefault(__webpack_require__(/*! ./plugin-webgl/mmd/PmdFileParser.js */ \"./src/plugin-webgl/mmd/PmdFileParser.js\"));\n\nvar _PmdModelView_easycanvas = _interopRequireDefault(__webpack_require__(/*! ./plugin-webgl/mmd/PmdModelView_easycanvas.js */ \"./src/plugin-webgl/mmd/PmdModelView_easycanvas.js\"));\n\nvar _PmdView_easycanvas = _interopRequireDefault(__webpack_require__(/*! ./plugin-webgl/mmd/PmdView_easycanvas.js */ \"./src/plugin-webgl/mmd/PmdView_easycanvas.js\"));\n\nvar _Vmd = _interopRequireDefault(__webpack_require__(/*! ./plugin-webgl/mmd/Vmd.js */ \"./src/plugin-webgl/mmd/Vmd.js\"));\n\nvar _VmdFileParser = _interopRequireDefault(__webpack_require__(/*! ./plugin-webgl/mmd/VmdFileParser.js */ \"./src/plugin-webgl/mmd/VmdFileParser.js\"));\n\nvar _Physics = _interopRequireDefault(__webpack_require__(/*! ./plugin-webgl/mmd/Physics.js */ \"./src/plugin-webgl/mmd/Physics.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\n/** ********** *\n *\n * Based on mmd-viewer-js, Ammo.js\n * - https://github.com/takahirox/mmd-viewer-js\n * - https://github.com/kripken/ammo.js\n *\n * ********** **/\nvar err = function err(msg) {\n  console.error('[Easycanvas-webgl] ' + msg);\n};\n\nvar pmdCache = {};\nvar ProcessingFlag = 'processing';\n\nvar __analyzePMD = function __analyzePMD(url, buffer, callback) {\n  var pfp = new _PmdFileParser[\"default\"](buffer);\n\n  if (!pfp.valid()) {\n    err('PMD Parse Error.');\n    return;\n  }\n\n  var pmd = pfp.parse();\n  pmd.setup();\n  var vertices = pmd.vertices.map(function (a) {\n    return a.position;\n  }).join(',').split(',').map(function (a) {\n    return Number(a);\n  });\n  var normals = pmd.vertices.map(function (a) {\n    return a.normal;\n  }).join(',').split(',');\n  var textures = pmd.vertices.map(function (a) {\n    return a.uv;\n  }).join(',').split(',');\n  var indices = pmd.vertexIndices.map(function (a) {\n    return a.index;\n  });\n  var data = {\n    vertices: vertices,\n    normals: normals,\n    textures: textures,\n    indices: indices\n  };\n  pmd.$vertices = vertices;\n  pmdCache[url] = {\n    data: data,\n    pmd: pmd\n  };\n  callback(data, pmd);\n};\n\nvar __analyzeVMD = function __analyzeVMD(buffers, callback) {\n  var vmds = [];\n  var vfps = [];\n\n  for (var i = 0; i < buffers.length; i++) {\n    vfps[i] = new _VmdFileParser[\"default\"](buffers[i]);\n\n    if (!vfps[i].valid()) {\n      err('VMD Parse Error.');\n      return;\n    }\n\n    vmds[i] = vfps[i].parse();\n  }\n\n  var vmd = vmds[0];\n  var vfp = vfps[0]; // __vfp = vfps[0]; // for console debug.\n  // __vmd = vmds[0]; // for console debug.\n\n  for (var i = 1; i < buffers.length; i++) {\n    vmd.merge(vmds[i]);\n  } // if(__selectedMotion.music) {\n  //   __loadMusicFile();\n  // } else {\n\n\n  callback({\n    start: function start(pmd, vertices) {\n      var p = new _Physics[\"default\"](pmd);\n      var v = new _PmdView_easycanvas[\"default\"]();\n      var mv = new _PmdModelView_easycanvas[\"default\"](null, pmd, v);\n      mv.setup(); // \n\n      mv._initMotions();\n\n      v.setup();\n      v.addModelView(mv); // TODO: has accessed pmdView\n\n      v.setVMD(vmd); // pmdView.setEye(__selectedMotion.eye);\n\n      v.startDance();\n      var getVerticals = mv.getVerticals; // window.getVerticals=getVerticals;\n\n      setInterval(function () {\n        v.update();\n\n        for (var _i = 0, l = vertices.length / 3; _i < l; _i++) {\n          // 这块比较耗性能，需要修改\n          var temp = getVerticals(_i);\n          vertices[_i * 3 + 0] = temp[0];\n          vertices[_i * 3 + 1] = temp[1];\n          vertices[_i * 3 + 2] = temp[2];\n        }\n\n        vertices.$cacheBuffer = undefined;\n      }, 50);\n    }\n  }); // }\n};\n\nvar loaderPMD = function loaderPMD(url, callback) {\n  var useCache = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n\n  if (useCache) {\n    if (pmdCache[url]) {\n      if (pmdCache[url] === ProcessingFlag) {\n        setTimeout(function () {\n          loaderPMD(url, callback);\n        }, 100);\n      } else {\n        callback(pmdCache[url].data, pmdCache[url].pmd);\n      }\n\n      return;\n    }\n\n    pmdCache[url] = ProcessingFlag;\n  }\n\n  var modelURL = url;\n  var request = new XMLHttpRequest();\n  request.responseType = 'arraybuffer';\n\n  request.onload = function () {\n    __analyzePMD(url, request.response, callback);\n  };\n\n  request.onerror = function (error) {\n    err('PMD File Loaded Error.');\n  };\n\n  request.open('GET', modelURL, true);\n  request.send(null);\n};\n\nvar loaderVMD = function loaderVMD(urls, callback, index, buffers) {\n  // 这俩参数暂时没发现有多大用\n  index = index || 0;\n  buffers = buffers || [];\n  var url = urls.pop ? urls.length[index] : urls;\n  var request = new XMLHttpRequest();\n  request.responseType = 'arraybuffer';\n\n  request.onload = function () {\n    buffers.push(request.response); // if (index + 1 >= urls.length) {\n\n    __analyzeVMD(buffers, callback); // } else {\n    //     loaderVMD(urls, index+1, buffers);\n    // }\n\n  };\n\n  request.onerror = function (error) {\n    err('VMD File Loaded Error.');\n  };\n\n  request.open('GET', url, true);\n  request.send(null);\n};\n\nvar classInit = function classInit(opt) {\n  if (!opt.webgl || !opt.webgl.pmd) {\n    return;\n  }\n\n  var pmdUrl = opt.webgl.pmd;\n  var imgPath = opt.webgl.imgPath;\n  var useCache = opt.webgl.cache !== false;\n  var sprite = this;\n  var vmdQueue;\n  loaderPMD(pmdUrl, function (data, pmd) {\n    sprite.webgl = {};\n    var vertices = data.vertices;\n    var normals = data.normals;\n    var textures = data.textures;\n    var indices = data.indices;\n    delete opt.webgl.pmd;\n    delete opt.webgl.imgPath;\n    delete opt.webgl.cache;\n    var lastCount = 0;\n    pmd.materials.forEach(function (mt, i) {\n      var currentIndices = pmdCache[pmdUrl]['currentIndices' + i] || indices.slice(lastCount, lastCount + mt.vertexCount);\n      pmdCache[pmdUrl]['currentIndices' + i] = currentIndices;\n      sprite.add({\n        name: mt.fileName,\n        // 这块如果属性是function的话assign过去会有坑，需要改成非function的再assign过去，todo\n        webgl: Object.assign(window.Easycanvas.webglShapes.custom({\n          vertices: vertices,\n          normals: normals,\n          indices: currentIndices,\n          textures: textures,\n          img: mt.fileName ? imgPath + mt.fileName : undefined,\n          colors: mt.fileName ? undefined : mt.color.map(function (num) {\n            return num * 255;\n          }).slice(0, 3) // mirrorColor\n\n        }), opt.webgl)\n      });\n      lastCount += mt.vertexCount;\n    });\n\n    sprite.vmdStart = function (vmdUrl) {\n      loaderVMD(vmdUrl, function (vmd) {\n        sprite.trigger('webgl-vmd-loaded');\n        vmd.start(pmd, sprite.children[0].webgl.vertices);\n      });\n    };\n\n    if (vmdQueue) {\n      sprite.vmdStart(vmdQueue);\n    }\n\n    sprite.trigger('webgl-pmd-loaded');\n  }, useCache);\n\n  sprite.vmdStart = function (vmdUrl) {\n    vmdQueue = vmdUrl;\n  };\n};\n\nvar inBrowser = typeof window !== 'undefined';\n\nif (inBrowser && window.Easycanvas) {\n  Easycanvas.loaderPMD = loaderPMD;\n  Easycanvas.loaderVMD = loaderVMD;\n  Easycanvas.extend(classInit);\n} else {\n  module.exports = {\n    loaderPMD: loaderPMD,\n    loaderVMD: loaderVMD,\n    classInit: classInit\n  };\n}\n\n//# sourceURL=webpack:///./src/plugin.webgl.mmd.js?");

/***/ }),

/***/ 9:
/*!***************************************!*\
  !*** multi ./src/plugin.webgl.mmd.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__(/*! ./src/plugin.webgl.mmd.js */\"./src/plugin.webgl.mmd.js\");\n\n\n//# sourceURL=webpack:///multi_./src/plugin.webgl.mmd.js?");

/***/ })

/******/ })));